/**
 * name: @securecitizen/sc-camera-module
 * version: v2.0.4
 * description: This is the SC Camera Module repo that will create a Vite workflow to ease creation of Javascript modules with a dev server, GitHub Pages support and automated publishing to NPM.
 * author: Grant Vine <grantv@securecitizen.co.za> (https://securecitizen.co.za)
 * repository: https://github.com/securecitizen/sc-camera-module
 * build date: 2023-08-01T13:43:43.413Z 
 */
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2["sc-camera-module"] = factory());
})(this, function() {
  var _a2, _b, _c2, _d2;
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var core = { exports: {} };
  var cryptoBrowserify = {};
  var buffer$1 = {};
  var base64Js = {};
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i10;
    for (i10 = 0; i10 < len2; i10 += 4) {
      tmp = revLookup[b64.charCodeAt(i10)] << 18 | revLookup[b64.charCodeAt(i10 + 1)] << 12 | revLookup[b64.charCodeAt(i10 + 2)] << 6 | revLookup[b64.charCodeAt(i10 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i10)] << 2 | revLookup[b64.charCodeAt(i10 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i10)] << 10 | revLookup[b64.charCodeAt(i10 + 1)] << 4 | revLookup[b64.charCodeAt(i10 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i10 = start; i10 < end; i10 += 3) {
      tmp = (uint8[i10] << 16 & 16711680) + (uint8[i10 + 1] << 8 & 65280) + (uint8[i10 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i10 = 0, len22 = len2 - extraBytes; i10 < len22; i10 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i10, i10 + maxChunkLength > len22 ? len22 : i10 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  var ieee754 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e8, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i10 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i10];
    i10 += d;
    e8 = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e8 = e8 * 256 + buffer2[offset + i10], i10 += d, nBits -= 8) {
    }
    m = e8 & (1 << -nBits) - 1;
    e8 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i10], i10 += d, nBits -= 8) {
    }
    if (e8 === 0) {
      e8 = 1 - eBias;
    } else if (e8 === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e8 = e8 - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e8 - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e8, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i10 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e8 = eMax;
    } else {
      e8 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e8)) < 1) {
        e8--;
        c *= 2;
      }
      if (e8 + eBias >= 1) {
        value += rt2 / c;
      } else {
        value += rt2 * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e8++;
        c /= 2;
      }
      if (e8 + eBias >= eMax) {
        m = 0;
        e8 = eMax;
      } else if (e8 + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e8 = e8 + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e8 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i10] = m & 255, i10 += d, m /= 256, mLen -= 8) {
    }
    e8 = e8 << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i10] = e8 & 255, i10 += d, e8 /= 256, eLen -= 8) {
    }
    buffer2[offset + i10 - d] |= s * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(exports2) {
    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e8) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size2 < 0) {
        throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
      }
    }
    function alloc(size2, fill, encoding) {
      assertSize(size2);
      if (size2 <= 0) {
        return createBuffer(size2);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
      }
      return createBuffer(size2);
    }
    Buffer2.alloc = function(size2, fill, encoding) {
      return alloc(size2, fill, encoding);
    };
    function allocUnsafe(size2) {
      assertSize(size2);
      return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
    }
    Buffer2.allocUnsafe = function(size2) {
      return allocUnsafe(size2);
    };
    Buffer2.allocUnsafeSlow = function(size2) {
      return allocUnsafe(size2);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength2(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i10 = 0; i10 < length; i10 += 1) {
        buf[i10] = array[i10] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len2 = checked(obj.length) | 0;
        var buf = createBuffer(len2);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len2);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y10 = b.length;
      for (var i10 = 0, len2 = Math.min(x, y10); i10 < len2; ++i10) {
        if (a[i10] !== b[i10]) {
          x = a[i10];
          y10 = b[i10];
          break;
        }
      }
      if (x < y10)
        return -1;
      if (y10 < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i10;
      if (length === void 0) {
        length = 0;
        for (i10 = 0; i10 < list.length; ++i10) {
          length += list[i10].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i10 = 0; i10 < list.length; ++i10) {
        var buf = list[i10];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength2(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len2 = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len2 === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len2;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len2 * 2;
          case "hex":
            return len2 >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n8, m) {
      var i10 = b[n8];
      b[n8] = b[m];
      b[m] = i10;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len2 = this.length;
      if (len2 % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i10 = 0; i10 < len2; i10 += 2) {
        swap(this, i10, i10 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len2 = this.length;
      if (len2 % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i10 = 0; i10 < len2; i10 += 4) {
        swap(this, i10, i10 + 3);
        swap(this, i10 + 1, i10 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len2 = this.length;
      if (len2 % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i10 = 0; i10 < len2; i10 += 8) {
        swap(this, i10, i10 + 7);
        swap(this, i10 + 1, i10 + 6);
        swap(this, i10 + 2, i10 + 5);
        swap(this, i10 + 3, i10 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y10 = end - start;
      var len2 = Math.min(x, y10);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i10 = 0; i10 < len2; ++i10) {
        if (thisCopy[i10] !== targetCopy[i10]) {
          x = thisCopy[i10];
          y10 = targetCopy[i10];
          break;
        }
      }
      if (x < y10)
        return -1;
      if (y10 < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i11) {
        if (indexSize === 1) {
          return buf[i11];
        } else {
          return buf.readUInt16BE(i11 * indexSize);
        }
      }
      var i10;
      if (dir) {
        var foundIndex = -1;
        for (i10 = byteOffset; i10 < arrLength; i10++) {
          if (read(arr, i10) === read(val, foundIndex === -1 ? 0 : i10 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i10;
            if (i10 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i10 -= i10 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i10 = byteOffset; i10 >= 0; i10--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i10 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i10;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i10 = 0; i10 < length; ++i10) {
        var parsed = parseInt(string.substr(i10 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i10;
        buf[offset + i10] = parsed;
      }
      return i10;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i10 = start;
      while (i10 < end) {
        var firstByte = buf[i10];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i10 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i10 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i10 + 1];
              thirdByte = buf[i10 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i10 + 1];
              thirdByte = buf[i10 + 2];
              fourthByte = buf[i10 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i10 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len2 = codePoints.length;
      if (len2 <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i10 = 0;
      while (i10 < len2) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i10, i10 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i10 = start; i10 < end; ++i10) {
        ret += String.fromCharCode(buf[i10] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i10 = start; i10 < end; ++i10) {
        ret += String.fromCharCode(buf[i10]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len2 = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len2)
        end = len2;
      var out = "";
      for (var i10 = start; i10 < end; ++i10) {
        out += hexSliceLookupTable[buf[i10]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i10 = 0; i10 < bytes.length - 1; i10 += 2) {
        res += String.fromCharCode(bytes[i10] + bytes[i10 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len2 = this.length;
      start = ~~start;
      end = end === void 0 ? len2 : ~~end;
      if (start < 0) {
        start += len2;
        if (start < 0)
          start = 0;
      } else if (start > len2) {
        start = len2;
      }
      if (end < 0) {
        end += len2;
        if (end < 0)
          end = 0;
      } else if (end > len2) {
        end = len2;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i10 = 0;
      while (++i10 < byteLength3 && (mul *= 256)) {
        val += this[offset + i10] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i10 = 0;
      while (++i10 < byteLength3 && (mul *= 256)) {
        val += this[offset + i10] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i10 = byteLength3;
      var mul = 1;
      var val = this[offset + --i10];
      while (i10 > 0 && (mul *= 256)) {
        val += this[offset + --i10] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i10 = 0;
      this[offset] = value & 255;
      while (++i10 < byteLength3 && (mul *= 256)) {
        this[offset + i10] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i10 = byteLength3 - 1;
      var mul = 1;
      this[offset + i10] = value & 255;
      while (--i10 >= 0 && (mul *= 256)) {
        this[offset + i10] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i10 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i10 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i10 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i10] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i10 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i10] = value & 255;
      while (--i10 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i10 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i10] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len2 = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len2;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i10;
      if (typeof val === "number") {
        for (i10 = start; i10 < end; ++i10) {
          this[i10] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len2 = bytes.length;
        if (len2 === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i10 = 0; i10 < end - start; ++i10) {
          this[i10 + start] = bytes[i10 % len2];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i10 = 0; i10 < length; ++i10) {
        codePoint = string.charCodeAt(i10);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i10 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i10 = 0; i10 < str.length; ++i10) {
        byteArray.push(str.charCodeAt(i10) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi2, lo2;
      var byteArray = [];
      for (var i10 = 0; i10 < str.length; ++i10) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i10);
        hi2 = c >> 8;
        lo2 = c % 256;
        byteArray.push(lo2);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length) {
      for (var i10 = 0; i10 < length; ++i10) {
        if (i10 + offset >= dst.length || i10 >= src2.length)
          break;
        dst[i10 + offset] = src2[i10];
      }
      return i10;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i10 = 0; i10 < 16; ++i10) {
        var i16 = i10 * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i10] + alphabet[j];
        }
      }
      return table;
    }();
  })(buffer$1);
  var browser$c = { exports: {} };
  var process = browser$c.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e8) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e8) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e8) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e10) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e8) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e10) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len2 = queue.length;
    while (len2) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len2) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len2 = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i10 = 1; i10 < arguments.length; i10++) {
        args[i10 - 1] = arguments[i10];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = "browser";
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = "";
  process.versions = {};
  function noop() {
  }
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;
  process.listeners = function(name2) {
    return [];
  };
  process.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process.cwd = function() {
    return "/";
  };
  process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process.umask = function() {
    return 0;
  };
  var browserExports = browser$c.exports;
  const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
  var _globalThis = function(Object2) {
    function get() {
      var _global3 = this || self;
      delete Object2.prototype.__magic__;
      return _global3;
    }
    if (typeof globalThis === "object") {
      return globalThis;
    }
    if (this) {
      return get();
    } else {
      Object2.defineProperty(Object2.prototype, "__magic__", {
        configurable: true,
        get
      });
      var _global2 = __magic__;
      return _global2;
    }
  }(Object);
  var _global = _globalThis;
  var browser$b = { exports: {} };
  var safeBuffer = { exports: {} };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var hasRequiredSafeBuffer;
  function requireSafeBuffer() {
    if (hasRequiredSafeBuffer)
      return safeBuffer.exports;
    hasRequiredSafeBuffer = 1;
    (function(module2, exports2) {
      var buffer2 = buffer$1;
      var Buffer2 = buffer2.Buffer;
      function copyProps(src2, dst) {
        for (var key2 in src2) {
          dst[key2] = src2[key2];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer2;
      } else {
        copyProps(buffer2, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size2, fill, encoding) {
        if (typeof size2 !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size2);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size2) {
        if (typeof size2 !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size2);
      };
      SafeBuffer.allocUnsafeSlow = function(size2) {
        if (typeof size2 !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size2);
      };
    })(safeBuffer, safeBuffer.exports);
    return safeBuffer.exports;
  }
  var hasRequiredBrowser$b;
  function requireBrowser$b() {
    if (hasRequiredBrowser$b)
      return browser$b.exports;
    hasRequiredBrowser$b = 1;
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = requireSafeBuffer().Buffer;
    var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
    if (crypto && crypto.getRandomValues) {
      browser$b.exports = randomBytes;
    } else {
      browser$b.exports = oldBrowser;
    }
    function randomBytes(size2, cb) {
      if (size2 > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer2.allocUnsafe(size2);
      if (size2 > 0) {
        if (size2 > MAX_BYTES) {
          for (var generated = 0; generated < size2; generated += MAX_BYTES) {
            crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process$1.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
    return browser$b.exports;
  }
  var inherits_browser = { exports: {} };
  var hasRequiredInherits_browser;
  function requireInherits_browser() {
    if (hasRequiredInherits_browser)
      return inherits_browser.exports;
    hasRequiredInherits_browser = 1;
    if (typeof Object.create === "function") {
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    return inherits_browser.exports;
  }
  var readableBrowser = { exports: {} };
  var events = { exports: {} };
  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents)
      return events.exports;
    hasRequiredEvents = 1;
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    events.exports = EventEmitter;
    events.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n8) {
      if (typeof n8 !== "number" || n8 < 0 || NumberIsNaN(n8)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n8 + ".");
      }
      this._maxListeners = n8;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i10 = 1; i10 < arguments.length; i10++)
        args.push(arguments[i10]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len2 = handler.length;
        var listeners = arrayClone(handler, len2);
        for (var i10 = 0; i10 < len2; ++i10)
          ReflectApply(listeners[i10], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w10 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w10.name = "MaxListenersExceededWarning";
          w10.emitter = target;
          w10.type = type;
          w10.count = existing.length;
          ProcessEmitWarning(w10);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state2 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state2);
      wrapped.listener = listener;
      state2.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i10, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i10 = list.length - 1; i10 >= 0; i10--) {
          if (list[i10] === listener || list[i10].listener === listener) {
            originalListener = list[i10].listener;
            position = i10;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i10;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key2;
        for (i10 = 0; i10 < keys.length; ++i10) {
          key2 = keys[i10];
          if (key2 === "removeListener")
            continue;
          this.removeAllListeners(key2);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i10 = listeners.length - 1; i10 >= 0; i10--) {
          this.removeListener(type, listeners[i10]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n8) {
      var copy2 = new Array(n8);
      for (var i10 = 0; i10 < n8; ++i10)
        copy2[i10] = arr[i10];
      return copy2;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i10 = 0; i10 < ret.length; ++i10) {
        ret[i10] = arr[i10].listener || arr[i10];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    return events.exports;
  }
  var streamBrowser;
  var hasRequiredStreamBrowser;
  function requireStreamBrowser() {
    if (hasRequiredStreamBrowser)
      return streamBrowser;
    hasRequiredStreamBrowser = 1;
    streamBrowser = requireEvents().EventEmitter;
    return streamBrowser;
  }
  var util = {};
  var types = {};
  var shams$1;
  var hasRequiredShams$1;
  function requireShams$1() {
    if (hasRequiredShams$1)
      return shams$1;
    hasRequiredShams$1 = 1;
    shams$1 = function hasSymbols2() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
    return shams$1;
  }
  var shams;
  var hasRequiredShams;
  function requireShams() {
    if (hasRequiredShams)
      return shams;
    hasRequiredShams = 1;
    var hasSymbols2 = requireShams$1();
    shams = function hasToStringTagShams() {
      return hasSymbols2() && !!Symbol.toStringTag;
    };
    return shams;
  }
  var hasSymbols;
  var hasRequiredHasSymbols;
  function requireHasSymbols() {
    if (hasRequiredHasSymbols)
      return hasSymbols;
    hasRequiredHasSymbols = 1;
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = requireShams$1();
    hasSymbols = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
    return hasSymbols;
  }
  var hasProto;
  var hasRequiredHasProto;
  function requireHasProto() {
    if (hasRequiredHasProto)
      return hasProto;
    hasRequiredHasProto = 1;
    var test = {
      foo: {}
    };
    var $Object = Object;
    hasProto = function hasProto2() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
    return hasProto;
  }
  var implementation;
  var hasRequiredImplementation;
  function requireImplementation() {
    if (hasRequiredImplementation)
      return implementation;
    hasRequiredImplementation = 1;
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    implementation = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i10 = 0; i10 < boundLength; i10++) {
        boundArgs.push("$" + i10);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
    return implementation;
  }
  var functionBind;
  var hasRequiredFunctionBind;
  function requireFunctionBind() {
    if (hasRequiredFunctionBind)
      return functionBind;
    hasRequiredFunctionBind = 1;
    var implementation2 = requireImplementation();
    functionBind = Function.prototype.bind || implementation2;
    return functionBind;
  }
  var src;
  var hasRequiredSrc;
  function requireSrc() {
    if (hasRequiredSrc)
      return src;
    hasRequiredSrc = 1;
    var bind = requireFunctionBind();
    src = bind.call(Function.call, Object.prototype.hasOwnProperty);
    return src;
  }
  var getIntrinsic;
  var hasRequiredGetIntrinsic;
  function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
      return getIntrinsic;
    hasRequiredGetIntrinsic = 1;
    var undefined$1;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e8) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e8) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols2 = requireHasSymbols()();
    var hasProto2 = requireHasProto()();
    var getProto = Object.getPrototypeOf || (hasProto2 ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
      "%AsyncFromSyncIteratorPrototype%": undefined$1,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
      "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
      "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e8) {
        var errorProto = getProto(getProto(e8));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn2 = doEval2("%AsyncGeneratorFunction%");
        if (fn2) {
          value = fn2.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = requireFunctionBind();
    var hasOwn = requireSrc();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last11 = $strSlice(string, -1);
      if (first === "%" && last11 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last11 === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match2, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    getIntrinsic = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i10 = 1, isOwn = true; i10 < parts.length; i10 += 1) {
        var part = parts[i10];
        var first = $strSlice(part, 0, 1);
        var last11 = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last11 === '"' || last11 === "'" || last11 === "`")) && first !== last11) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i10 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
    return getIntrinsic;
  }
  var callBind = { exports: {} };
  var hasRequiredCallBind;
  function requireCallBind() {
    if (hasRequiredCallBind)
      return callBind.exports;
    hasRequiredCallBind = 1;
    (function(module2) {
      var bind = requireFunctionBind();
      var GetIntrinsic = requireGetIntrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e8) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind2(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", { value: applyBind });
      } else {
        module2.exports.apply = applyBind;
      }
    })(callBind);
    return callBind.exports;
  }
  var callBound;
  var hasRequiredCallBound;
  function requireCallBound() {
    if (hasRequiredCallBound)
      return callBound;
    hasRequiredCallBound = 1;
    var GetIntrinsic = requireGetIntrinsic();
    var callBind2 = requireCallBind();
    var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
    callBound = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind2(intrinsic);
      }
      return intrinsic;
    };
    return callBound;
  }
  var isArguments;
  var hasRequiredIsArguments;
  function requireIsArguments() {
    if (hasRequiredIsArguments)
      return isArguments;
    hasRequiredIsArguments = 1;
    var hasToStringTag = requireShams()();
    var callBound2 = requireCallBound();
    var $toString = callBound2("Object.prototype.toString");
    var isStandardArguments = function isArguments2(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments2(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    return isArguments;
  }
  var isGeneratorFunction;
  var hasRequiredIsGeneratorFunction;
  function requireIsGeneratorFunction() {
    if (hasRequiredIsGeneratorFunction)
      return isGeneratorFunction;
    hasRequiredIsGeneratorFunction = 1;
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = requireShams()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e8) {
      }
    };
    var GeneratorFunction;
    isGeneratorFunction = function isGeneratorFunction2(fn2) {
      if (typeof fn2 !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn2))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn2);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn2) === GeneratorFunction;
    };
    return isGeneratorFunction;
  }
  var isCallable;
  var hasRequiredIsCallable;
  function requireIsCallable() {
    if (hasRequiredIsCallable)
      return isCallable;
    hasRequiredIsCallable = 1;
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e8) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e8) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      var all2 = document.all;
      if (toStr.call(all2) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e8) {
            }
          }
          return false;
        };
      }
    }
    isCallable = reflectApply ? function isCallable2(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e8) {
        if (e8 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable2(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
    return isCallable;
  }
  var forEach_1;
  var hasRequiredForEach;
  function requireForEach() {
    if (hasRequiredForEach)
      return forEach_1;
    hasRequiredForEach = 1;
    var isCallable2 = requireIsCallable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i10 = 0, len2 = array.length; i10 < len2; i10++) {
        if (hasOwnProperty.call(array, i10)) {
          if (receiver == null) {
            iterator(array[i10], i10, array);
          } else {
            iterator.call(receiver, array[i10], i10, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i10 = 0, len2 = string.length; i10 < len2; i10++) {
        if (receiver == null) {
          iterator(string.charAt(i10), i10, string);
        } else {
          iterator.call(receiver, string.charAt(i10), i10, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object2, iterator, receiver) {
      for (var k in object2) {
        if (hasOwnProperty.call(object2, k)) {
          if (receiver == null) {
            iterator(object2[k], k, object2);
          } else {
            iterator.call(receiver, object2[k], k, object2);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable2(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    forEach_1 = forEach;
    return forEach_1;
  }
  var availableTypedArrays;
  var hasRequiredAvailableTypedArrays;
  function requireAvailableTypedArrays() {
    if (hasRequiredAvailableTypedArrays)
      return availableTypedArrays;
    hasRequiredAvailableTypedArrays = 1;
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    availableTypedArrays = function availableTypedArrays2() {
      var out = [];
      for (var i10 = 0; i10 < possibleNames.length; i10++) {
        if (typeof g[possibleNames[i10]] === "function") {
          out[out.length] = possibleNames[i10];
        }
      }
      return out;
    };
    return availableTypedArrays;
  }
  var gopd;
  var hasRequiredGopd;
  function requireGopd() {
    if (hasRequiredGopd)
      return gopd;
    hasRequiredGopd = 1;
    var GetIntrinsic = requireGetIntrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e8) {
        $gOPD = null;
      }
    }
    gopd = $gOPD;
    return gopd;
  }
  var isTypedArray;
  var hasRequiredIsTypedArray;
  function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
      return isTypedArray;
    hasRequiredIsTypedArray = 1;
    var forEach = requireForEach();
    var availableTypedArrays2 = requireAvailableTypedArrays();
    var callBound2 = requireCallBound();
    var $toString = callBound2("Object.prototype.toString");
    var hasToStringTag = requireShams()();
    var gOPD = requireGopd();
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var typedArrays = availableTypedArrays2();
    var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i10 = 0; i10 < array.length; i10 += 1) {
        if (array[i10] === value) {
          return i10;
        }
      }
      return -1;
    };
    var $slice = callBound2("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e8) {
          }
        }
      });
      return anyTrue;
    };
    isTypedArray = function isTypedArray2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
    return isTypedArray;
  }
  var whichTypedArray;
  var hasRequiredWhichTypedArray;
  function requireWhichTypedArray() {
    if (hasRequiredWhichTypedArray)
      return whichTypedArray;
    hasRequiredWhichTypedArray = 1;
    var forEach = requireForEach();
    var availableTypedArrays2 = requireAvailableTypedArrays();
    var callBind2 = requireCallBind();
    var callBound2 = requireCallBound();
    var gOPD = requireGopd();
    var $toString = callBound2("Object.prototype.toString");
    var hasToStringTag = requireShams()();
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var typedArrays = availableTypedArrays2();
    var $slice = callBound2("String.prototype.slice");
    var toStrTags = { __proto__: null };
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g[typedArray] === "function") {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = callBind2(descriptor.get);
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name2 = getter(value);
            if (name2 === typedArray) {
              foundName = name2;
            }
          } catch (e8) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray2 = requireIsTypedArray();
    whichTypedArray = function whichTypedArray2(value) {
      if (!isTypedArray2(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
    return whichTypedArray;
  }
  var hasRequiredTypes;
  function requireTypes() {
    if (hasRequiredTypes)
      return types;
    hasRequiredTypes = 1;
    (function(exports2) {
      var isArgumentsObject = requireIsArguments();
      var isGeneratorFunction2 = requireIsGeneratorFunction();
      var whichTypedArray2 = requireWhichTypedArray();
      var isTypedArray2 = requireIsTypedArray();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      if (SymbolSupported) {
        var symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e8) {
          return false;
        }
      }
      exports2.isArgumentsObject = isArgumentsObject;
      exports2.isGeneratorFunction = isGeneratorFunction2;
      exports2.isTypedArray = isTypedArray2;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports2.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray2(value) || isDataView(value);
      }
      exports2.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray2(value) === "Uint8Array";
      }
      exports2.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray2(value) === "Uint8ClampedArray";
      }
      exports2.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray2(value) === "Uint16Array";
      }
      exports2.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray2(value) === "Uint32Array";
      }
      exports2.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray2(value) === "Int8Array";
      }
      exports2.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray2(value) === "Int16Array";
      }
      exports2.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray2(value) === "Int32Array";
      }
      exports2.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray2(value) === "Float32Array";
      }
      exports2.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray2(value) === "Float64Array";
      }
      exports2.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray2(value) === "BigInt64Array";
      }
      exports2.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray2(value) === "BigUint64Array";
      }
      exports2.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports2.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports2.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports2.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports2.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports2.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports2.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports2.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports2.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports2.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports2.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports2.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports2.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports2.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports2.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports2.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports2.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports2.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports2.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports2, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    })(types);
    return types;
  }
  var isBufferBrowser;
  var hasRequiredIsBufferBrowser;
  function requireIsBufferBrowser() {
    if (hasRequiredIsBufferBrowser)
      return isBufferBrowser;
    hasRequiredIsBufferBrowser = 1;
    isBufferBrowser = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
    return isBufferBrowser;
  }
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil)
      return util;
    hasRequiredUtil = 1;
    (function(exports2) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i10 = 0; i10 < keys.length; i10++) {
          descriptors[keys[i10]] = Object.getOwnPropertyDescriptor(obj, keys[i10]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports2.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i10 = 0; i10 < arguments.length; i10++) {
            objects.push(inspect(arguments[i10]));
          }
          return objects.join(" ");
        }
        var i10 = 1;
        var args = arguments;
        var len2 = args.length;
        var str = String(f).replace(formatRegExp, function(x5) {
          if (x5 === "%%")
            return "%";
          if (i10 >= len2)
            return x5;
          switch (x5) {
            case "%s":
              return String(args[i10++]);
            case "%d":
              return Number(args[i10++]);
            case "%j":
              try {
                return JSON.stringify(args[i10++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x5;
          }
        });
        for (var x = args[i10]; i10 < len2; x = args[++i10]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports2.deprecate = function(fn2, msg) {
        if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
          return fn2;
        }
        if (typeof process$1 === "undefined") {
          return function() {
            return exports2.deprecate(fn2, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process$1.throwDeprecation) {
              throw new Error(msg);
            } else if (process$1.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn2.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process$1.env.NODE_DEBUG) {
        var debugEnv = process$1.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      exports2.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process$1.pid;
            debugs[set] = function() {
              var msg = exports2.format.apply(exports2, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports2._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports2.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash2 = {};
        array.forEach(function(val, idx) {
          hash2[val] = true;
        });
        return hash2;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name2 = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name2 + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base2 = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n8 = value.name ? ": " + value.name : "";
          base2 = " [Function" + n8 + "]";
        }
        if (isRegExp(value)) {
          base2 = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base2 = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base2 = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base2 + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key2) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base2, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i10 = 0, l = value.length; i10 < l; ++i10) {
          if (hasOwnProperty(value, String(i10))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i10),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key2) {
          if (!key2.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key2,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
        var name2, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key2)) {
          name2 = "[" + key2 + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name2)) {
          if (array && key2.match(/^\d+$/)) {
            return str;
          }
          name2 = JSON.stringify("" + key2);
          if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name2 = name2.slice(1, -1);
            name2 = ctx.stylize(name2, "name");
          } else {
            name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name2 = ctx.stylize(name2, "string");
          }
        }
        return name2 + ": " + str;
      }
      function reduceToSingleString(output, base2, braces) {
        var length = output.reduce(function(prev, cur) {
          if (cur.indexOf("\n") >= 0)
            ;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
      }
      exports2.types = requireTypes();
      function isArray(ar2) {
        return Array.isArray(ar2);
      }
      exports2.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports2.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports2.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports2.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports2.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports2.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports2.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports2.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports2.isRegExp = isRegExp;
      exports2.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports2.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports2.isDate = isDate;
      exports2.types.isDate = isDate;
      function isError(e8) {
        return isObject(e8) && (objectToString(e8) === "[object Error]" || e8 instanceof Error);
      }
      exports2.isError = isError;
      exports2.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports2.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports2.isPrimitive = isPrimitive;
      exports2.isBuffer = requireIsBufferBrowser();
      function objectToString(o8) {
        return Object.prototype.toString.call(o8);
      }
      function pad(n8) {
        return n8 < 10 ? "0" + n8.toString(10) : n8.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports2.log = function() {
        console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
      };
      exports2.inherits = requireInherits_browser();
      exports2._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i10 = keys.length;
        while (i10--) {
          origin[keys[i10]] = add[keys[i10]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports2.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn2 = original[kCustomPromisifiedSymbol];
          if (typeof fn2 !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
            value: fn2,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn2;
        }
        function fn2() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i10 = 0; i10 < arguments.length; i10++) {
            args.push(arguments[i10]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
            value: fn2,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(
          fn2,
          getOwnPropertyDescriptors(original)
        );
      };
      exports2.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i10 = 0; i10 < arguments.length; i10++) {
            args.push(arguments[i10]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process$1.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports2.callbackify = callbackify;
    })(util);
    return util;
  }
  var buffer_list;
  var hasRequiredBuffer_list;
  function requireBuffer_list() {
    if (hasRequiredBuffer_list)
      return buffer_list;
    hasRequiredBuffer_list = 1;
    function ownKeys(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i10 = 1; i10 < arguments.length; i10++) {
        var source = null != arguments[i10] ? arguments[i10] : {};
        i10 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i10 = 0; i10 < props.length; i10++) {
        var descriptor = props[i10];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = buffer$1, Buffer2 = _require.Buffer;
    var _require2 = requireUtil(), inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src2, target, offset) {
      Buffer2.prototype.copy.call(src2, target, offset);
    }
    buffer_list = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v10) {
          var entry = {
            data: v10,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v10) {
          var entry = {
            data: v10,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join3(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n8) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n8 >>> 0);
          var p = this.head;
          var i10 = 0;
          while (p) {
            copyBuffer(p.data, ret, i10);
            i10 += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n8, hasStrings) {
          var ret;
          if (n8 < this.head.data.length) {
            ret = this.head.data.slice(0, n8);
            this.head.data = this.head.data.slice(n8);
          } else if (n8 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n8) : this._getBuffer(n8);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n8) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n8 -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n8 > str.length ? str.length : n8;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n8);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n8) {
          var ret = Buffer2.allocUnsafe(n8);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n8 -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n8 > buf.length ? buf.length : n8;
            buf.copy(ret, ret.length - n8, 0, nb);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options4) {
          return inspect(this, _objectSpread(_objectSpread({}, options4), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return buffer_list;
  }
  var destroy_1;
  var hasRequiredDestroy;
  function requireDestroy() {
    if (hasRequiredDestroy)
      return destroy_1;
    hasRequiredDestroy = 1;
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process$1.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process$1.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process$1.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    destroy_1 = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return destroy_1;
  }
  var errorsBrowser = {};
  var hasRequiredErrorsBrowser;
  function requireErrorsBrowser() {
    if (hasRequiredErrorsBrowser)
      return errorsBrowser;
    hasRequiredErrorsBrowser = 1;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code2, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code2;
      codes[code2] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len2 = expected.length;
        expected = expected.map(function(i10) {
          return String(i10);
        });
        if (len2 > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
        } else if (len2 === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    errorsBrowser.codes = codes;
    return errorsBrowser;
  }
  var state;
  var hasRequiredState;
  function requireState() {
    if (hasRequiredState)
      return state;
    hasRequiredState = 1;
    var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options4, isDuplex, duplexKey) {
      return options4.highWaterMark != null ? options4.highWaterMark : isDuplex ? options4[duplexKey] : null;
    }
    function getHighWaterMark(state2, options4, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options4, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state2.objectMode ? 16 : 16 * 1024;
    }
    state = {
      getHighWaterMark
    };
    return state;
  }
  var browser$a;
  var hasRequiredBrowser$a;
  function requireBrowser$a() {
    if (hasRequiredBrowser$a)
      return browser$a;
    hasRequiredBrowser$a = 1;
    browser$a = deprecate;
    function deprecate(fn2, msg) {
      if (config3("noDeprecation")) {
        return fn2;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config3("throwDeprecation")) {
            throw new Error(msg);
          } else if (config3("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    }
    function config3(name2) {
      try {
        if (!commonjsGlobal.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = commonjsGlobal.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
    return browser$a;
  }
  var _stream_writable;
  var hasRequired_stream_writable;
  function require_stream_writable() {
    if (hasRequired_stream_writable)
      return _stream_writable;
    hasRequired_stream_writable = 1;
    _stream_writable = Writable;
    function CorkedRequest(state2) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state2);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: requireBrowser$a()
    };
    var Stream = requireStreamBrowser();
    var Buffer2 = buffer$1.Buffer;
    var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = requireDestroy();
    var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    requireInherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options4, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options4 = options4 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options4.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options4.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options4, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options4.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options4.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er2) {
        onwrite(stream, er2);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options4.emitClose !== false;
      this.autoDestroy = !!options4.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object2) {
          if (realHasInstance.call(this, object2))
            return true;
          if (this !== Writable)
            return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object2) {
        return object2 instanceof this;
      };
    }
    function Writable(options4) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options4);
      this._writableState = new WritableState(options4, this, isDuplex);
      this.writable = true;
      if (options4) {
        if (typeof options4.write === "function")
          this._write = options4.write;
        if (typeof options4.writev === "function")
          this._writev = options4.writev;
        if (typeof options4.destroy === "function")
          this._destroy = options4.destroy;
        if (typeof options4.final === "function")
          this._final = options4.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er2 = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er2);
      process$1.nextTick(cb, er2);
    }
    function validChunk(stream, state2, chunk, cb) {
      var er2;
      if (chunk === null) {
        er2 = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state2.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er2) {
        errorOrDestroy(stream, er2);
        process$1.nextTick(cb, er2);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      var ret = false;
      var isBuf = !state2.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state2.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state2.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state2, chunk, cb)) {
        state2.pendingcb++;
        ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state2 = this._writableState;
      if (state2.corked) {
        state2.corked--;
        if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
          clearBuffer(this, state2);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state2, chunk, encoding) {
      if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state2, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len2 = state2.objectMode ? 1 : chunk.length;
      state2.length += len2;
      var ret = state2.length < state2.highWaterMark;
      if (!ret)
        state2.needDrain = true;
      if (state2.writing || state2.corked) {
        var last11 = state2.lastBufferedRequest;
        state2.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last11) {
          last11.next = state2.lastBufferedRequest;
        } else {
          state2.bufferedRequest = state2.lastBufferedRequest;
        }
        state2.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
      state2.writelen = len2;
      state2.writecb = cb;
      state2.writing = true;
      state2.sync = true;
      if (state2.destroyed)
        state2.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state2.onwrite);
      else
        stream._write(chunk, encoding, state2.onwrite);
      state2.sync = false;
    }
    function onwriteError(stream, state2, sync, er2, cb) {
      --state2.pendingcb;
      if (sync) {
        process$1.nextTick(cb, er2);
        process$1.nextTick(finishMaybe, stream, state2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
      } else {
        cb(er2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
        finishMaybe(stream, state2);
      }
    }
    function onwriteStateUpdate(state2) {
      state2.writing = false;
      state2.writecb = null;
      state2.length -= state2.writelen;
      state2.writelen = 0;
    }
    function onwrite(stream, er2) {
      var state2 = stream._writableState;
      var sync = state2.sync;
      var cb = state2.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state2);
      if (er2)
        onwriteError(stream, state2, sync, er2, cb);
      else {
        var finished = needFinish(state2) || stream.destroyed;
        if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
          clearBuffer(stream, state2);
        }
        if (sync) {
          process$1.nextTick(afterWrite, stream, state2, finished, cb);
        } else {
          afterWrite(stream, state2, finished, cb);
        }
      }
    }
    function afterWrite(stream, state2, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state2);
      state2.pendingcb--;
      cb();
      finishMaybe(stream, state2);
    }
    function onwriteDrain(stream, state2) {
      if (state2.length === 0 && state2.needDrain) {
        state2.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state2) {
      state2.bufferProcessing = true;
      var entry = state2.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state2.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state2.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
        state2.pendingcb++;
        state2.lastBufferedRequest = null;
        if (holder.next) {
          state2.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state2.corkedRequestsFree = new CorkedRequest(state2);
        }
        state2.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len2 = state2.objectMode ? 1 : chunk.length;
          doWrite(stream, state2, false, len2, chunk, encoding, cb);
          entry = entry.next;
          state2.bufferedRequestCount--;
          if (state2.writing) {
            break;
          }
        }
        if (entry === null)
          state2.lastBufferedRequest = null;
      }
      state2.bufferedRequest = entry;
      state2.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state2.corked) {
        state2.corked = 1;
        this.uncork();
      }
      if (!state2.ending)
        endWritable(this, state2, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state2) {
      return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
    }
    function callFinal(stream, state2) {
      stream._final(function(err) {
        state2.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state2.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state2);
      });
    }
    function prefinish(stream, state2) {
      if (!state2.prefinished && !state2.finalCalled) {
        if (typeof stream._final === "function" && !state2.destroyed) {
          state2.pendingcb++;
          state2.finalCalled = true;
          process$1.nextTick(callFinal, stream, state2);
        } else {
          state2.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state2) {
      var need = needFinish(state2);
      if (need) {
        prefinish(stream, state2);
        if (state2.pendingcb === 0) {
          state2.finished = true;
          stream.emit("finish");
          if (state2.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state2, cb) {
      state2.ending = true;
      finishMaybe(stream, state2);
      if (cb) {
        if (state2.finished)
          process$1.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state2.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state2, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state2.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state2.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return _stream_writable;
  }
  var _stream_duplex;
  var hasRequired_stream_duplex;
  function require_stream_duplex() {
    if (hasRequired_stream_duplex)
      return _stream_duplex;
    hasRequired_stream_duplex = 1;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key2 in obj)
        keys2.push(key2);
      return keys2;
    };
    _stream_duplex = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    requireInherits_browser()(Duplex, Readable);
    {
      var keys = objectKeys(Writable.prototype);
      for (var v10 = 0; v10 < keys.length; v10++) {
        var method = keys[v10];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options4) {
      if (!(this instanceof Duplex))
        return new Duplex(options4);
      Readable.call(this, options4);
      Writable.call(this, options4);
      this.allowHalfOpen = true;
      if (options4) {
        if (options4.readable === false)
          this.readable = false;
        if (options4.writable === false)
          this.writable = false;
        if (options4.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process$1.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return _stream_duplex;
  }
  var string_decoder = {};
  var hasRequiredString_decoder;
  function requireString_decoder() {
    if (hasRequiredString_decoder)
      return string_decoder;
    hasRequiredString_decoder = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    string_decoder.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r8;
      var i10;
      if (this.lastNeed) {
        r8 = this.fillLast(buf);
        if (r8 === void 0)
          return "";
        i10 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i10 = 0;
      }
      if (i10 < buf.length)
        return r8 ? r8 + this.text(buf, i10) : this.text(buf, i10);
      return r8 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i10) {
      var j = buf.length - 1;
      if (j < i10)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i10 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i10 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r8 = utf8CheckExtraBytes(this, buf);
      if (r8 !== void 0)
        return r8;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i10) {
      var total = utf8CheckIncomplete(this, buf, i10);
      if (!this.lastNeed)
        return buf.toString("utf8", i10);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i10, end);
    }
    function utf8End(buf) {
      var r8 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r8 + "�";
      return r8;
    }
    function utf16Text(buf, i10) {
      if ((buf.length - i10) % 2 === 0) {
        var r8 = buf.toString("utf16le", i10);
        if (r8) {
          var c = r8.charCodeAt(r8.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r8.slice(0, -1);
          }
        }
        return r8;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i10, buf.length - 1);
    }
    function utf16End(buf) {
      var r8 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r8 + this.lastChar.toString("utf16le", 0, end);
      }
      return r8;
    }
    function base64Text(buf, i10) {
      var n8 = (buf.length - i10) % 3;
      if (n8 === 0)
        return buf.toString("base64", i10);
      this.lastNeed = 3 - n8;
      this.lastTotal = 3;
      if (n8 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i10, buf.length - n8);
    }
    function base64End(buf) {
      var r8 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r8 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r8;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    return string_decoder;
  }
  var endOfStream;
  var hasRequiredEndOfStream;
  function requireEndOfStream() {
    if (hasRequiredEndOfStream)
      return endOfStream;
    hasRequiredEndOfStream = 1;
    var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    endOfStream = eos;
    return endOfStream;
  }
  var async_iterator;
  var hasRequiredAsync_iterator;
  function requireAsync_iterator() {
    if (hasRequiredAsync_iterator)
      return async_iterator;
    hasRequiredAsync_iterator = 1;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = requireEndOfStream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process$1.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process$1.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    async_iterator = createReadableStreamAsyncIterator;
    return async_iterator;
  }
  var fromBrowser;
  var hasRequiredFromBrowser;
  function requireFromBrowser() {
    if (hasRequiredFromBrowser)
      return fromBrowser;
    hasRequiredFromBrowser = 1;
    fromBrowser = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return fromBrowser;
  }
  var _stream_readable;
  var hasRequired_stream_readable;
  function require_stream_readable() {
    if (hasRequired_stream_readable)
      return _stream_readable;
    hasRequired_stream_readable = 1;
    _stream_readable = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    requireEvents().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = requireStreamBrowser();
    var Buffer2 = buffer$1.Buffer;
    var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = requireUtil();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = requireBuffer_list();
    var destroyImpl = requireDestroy();
    var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    requireInherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options4, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options4 = options4 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options4.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options4.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options4, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options4.emitClose !== false;
      this.autoDestroy = !!options4.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options4.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options4.encoding) {
        if (!StringDecoder)
          StringDecoder = requireString_decoder().StringDecoder;
        this.decoder = new StringDecoder(options4.encoding);
        this.encoding = options4.encoding;
      }
    }
    function Readable(options4) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options4);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options4, this, isDuplex);
      this.readable = true;
      if (options4) {
        if (typeof options4.read === "function")
          this._read = options4.read;
        if (typeof options4.destroy === "function")
          this._destroy = options4.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state2 = this._readableState;
      var skipChunkCheck;
      if (!state2.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state2.defaultEncoding;
          if (encoding !== state2.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state2 = stream._readableState;
      if (chunk === null) {
        state2.reading = false;
        onEofChunk(stream, state2);
      } else {
        var er2;
        if (!skipChunkCheck)
          er2 = chunkInvalid(state2, chunk);
        if (er2) {
          errorOrDestroy(stream, er2);
        } else if (state2.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state2.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state2, chunk, true);
          } else if (state2.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state2.destroyed) {
            return false;
          } else {
            state2.reading = false;
            if (state2.decoder && !encoding) {
              chunk = state2.decoder.write(chunk);
              if (state2.objectMode || chunk.length !== 0)
                addChunk(stream, state2, chunk, false);
              else
                maybeReadMore(stream, state2);
            } else {
              addChunk(stream, state2, chunk, false);
            }
          }
        } else if (!addToFront) {
          state2.reading = false;
          maybeReadMore(stream, state2);
        }
      }
      return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
    }
    function addChunk(stream, state2, chunk, addToFront) {
      if (state2.flowing && state2.length === 0 && !state2.sync) {
        state2.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state2.length += state2.objectMode ? 1 : chunk.length;
        if (addToFront)
          state2.buffer.unshift(chunk);
        else
          state2.buffer.push(chunk);
        if (state2.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state2);
    }
    function chunkInvalid(state2, chunk) {
      var er2;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er2;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n8) {
      if (n8 >= MAX_HWM) {
        n8 = MAX_HWM;
      } else {
        n8--;
        n8 |= n8 >>> 1;
        n8 |= n8 >>> 2;
        n8 |= n8 >>> 4;
        n8 |= n8 >>> 8;
        n8 |= n8 >>> 16;
        n8++;
      }
      return n8;
    }
    function howMuchToRead(n8, state2) {
      if (n8 <= 0 || state2.length === 0 && state2.ended)
        return 0;
      if (state2.objectMode)
        return 1;
      if (n8 !== n8) {
        if (state2.flowing && state2.length)
          return state2.buffer.head.data.length;
        else
          return state2.length;
      }
      if (n8 > state2.highWaterMark)
        state2.highWaterMark = computeNewHighWaterMark(n8);
      if (n8 <= state2.length)
        return n8;
      if (!state2.ended) {
        state2.needReadable = true;
        return 0;
      }
      return state2.length;
    }
    Readable.prototype.read = function(n8) {
      debug("read", n8);
      n8 = parseInt(n8, 10);
      var state2 = this._readableState;
      var nOrig = n8;
      if (n8 !== 0)
        state2.emittedReadable = false;
      if (n8 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
        debug("read: emitReadable", state2.length, state2.ended);
        if (state2.length === 0 && state2.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n8 = howMuchToRead(n8, state2);
      if (n8 === 0 && state2.ended) {
        if (state2.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state2.needReadable;
      debug("need readable", doRead);
      if (state2.length === 0 || state2.length - n8 < state2.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state2.ended || state2.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state2.reading = true;
        state2.sync = true;
        if (state2.length === 0)
          state2.needReadable = true;
        this._read(state2.highWaterMark);
        state2.sync = false;
        if (!state2.reading)
          n8 = howMuchToRead(nOrig, state2);
      }
      var ret;
      if (n8 > 0)
        ret = fromList(n8, state2);
      else
        ret = null;
      if (ret === null) {
        state2.needReadable = state2.length <= state2.highWaterMark;
        n8 = 0;
      } else {
        state2.length -= n8;
        state2.awaitDrain = 0;
      }
      if (state2.length === 0) {
        if (!state2.ended)
          state2.needReadable = true;
        if (nOrig !== n8 && state2.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state2) {
      debug("onEofChunk");
      if (state2.ended)
        return;
      if (state2.decoder) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) {
          state2.buffer.push(chunk);
          state2.length += state2.objectMode ? 1 : chunk.length;
        }
      }
      state2.ended = true;
      if (state2.sync) {
        emitReadable(stream);
      } else {
        state2.needReadable = false;
        if (!state2.emittedReadable) {
          state2.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state2 = stream._readableState;
      debug("emitReadable", state2.needReadable, state2.emittedReadable);
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        debug("emitReadable", state2.flowing);
        state2.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state2 = stream._readableState;
      debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
      if (!state2.destroyed && (state2.length || state2.ended)) {
        stream.emit("readable");
        state2.emittedReadable = false;
      }
      state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state2) {
      if (!state2.readingMore) {
        state2.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state2);
      }
    }
    function maybeReadMore_(stream, state2) {
      while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
        var len2 = state2.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len2 === state2.length)
          break;
      }
      state2.readingMore = false;
    }
    Readable.prototype._read = function(n8) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state2 = this._readableState;
      switch (state2.pipesCount) {
        case 0:
          state2.pipes = dest;
          break;
        case 1:
          state2.pipes = [state2.pipes, dest];
          break;
        default:
          state2.pipes.push(dest);
          break;
      }
      state2.pipesCount += 1;
      debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state2.endEmitted)
        process$1.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state2.awaitDrain);
            state2.awaitDrain++;
          }
          src2.pause();
        }
      }
      function onerror(er2) {
        debug("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er2);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state2.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function pipeOnDrainFunctionResult() {
        var state2 = src2._readableState;
        debug("pipeOnDrain", state2.awaitDrain);
        if (state2.awaitDrain)
          state2.awaitDrain--;
        if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state2.flowing = true;
          flow(src2);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state2 = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state2.pipesCount === 0)
        return this;
      if (state2.pipesCount === 1) {
        if (dest && dest !== state2.pipes)
          return this;
        if (!dest)
          dest = state2.pipes;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state2.pipes;
        var len2 = state2.pipesCount;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        for (var i10 = 0; i10 < len2; i10++)
          dests[i10].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index2 = indexOf(state2.pipes, dest);
      if (index2 === -1)
        return this;
      state2.pipes.splice(index2, 1);
      state2.pipesCount -= 1;
      if (state2.pipesCount === 1)
        state2.pipes = state2.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev2, fn2) {
      var res = Stream.prototype.on.call(this, ev2, fn2);
      var state2 = this._readableState;
      if (ev2 === "data") {
        state2.readableListening = this.listenerCount("readable") > 0;
        if (state2.flowing !== false)
          this.resume();
      } else if (ev2 === "readable") {
        if (!state2.endEmitted && !state2.readableListening) {
          state2.readableListening = state2.needReadable = true;
          state2.flowing = false;
          state2.emittedReadable = false;
          debug("on readable", state2.length, state2.reading);
          if (state2.length) {
            emitReadable(this);
          } else if (!state2.reading) {
            process$1.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev2, fn2) {
      var res = Stream.prototype.removeListener.call(this, ev2, fn2);
      if (ev2 === "readable") {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev2) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev2 === "readable" || ev2 === void 0) {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state2 = self2._readableState;
      state2.readableListening = self2.listenerCount("readable") > 0;
      if (state2.resumeScheduled && !state2.paused) {
        state2.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state2 = this._readableState;
      if (!state2.flowing) {
        debug("resume");
        state2.flowing = !state2.readableListening;
        resume(this, state2);
      }
      state2.paused = false;
      return this;
    };
    function resume(stream, state2) {
      if (!state2.resumeScheduled) {
        state2.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state2);
      }
    }
    function resume_(stream, state2) {
      debug("resume", state2.reading);
      if (!state2.reading) {
        stream.read(0);
      }
      state2.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state2.flowing && !state2.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state2 = stream._readableState;
      debug("flow", state2.flowing);
      while (state2.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state2 = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state2.decoder && !state2.ended) {
          var chunk = state2.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state2.decoder)
          chunk = state2.decoder.write(chunk);
        if (state2.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state2.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i10 in stream) {
        if (this[i10] === void 0 && typeof stream[i10] === "function") {
          this[i10] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i10);
        }
      }
      for (var n8 = 0; n8 < kProxyEvents.length; n8++) {
        stream.on(kProxyEvents[n8], this.emit.bind(this, kProxyEvents[n8]));
      }
      this._read = function(n10) {
        debug("wrapped _read", n10);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = requireAsync_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state2) {
        if (this._readableState) {
          this._readableState.flowing = state2;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n8, state2) {
      if (state2.length === 0)
        return null;
      var ret;
      if (state2.objectMode)
        ret = state2.buffer.shift();
      else if (!n8 || n8 >= state2.length) {
        if (state2.decoder)
          ret = state2.buffer.join("");
        else if (state2.buffer.length === 1)
          ret = state2.buffer.first();
        else
          ret = state2.buffer.concat(state2.length);
        state2.buffer.clear();
      } else {
        ret = state2.buffer.consume(n8, state2.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state2 = stream._readableState;
      debug("endReadable", state2.endEmitted);
      if (!state2.endEmitted) {
        state2.ended = true;
        process$1.nextTick(endReadableNT, state2, stream);
      }
    }
    function endReadableNT(state2, stream) {
      debug("endReadableNT", state2.endEmitted, state2.length);
      if (!state2.endEmitted && state2.length === 0) {
        state2.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state2.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = requireFromBrowser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs2, x) {
      for (var i10 = 0, l = xs2.length; i10 < l; i10++) {
        if (xs2[i10] === x)
          return i10;
      }
      return -1;
    }
    return _stream_readable;
  }
  var _stream_transform;
  var hasRequired_stream_transform;
  function require_stream_transform() {
    if (hasRequired_stream_transform)
      return _stream_transform;
    hasRequired_stream_transform = 1;
    _stream_transform = Transform;
    var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    requireInherits_browser()(Transform, Duplex);
    function afterTransform(er2, data) {
      var ts2 = this._transformState;
      ts2.transforming = false;
      var cb = ts2.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts2.writechunk = null;
      ts2.writecb = null;
      if (data != null)
        this.push(data);
      cb(er2);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options4) {
      if (!(this instanceof Transform))
        return new Transform(options4);
      Duplex.call(this, options4);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options4) {
        if (typeof options4.transform === "function")
          this._transform = options4.transform;
        if (typeof options4.flush === "function")
          this._flush = options4.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er2, data) {
          done(_this, er2, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n8) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er2, data) {
      if (er2)
        return stream.emit("error", er2);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    return _stream_transform;
  }
  var _stream_passthrough;
  var hasRequired_stream_passthrough;
  function require_stream_passthrough() {
    if (hasRequired_stream_passthrough)
      return _stream_passthrough;
    hasRequired_stream_passthrough = 1;
    _stream_passthrough = PassThrough;
    var Transform = require_stream_transform();
    requireInherits_browser()(PassThrough, Transform);
    function PassThrough(options4) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options4);
      Transform.call(this, options4);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return _stream_passthrough;
  }
  var pipeline_1;
  var hasRequiredPipeline;
  function requirePipeline() {
    if (hasRequiredPipeline)
      return pipeline_1;
    hasRequiredPipeline = 1;
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = requireEndOfStream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i10) {
        var reading = i10 < streams.length - 1;
        var writing = i10 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    pipeline_1 = pipeline;
    return pipeline_1;
  }
  var hasRequiredReadableBrowser;
  function requireReadableBrowser() {
    if (hasRequiredReadableBrowser)
      return readableBrowser.exports;
    hasRequiredReadableBrowser = 1;
    (function(module2, exports2) {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = requireEndOfStream();
      exports2.pipeline = requirePipeline();
    })(readableBrowser, readableBrowser.exports);
    return readableBrowser.exports;
  }
  var hashBase;
  var hasRequiredHashBase;
  function requireHashBase() {
    if (hasRequiredHashBase)
      return hashBase;
    hasRequiredHashBase = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var Transform = requireReadableBrowser().Transform;
    var inherits = requireInherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer2.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer2.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer2.isBuffer(data))
        data = Buffer2.from(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i10 = this._blockOffset; i10 < this._blockSize; )
          block[i10++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0)
          this._length[j] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i10 = 0; i10 < 4; ++i10)
        this._length[i10] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    hashBase = HashBase;
    return hashBase;
  }
  var md5_js;
  var hasRequiredMd5_js;
  function requireMd5_js() {
    if (hasRequiredMd5_js)
      return md5_js;
    hasRequiredMd5_js = 1;
    var inherits = requireInherits_browser();
    var HashBase = requireHashBase();
    var Buffer2 = requireSafeBuffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i10 = 0; i10 < 16; ++i10)
        M[i10] = this._block.readInt32LE(i10 * 4);
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b, M[2], 606105819, 17);
      b = fnF(b, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b, M[6], 2821735955, 17);
      b = fnF(b, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b, M[10], 4294925233, 17);
      b = fnF(b, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b, M[14], 2792965006, 17);
      b = fnF(b, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b, M[11], 643717713, 14);
      b = fnG(b, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b, M[15], 3634488961, 14);
      b = fnG(b, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b, M[3], 4107603335, 14);
      b = fnG(b, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b, M[7], 1735328473, 14);
      b = fnG(b, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b, M[11], 1839030562, 16);
      b = fnH(b, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b, M[7], 4139469664, 16);
      b = fnH(b, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b, M[3], 3572445317, 16);
      b = fnH(b, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b, M[15], 530742520, 16);
      b = fnH(b, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b, M[14], 2878612391, 15);
      b = fnI(b, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b, M[10], 4293915773, 15);
      b = fnI(b, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b, M[6], 2734768916, 15);
      b = fnI(b, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b, M[2], 718787259, 15);
      b = fnI(b, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer2.allocUnsafe(16);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      return buffer2;
    };
    function rotl(x, n8) {
      return x << n8 | x >>> 32 - n8;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    md5_js = MD5;
    return md5_js;
  }
  var ripemd160;
  var hasRequiredRipemd160;
  function requireRipemd160() {
    if (hasRequiredRipemd160)
      return ripemd160;
    hasRequiredRipemd160 = 1;
    var Buffer2 = buffer$1.Buffer;
    var inherits = requireInherits_browser();
    var HashBase = requireHashBase();
    var ARRAY16 = new Array(16);
    var zl2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr2 = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl2 = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var words = ARRAY16;
      for (var j = 0; j < 16; ++j)
        words[j] = this._block.readInt32LE(j * 4);
      var al = this._a | 0;
      var bl2 = this._b | 0;
      var cl2 = this._c | 0;
      var dl2 = this._d | 0;
      var el2 = this._e | 0;
      var ar2 = this._a | 0;
      var br = this._b | 0;
      var cr2 = this._c | 0;
      var dr2 = this._d | 0;
      var er2 = this._e | 0;
      for (var i10 = 0; i10 < 80; i10 += 1) {
        var tl;
        var tr2;
        if (i10 < 16) {
          tl = fn1(al, bl2, cl2, dl2, el2, words[zl2[i10]], hl2[0], sl[i10]);
          tr2 = fn5(ar2, br, cr2, dr2, er2, words[zr2[i10]], hr[0], sr[i10]);
        } else if (i10 < 32) {
          tl = fn2(al, bl2, cl2, dl2, el2, words[zl2[i10]], hl2[1], sl[i10]);
          tr2 = fn4(ar2, br, cr2, dr2, er2, words[zr2[i10]], hr[1], sr[i10]);
        } else if (i10 < 48) {
          tl = fn3(al, bl2, cl2, dl2, el2, words[zl2[i10]], hl2[2], sl[i10]);
          tr2 = fn3(ar2, br, cr2, dr2, er2, words[zr2[i10]], hr[2], sr[i10]);
        } else if (i10 < 64) {
          tl = fn4(al, bl2, cl2, dl2, el2, words[zl2[i10]], hl2[3], sl[i10]);
          tr2 = fn2(ar2, br, cr2, dr2, er2, words[zr2[i10]], hr[3], sr[i10]);
        } else {
          tl = fn5(al, bl2, cl2, dl2, el2, words[zl2[i10]], hl2[4], sl[i10]);
          tr2 = fn1(ar2, br, cr2, dr2, er2, words[zr2[i10]], hr[4], sr[i10]);
        }
        al = el2;
        el2 = dl2;
        dl2 = rotl(cl2, 10);
        cl2 = bl2;
        bl2 = tl;
        ar2 = er2;
        er2 = dr2;
        dr2 = rotl(cr2, 10);
        cr2 = br;
        br = tr2;
      }
      var t8 = this._b + cl2 + dr2 | 0;
      this._b = this._c + dl2 + er2 | 0;
      this._c = this._d + el2 + ar2 | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl2 + cr2 | 0;
      this._a = t8;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      buffer2.writeInt32LE(this._e, 16);
      return buffer2;
    };
    function rotl(x, n8) {
      return x << n8 | x >>> 32 - n8;
    }
    function fn1(a, b, c, d, e8, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e8 | 0;
    }
    function fn2(a, b, c, d, e8, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e8 | 0;
    }
    function fn3(a, b, c, d, e8, m, k, s) {
      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e8 | 0;
    }
    function fn4(a, b, c, d, e8, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e8 | 0;
    }
    function fn5(a, b, c, d, e8, m, k, s) {
      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e8 | 0;
    }
    ripemd160 = RIPEMD160;
    return ripemd160;
  }
  var sha_js = { exports: {} };
  var hash$1;
  var hasRequiredHash$1;
  function requireHash$1() {
    if (hasRequiredHash$1)
      return hash$1;
    hasRequiredHash$1 = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i10 = 0; i10 < remainder; i10++) {
          block[assigned + i10] = data[offset + i10];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash2 = this._hash();
      return enc ? hash2.toString(enc) : hash2;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    hash$1 = Hash;
    return hash$1;
  }
  var sha$1;
  var hasRequiredSha$1;
  function requireSha$1() {
    if (hasRequiredSha$1)
      return sha$1;
    hasRequiredSha$1 = 1;
    var inherits = requireInherits_browser();
    var Hash = requireHash$1();
    var Buffer2 = requireSafeBuffer().Buffer;
    var K5 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W5 = new Array(80);
    function Sha() {
      this.init();
      this._w = W5;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft2(s, b, c, d) {
      if (s === 0)
        return b & c | ~b & d;
      if (s === 2)
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W10 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e8 = this._e | 0;
      for (var i10 = 0; i10 < 16; ++i10)
        W10[i10] = M.readInt32BE(i10 * 4);
      for (; i10 < 80; ++i10)
        W10[i10] = W10[i10 - 3] ^ W10[i10 - 8] ^ W10[i10 - 14] ^ W10[i10 - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t8 = rotl5(a) + ft2(s, b, c, d) + e8 + W10[j] + K5[s] | 0;
        e8 = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t8;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e8 + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(20);
      H2.writeInt32BE(this._a | 0, 0);
      H2.writeInt32BE(this._b | 0, 4);
      H2.writeInt32BE(this._c | 0, 8);
      H2.writeInt32BE(this._d | 0, 12);
      H2.writeInt32BE(this._e | 0, 16);
      return H2;
    };
    sha$1 = Sha;
    return sha$1;
  }
  var sha1;
  var hasRequiredSha1;
  function requireSha1() {
    if (hasRequiredSha1)
      return sha1;
    hasRequiredSha1 = 1;
    var inherits = requireInherits_browser();
    var Hash = requireHash$1();
    var Buffer2 = requireSafeBuffer().Buffer;
    var K5 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W5 = new Array(80);
    function Sha1() {
      this.init();
      this._w = W5;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft2(s, b, c, d) {
      if (s === 0)
        return b & c | ~b & d;
      if (s === 2)
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W10 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e8 = this._e | 0;
      for (var i10 = 0; i10 < 16; ++i10)
        W10[i10] = M.readInt32BE(i10 * 4);
      for (; i10 < 80; ++i10)
        W10[i10] = rotl1(W10[i10 - 3] ^ W10[i10 - 8] ^ W10[i10 - 14] ^ W10[i10 - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t8 = rotl5(a) + ft2(s, b, c, d) + e8 + W10[j] + K5[s] | 0;
        e8 = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t8;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e8 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(20);
      H2.writeInt32BE(this._a | 0, 0);
      H2.writeInt32BE(this._b | 0, 4);
      H2.writeInt32BE(this._c | 0, 8);
      H2.writeInt32BE(this._d | 0, 12);
      H2.writeInt32BE(this._e | 0, 16);
      return H2;
    };
    sha1 = Sha1;
    return sha1;
  }
  var sha256$3;
  var hasRequiredSha256;
  function requireSha256() {
    if (hasRequiredSha256)
      return sha256$3;
    hasRequiredSha256 = 1;
    var inherits = requireInherits_browser();
    var Hash = requireHash$1();
    var Buffer2 = requireSafeBuffer().Buffer;
    var K5 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W5 = new Array(64);
    function Sha256() {
      this.init();
      this._w = W5;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch2(x, y10, z) {
      return z ^ x & (y10 ^ z);
    }
    function maj(x, y10, z) {
      return x & y10 | z & (x | y10);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var W10 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e8 = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i10 = 0; i10 < 16; ++i10)
        W10[i10] = M.readInt32BE(i10 * 4);
      for (; i10 < 64; ++i10)
        W10[i10] = gamma1(W10[i10 - 2]) + W10[i10 - 7] + gamma0(W10[i10 - 15]) + W10[i10 - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T12 = h + sigma1(e8) + ch2(e8, f, g) + K5[j] + W10[j] | 0;
        var T22 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e8;
        e8 = d + T12 | 0;
        d = c;
        c = b;
        b = a;
        a = T12 + T22 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e8 + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(32);
      H2.writeInt32BE(this._a, 0);
      H2.writeInt32BE(this._b, 4);
      H2.writeInt32BE(this._c, 8);
      H2.writeInt32BE(this._d, 12);
      H2.writeInt32BE(this._e, 16);
      H2.writeInt32BE(this._f, 20);
      H2.writeInt32BE(this._g, 24);
      H2.writeInt32BE(this._h, 28);
      return H2;
    };
    sha256$3 = Sha256;
    return sha256$3;
  }
  var sha224$1;
  var hasRequiredSha224;
  function requireSha224() {
    if (hasRequiredSha224)
      return sha224$1;
    hasRequiredSha224 = 1;
    var inherits = requireInherits_browser();
    var Sha256 = requireSha256();
    var Hash = requireHash$1();
    var Buffer2 = requireSafeBuffer().Buffer;
    var W5 = new Array(64);
    function Sha224() {
      this.init();
      this._w = W5;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(28);
      H2.writeInt32BE(this._a, 0);
      H2.writeInt32BE(this._b, 4);
      H2.writeInt32BE(this._c, 8);
      H2.writeInt32BE(this._d, 12);
      H2.writeInt32BE(this._e, 16);
      H2.writeInt32BE(this._f, 20);
      H2.writeInt32BE(this._g, 24);
      return H2;
    };
    sha224$1 = Sha224;
    return sha224$1;
  }
  var sha512$1;
  var hasRequiredSha512;
  function requireSha512() {
    if (hasRequiredSha512)
      return sha512$1;
    hasRequiredSha512 = 1;
    var inherits = requireInherits_browser();
    var Hash = requireHash$1();
    var Buffer2 = requireSafeBuffer().Buffer;
    var K5 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W5 = new Array(160);
    function Sha512() {
      this.init();
      this._w = W5;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch2(x, y10, z) {
      return z ^ x & (y10 ^ z);
    }
    function maj(x, y10, z) {
      return x & y10 | z & (x | y10);
    }
    function sigma0(x, xl2) {
      return (x >>> 28 | xl2 << 4) ^ (xl2 >>> 2 | x << 30) ^ (xl2 >>> 7 | x << 25);
    }
    function sigma1(x, xl2) {
      return (x >>> 14 | xl2 << 18) ^ (x >>> 18 | xl2 << 14) ^ (xl2 >>> 9 | x << 23);
    }
    function Gamma0(x, xl2) {
      return (x >>> 1 | xl2 << 31) ^ (x >>> 8 | xl2 << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl2) {
      return (x >>> 1 | xl2 << 31) ^ (x >>> 8 | xl2 << 24) ^ (x >>> 7 | xl2 << 25);
    }
    function Gamma1(x, xl2) {
      return (x >>> 19 | xl2 << 13) ^ (xl2 >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl2) {
      return (x >>> 19 | xl2 << 13) ^ (xl2 >>> 29 | x << 3) ^ (x >>> 6 | xl2 << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W10 = this._w;
      var ah2 = this._ah | 0;
      var bh2 = this._bh | 0;
      var ch2 = this._ch | 0;
      var dh2 = this._dh | 0;
      var eh2 = this._eh | 0;
      var fh2 = this._fh | 0;
      var gh2 = this._gh | 0;
      var hh2 = this._hh | 0;
      var al = this._al | 0;
      var bl2 = this._bl | 0;
      var cl2 = this._cl | 0;
      var dl2 = this._dl | 0;
      var el2 = this._el | 0;
      var fl2 = this._fl | 0;
      var gl2 = this._gl | 0;
      var hl2 = this._hl | 0;
      for (var i10 = 0; i10 < 32; i10 += 2) {
        W10[i10] = M.readInt32BE(i10 * 4);
        W10[i10 + 1] = M.readInt32BE(i10 * 4 + 4);
      }
      for (; i10 < 160; i10 += 2) {
        var xh2 = W10[i10 - 15 * 2];
        var xl2 = W10[i10 - 15 * 2 + 1];
        var gamma0 = Gamma0(xh2, xl2);
        var gamma0l = Gamma0l(xl2, xh2);
        xh2 = W10[i10 - 2 * 2];
        xl2 = W10[i10 - 2 * 2 + 1];
        var gamma1 = Gamma1(xh2, xl2);
        var gamma1l = Gamma1l(xl2, xh2);
        var Wi7h = W10[i10 - 7 * 2];
        var Wi7l = W10[i10 - 7 * 2 + 1];
        var Wi16h = W10[i10 - 16 * 2];
        var Wi16l = W10[i10 - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W10[i10] = Wih;
        W10[i10 + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W10[j];
        Wil = W10[j + 1];
        var majh = maj(ah2, bh2, ch2);
        var majl = maj(al, bl2, cl2);
        var sigma0h = sigma0(ah2, al);
        var sigma0l = sigma0(al, ah2);
        var sigma1h = sigma1(eh2, el2);
        var sigma1l = sigma1(el2, eh2);
        var Kih = K5[j];
        var Kil = K5[j + 1];
        var chh = Ch2(eh2, fh2, gh2);
        var chl = Ch2(el2, fl2, gl2);
        var t1l = hl2 + sigma1l | 0;
        var t1h = hh2 + sigma1h + getCarry(t1l, hl2) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh2 = gh2;
        hl2 = gl2;
        gh2 = fh2;
        gl2 = fl2;
        fh2 = eh2;
        fl2 = el2;
        el2 = dl2 + t1l | 0;
        eh2 = dh2 + t1h + getCarry(el2, dl2) | 0;
        dh2 = ch2;
        dl2 = cl2;
        ch2 = bh2;
        cl2 = bl2;
        bh2 = ah2;
        bl2 = al;
        al = t1l + t2l | 0;
        ah2 = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl2 | 0;
      this._cl = this._cl + cl2 | 0;
      this._dl = this._dl + dl2 | 0;
      this._el = this._el + el2 | 0;
      this._fl = this._fl + fl2 | 0;
      this._gl = this._gl + gl2 | 0;
      this._hl = this._hl + hl2 | 0;
      this._ah = this._ah + ah2 + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh2 + getCarry(this._bl, bl2) | 0;
      this._ch = this._ch + ch2 + getCarry(this._cl, cl2) | 0;
      this._dh = this._dh + dh2 + getCarry(this._dl, dl2) | 0;
      this._eh = this._eh + eh2 + getCarry(this._el, el2) | 0;
      this._fh = this._fh + fh2 + getCarry(this._fl, fl2) | 0;
      this._gh = this._gh + gh2 + getCarry(this._gl, gl2) | 0;
      this._hh = this._hh + hh2 + getCarry(this._hl, hl2) | 0;
    };
    Sha512.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H2.writeInt32BE(h, offset);
        H2.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H2;
    };
    sha512$1 = Sha512;
    return sha512$1;
  }
  var sha384$1;
  var hasRequiredSha384;
  function requireSha384() {
    if (hasRequiredSha384)
      return sha384$1;
    hasRequiredSha384 = 1;
    var inherits = requireInherits_browser();
    var SHA512 = requireSha512();
    var Hash = requireHash$1();
    var Buffer2 = requireSafeBuffer().Buffer;
    var W5 = new Array(160);
    function Sha384() {
      this.init();
      this._w = W5;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H2 = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H2.writeInt32BE(h, offset);
        H2.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H2;
    };
    sha384$1 = Sha384;
    return sha384$1;
  }
  var hasRequiredSha_js;
  function requireSha_js() {
    if (hasRequiredSha_js)
      return sha_js.exports;
    hasRequiredSha_js = 1;
    var exports2 = sha_js.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports2[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports2.sha = requireSha$1();
    exports2.sha1 = requireSha1();
    exports2.sha224 = requireSha224();
    exports2.sha256 = requireSha256();
    exports2.sha384 = requireSha384();
    exports2.sha512 = requireSha512();
    return sha_js.exports;
  }
  var streamBrowserify;
  var hasRequiredStreamBrowserify;
  function requireStreamBrowserify() {
    if (hasRequiredStreamBrowserify)
      return streamBrowserify;
    hasRequiredStreamBrowserify = 1;
    streamBrowserify = Stream;
    var EE2 = requireEvents().EventEmitter;
    var inherits = requireInherits_browser();
    inherits(Stream, EE2);
    Stream.Readable = require_stream_readable();
    Stream.Writable = require_stream_writable();
    Stream.Duplex = require_stream_duplex();
    Stream.Transform = require_stream_transform();
    Stream.PassThrough = require_stream_passthrough();
    Stream.finished = requireEndOfStream();
    Stream.pipeline = requirePipeline();
    Stream.Stream = Stream;
    function Stream() {
      EE2.call(this);
    }
    Stream.prototype.pipe = function(dest, options4) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options4 || options4.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er2) {
        cleanup();
        if (EE2.listenerCount(this, "error") === 0) {
          throw er2;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    return streamBrowserify;
  }
  var cipherBase;
  var hasRequiredCipherBase;
  function requireCipherBase() {
    if (hasRequiredCipherBase)
      return cipherBase;
    hasRequiredCipherBase = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var Transform = requireStreamBrowserify().Transform;
    var StringDecoder = requireString_decoder().StringDecoder;
    var inherits = requireInherits_browser();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits(CipherBase, Transform);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer2.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode)
        return this;
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e8) {
        err = e8;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e8) {
        err = e8;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer2.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc)
        throw new Error("can't switch encodings");
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    cipherBase = CipherBase;
    return cipherBase;
  }
  var browser$9;
  var hasRequiredBrowser$9;
  function requireBrowser$9() {
    if (hasRequiredBrowser$9)
      return browser$9;
    hasRequiredBrowser$9 = 1;
    var inherits = requireInherits_browser();
    var MD5 = requireMd5_js();
    var RIPEMD160 = requireRipemd160();
    var sha2 = requireSha_js();
    var Base = requireCipherBase();
    function Hash(hash2) {
      Base.call(this, "digest");
      this._hash = hash2;
    }
    inherits(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    browser$9 = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5")
        return new MD5();
      if (alg === "rmd160" || alg === "ripemd160")
        return new RIPEMD160();
      return new Hash(sha2(alg));
    };
    return browser$9;
  }
  var legacy;
  var hasRequiredLegacy;
  function requireLegacy() {
    if (hasRequiredLegacy)
      return legacy;
    hasRequiredLegacy = 1;
    var inherits = requireInherits_browser();
    var Buffer2 = requireSafeBuffer().Buffer;
    var Base = requireCipherBase();
    var ZEROS = Buffer2.alloc(128);
    var blocksize = 64;
    function Hmac(alg, key2) {
      Base.call(this, "digest");
      if (typeof key2 === "string") {
        key2 = Buffer2.from(key2);
      }
      this._alg = alg;
      this._key = key2;
      if (key2.length > blocksize) {
        key2 = alg(key2);
      } else if (key2.length < blocksize) {
        key2 = Buffer2.concat([key2, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i10 = 0; i10 < blocksize; i10++) {
        ipad[i10] = key2[i10] ^ 54;
        opad[i10] = key2[i10] ^ 92;
      }
      this._hash = [ipad];
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.push(data);
    };
    Hmac.prototype._final = function() {
      var h = this._alg(Buffer2.concat(this._hash));
      return this._alg(Buffer2.concat([this._opad, h]));
    };
    legacy = Hmac;
    return legacy;
  }
  var md5;
  var hasRequiredMd5;
  function requireMd5() {
    if (hasRequiredMd5)
      return md5;
    hasRequiredMd5 = 1;
    var MD5 = requireMd5_js();
    md5 = function(buffer2) {
      return new MD5().update(buffer2).digest();
    };
    return md5;
  }
  var browser$8;
  var hasRequiredBrowser$8;
  function requireBrowser$8() {
    if (hasRequiredBrowser$8)
      return browser$8;
    hasRequiredBrowser$8 = 1;
    var inherits = requireInherits_browser();
    var Legacy = requireLegacy();
    var Base = requireCipherBase();
    var Buffer2 = requireSafeBuffer().Buffer;
    var md52 = requireMd5();
    var RIPEMD160 = requireRipemd160();
    var sha2 = requireSha_js();
    var ZEROS = Buffer2.alloc(128);
    function Hmac(alg, key2) {
      Base.call(this, "digest");
      if (typeof key2 === "string") {
        key2 = Buffer2.from(key2);
      }
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      this._alg = alg;
      this._key = key2;
      if (key2.length > blocksize) {
        var hash2 = alg === "rmd160" ? new RIPEMD160() : sha2(alg);
        key2 = hash2.update(key2).digest();
      } else if (key2.length < blocksize) {
        key2 = Buffer2.concat([key2, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i10 = 0; i10 < blocksize; i10++) {
        ipad[i10] = key2[i10] ^ 54;
        opad[i10] = key2[i10] ^ 92;
      }
      this._hash = alg === "rmd160" ? new RIPEMD160() : sha2(alg);
      this._hash.update(ipad);
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hmac.prototype._final = function() {
      var h = this._hash.digest();
      var hash2 = this._alg === "rmd160" ? new RIPEMD160() : sha2(this._alg);
      return hash2.update(this._opad).update(h).digest();
    };
    browser$8 = function createHmac(alg, key2) {
      alg = alg.toLowerCase();
      if (alg === "rmd160" || alg === "ripemd160") {
        return new Hmac("rmd160", key2);
      }
      if (alg === "md5") {
        return new Legacy(md52, key2);
      }
      return new Hmac(alg, key2);
    };
    return browser$8;
  }
  const sha224WithRSAEncryption = {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  };
  const sha256WithRSAEncryption = {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  };
  const sha384WithRSAEncryption = {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  };
  const sha512WithRSAEncryption = {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  };
  const sha256$2 = {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
  };
  const sha224 = {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
  };
  const sha384 = {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
  };
  const sha512 = {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
  };
  const DSA = {
    sign: "dsa",
    hash: "sha1",
    id: ""
  };
  const ripemd160WithRSA = {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  };
  const md5WithRSAEncryption = {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  };
  const require$$6 = {
    sha224WithRSAEncryption,
    "RSA-SHA224": {
      sign: "ecdsa/rsa",
      hash: "sha224",
      id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption,
    "RSA-SHA256": {
      sign: "ecdsa/rsa",
      hash: "sha256",
      id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption,
    "RSA-SHA384": {
      sign: "ecdsa/rsa",
      hash: "sha384",
      id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption,
    "RSA-SHA512": {
      sign: "ecdsa/rsa",
      hash: "sha512",
      id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
      sign: "rsa",
      hash: "sha1",
      id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
      sign: "ecdsa",
      hash: "sha1",
      id: ""
    },
    sha256: sha256$2,
    sha224,
    sha384,
    sha512,
    "DSA-SHA": {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    "DSA-SHA1": {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    DSA,
    "DSA-WITH-SHA224": {
      sign: "dsa",
      hash: "sha224",
      id: ""
    },
    "DSA-SHA224": {
      sign: "dsa",
      hash: "sha224",
      id: ""
    },
    "DSA-WITH-SHA256": {
      sign: "dsa",
      hash: "sha256",
      id: ""
    },
    "DSA-SHA256": {
      sign: "dsa",
      hash: "sha256",
      id: ""
    },
    "DSA-WITH-SHA384": {
      sign: "dsa",
      hash: "sha384",
      id: ""
    },
    "DSA-SHA384": {
      sign: "dsa",
      hash: "sha384",
      id: ""
    },
    "DSA-WITH-SHA512": {
      sign: "dsa",
      hash: "sha512",
      id: ""
    },
    "DSA-SHA512": {
      sign: "dsa",
      hash: "sha512",
      id: ""
    },
    "DSA-RIPEMD160": {
      sign: "dsa",
      hash: "rmd160",
      id: ""
    },
    ripemd160WithRSA,
    "RSA-RIPEMD160": {
      sign: "rsa",
      hash: "rmd160",
      id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption,
    "RSA-MD5": {
      sign: "rsa",
      hash: "md5",
      id: "3020300c06082a864886f70d020505000410"
    }
  };
  var algos;
  var hasRequiredAlgos;
  function requireAlgos() {
    if (hasRequiredAlgos)
      return algos;
    hasRequiredAlgos = 1;
    algos = require$$6;
    return algos;
  }
  var browser$7 = {};
  var precondition;
  var hasRequiredPrecondition;
  function requirePrecondition() {
    if (hasRequiredPrecondition)
      return precondition;
    hasRequiredPrecondition = 1;
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    precondition = function(iterations, keylen) {
      if (typeof iterations !== "number") {
        throw new TypeError("Iterations not a number");
      }
      if (iterations < 0) {
        throw new TypeError("Bad iterations");
      }
      if (typeof keylen !== "number") {
        throw new TypeError("Key length not a number");
      }
      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
        throw new TypeError("Bad key length");
      }
    };
    return precondition;
  }
  var defaultEncoding_1;
  var hasRequiredDefaultEncoding;
  function requireDefaultEncoding() {
    if (hasRequiredDefaultEncoding)
      return defaultEncoding_1;
    hasRequiredDefaultEncoding = 1;
    var defaultEncoding;
    if (commonjsGlobal.process && commonjsGlobal.process.browser) {
      defaultEncoding = "utf-8";
    } else if (commonjsGlobal.process && commonjsGlobal.process.version) {
      var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
      defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
    } else {
      defaultEncoding = "utf-8";
    }
    defaultEncoding_1 = defaultEncoding;
    return defaultEncoding_1;
  }
  var toBuffer;
  var hasRequiredToBuffer;
  function requireToBuffer() {
    if (hasRequiredToBuffer)
      return toBuffer;
    hasRequiredToBuffer = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    toBuffer = function(thing, encoding, name2) {
      if (Buffer2.isBuffer(thing)) {
        return thing;
      } else if (typeof thing === "string") {
        return Buffer2.from(thing, encoding);
      } else if (ArrayBuffer.isView(thing)) {
        return Buffer2.from(thing.buffer);
      } else {
        throw new TypeError(name2 + " must be a string, a Buffer, a typed array or a DataView");
      }
    };
    return toBuffer;
  }
  var syncBrowser;
  var hasRequiredSyncBrowser;
  function requireSyncBrowser() {
    if (hasRequiredSyncBrowser)
      return syncBrowser;
    hasRequiredSyncBrowser = 1;
    var md52 = requireMd5();
    var RIPEMD160 = requireRipemd160();
    var sha2 = requireSha_js();
    var Buffer2 = requireSafeBuffer().Buffer;
    var checkParameters = requirePrecondition();
    var defaultEncoding = requireDefaultEncoding();
    var toBuffer2 = requireToBuffer();
    var ZEROS = Buffer2.alloc(128);
    var sizes = {
      md5: 16,
      sha1: 20,
      sha224: 28,
      sha256: 32,
      sha384: 48,
      sha512: 64,
      rmd160: 20,
      ripemd160: 20
    };
    function Hmac(alg, key2, saltLen) {
      var hash2 = getDigest(alg);
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      if (key2.length > blocksize) {
        key2 = hash2(key2);
      } else if (key2.length < blocksize) {
        key2 = Buffer2.concat([key2, ZEROS], blocksize);
      }
      var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
      var opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
      for (var i10 = 0; i10 < blocksize; i10++) {
        ipad[i10] = key2[i10] ^ 54;
        opad[i10] = key2[i10] ^ 92;
      }
      var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
      ipad.copy(ipad1, 0, 0, blocksize);
      this.ipad1 = ipad1;
      this.ipad2 = ipad;
      this.opad = opad;
      this.alg = alg;
      this.blocksize = blocksize;
      this.hash = hash2;
      this.size = sizes[alg];
    }
    Hmac.prototype.run = function(data, ipad) {
      data.copy(ipad, this.blocksize);
      var h = this.hash(ipad);
      h.copy(this.opad, this.blocksize);
      return this.hash(this.opad);
    };
    function getDigest(alg) {
      function shaFunc(data) {
        return sha2(alg).update(data).digest();
      }
      function rmd160Func(data) {
        return new RIPEMD160().update(data).digest();
      }
      if (alg === "rmd160" || alg === "ripemd160")
        return rmd160Func;
      if (alg === "md5")
        return md52;
      return shaFunc;
    }
    function pbkdf2(password, salt, iterations, keylen, digest) {
      checkParameters(iterations, keylen);
      password = toBuffer2(password, defaultEncoding, "Password");
      salt = toBuffer2(salt, defaultEncoding, "Salt");
      digest = digest || "sha1";
      var hmac2 = new Hmac(digest, password, salt.length);
      var DK2 = Buffer2.allocUnsafe(keylen);
      var block1 = Buffer2.allocUnsafe(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var destPos = 0;
      var hLen = sizes[digest];
      var l = Math.ceil(keylen / hLen);
      for (var i10 = 1; i10 <= l; i10++) {
        block1.writeUInt32BE(i10, salt.length);
        var T10 = hmac2.run(block1, hmac2.ipad1);
        var U = T10;
        for (var j = 1; j < iterations; j++) {
          U = hmac2.run(U, hmac2.ipad2);
          for (var k = 0; k < hLen; k++)
            T10[k] ^= U[k];
        }
        T10.copy(DK2, destPos);
        destPos += hLen;
      }
      return DK2;
    }
    syncBrowser = pbkdf2;
    return syncBrowser;
  }
  var async;
  var hasRequiredAsync;
  function requireAsync() {
    if (hasRequiredAsync)
      return async;
    hasRequiredAsync = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var checkParameters = requirePrecondition();
    var defaultEncoding = requireDefaultEncoding();
    var sync = requireSyncBrowser();
    var toBuffer2 = requireToBuffer();
    var ZERO_BUF;
    var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
    var toBrowser = {
      sha: "SHA-1",
      "sha-1": "SHA-1",
      sha1: "SHA-1",
      sha256: "SHA-256",
      "sha-256": "SHA-256",
      sha384: "SHA-384",
      "sha-384": "SHA-384",
      "sha-512": "SHA-512",
      sha512: "SHA-512"
    };
    var checks = [];
    function checkNative(algo) {
      if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
        return Promise.resolve(false);
      }
      if (!subtle || !subtle.importKey || !subtle.deriveBits) {
        return Promise.resolve(false);
      }
      if (checks[algo] !== void 0) {
        return checks[algo];
      }
      ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);
      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      checks[algo] = prom;
      return prom;
    }
    var nextTick;
    function getNextTick() {
      if (nextTick) {
        return nextTick;
      }
      if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
        nextTick = commonjsGlobal.process.nextTick;
      } else if (commonjsGlobal.queueMicrotask) {
        nextTick = commonjsGlobal.queueMicrotask;
      } else if (commonjsGlobal.setImmediate) {
        nextTick = commonjsGlobal.setImmediate;
      } else {
        nextTick = commonjsGlobal.setTimeout;
      }
      return nextTick;
    }
    function browserPbkdf2(password, salt, iterations, length, algo) {
      return subtle.importKey(
        "raw",
        password,
        { name: "PBKDF2" },
        false,
        ["deriveBits"]
      ).then(function(key2) {
        return subtle.deriveBits({
          name: "PBKDF2",
          salt,
          iterations,
          hash: {
            name: algo
          }
        }, key2, length << 3);
      }).then(function(res) {
        return Buffer2.from(res);
      });
    }
    function resolvePromise(promise, callback) {
      promise.then(function(out) {
        getNextTick()(function() {
          callback(null, out);
        });
      }, function(e8) {
        getNextTick()(function() {
          callback(e8);
        });
      });
    }
    async = function(password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === "function") {
        callback = digest;
        digest = void 0;
      }
      digest = digest || "sha1";
      var algo = toBrowser[digest.toLowerCase()];
      if (!algo || typeof commonjsGlobal.Promise !== "function") {
        getNextTick()(function() {
          var out;
          try {
            out = sync(password, salt, iterations, keylen, digest);
          } catch (e8) {
            return callback(e8);
          }
          callback(null, out);
        });
        return;
      }
      checkParameters(iterations, keylen);
      password = toBuffer2(password, defaultEncoding, "Password");
      salt = toBuffer2(salt, defaultEncoding, "Salt");
      if (typeof callback !== "function")
        throw new Error("No callback provided to pbkdf2");
      resolvePromise(checkNative(algo).then(function(resp) {
        if (resp)
          return browserPbkdf2(password, salt, iterations, keylen, algo);
        return sync(password, salt, iterations, keylen, digest);
      }), callback);
    };
    return async;
  }
  var hasRequiredBrowser$7;
  function requireBrowser$7() {
    if (hasRequiredBrowser$7)
      return browser$7;
    hasRequiredBrowser$7 = 1;
    browser$7.pbkdf2 = requireAsync();
    browser$7.pbkdf2Sync = requireSyncBrowser();
    return browser$7;
  }
  var browser$6 = {};
  var des$1 = {};
  var utils$3 = {};
  var hasRequiredUtils$3;
  function requireUtils$3() {
    if (hasRequiredUtils$3)
      return utils$3;
    hasRequiredUtils$3 = 1;
    utils$3.readUInt32BE = function readUInt32BE(bytes, off) {
      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
      return res >>> 0;
    };
    utils$3.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
      bytes[0 + off] = value >>> 24;
      bytes[1 + off] = value >>> 16 & 255;
      bytes[2 + off] = value >>> 8 & 255;
      bytes[3 + off] = value & 255;
    };
    utils$3.ip = function ip2(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i10 = 6; i10 >= 0; i10 -= 2) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >>> j + i10 & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >>> j + i10 & 1;
        }
      }
      for (var i10 = 6; i10 >= 0; i10 -= 2) {
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inR >>> j + i10 & 1;
        }
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inL >>> j + i10 & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    utils$3.rip = function rip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i10 = 0; i10 < 4; i10++) {
        for (var j = 24; j >= 0; j -= 8) {
          outL <<= 1;
          outL |= inR >>> j + i10 & 1;
          outL <<= 1;
          outL |= inL >>> j + i10 & 1;
        }
      }
      for (var i10 = 4; i10 < 8; i10++) {
        for (var j = 24; j >= 0; j -= 8) {
          outR <<= 1;
          outR |= inR >>> j + i10 & 1;
          outR <<= 1;
          outR |= inL >>> j + i10 & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    utils$3.pc1 = function pc1(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i10 = 7; i10 >= 5; i10--) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i10 & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >> j + i10 & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i10 & 1;
      }
      for (var i10 = 1; i10 <= 3; i10++) {
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inR >> j + i10 & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i10 & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i10 & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    utils$3.r28shl = function r28shl(num, shift) {
      return num << shift & 268435455 | num >>> 28 - shift;
    };
    var pc2table = [
      // inL => outL
      14,
      11,
      17,
      4,
      27,
      23,
      25,
      0,
      13,
      22,
      7,
      18,
      5,
      9,
      16,
      24,
      2,
      20,
      12,
      21,
      1,
      8,
      15,
      26,
      // inR => outR
      15,
      4,
      25,
      19,
      9,
      1,
      26,
      16,
      5,
      11,
      23,
      8,
      12,
      7,
      17,
      0,
      22,
      3,
      10,
      14,
      6,
      20,
      27,
      24
    ];
    utils$3.pc2 = function pc2(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      var len2 = pc2table.length >>> 1;
      for (var i10 = 0; i10 < len2; i10++) {
        outL <<= 1;
        outL |= inL >>> pc2table[i10] & 1;
      }
      for (var i10 = len2; i10 < pc2table.length; i10++) {
        outR <<= 1;
        outR |= inR >>> pc2table[i10] & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    utils$3.expand = function expand(r8, out, off) {
      var outL = 0;
      var outR = 0;
      outL = (r8 & 1) << 5 | r8 >>> 27;
      for (var i10 = 23; i10 >= 15; i10 -= 4) {
        outL <<= 6;
        outL |= r8 >>> i10 & 63;
      }
      for (var i10 = 11; i10 >= 3; i10 -= 4) {
        outR |= r8 >>> i10 & 63;
        outR <<= 6;
      }
      outR |= (r8 & 31) << 1 | r8 >>> 31;
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    var sTable = [
      14,
      0,
      4,
      15,
      13,
      7,
      1,
      4,
      2,
      14,
      15,
      2,
      11,
      13,
      8,
      1,
      3,
      10,
      10,
      6,
      6,
      12,
      12,
      11,
      5,
      9,
      9,
      5,
      0,
      3,
      7,
      8,
      4,
      15,
      1,
      12,
      14,
      8,
      8,
      2,
      13,
      4,
      6,
      9,
      2,
      1,
      11,
      7,
      15,
      5,
      12,
      11,
      9,
      3,
      7,
      14,
      3,
      10,
      10,
      0,
      5,
      6,
      0,
      13,
      15,
      3,
      1,
      13,
      8,
      4,
      14,
      7,
      6,
      15,
      11,
      2,
      3,
      8,
      4,
      14,
      9,
      12,
      7,
      0,
      2,
      1,
      13,
      10,
      12,
      6,
      0,
      9,
      5,
      11,
      10,
      5,
      0,
      13,
      14,
      8,
      7,
      10,
      11,
      1,
      10,
      3,
      4,
      15,
      13,
      4,
      1,
      2,
      5,
      11,
      8,
      6,
      12,
      7,
      6,
      12,
      9,
      0,
      3,
      5,
      2,
      14,
      15,
      9,
      10,
      13,
      0,
      7,
      9,
      0,
      14,
      9,
      6,
      3,
      3,
      4,
      15,
      6,
      5,
      10,
      1,
      2,
      13,
      8,
      12,
      5,
      7,
      14,
      11,
      12,
      4,
      11,
      2,
      15,
      8,
      1,
      13,
      1,
      6,
      10,
      4,
      13,
      9,
      0,
      8,
      6,
      15,
      9,
      3,
      8,
      0,
      7,
      11,
      4,
      1,
      15,
      2,
      14,
      12,
      3,
      5,
      11,
      10,
      5,
      14,
      2,
      7,
      12,
      7,
      13,
      13,
      8,
      14,
      11,
      3,
      5,
      0,
      6,
      6,
      15,
      9,
      0,
      10,
      3,
      1,
      4,
      2,
      7,
      8,
      2,
      5,
      12,
      11,
      1,
      12,
      10,
      4,
      14,
      15,
      9,
      10,
      3,
      6,
      15,
      9,
      0,
      0,
      6,
      12,
      10,
      11,
      1,
      7,
      13,
      13,
      8,
      15,
      9,
      1,
      4,
      3,
      5,
      14,
      11,
      5,
      12,
      2,
      7,
      8,
      2,
      4,
      14,
      2,
      14,
      12,
      11,
      4,
      2,
      1,
      12,
      7,
      4,
      10,
      7,
      11,
      13,
      6,
      1,
      8,
      5,
      5,
      0,
      3,
      15,
      15,
      10,
      13,
      3,
      0,
      9,
      14,
      8,
      9,
      6,
      4,
      11,
      2,
      8,
      1,
      12,
      11,
      7,
      10,
      1,
      13,
      14,
      7,
      2,
      8,
      13,
      15,
      6,
      9,
      15,
      12,
      0,
      5,
      9,
      6,
      10,
      3,
      4,
      0,
      5,
      14,
      3,
      12,
      10,
      1,
      15,
      10,
      4,
      15,
      2,
      9,
      7,
      2,
      12,
      6,
      9,
      8,
      5,
      0,
      6,
      13,
      1,
      3,
      13,
      4,
      14,
      14,
      0,
      7,
      11,
      5,
      3,
      11,
      8,
      9,
      4,
      14,
      3,
      15,
      2,
      5,
      12,
      2,
      9,
      8,
      5,
      12,
      15,
      3,
      10,
      7,
      11,
      0,
      14,
      4,
      1,
      10,
      7,
      1,
      6,
      13,
      0,
      11,
      8,
      6,
      13,
      4,
      13,
      11,
      0,
      2,
      11,
      14,
      7,
      15,
      4,
      0,
      9,
      8,
      1,
      13,
      10,
      3,
      14,
      12,
      3,
      9,
      5,
      7,
      12,
      5,
      2,
      10,
      15,
      6,
      8,
      1,
      6,
      1,
      6,
      4,
      11,
      11,
      13,
      13,
      8,
      12,
      1,
      3,
      4,
      7,
      10,
      14,
      7,
      10,
      9,
      15,
      5,
      6,
      0,
      8,
      15,
      0,
      14,
      5,
      2,
      9,
      3,
      2,
      12,
      13,
      1,
      2,
      15,
      8,
      13,
      4,
      8,
      6,
      10,
      15,
      3,
      11,
      7,
      1,
      4,
      10,
      12,
      9,
      5,
      3,
      6,
      14,
      11,
      5,
      0,
      0,
      14,
      12,
      9,
      7,
      2,
      7,
      2,
      11,
      1,
      4,
      14,
      1,
      7,
      9,
      4,
      12,
      10,
      14,
      8,
      2,
      13,
      0,
      15,
      6,
      12,
      10,
      9,
      13,
      0,
      15,
      3,
      3,
      5,
      5,
      6,
      8,
      11
    ];
    utils$3.substitute = function substitute(inL, inR) {
      var out = 0;
      for (var i10 = 0; i10 < 4; i10++) {
        var b = inL >>> 18 - i10 * 6 & 63;
        var sb = sTable[i10 * 64 + b];
        out <<= 4;
        out |= sb;
      }
      for (var i10 = 0; i10 < 4; i10++) {
        var b = inR >>> 18 - i10 * 6 & 63;
        var sb = sTable[4 * 64 + i10 * 64 + b];
        out <<= 4;
        out |= sb;
      }
      return out >>> 0;
    };
    var permuteTable = [
      16,
      25,
      12,
      11,
      3,
      20,
      4,
      15,
      31,
      17,
      9,
      6,
      27,
      14,
      1,
      22,
      30,
      24,
      8,
      18,
      0,
      5,
      29,
      23,
      13,
      19,
      2,
      26,
      10,
      21,
      28,
      7
    ];
    utils$3.permute = function permute(num) {
      var out = 0;
      for (var i10 = 0; i10 < permuteTable.length; i10++) {
        out <<= 1;
        out |= num >>> permuteTable[i10] & 1;
      }
      return out >>> 0;
    };
    utils$3.padSplit = function padSplit(num, size2, group) {
      var str = num.toString(2);
      while (str.length < size2)
        str = "0" + str;
      var out = [];
      for (var i10 = 0; i10 < size2; i10 += group)
        out.push(str.slice(i10, i10 + group));
      return out.join(" ");
    };
    return utils$3;
  }
  var minimalisticAssert;
  var hasRequiredMinimalisticAssert;
  function requireMinimalisticAssert() {
    if (hasRequiredMinimalisticAssert)
      return minimalisticAssert;
    hasRequiredMinimalisticAssert = 1;
    minimalisticAssert = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r8, msg) {
      if (l != r8)
        throw new Error(msg || "Assertion failed: " + l + " != " + r8);
    };
    return minimalisticAssert;
  }
  var cipher;
  var hasRequiredCipher;
  function requireCipher() {
    if (hasRequiredCipher)
      return cipher;
    hasRequiredCipher = 1;
    var assert = requireMinimalisticAssert();
    function Cipher(options4) {
      this.options = options4;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
      this.padding = options4.padding !== false;
    }
    cipher = Cipher;
    Cipher.prototype._init = function _init() {
    };
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === "decrypt")
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
      var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
      for (var i10 = 0; i10 < min; i10++)
        this.buffer[this.bufferOff + i10] = data[off + i10];
      this.bufferOff += min;
      return min;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
      this._update(this.buffer, 0, out, off);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count2 = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count2 * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count2 = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count2 * this.blockSize);
      for (; count2 > 0; count2--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer2) {
      var first;
      if (buffer2)
        first = this.update(buffer2);
      var last11;
      if (this.type === "encrypt")
        last11 = this._finalEncrypt();
      else
        last11 = this._finalDecrypt();
      if (first)
        return first.concat(last11);
      else
        return last11;
    };
    Cipher.prototype._pad = function _pad(buffer2, off) {
      if (off === 0)
        return false;
      while (off < buffer2.length)
        buffer2[off++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer2) {
      return buffer2;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
    return cipher;
  }
  var des;
  var hasRequiredDes$1;
  function requireDes$1() {
    if (hasRequiredDes$1)
      return des;
    hasRequiredDes$1 = 1;
    var assert = requireMinimalisticAssert();
    var inherits = requireInherits_browser();
    var utils2 = requireUtils$3();
    var Cipher = requireCipher();
    function DESState() {
      this.tmp = new Array(2);
      this.keys = null;
    }
    function DES(options4) {
      Cipher.call(this, options4);
      var state2 = new DESState();
      this._desState = state2;
      this.deriveKeys(state2, options4.key);
    }
    inherits(DES, Cipher);
    des = DES;
    DES.create = function create(options4) {
      return new DES(options4);
    };
    var shiftTable = [
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1
    ];
    DES.prototype.deriveKeys = function deriveKeys(state2, key2) {
      state2.keys = new Array(16 * 2);
      assert.equal(key2.length, this.blockSize, "Invalid key length");
      var kL2 = utils2.readUInt32BE(key2, 0);
      var kR2 = utils2.readUInt32BE(key2, 4);
      utils2.pc1(kL2, kR2, state2.tmp, 0);
      kL2 = state2.tmp[0];
      kR2 = state2.tmp[1];
      for (var i10 = 0; i10 < state2.keys.length; i10 += 2) {
        var shift = shiftTable[i10 >>> 1];
        kL2 = utils2.r28shl(kL2, shift);
        kR2 = utils2.r28shl(kR2, shift);
        utils2.pc2(kL2, kR2, state2.keys, i10);
      }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
      var state2 = this._desState;
      var l = utils2.readUInt32BE(inp, inOff);
      var r8 = utils2.readUInt32BE(inp, inOff + 4);
      utils2.ip(l, r8, state2.tmp, 0);
      l = state2.tmp[0];
      r8 = state2.tmp[1];
      if (this.type === "encrypt")
        this._encrypt(state2, l, r8, state2.tmp, 0);
      else
        this._decrypt(state2, l, r8, state2.tmp, 0);
      l = state2.tmp[0];
      r8 = state2.tmp[1];
      utils2.writeUInt32BE(out, l, outOff);
      utils2.writeUInt32BE(out, r8, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer2, off) {
      if (this.padding === false) {
        return false;
      }
      var value = buffer2.length - off;
      for (var i10 = off; i10 < buffer2.length; i10++)
        buffer2[i10] = value;
      return true;
    };
    DES.prototype._unpad = function _unpad(buffer2) {
      if (this.padding === false) {
        return buffer2;
      }
      var pad = buffer2[buffer2.length - 1];
      for (var i10 = buffer2.length - pad; i10 < buffer2.length; i10++)
        assert.equal(buffer2[i10], pad);
      return buffer2.slice(0, buffer2.length - pad);
    };
    DES.prototype._encrypt = function _encrypt(state2, lStart, rStart, out, off) {
      var l = lStart;
      var r8 = rStart;
      for (var i10 = 0; i10 < state2.keys.length; i10 += 2) {
        var keyL = state2.keys[i10];
        var keyR = state2.keys[i10 + 1];
        utils2.expand(r8, state2.tmp, 0);
        keyL ^= state2.tmp[0];
        keyR ^= state2.tmp[1];
        var s = utils2.substitute(keyL, keyR);
        var f = utils2.permute(s);
        var t8 = r8;
        r8 = (l ^ f) >>> 0;
        l = t8;
      }
      utils2.rip(r8, l, out, off);
    };
    DES.prototype._decrypt = function _decrypt(state2, lStart, rStart, out, off) {
      var l = rStart;
      var r8 = lStart;
      for (var i10 = state2.keys.length - 2; i10 >= 0; i10 -= 2) {
        var keyL = state2.keys[i10];
        var keyR = state2.keys[i10 + 1];
        utils2.expand(l, state2.tmp, 0);
        keyL ^= state2.tmp[0];
        keyR ^= state2.tmp[1];
        var s = utils2.substitute(keyL, keyR);
        var f = utils2.permute(s);
        var t8 = l;
        l = (r8 ^ f) >>> 0;
        r8 = t8;
      }
      utils2.rip(l, r8, out, off);
    };
    return des;
  }
  var cbc$1 = {};
  var hasRequiredCbc$1;
  function requireCbc$1() {
    if (hasRequiredCbc$1)
      return cbc$1;
    hasRequiredCbc$1 = 1;
    var assert = requireMinimalisticAssert();
    var inherits = requireInherits_browser();
    var proto = {};
    function CBCState(iv2) {
      assert.equal(iv2.length, 8, "Invalid IV length");
      this.iv = new Array(8);
      for (var i10 = 0; i10 < this.iv.length; i10++)
        this.iv[i10] = iv2[i10];
    }
    function instantiate(Base) {
      function CBC(options4) {
        Base.call(this, options4);
        this._cbcInit();
      }
      inherits(CBC, Base);
      var keys = Object.keys(proto);
      for (var i10 = 0; i10 < keys.length; i10++) {
        var key2 = keys[i10];
        CBC.prototype[key2] = proto[key2];
      }
      CBC.create = function create(options4) {
        return new CBC(options4);
      };
      return CBC;
    }
    cbc$1.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
      var state2 = new CBCState(this.options.iv);
      this._cbcState = state2;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
      var state2 = this._cbcState;
      var superProto = this.constructor.super_.prototype;
      var iv2 = state2.iv;
      if (this.type === "encrypt") {
        for (var i10 = 0; i10 < this.blockSize; i10++)
          iv2[i10] ^= inp[inOff + i10];
        superProto._update.call(this, iv2, 0, out, outOff);
        for (var i10 = 0; i10 < this.blockSize; i10++)
          iv2[i10] = out[outOff + i10];
      } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for (var i10 = 0; i10 < this.blockSize; i10++)
          out[outOff + i10] ^= iv2[i10];
        for (var i10 = 0; i10 < this.blockSize; i10++)
          iv2[i10] = inp[inOff + i10];
      }
    };
    return cbc$1;
  }
  var ede$1;
  var hasRequiredEde;
  function requireEde() {
    if (hasRequiredEde)
      return ede$1;
    hasRequiredEde = 1;
    var assert = requireMinimalisticAssert();
    var inherits = requireInherits_browser();
    var Cipher = requireCipher();
    var DES = requireDes$1();
    function EDEState(type, key2) {
      assert.equal(key2.length, 24, "Invalid key length");
      var k12 = key2.slice(0, 8);
      var k22 = key2.slice(8, 16);
      var k32 = key2.slice(16, 24);
      if (type === "encrypt") {
        this.ciphers = [
          DES.create({ type: "encrypt", key: k12 }),
          DES.create({ type: "decrypt", key: k22 }),
          DES.create({ type: "encrypt", key: k32 })
        ];
      } else {
        this.ciphers = [
          DES.create({ type: "decrypt", key: k32 }),
          DES.create({ type: "encrypt", key: k22 }),
          DES.create({ type: "decrypt", key: k12 })
        ];
      }
    }
    function EDE(options4) {
      Cipher.call(this, options4);
      var state2 = new EDEState(this.type, this.options.key);
      this._edeState = state2;
    }
    inherits(EDE, Cipher);
    ede$1 = EDE;
    EDE.create = function create(options4) {
      return new EDE(options4);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
      var state2 = this._edeState;
      state2.ciphers[0]._update(inp, inOff, out, outOff);
      state2.ciphers[1]._update(out, outOff, out, outOff);
      state2.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
    return ede$1;
  }
  var hasRequiredDes;
  function requireDes() {
    if (hasRequiredDes)
      return des$1;
    hasRequiredDes = 1;
    des$1.utils = requireUtils$3();
    des$1.Cipher = requireCipher();
    des$1.DES = requireDes$1();
    des$1.CBC = requireCbc$1();
    des$1.EDE = requireEde();
    return des$1;
  }
  var browserifyDes;
  var hasRequiredBrowserifyDes;
  function requireBrowserifyDes() {
    if (hasRequiredBrowserifyDes)
      return browserifyDes;
    hasRequiredBrowserifyDes = 1;
    var CipherBase = requireCipherBase();
    var des2 = requireDes();
    var inherits = requireInherits_browser();
    var Buffer2 = requireSafeBuffer().Buffer;
    var modes2 = {
      "des-ede3-cbc": des2.CBC.instantiate(des2.EDE),
      "des-ede3": des2.EDE,
      "des-ede-cbc": des2.CBC.instantiate(des2.EDE),
      "des-ede": des2.EDE,
      "des-cbc": des2.CBC.instantiate(des2.DES),
      "des-ecb": des2.DES
    };
    modes2.des = modes2["des-cbc"];
    modes2.des3 = modes2["des-ede3-cbc"];
    browserifyDes = DES;
    inherits(DES, CipherBase);
    function DES(opts) {
      CipherBase.call(this);
      var modeName = opts.mode.toLowerCase();
      var mode = modes2[modeName];
      var type;
      if (opts.decrypt) {
        type = "decrypt";
      } else {
        type = "encrypt";
      }
      var key2 = opts.key;
      if (!Buffer2.isBuffer(key2)) {
        key2 = Buffer2.from(key2);
      }
      if (modeName === "des-ede" || modeName === "des-ede-cbc") {
        key2 = Buffer2.concat([key2, key2.slice(0, 8)]);
      }
      var iv2 = opts.iv;
      if (!Buffer2.isBuffer(iv2)) {
        iv2 = Buffer2.from(iv2);
      }
      this._des = mode.create({
        key: key2,
        iv: iv2,
        type
      });
    }
    DES.prototype._update = function(data) {
      return Buffer2.from(this._des.update(data));
    };
    DES.prototype._final = function() {
      return Buffer2.from(this._des.final());
    };
    return browserifyDes;
  }
  var browser$5 = {};
  var encrypter = {};
  var ecb = {};
  var hasRequiredEcb;
  function requireEcb() {
    if (hasRequiredEcb)
      return ecb;
    hasRequiredEcb = 1;
    ecb.encrypt = function(self2, block) {
      return self2._cipher.encryptBlock(block);
    };
    ecb.decrypt = function(self2, block) {
      return self2._cipher.decryptBlock(block);
    };
    return ecb;
  }
  var cbc = {};
  var bufferXor;
  var hasRequiredBufferXor;
  function requireBufferXor() {
    if (hasRequiredBufferXor)
      return bufferXor;
    hasRequiredBufferXor = 1;
    bufferXor = function xor2(a, b) {
      var length = Math.min(a.length, b.length);
      var buffer2 = new buffer$1.Buffer(length);
      for (var i10 = 0; i10 < length; ++i10) {
        buffer2[i10] = a[i10] ^ b[i10];
      }
      return buffer2;
    };
    return bufferXor;
  }
  var hasRequiredCbc;
  function requireCbc() {
    if (hasRequiredCbc)
      return cbc;
    hasRequiredCbc = 1;
    var xor2 = requireBufferXor();
    cbc.encrypt = function(self2, block) {
      var data = xor2(block, self2._prev);
      self2._prev = self2._cipher.encryptBlock(data);
      return self2._prev;
    };
    cbc.decrypt = function(self2, block) {
      var pad = self2._prev;
      self2._prev = block;
      var out = self2._cipher.decryptBlock(block);
      return xor2(out, pad);
    };
    return cbc;
  }
  var cfb = {};
  var hasRequiredCfb;
  function requireCfb() {
    if (hasRequiredCfb)
      return cfb;
    hasRequiredCfb = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var xor2 = requireBufferXor();
    function encryptStart(self2, data, decrypt) {
      var len2 = data.length;
      var out = xor2(data, self2._cache);
      self2._cache = self2._cache.slice(len2);
      self2._prev = Buffer2.concat([self2._prev, decrypt ? data : out]);
      return out;
    }
    cfb.encrypt = function(self2, data, decrypt) {
      var out = Buffer2.allocUnsafe(0);
      var len2;
      while (data.length) {
        if (self2._cache.length === 0) {
          self2._cache = self2._cipher.encryptBlock(self2._prev);
          self2._prev = Buffer2.allocUnsafe(0);
        }
        if (self2._cache.length <= data.length) {
          len2 = self2._cache.length;
          out = Buffer2.concat([out, encryptStart(self2, data.slice(0, len2), decrypt)]);
          data = data.slice(len2);
        } else {
          out = Buffer2.concat([out, encryptStart(self2, data, decrypt)]);
          break;
        }
      }
      return out;
    };
    return cfb;
  }
  var cfb8 = {};
  var hasRequiredCfb8;
  function requireCfb8() {
    if (hasRequiredCfb8)
      return cfb8;
    hasRequiredCfb8 = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    function encryptByte(self2, byteParam, decrypt) {
      var pad = self2._cipher.encryptBlock(self2._prev);
      var out = pad[0] ^ byteParam;
      self2._prev = Buffer2.concat([
        self2._prev.slice(1),
        Buffer2.from([decrypt ? byteParam : out])
      ]);
      return out;
    }
    cfb8.encrypt = function(self2, chunk, decrypt) {
      var len2 = chunk.length;
      var out = Buffer2.allocUnsafe(len2);
      var i10 = -1;
      while (++i10 < len2) {
        out[i10] = encryptByte(self2, chunk[i10], decrypt);
      }
      return out;
    };
    return cfb8;
  }
  var cfb1 = {};
  var hasRequiredCfb1;
  function requireCfb1() {
    if (hasRequiredCfb1)
      return cfb1;
    hasRequiredCfb1 = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    function encryptByte(self2, byteParam, decrypt) {
      var pad;
      var i10 = -1;
      var len2 = 8;
      var out = 0;
      var bit, value;
      while (++i10 < len2) {
        pad = self2._cipher.encryptBlock(self2._prev);
        bit = byteParam & 1 << 7 - i10 ? 128 : 0;
        value = pad[0] ^ bit;
        out += (value & 128) >> i10 % 8;
        self2._prev = shiftIn(self2._prev, decrypt ? bit : value);
      }
      return out;
    }
    function shiftIn(buffer2, value) {
      var len2 = buffer2.length;
      var i10 = -1;
      var out = Buffer2.allocUnsafe(buffer2.length);
      buffer2 = Buffer2.concat([buffer2, Buffer2.from([value])]);
      while (++i10 < len2) {
        out[i10] = buffer2[i10] << 1 | buffer2[i10 + 1] >> 7;
      }
      return out;
    }
    cfb1.encrypt = function(self2, chunk, decrypt) {
      var len2 = chunk.length;
      var out = Buffer2.allocUnsafe(len2);
      var i10 = -1;
      while (++i10 < len2) {
        out[i10] = encryptByte(self2, chunk[i10], decrypt);
      }
      return out;
    };
    return cfb1;
  }
  var ofb = {};
  var hasRequiredOfb;
  function requireOfb() {
    if (hasRequiredOfb)
      return ofb;
    hasRequiredOfb = 1;
    var xor2 = requireBufferXor();
    function getBlock(self2) {
      self2._prev = self2._cipher.encryptBlock(self2._prev);
      return self2._prev;
    }
    ofb.encrypt = function(self2, chunk) {
      while (self2._cache.length < chunk.length) {
        self2._cache = buffer$1.Buffer.concat([self2._cache, getBlock(self2)]);
      }
      var pad = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor2(chunk, pad);
    };
    return ofb;
  }
  var ctr = {};
  var incr32_1;
  var hasRequiredIncr32;
  function requireIncr32() {
    if (hasRequiredIncr32)
      return incr32_1;
    hasRequiredIncr32 = 1;
    function incr32(iv2) {
      var len2 = iv2.length;
      var item;
      while (len2--) {
        item = iv2.readUInt8(len2);
        if (item === 255) {
          iv2.writeUInt8(0, len2);
        } else {
          item++;
          iv2.writeUInt8(item, len2);
          break;
        }
      }
    }
    incr32_1 = incr32;
    return incr32_1;
  }
  var hasRequiredCtr;
  function requireCtr() {
    if (hasRequiredCtr)
      return ctr;
    hasRequiredCtr = 1;
    var xor2 = requireBufferXor();
    var Buffer2 = requireSafeBuffer().Buffer;
    var incr32 = requireIncr32();
    function getBlock(self2) {
      var out = self2._cipher.encryptBlockRaw(self2._prev);
      incr32(self2._prev);
      return out;
    }
    var blockSize = 16;
    ctr.encrypt = function(self2, chunk) {
      var chunkNum = Math.ceil(chunk.length / blockSize);
      var start = self2._cache.length;
      self2._cache = Buffer2.concat([
        self2._cache,
        Buffer2.allocUnsafe(chunkNum * blockSize)
      ]);
      for (var i10 = 0; i10 < chunkNum; i10++) {
        var out = getBlock(self2);
        var offset = start + i10 * blockSize;
        self2._cache.writeUInt32BE(out[0], offset + 0);
        self2._cache.writeUInt32BE(out[1], offset + 4);
        self2._cache.writeUInt32BE(out[2], offset + 8);
        self2._cache.writeUInt32BE(out[3], offset + 12);
      }
      var pad = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor2(chunk, pad);
    };
    return ctr;
  }
  const aes128 = {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  };
  const aes192 = {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  };
  const aes256 = {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  };
  const require$$2 = {
    "aes-128-ecb": {
      cipher: "AES",
      key: 128,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-192-ecb": {
      cipher: "AES",
      key: 192,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-256-ecb": {
      cipher: "AES",
      key: 256,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-128-cbc": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-192-cbc": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-256-cbc": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes128,
    aes192,
    aes256,
    "aes-128-cfb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-192-cfb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-256-cfb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-128-cfb8": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-192-cfb8": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-256-cfb8": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-128-cfb1": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-192-cfb1": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-256-cfb1": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-128-ofb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-192-ofb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-256-ofb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-128-ctr": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-192-ctr": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-256-ctr": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-128-gcm": {
      cipher: "AES",
      key: 128,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-192-gcm": {
      cipher: "AES",
      key: 192,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-256-gcm": {
      cipher: "AES",
      key: 256,
      iv: 12,
      mode: "GCM",
      type: "auth"
    }
  };
  var modes_1;
  var hasRequiredModes$1;
  function requireModes$1() {
    if (hasRequiredModes$1)
      return modes_1;
    hasRequiredModes$1 = 1;
    var modeModules = {
      ECB: requireEcb(),
      CBC: requireCbc(),
      CFB: requireCfb(),
      CFB8: requireCfb8(),
      CFB1: requireCfb1(),
      OFB: requireOfb(),
      CTR: requireCtr(),
      GCM: requireCtr()
    };
    var modes2 = require$$2;
    for (var key2 in modes2) {
      modes2[key2].module = modeModules[modes2[key2].mode];
    }
    modes_1 = modes2;
    return modes_1;
  }
  var aes = {};
  var hasRequiredAes;
  function requireAes() {
    if (hasRequiredAes)
      return aes;
    hasRequiredAes = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    function asUInt32Array(buf) {
      if (!Buffer2.isBuffer(buf))
        buf = Buffer2.from(buf);
      var len2 = buf.length / 4 | 0;
      var out = new Array(len2);
      for (var i10 = 0; i10 < len2; i10++) {
        out[i10] = buf.readUInt32BE(i10 * 4);
      }
      return out;
    }
    function scrubVec(v10) {
      for (var i10 = 0; i10 < v10.length; v10++) {
        v10[i10] = 0;
      }
    }
    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
      var SUB_MIX0 = SUB_MIX[0];
      var SUB_MIX1 = SUB_MIX[1];
      var SUB_MIX2 = SUB_MIX[2];
      var SUB_MIX3 = SUB_MIX[3];
      var s0 = M[0] ^ keySchedule[0];
      var s12 = M[1] ^ keySchedule[1];
      var s22 = M[2] ^ keySchedule[2];
      var s32 = M[3] ^ keySchedule[3];
      var t02, t12, t22, t32;
      var ksRow = 4;
      for (var round = 1; round < nRounds; round++) {
        t02 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s12 >>> 16 & 255] ^ SUB_MIX2[s22 >>> 8 & 255] ^ SUB_MIX3[s32 & 255] ^ keySchedule[ksRow++];
        t12 = SUB_MIX0[s12 >>> 24] ^ SUB_MIX1[s22 >>> 16 & 255] ^ SUB_MIX2[s32 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
        t22 = SUB_MIX0[s22 >>> 24] ^ SUB_MIX1[s32 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s12 & 255] ^ keySchedule[ksRow++];
        t32 = SUB_MIX0[s32 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s12 >>> 8 & 255] ^ SUB_MIX3[s22 & 255] ^ keySchedule[ksRow++];
        s0 = t02;
        s12 = t12;
        s22 = t22;
        s32 = t32;
      }
      t02 = (SBOX[s0 >>> 24] << 24 | SBOX[s12 >>> 16 & 255] << 16 | SBOX[s22 >>> 8 & 255] << 8 | SBOX[s32 & 255]) ^ keySchedule[ksRow++];
      t12 = (SBOX[s12 >>> 24] << 24 | SBOX[s22 >>> 16 & 255] << 16 | SBOX[s32 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
      t22 = (SBOX[s22 >>> 24] << 24 | SBOX[s32 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s12 & 255]) ^ keySchedule[ksRow++];
      t32 = (SBOX[s32 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s12 >>> 8 & 255] << 8 | SBOX[s22 & 255]) ^ keySchedule[ksRow++];
      t02 = t02 >>> 0;
      t12 = t12 >>> 0;
      t22 = t22 >>> 0;
      t32 = t32 >>> 0;
      return [t02, t12, t22, t32];
    }
    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var G = function() {
      var d = new Array(256);
      for (var j = 0; j < 256; j++) {
        if (j < 128) {
          d[j] = j << 1;
        } else {
          d[j] = j << 1 ^ 283;
        }
      }
      var SBOX = [];
      var INV_SBOX = [];
      var SUB_MIX = [[], [], [], []];
      var INV_SUB_MIX = [[], [], [], []];
      var x = 0;
      var xi2 = 0;
      for (var i10 = 0; i10 < 256; ++i10) {
        var sx2 = xi2 ^ xi2 << 1 ^ xi2 << 2 ^ xi2 << 3 ^ xi2 << 4;
        sx2 = sx2 >>> 8 ^ sx2 & 255 ^ 99;
        SBOX[x] = sx2;
        INV_SBOX[sx2] = x;
        var x22 = d[x];
        var x42 = d[x22];
        var x82 = d[x42];
        var t8 = d[sx2] * 257 ^ sx2 * 16843008;
        SUB_MIX[0][x] = t8 << 24 | t8 >>> 8;
        SUB_MIX[1][x] = t8 << 16 | t8 >>> 16;
        SUB_MIX[2][x] = t8 << 8 | t8 >>> 24;
        SUB_MIX[3][x] = t8;
        t8 = x82 * 16843009 ^ x42 * 65537 ^ x22 * 257 ^ x * 16843008;
        INV_SUB_MIX[0][sx2] = t8 << 24 | t8 >>> 8;
        INV_SUB_MIX[1][sx2] = t8 << 16 | t8 >>> 16;
        INV_SUB_MIX[2][sx2] = t8 << 8 | t8 >>> 24;
        INV_SUB_MIX[3][sx2] = t8;
        if (x === 0) {
          x = xi2 = 1;
        } else {
          x = x22 ^ d[d[d[x82 ^ x22]]];
          xi2 ^= d[d[xi2]];
        }
      }
      return {
        SBOX,
        INV_SBOX,
        SUB_MIX,
        INV_SUB_MIX
      };
    }();
    function AES(key2) {
      this._key = asUInt32Array(key2);
      this._reset();
    }
    AES.blockSize = 4 * 4;
    AES.keySize = 256 / 8;
    AES.prototype.blockSize = AES.blockSize;
    AES.prototype.keySize = AES.keySize;
    AES.prototype._reset = function() {
      var keyWords = this._key;
      var keySize = keyWords.length;
      var nRounds = keySize + 6;
      var ksRows = (nRounds + 1) * 4;
      var keySchedule = [];
      for (var k = 0; k < keySize; k++) {
        keySchedule[k] = keyWords[k];
      }
      for (k = keySize; k < ksRows; k++) {
        var t8 = keySchedule[k - 1];
        if (k % keySize === 0) {
          t8 = t8 << 8 | t8 >>> 24;
          t8 = G.SBOX[t8 >>> 24] << 24 | G.SBOX[t8 >>> 16 & 255] << 16 | G.SBOX[t8 >>> 8 & 255] << 8 | G.SBOX[t8 & 255];
          t8 ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
          t8 = G.SBOX[t8 >>> 24] << 24 | G.SBOX[t8 >>> 16 & 255] << 16 | G.SBOX[t8 >>> 8 & 255] << 8 | G.SBOX[t8 & 255];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t8;
      }
      var invKeySchedule = [];
      for (var ik2 = 0; ik2 < ksRows; ik2++) {
        var ksR = ksRows - ik2;
        var tt2 = keySchedule[ksR - (ik2 % 4 ? 0 : 4)];
        if (ik2 < 4 || ksR <= 4) {
          invKeySchedule[ik2] = tt2;
        } else {
          invKeySchedule[ik2] = G.INV_SUB_MIX[0][G.SBOX[tt2 >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt2 >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt2 >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt2 & 255]];
        }
      }
      this._nRounds = nRounds;
      this._keySchedule = keySchedule;
      this._invKeySchedule = invKeySchedule;
    };
    AES.prototype.encryptBlockRaw = function(M) {
      M = asUInt32Array(M);
      return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
    };
    AES.prototype.encryptBlock = function(M) {
      var out = this.encryptBlockRaw(M);
      var buf = Buffer2.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    };
    AES.prototype.decryptBlock = function(M) {
      M = asUInt32Array(M);
      var m12 = M[1];
      M[1] = M[3];
      M[3] = m12;
      var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
      var buf = Buffer2.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[3], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[1], 12);
      return buf;
    };
    AES.prototype.scrub = function() {
      scrubVec(this._keySchedule);
      scrubVec(this._invKeySchedule);
      scrubVec(this._key);
    };
    aes.AES = AES;
    return aes;
  }
  var ghash;
  var hasRequiredGhash;
  function requireGhash() {
    if (hasRequiredGhash)
      return ghash;
    hasRequiredGhash = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var ZEROES = Buffer2.alloc(16, 0);
    function toArray(buf) {
      return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12)
      ];
    }
    function fromArray(out) {
      var buf = Buffer2.allocUnsafe(16);
      buf.writeUInt32BE(out[0] >>> 0, 0);
      buf.writeUInt32BE(out[1] >>> 0, 4);
      buf.writeUInt32BE(out[2] >>> 0, 8);
      buf.writeUInt32BE(out[3] >>> 0, 12);
      return buf;
    }
    function GHASH(key2) {
      this.h = key2;
      this.state = Buffer2.alloc(16, 0);
      this.cache = Buffer2.allocUnsafe(0);
    }
    GHASH.prototype.ghash = function(block) {
      var i10 = -1;
      while (++i10 < block.length) {
        this.state[i10] ^= block[i10];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function() {
      var Vi2 = toArray(this.h);
      var Zi2 = [0, 0, 0, 0];
      var j, xi2, lsbVi;
      var i10 = -1;
      while (++i10 < 128) {
        xi2 = (this.state[~~(i10 / 8)] & 1 << 7 - i10 % 8) !== 0;
        if (xi2) {
          Zi2[0] ^= Vi2[0];
          Zi2[1] ^= Vi2[1];
          Zi2[2] ^= Vi2[2];
          Zi2[3] ^= Vi2[3];
        }
        lsbVi = (Vi2[3] & 1) !== 0;
        for (j = 3; j > 0; j--) {
          Vi2[j] = Vi2[j] >>> 1 | (Vi2[j - 1] & 1) << 31;
        }
        Vi2[0] = Vi2[0] >>> 1;
        if (lsbVi) {
          Vi2[0] = Vi2[0] ^ 225 << 24;
        }
      }
      this.state = fromArray(Zi2);
    };
    GHASH.prototype.update = function(buf) {
      this.cache = Buffer2.concat([this.cache, buf]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function(abl, bl2) {
      if (this.cache.length) {
        this.ghash(Buffer2.concat([this.cache, ZEROES], 16));
      }
      this.ghash(fromArray([0, abl, 0, bl2]));
      return this.state;
    };
    ghash = GHASH;
    return ghash;
  }
  var authCipher;
  var hasRequiredAuthCipher;
  function requireAuthCipher() {
    if (hasRequiredAuthCipher)
      return authCipher;
    hasRequiredAuthCipher = 1;
    var aes2 = requireAes();
    var Buffer2 = requireSafeBuffer().Buffer;
    var Transform = requireCipherBase();
    var inherits = requireInherits_browser();
    var GHASH = requireGhash();
    var xor2 = requireBufferXor();
    var incr32 = requireIncr32();
    function xorTest(a, b) {
      var out = 0;
      if (a.length !== b.length)
        out++;
      var len2 = Math.min(a.length, b.length);
      for (var i10 = 0; i10 < len2; ++i10) {
        out += a[i10] ^ b[i10];
      }
      return out;
    }
    function calcIv(self2, iv2, ck2) {
      if (iv2.length === 12) {
        self2._finID = Buffer2.concat([iv2, Buffer2.from([0, 0, 0, 1])]);
        return Buffer2.concat([iv2, Buffer2.from([0, 0, 0, 2])]);
      }
      var ghash2 = new GHASH(ck2);
      var len2 = iv2.length;
      var toPad = len2 % 16;
      ghash2.update(iv2);
      if (toPad) {
        toPad = 16 - toPad;
        ghash2.update(Buffer2.alloc(toPad, 0));
      }
      ghash2.update(Buffer2.alloc(8, 0));
      var ivBits = len2 * 8;
      var tail = Buffer2.alloc(8);
      tail.writeUIntBE(ivBits, 0, 8);
      ghash2.update(tail);
      self2._finID = ghash2.state;
      var out = Buffer2.from(self2._finID);
      incr32(out);
      return out;
    }
    function StreamCipher(mode, key2, iv2, decrypt) {
      Transform.call(this);
      var h = Buffer2.alloc(4, 0);
      this._cipher = new aes2.AES(key2);
      var ck2 = this._cipher.encryptBlock(h);
      this._ghash = new GHASH(ck2);
      iv2 = calcIv(this, iv2, ck2);
      this._prev = Buffer2.from(iv2);
      this._cache = Buffer2.allocUnsafe(0);
      this._secCache = Buffer2.allocUnsafe(0);
      this._decrypt = decrypt;
      this._alen = 0;
      this._len = 0;
      this._mode = mode;
      this._authTag = null;
      this._called = false;
    }
    inherits(StreamCipher, Transform);
    StreamCipher.prototype._update = function(chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
          rump = Buffer2.alloc(rump, 0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var tag = xor2(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && xorTest(tag, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = tag;
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (this._decrypt || !Buffer2.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = tag;
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(buf);
      this._alen += buf.length;
    };
    authCipher = StreamCipher;
    return authCipher;
  }
  var streamCipher;
  var hasRequiredStreamCipher;
  function requireStreamCipher() {
    if (hasRequiredStreamCipher)
      return streamCipher;
    hasRequiredStreamCipher = 1;
    var aes2 = requireAes();
    var Buffer2 = requireSafeBuffer().Buffer;
    var Transform = requireCipherBase();
    var inherits = requireInherits_browser();
    function StreamCipher(mode, key2, iv2, decrypt) {
      Transform.call(this);
      this._cipher = new aes2.AES(key2);
      this._prev = Buffer2.from(iv2);
      this._cache = Buffer2.allocUnsafe(0);
      this._secCache = Buffer2.allocUnsafe(0);
      this._decrypt = decrypt;
      this._mode = mode;
    }
    inherits(StreamCipher, Transform);
    StreamCipher.prototype._update = function(chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function() {
      this._cipher.scrub();
    };
    streamCipher = StreamCipher;
    return streamCipher;
  }
  var evp_bytestokey;
  var hasRequiredEvp_bytestokey;
  function requireEvp_bytestokey() {
    if (hasRequiredEvp_bytestokey)
      return evp_bytestokey;
    hasRequiredEvp_bytestokey = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var MD5 = requireMd5_js();
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer2.isBuffer(password))
        password = Buffer2.from(password, "binary");
      if (salt) {
        if (!Buffer2.isBuffer(salt))
          salt = Buffer2.from(salt, "binary");
        if (salt.length !== 8)
          throw new RangeError("salt should be Buffer with 8 byte length");
      }
      var keyLen = keyBits / 8;
      var key2 = Buffer2.alloc(keyLen);
      var iv2 = Buffer2.alloc(ivLen || 0);
      var tmp = Buffer2.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        var hash2 = new MD5();
        hash2.update(tmp);
        hash2.update(password);
        if (salt)
          hash2.update(salt);
        tmp = hash2.digest();
        var used = 0;
        if (keyLen > 0) {
          var keyStart = key2.length - keyLen;
          used = Math.min(keyLen, tmp.length);
          tmp.copy(key2, keyStart, 0, used);
          keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          var ivStart = iv2.length - ivLen;
          var length = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv2, ivStart, used, used + length);
          ivLen -= length;
        }
      }
      tmp.fill(0);
      return { key: key2, iv: iv2 };
    }
    evp_bytestokey = EVP_BytesToKey;
    return evp_bytestokey;
  }
  var hasRequiredEncrypter;
  function requireEncrypter() {
    if (hasRequiredEncrypter)
      return encrypter;
    hasRequiredEncrypter = 1;
    var MODES = requireModes$1();
    var AuthCipher = requireAuthCipher();
    var Buffer2 = requireSafeBuffer().Buffer;
    var StreamCipher = requireStreamCipher();
    var Transform = requireCipherBase();
    var aes2 = requireAes();
    var ebtk = requireEvp_bytestokey();
    var inherits = requireInherits_browser();
    function Cipher(mode, key2, iv2) {
      Transform.call(this);
      this._cache = new Splitter();
      this._cipher = new aes2.AES(key2);
      this._prev = Buffer2.from(iv2);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits(Cipher, Transform);
    Cipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get()) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer2.concat(out);
    };
    var PADDING = Buffer2.alloc(16, 16);
    Cipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      }
      if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
      }
    };
    Cipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer2.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer2.concat([this.cache, data]);
    };
    Splitter.prototype.get = function() {
      if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      var len2 = 16 - this.cache.length;
      var padBuff = Buffer2.allocUnsafe(len2);
      var i10 = -1;
      while (++i10 < len2) {
        padBuff.writeUInt8(len2, i10);
      }
      return Buffer2.concat([this.cache, padBuff]);
    };
    function createCipheriv(suite, password, iv2) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      if (typeof password === "string")
        password = Buffer2.from(password);
      if (password.length !== config3.key / 8)
        throw new TypeError("invalid key length " + password.length);
      if (typeof iv2 === "string")
        iv2 = Buffer2.from(iv2);
      if (config3.mode !== "GCM" && iv2.length !== config3.iv)
        throw new TypeError("invalid iv length " + iv2.length);
      if (config3.type === "stream") {
        return new StreamCipher(config3.module, password, iv2);
      } else if (config3.type === "auth") {
        return new AuthCipher(config3.module, password, iv2);
      }
      return new Cipher(config3.module, password, iv2);
    }
    function createCipher(suite, password) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      var keys = ebtk(password, false, config3.key, config3.iv);
      return createCipheriv(suite, keys.key, keys.iv);
    }
    encrypter.createCipheriv = createCipheriv;
    encrypter.createCipher = createCipher;
    return encrypter;
  }
  var decrypter = {};
  var hasRequiredDecrypter;
  function requireDecrypter() {
    if (hasRequiredDecrypter)
      return decrypter;
    hasRequiredDecrypter = 1;
    var AuthCipher = requireAuthCipher();
    var Buffer2 = requireSafeBuffer().Buffer;
    var MODES = requireModes$1();
    var StreamCipher = requireStreamCipher();
    var Transform = requireCipherBase();
    var aes2 = requireAes();
    var ebtk = requireEvp_bytestokey();
    var inherits = requireInherits_browser();
    function Decipher(mode, key2, iv2) {
      Transform.call(this);
      this._cache = new Splitter();
      this._last = void 0;
      this._cipher = new aes2.AES(key2);
      this._prev = Buffer2.from(iv2);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits(Decipher, Transform);
    Decipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get(this._autopadding)) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer2.concat(out);
    };
    Decipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error("data not multiple of block length");
      }
    };
    Decipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer2.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer2.concat([this.cache, data]);
    };
    Splitter.prototype.get = function(autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function unpad(last11) {
      var padded = last11[15];
      if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
      }
      var i10 = -1;
      while (++i10 < padded) {
        if (last11[i10 + (16 - padded)] !== padded) {
          throw new Error("unable to decrypt data");
        }
      }
      if (padded === 16)
        return;
      return last11.slice(0, 16 - padded);
    }
    function createDecipheriv(suite, password, iv2) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      if (typeof iv2 === "string")
        iv2 = Buffer2.from(iv2);
      if (config3.mode !== "GCM" && iv2.length !== config3.iv)
        throw new TypeError("invalid iv length " + iv2.length);
      if (typeof password === "string")
        password = Buffer2.from(password);
      if (password.length !== config3.key / 8)
        throw new TypeError("invalid key length " + password.length);
      if (config3.type === "stream") {
        return new StreamCipher(config3.module, password, iv2, true);
      } else if (config3.type === "auth") {
        return new AuthCipher(config3.module, password, iv2, true);
      }
      return new Decipher(config3.module, password, iv2);
    }
    function createDecipher(suite, password) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      var keys = ebtk(password, false, config3.key, config3.iv);
      return createDecipheriv(suite, keys.key, keys.iv);
    }
    decrypter.createDecipher = createDecipher;
    decrypter.createDecipheriv = createDecipheriv;
    return decrypter;
  }
  var hasRequiredBrowser$6;
  function requireBrowser$6() {
    if (hasRequiredBrowser$6)
      return browser$5;
    hasRequiredBrowser$6 = 1;
    var ciphers = requireEncrypter();
    var deciphers = requireDecrypter();
    var modes2 = require$$2;
    function getCiphers() {
      return Object.keys(modes2);
    }
    browser$5.createCipher = browser$5.Cipher = ciphers.createCipher;
    browser$5.createCipheriv = browser$5.Cipheriv = ciphers.createCipheriv;
    browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
    browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
    browser$5.listCiphers = browser$5.getCiphers = getCiphers;
    return browser$5;
  }
  var modes = {};
  var hasRequiredModes;
  function requireModes() {
    if (hasRequiredModes)
      return modes;
    hasRequiredModes = 1;
    (function(exports2) {
      exports2["des-ecb"] = {
        key: 8,
        iv: 0
      };
      exports2["des-cbc"] = exports2.des = {
        key: 8,
        iv: 8
      };
      exports2["des-ede3-cbc"] = exports2.des3 = {
        key: 24,
        iv: 8
      };
      exports2["des-ede3"] = {
        key: 24,
        iv: 0
      };
      exports2["des-ede-cbc"] = {
        key: 16,
        iv: 8
      };
      exports2["des-ede"] = {
        key: 16,
        iv: 0
      };
    })(modes);
    return modes;
  }
  var hasRequiredBrowser$5;
  function requireBrowser$5() {
    if (hasRequiredBrowser$5)
      return browser$6;
    hasRequiredBrowser$5 = 1;
    var DES = requireBrowserifyDes();
    var aes2 = requireBrowser$6();
    var aesModes = requireModes$1();
    var desModes = requireModes();
    var ebtk = requireEvp_bytestokey();
    function createCipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys = ebtk(password, false, keyLen, ivLen);
      return createCipheriv(suite, keys.key, keys.iv);
    }
    function createDecipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys = ebtk(password, false, keyLen, ivLen);
      return createDecipheriv(suite, keys.key, keys.iv);
    }
    function createCipheriv(suite, key2, iv2) {
      suite = suite.toLowerCase();
      if (aesModes[suite])
        return aes2.createCipheriv(suite, key2, iv2);
      if (desModes[suite])
        return new DES({ key: key2, iv: iv2, mode: suite });
      throw new TypeError("invalid suite type");
    }
    function createDecipheriv(suite, key2, iv2) {
      suite = suite.toLowerCase();
      if (aesModes[suite])
        return aes2.createDecipheriv(suite, key2, iv2);
      if (desModes[suite])
        return new DES({ key: key2, iv: iv2, mode: suite, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function getCiphers() {
      return Object.keys(desModes).concat(aes2.getCiphers());
    }
    browser$6.createCipher = browser$6.Cipher = createCipher;
    browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
    browser$6.createDecipher = browser$6.Decipher = createDecipher;
    browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
    browser$6.listCiphers = browser$6.getCiphers = getCiphers;
    return browser$6;
  }
  var browser$4 = {};
  var bn$7 = { exports: {} };
  bn$7.exports;
  var hasRequiredBn$6;
  function requireBn$6() {
    if (hasRequiredBn$6)
      return bn$7.exports;
    hasRequiredBn$6 = 1;
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base2, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = buffer$1.Buffer;
          }
        } catch (e8) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init4(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var j, w10;
          var off = 0;
          if (endian === "be") {
            for (i10 = number.length - 1, j = 0; i10 >= 0; i10 -= 3) {
              w10 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i10 = 0, j = 0; i10 < number.length; i10 += 3) {
              w10 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r8 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r8;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var off = 0;
          var j = 0;
          var w10;
          if (endian === "be") {
            for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r8 = 0;
          var len2 = Math.min(str.length, end);
          for (var i10 = start; i10 < len2; i10++) {
            var c = str.charCodeAt(i10) - 48;
            r8 *= mul;
            if (c >= 49) {
              r8 += c - 49 + 10;
            } else if (c >= 17) {
              r8 += c - 17 + 10;
            } else {
              r8 += c;
            }
          }
          return r8;
        }
        BN2.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i10 = start; i10 < end; i10 += limbLen) {
            word = parseBase(number, i10, i10 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i10, number.length, base2);
            for (i10 = 0; i10 < mod; i10++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN2.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            dest.words[i10] = this.words[i10];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r8 = new BN2(null);
          this.copy(r8);
          return r8;
        };
        BN2.prototype._expand = function _expand(size2) {
          while (this.length < size2) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i10 = 0; i10 < this.length; i10++) {
              var w10 = this.words[i10];
              var word = ((w10 << off | carry) & 16777215).toString(16);
              carry = w10 >>> 24 - off & 16777215;
              if (carry !== 0 || i10 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i10--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r8 = c.modn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength2 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i10;
          var q = this.clone();
          if (!littleEndian) {
            for (i10 = 0; i10 < reqLength - byteLength2; i10++) {
              res[i10] = 0;
            }
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i10 - 1] = b;
            }
          } else {
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i10] = b;
            }
            for (; i10 < reqLength; i10++) {
              res[i10] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w10) {
            return 32 - Math.clz32(w10);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w10) {
            var t8 = w10;
            var r8 = 0;
            if (t8 >= 4096) {
              r8 += 13;
              t8 >>>= 13;
            }
            if (t8 >= 64) {
              r8 += 7;
              t8 >>>= 7;
            }
            if (t8 >= 8) {
              r8 += 4;
              t8 >>>= 4;
            }
            if (t8 >= 2) {
              r8 += 2;
              t8 >>>= 2;
            }
            return r8 + t8;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w10) {
          if (w10 === 0)
            return 26;
          var t8 = w10;
          var r8 = 0;
          if ((t8 & 8191) === 0) {
            r8 += 13;
            t8 >>>= 13;
          }
          if ((t8 & 127) === 0) {
            r8 += 7;
            t8 >>>= 7;
          }
          if ((t8 & 15) === 0) {
            r8 += 4;
            t8 >>>= 4;
          }
          if ((t8 & 3) === 0) {
            r8 += 2;
            t8 >>>= 2;
          }
          if ((t8 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w10 = this.words[this.length - 1];
          var hi2 = this._countBits(w10);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w10 = new Array(num.bitLength());
          for (var bit = 0; bit < w10.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w10[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w10;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var b = this._zeroBits(this.words[i10]);
            r8 += b;
            if (b !== 26)
              break;
          }
          return r8;
        };
        BN2.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i10 = 0; i10 < num.length; i10++) {
            this.words[i10] = this.words[i10] | num.words[i10];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = this.words[i10] & num.words[i10];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = a.words[i10] ^ b.words[i10];
          }
          if (this !== a) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i10 = 0; i10 < bytesNeeded; i10++) {
            this.words[i10] = ~this.words[i10] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) + (b.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) - (b.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          if (carry === 0 && i10 < a.length && a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = Math.max(this.length, i10);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r8 = a * b;
          var lo2 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo2;
          for (var k = 1; k < len2; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j | 0;
              a = self2.words[i10] | 0;
              b = num.words[j] | 0;
              r8 = a * b + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o8 = out.words;
          var c = 0;
          var lo2;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a12 = a[1] | 0;
          var al1 = a12 & 8191;
          var ah1 = a12 >>> 13;
          var a22 = a[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a72 = a[7] | 0;
          var al7 = a72 & 8191;
          var ah7 = a72 >>> 13;
          var a82 = a[8] | 0;
          var al8 = a82 & 8191;
          var ah8 = a82 >>> 13;
          var a92 = a[9] | 0;
          var al9 = a92 & 8191;
          var ah9 = a92 >>> 13;
          var b02 = b[0] | 0;
          var bl0 = b02 & 8191;
          var bh0 = b02 >>> 13;
          var b12 = b[1] | 0;
          var bl1 = b12 & 8191;
          var bh1 = b12 >>> 13;
          var b22 = b[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b82 = b[8] | 0;
          var bl8 = b82 & 8191;
          var bh8 = b82 >>> 13;
          var b92 = b[9] | 0;
          var bl9 = b92 & 8191;
          var bh9 = b92 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo2 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w02 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
          w02 &= 67108863;
          lo2 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo2 = lo2 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo2 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo2 = lo2 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo2 = lo2 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo2 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo2 = lo2 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo2 = lo2 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo2 = lo2 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo2 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo2 = lo2 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo2 = lo2 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo2 = lo2 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo2 = lo2 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo2 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo2 = lo2 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo2 = lo2 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo2 = lo2 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo2 = lo2 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo2 = lo2 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo2 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo2 = lo2 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo2 = lo2 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo2 = lo2 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo2 = lo2 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo2 = lo2 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo2 = lo2 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo2 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo2 = lo2 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo2 = lo2 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo2 = lo2 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo2 = lo2 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo2 = lo2 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo2 = lo2 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo2 = lo2 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo2 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo2 = lo2 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo2 = lo2 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo2 = lo2 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo2 = lo2 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo2 = lo2 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo2 = lo2 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo2 = lo2 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo2 = lo2 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w82 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
          w82 &= 67108863;
          lo2 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo2 = lo2 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo2 = lo2 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo2 = lo2 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo2 = lo2 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo2 = lo2 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo2 = lo2 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo2 = lo2 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo2 = lo2 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo2 = lo2 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w92 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
          w92 &= 67108863;
          lo2 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo2 = lo2 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo2 = lo2 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo2 = lo2 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo2 = lo2 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo2 = lo2 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo2 = lo2 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo2 = lo2 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo2 = lo2 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo2 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo2 = lo2 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo2 = lo2 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo2 = lo2 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo2 = lo2 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo2 = lo2 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo2 = lo2 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo2 = lo2 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo2 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo2 = lo2 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo2 = lo2 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo2 = lo2 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo2 = lo2 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo2 = lo2 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo2 = lo2 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w122 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
          w122 &= 67108863;
          lo2 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo2 = lo2 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo2 = lo2 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo2 = lo2 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo2 = lo2 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo2 = lo2 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo2 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo2 = lo2 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo2 = lo2 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo2 = lo2 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo2 = lo2 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo2 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo2 = lo2 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo2 = lo2 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo2 = lo2 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo2 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo2 = lo2 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo2 = lo2 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo2 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo2 = lo2 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo2 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o8[0] = w02;
          o8[1] = w12;
          o8[2] = w22;
          o8[3] = w32;
          o8[4] = w42;
          o8[5] = w52;
          o8[6] = w62;
          o8[7] = w72;
          o8[8] = w82;
          o8[9] = w92;
          o8[10] = w10;
          o8[11] = w11;
          o8[12] = w122;
          o8[13] = w13;
          o8[14] = w14;
          o8[15] = w15;
          o8[16] = w16;
          o8[17] = w17;
          o8[18] = w18;
          if (c !== 0) {
            o8[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j;
              var a = self2.words[i10] | 0;
              var b = num.words[j] | 0;
              var r8 = a * b;
              var lo2 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo2 = lo2 + rword | 0;
              rword = lo2 & 67108863;
              ncarry = ncarry + (lo2 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y10) {
          this.x = x;
          this.y = y10;
        }
        FFTM.prototype.makeRBT = function makeRBT(N10) {
          var t8 = new Array(N10);
          var l = BN2.prototype._countBits(N10) - 1;
          for (var i10 = 0; i10 < N10; i10++) {
            t8[i10] = this.revBin(i10, l, N10);
          }
          return t8;
        };
        FFTM.prototype.revBin = function revBin(x, l, N10) {
          if (x === 0 || x === N10 - 1)
            return x;
          var rb = 0;
          for (var i10 = 0; i10 < l; i10++) {
            rb |= (x & 1) << l - i10 - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
          for (var i10 = 0; i10 < N10; i10++) {
            rtws[i10] = rws[rbt[i10]];
            itws[i10] = iws[rbt[i10]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N10);
          for (var s = 1; s < N10; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N10; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io2 = itws[p + j + s];
                var rx2 = rtwdf_ * ro - itwdf_ * io2;
                io2 = rtwdf_ * io2 + itwdf_ * ro;
                ro = rx2;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io2;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io2;
                if (j !== l) {
                  rx2 = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx2;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n8, m) {
          var N10 = Math.max(m, n8) | 1;
          var odd = N10 & 1;
          var i10 = 0;
          for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
            i10++;
          }
          return 1 << i10 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
          if (N10 <= 1)
            return;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var t8 = rws[i10];
            rws[i10] = rws[N10 - i10 - 1];
            rws[N10 - i10 - 1] = t8;
            t8 = iws[i10];
            iws[i10] = -iws[N10 - i10 - 1];
            iws[N10 - i10 - 1] = -t8;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var w10 = Math.round(ws2[2 * i10 + 1] / N10) * 8192 + Math.round(ws2[2 * i10] / N10) + carry;
            ws2[i10] = w10 & 67108863;
            if (w10 < 67108864) {
              carry = 0;
            } else {
              carry = w10 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len2, rws, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < len2; i10++) {
            carry = carry + (ws2[i10] | 0);
            rws[2 * i10] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i10 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i10 = 2 * len2; i10 < N10; ++i10) {
            rws[i10] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N10) {
          var ph2 = new Array(N10);
          for (var i10 = 0; i10 < N10; i10++) {
            ph2[i10] = 0;
          }
          return ph2;
        };
        FFTM.prototype.mulp = function mulp(x, y10, out) {
          var N10 = 2 * this.guessLen13b(x.length, y10.length);
          var rbt = this.makeRBT(N10);
          var _ = this.stub(N10);
          var rws = new Array(N10);
          var rwst = new Array(N10);
          var iwst = new Array(N10);
          var nrws = new Array(N10);
          var nrwst = new Array(N10);
          var niwst = new Array(N10);
          var rmws = out.words;
          rmws.length = N10;
          this.convert13b(x.words, x.length, rws, N10);
          this.convert13b(y10.words, y10.length, nrws, N10);
          this.transform(rws, _, rwst, iwst, N10, rbt);
          this.transform(nrws, _, nrwst, niwst, N10, rbt);
          for (var i10 = 0; i10 < N10; i10++) {
            var rx2 = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
            iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
            rwst[i10] = rx2;
          }
          this.conjugate(rwst, iwst, N10);
          this.transform(rwst, iwst, rmws, _, N10, rbt);
          this.conjugate(rmws, _, N10);
          this.normalize13b(rmws, N10);
          out.negative = x.negative ^ y10.negative;
          out.length = x.length + y10.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w10 = (this.words[i10] | 0) * num;
            var lo2 = (w10 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w10 / 67108864 | 0;
            carry += lo2 >>> 26;
            this.words[i10] = lo2 & 67108863;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w10 = toBitArray(num);
          if (w10.length === 0)
            return new BN2(1);
          var res = this;
          for (var i10 = 0; i10 < w10.length; i10++, res = res.sqr()) {
            if (w10[i10] !== 0)
              break;
          }
          if (++i10 < w10.length) {
            for (var q = res.sqr(); i10 < w10.length; i10++, q = q.sqr()) {
              if (w10[i10] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i10;
          if (r8 !== 0) {
            var carry = 0;
            for (i10 = 0; i10 < this.length; i10++) {
              var newCarry = this.words[i10] & carryMask;
              var c = (this.words[i10] | 0) - newCarry << r8;
              this.words[i10] = c | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i10] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i10 = this.length - 1; i10 >= 0; i10--) {
              this.words[i10 + s] = this.words[i10];
            }
            for (i10 = 0; i10 < s; i10++) {
              this.words[i10] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r8 = bits % 26;
          var s = Math.min((bits - r8) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i10 = 0; i10 < s; i10++) {
              maskedWords.words[i10] = this.words[i10];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i10 = 0; i10 < this.length; i10++) {
              this.words[i10] = this.words[i10 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h); i10--) {
            var word = this.words[i10] | 0;
            this.words[i10] = carry << 26 - r8 | word >>> r8;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s)
            return false;
          var w10 = this.words[s];
          return !!(w10 & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r8 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r8 !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask2;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
            this.words[i10] -= 67108864;
            if (i10 === this.length - 1) {
              this.words[i10 + 1] = 1;
            } else {
              this.words[i10 + 1]++;
            }
          }
          this.length = Math.max(this.length, i10 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
              this.words[i10] += 67108864;
              this.words[i10 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i10;
          this._expand(len2);
          var w10;
          var carry = 0;
          for (i10 = 0; i10 < num.length; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            var right = (num.words[i10] | 0) * mul;
            w10 -= right & 67108863;
            carry = (w10 >> 26) - (right / 67108864 | 0);
            this.words[i10 + shift] = w10 & 67108863;
          }
          for (; i10 < this.length - shift; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10 + shift] = w10 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            w10 = -(this.words[i10] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10] = w10 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i10 = 0; i10 < q.length; i10++) {
              q.words[i10] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj2;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm2 = this.divmod(num);
          if (dm2.mod.isZero())
            return dm2.div;
          var mod = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
          var half2 = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half2);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm2.div;
          return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            acc = (p * acc + (this.words[i10] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var w10 = (this.words[i10] | 0) + carry * 67108864;
            this.words[i10] = w10 / num | 0;
            carry = w10 % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y10 = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A10 = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y10.isEven()) {
            x.iushrn(1);
            y10.iushrn(1);
            ++g;
          }
          var yp2 = y10.clone();
          var xp2 = x.clone();
          while (!x.isZero()) {
            for (var i10 = 0, im2 = 1; (x.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              x.iushrn(i10);
              while (i10-- > 0) {
                if (A10.isOdd() || B.isOdd()) {
                  A10.iadd(yp2);
                  B.isub(xp2);
                }
                A10.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (y10.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              y10.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp2);
                  D.isub(xp2);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y10) >= 0) {
              x.isub(y10);
              A10.isub(C);
              B.isub(D);
            } else {
              y10.isub(x);
              C.isub(A10);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y10.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x12 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i10 = 0, im2 = 1; (a.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              a.iushrn(i10);
              while (i10-- > 0) {
                if (x12.isOdd()) {
                  x12.iadd(delta);
                }
                x12.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (b.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x12.isub(x22);
            } else {
              b.isub(a);
              x22.isub(x12);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x12;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r8 = a.cmp(b);
            if (r8 < 0) {
              var t8 = a;
              a = b;
              b = t8;
            } else if (r8 === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i10 = s; carry !== 0 && i10 < this.length; i10++) {
            var w10 = this.words[i10] | 0;
            w10 += carry;
            carry = w10 >>> 26;
            w10 &= 67108863;
            this.words[i10] = w10;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w10 = this.words[0] | 0;
            res = w10 === num ? 0 : w10 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var a = this.words[i10] | 0;
            var b = num.words[i10] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte2(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte2(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i10 = 0; i10 < outLen; i10++) {
            output.words[i10] = input.words[i10];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i10 = 10; i10 < input.length; i10++) {
            var next = input.words[i10] | 0;
            input.words[i10 - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i10 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo2 = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var w10 = num.words[i10] | 0;
            lo2 += w10 * 977;
            num.words[i10] = lo2 & 67108863;
            lo2 = w10 * 64 + (lo2 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var hi2 = (num.words[i10] | 0) * 19 + carry;
            var lo2 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i10] = lo2;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one2 = new BN2(1).toRed(this);
          var nOne = one2.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r8 = this.pow(a, q.addn(1).iushrn(1));
          var t8 = this.pow(a, q);
          var m = s;
          while (t8.cmp(one2) !== 0) {
            var tmp = t8;
            for (var i10 = 0; tmp.cmp(one2) !== 0; i10++) {
              tmp = tmp.redSqr();
            }
            assert(i10 < m);
            var b = this.pow(c, new BN2(1).iushln(m - i10 - 1));
            r8 = r8.redMul(b);
            c = b.redSqr();
            t8 = t8.redMul(c);
            m = i10;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i10 = 2; i10 < wnd.length; i10++) {
            wnd[i10] = this.mul(wnd[i10 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i10 = num.length - 1; i10 >= 0; i10--) {
            var word = num.words[i10];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i10 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont2(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t8 = a.imul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t8 = a.mul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn$7);
    return bn$7.exports;
  }
  var bn$6 = { exports: {} };
  bn$6.exports;
  var hasRequiredBn$5;
  function requireBn$5() {
    if (hasRequiredBn$5)
      return bn$6.exports;
    hasRequiredBn$5 = 1;
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base2, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = buffer$1.Buffer;
          }
        } catch (e8) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init4(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var j, w10;
          var off = 0;
          if (endian === "be") {
            for (i10 = number.length - 1, j = 0; i10 >= 0; i10 -= 3) {
              w10 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i10 = 0, j = 0; i10 < number.length; i10 += 3) {
              w10 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r8 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r8;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var off = 0;
          var j = 0;
          var w10;
          if (endian === "be") {
            for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r8 = 0;
          var len2 = Math.min(str.length, end);
          for (var i10 = start; i10 < len2; i10++) {
            var c = str.charCodeAt(i10) - 48;
            r8 *= mul;
            if (c >= 49) {
              r8 += c - 49 + 10;
            } else if (c >= 17) {
              r8 += c - 17 + 10;
            } else {
              r8 += c;
            }
          }
          return r8;
        }
        BN2.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i10 = start; i10 < end; i10 += limbLen) {
            word = parseBase(number, i10, i10 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i10, number.length, base2);
            for (i10 = 0; i10 < mod; i10++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN2.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            dest.words[i10] = this.words[i10];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r8 = new BN2(null);
          this.copy(r8);
          return r8;
        };
        BN2.prototype._expand = function _expand(size2) {
          while (this.length < size2) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i10 = 0; i10 < this.length; i10++) {
              var w10 = this.words[i10];
              var word = ((w10 << off | carry) & 16777215).toString(16);
              carry = w10 >>> 24 - off & 16777215;
              if (carry !== 0 || i10 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i10--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r8 = c.modn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength2 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i10;
          var q = this.clone();
          if (!littleEndian) {
            for (i10 = 0; i10 < reqLength - byteLength2; i10++) {
              res[i10] = 0;
            }
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i10 - 1] = b;
            }
          } else {
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i10] = b;
            }
            for (; i10 < reqLength; i10++) {
              res[i10] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w10) {
            return 32 - Math.clz32(w10);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w10) {
            var t8 = w10;
            var r8 = 0;
            if (t8 >= 4096) {
              r8 += 13;
              t8 >>>= 13;
            }
            if (t8 >= 64) {
              r8 += 7;
              t8 >>>= 7;
            }
            if (t8 >= 8) {
              r8 += 4;
              t8 >>>= 4;
            }
            if (t8 >= 2) {
              r8 += 2;
              t8 >>>= 2;
            }
            return r8 + t8;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w10) {
          if (w10 === 0)
            return 26;
          var t8 = w10;
          var r8 = 0;
          if ((t8 & 8191) === 0) {
            r8 += 13;
            t8 >>>= 13;
          }
          if ((t8 & 127) === 0) {
            r8 += 7;
            t8 >>>= 7;
          }
          if ((t8 & 15) === 0) {
            r8 += 4;
            t8 >>>= 4;
          }
          if ((t8 & 3) === 0) {
            r8 += 2;
            t8 >>>= 2;
          }
          if ((t8 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w10 = this.words[this.length - 1];
          var hi2 = this._countBits(w10);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w10 = new Array(num.bitLength());
          for (var bit = 0; bit < w10.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w10[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w10;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var b = this._zeroBits(this.words[i10]);
            r8 += b;
            if (b !== 26)
              break;
          }
          return r8;
        };
        BN2.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i10 = 0; i10 < num.length; i10++) {
            this.words[i10] = this.words[i10] | num.words[i10];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = this.words[i10] & num.words[i10];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = a.words[i10] ^ b.words[i10];
          }
          if (this !== a) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i10 = 0; i10 < bytesNeeded; i10++) {
            this.words[i10] = ~this.words[i10] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) + (b.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) - (b.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          if (carry === 0 && i10 < a.length && a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = Math.max(this.length, i10);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r8 = a * b;
          var lo2 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo2;
          for (var k = 1; k < len2; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j | 0;
              a = self2.words[i10] | 0;
              b = num.words[j] | 0;
              r8 = a * b + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o8 = out.words;
          var c = 0;
          var lo2;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a12 = a[1] | 0;
          var al1 = a12 & 8191;
          var ah1 = a12 >>> 13;
          var a22 = a[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a72 = a[7] | 0;
          var al7 = a72 & 8191;
          var ah7 = a72 >>> 13;
          var a82 = a[8] | 0;
          var al8 = a82 & 8191;
          var ah8 = a82 >>> 13;
          var a92 = a[9] | 0;
          var al9 = a92 & 8191;
          var ah9 = a92 >>> 13;
          var b02 = b[0] | 0;
          var bl0 = b02 & 8191;
          var bh0 = b02 >>> 13;
          var b12 = b[1] | 0;
          var bl1 = b12 & 8191;
          var bh1 = b12 >>> 13;
          var b22 = b[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b82 = b[8] | 0;
          var bl8 = b82 & 8191;
          var bh8 = b82 >>> 13;
          var b92 = b[9] | 0;
          var bl9 = b92 & 8191;
          var bh9 = b92 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo2 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w02 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
          w02 &= 67108863;
          lo2 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo2 = lo2 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo2 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo2 = lo2 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo2 = lo2 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo2 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo2 = lo2 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo2 = lo2 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo2 = lo2 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo2 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo2 = lo2 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo2 = lo2 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo2 = lo2 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo2 = lo2 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo2 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo2 = lo2 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo2 = lo2 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo2 = lo2 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo2 = lo2 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo2 = lo2 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo2 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo2 = lo2 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo2 = lo2 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo2 = lo2 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo2 = lo2 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo2 = lo2 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo2 = lo2 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo2 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo2 = lo2 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo2 = lo2 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo2 = lo2 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo2 = lo2 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo2 = lo2 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo2 = lo2 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo2 = lo2 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo2 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo2 = lo2 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo2 = lo2 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo2 = lo2 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo2 = lo2 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo2 = lo2 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo2 = lo2 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo2 = lo2 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo2 = lo2 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w82 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
          w82 &= 67108863;
          lo2 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo2 = lo2 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo2 = lo2 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo2 = lo2 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo2 = lo2 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo2 = lo2 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo2 = lo2 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo2 = lo2 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo2 = lo2 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo2 = lo2 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w92 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
          w92 &= 67108863;
          lo2 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo2 = lo2 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo2 = lo2 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo2 = lo2 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo2 = lo2 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo2 = lo2 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo2 = lo2 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo2 = lo2 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo2 = lo2 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo2 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo2 = lo2 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo2 = lo2 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo2 = lo2 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo2 = lo2 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo2 = lo2 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo2 = lo2 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo2 = lo2 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo2 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo2 = lo2 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo2 = lo2 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo2 = lo2 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo2 = lo2 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo2 = lo2 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo2 = lo2 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w122 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
          w122 &= 67108863;
          lo2 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo2 = lo2 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo2 = lo2 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo2 = lo2 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo2 = lo2 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo2 = lo2 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo2 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo2 = lo2 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo2 = lo2 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo2 = lo2 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo2 = lo2 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo2 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo2 = lo2 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo2 = lo2 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo2 = lo2 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo2 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo2 = lo2 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo2 = lo2 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo2 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo2 = lo2 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo2 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o8[0] = w02;
          o8[1] = w12;
          o8[2] = w22;
          o8[3] = w32;
          o8[4] = w42;
          o8[5] = w52;
          o8[6] = w62;
          o8[7] = w72;
          o8[8] = w82;
          o8[9] = w92;
          o8[10] = w10;
          o8[11] = w11;
          o8[12] = w122;
          o8[13] = w13;
          o8[14] = w14;
          o8[15] = w15;
          o8[16] = w16;
          o8[17] = w17;
          o8[18] = w18;
          if (c !== 0) {
            o8[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j;
              var a = self2.words[i10] | 0;
              var b = num.words[j] | 0;
              var r8 = a * b;
              var lo2 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo2 = lo2 + rword | 0;
              rword = lo2 & 67108863;
              ncarry = ncarry + (lo2 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y10) {
          this.x = x;
          this.y = y10;
        }
        FFTM.prototype.makeRBT = function makeRBT(N10) {
          var t8 = new Array(N10);
          var l = BN2.prototype._countBits(N10) - 1;
          for (var i10 = 0; i10 < N10; i10++) {
            t8[i10] = this.revBin(i10, l, N10);
          }
          return t8;
        };
        FFTM.prototype.revBin = function revBin(x, l, N10) {
          if (x === 0 || x === N10 - 1)
            return x;
          var rb = 0;
          for (var i10 = 0; i10 < l; i10++) {
            rb |= (x & 1) << l - i10 - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
          for (var i10 = 0; i10 < N10; i10++) {
            rtws[i10] = rws[rbt[i10]];
            itws[i10] = iws[rbt[i10]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N10);
          for (var s = 1; s < N10; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N10; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io2 = itws[p + j + s];
                var rx2 = rtwdf_ * ro - itwdf_ * io2;
                io2 = rtwdf_ * io2 + itwdf_ * ro;
                ro = rx2;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io2;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io2;
                if (j !== l) {
                  rx2 = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx2;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n8, m) {
          var N10 = Math.max(m, n8) | 1;
          var odd = N10 & 1;
          var i10 = 0;
          for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
            i10++;
          }
          return 1 << i10 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
          if (N10 <= 1)
            return;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var t8 = rws[i10];
            rws[i10] = rws[N10 - i10 - 1];
            rws[N10 - i10 - 1] = t8;
            t8 = iws[i10];
            iws[i10] = -iws[N10 - i10 - 1];
            iws[N10 - i10 - 1] = -t8;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var w10 = Math.round(ws2[2 * i10 + 1] / N10) * 8192 + Math.round(ws2[2 * i10] / N10) + carry;
            ws2[i10] = w10 & 67108863;
            if (w10 < 67108864) {
              carry = 0;
            } else {
              carry = w10 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len2, rws, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < len2; i10++) {
            carry = carry + (ws2[i10] | 0);
            rws[2 * i10] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i10 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i10 = 2 * len2; i10 < N10; ++i10) {
            rws[i10] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N10) {
          var ph2 = new Array(N10);
          for (var i10 = 0; i10 < N10; i10++) {
            ph2[i10] = 0;
          }
          return ph2;
        };
        FFTM.prototype.mulp = function mulp(x, y10, out) {
          var N10 = 2 * this.guessLen13b(x.length, y10.length);
          var rbt = this.makeRBT(N10);
          var _ = this.stub(N10);
          var rws = new Array(N10);
          var rwst = new Array(N10);
          var iwst = new Array(N10);
          var nrws = new Array(N10);
          var nrwst = new Array(N10);
          var niwst = new Array(N10);
          var rmws = out.words;
          rmws.length = N10;
          this.convert13b(x.words, x.length, rws, N10);
          this.convert13b(y10.words, y10.length, nrws, N10);
          this.transform(rws, _, rwst, iwst, N10, rbt);
          this.transform(nrws, _, nrwst, niwst, N10, rbt);
          for (var i10 = 0; i10 < N10; i10++) {
            var rx2 = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
            iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
            rwst[i10] = rx2;
          }
          this.conjugate(rwst, iwst, N10);
          this.transform(rwst, iwst, rmws, _, N10, rbt);
          this.conjugate(rmws, _, N10);
          this.normalize13b(rmws, N10);
          out.negative = x.negative ^ y10.negative;
          out.length = x.length + y10.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w10 = (this.words[i10] | 0) * num;
            var lo2 = (w10 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w10 / 67108864 | 0;
            carry += lo2 >>> 26;
            this.words[i10] = lo2 & 67108863;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w10 = toBitArray(num);
          if (w10.length === 0)
            return new BN2(1);
          var res = this;
          for (var i10 = 0; i10 < w10.length; i10++, res = res.sqr()) {
            if (w10[i10] !== 0)
              break;
          }
          if (++i10 < w10.length) {
            for (var q = res.sqr(); i10 < w10.length; i10++, q = q.sqr()) {
              if (w10[i10] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i10;
          if (r8 !== 0) {
            var carry = 0;
            for (i10 = 0; i10 < this.length; i10++) {
              var newCarry = this.words[i10] & carryMask;
              var c = (this.words[i10] | 0) - newCarry << r8;
              this.words[i10] = c | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i10] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i10 = this.length - 1; i10 >= 0; i10--) {
              this.words[i10 + s] = this.words[i10];
            }
            for (i10 = 0; i10 < s; i10++) {
              this.words[i10] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r8 = bits % 26;
          var s = Math.min((bits - r8) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i10 = 0; i10 < s; i10++) {
              maskedWords.words[i10] = this.words[i10];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i10 = 0; i10 < this.length; i10++) {
              this.words[i10] = this.words[i10 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h); i10--) {
            var word = this.words[i10] | 0;
            this.words[i10] = carry << 26 - r8 | word >>> r8;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s)
            return false;
          var w10 = this.words[s];
          return !!(w10 & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r8 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r8 !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask2;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
            this.words[i10] -= 67108864;
            if (i10 === this.length - 1) {
              this.words[i10 + 1] = 1;
            } else {
              this.words[i10 + 1]++;
            }
          }
          this.length = Math.max(this.length, i10 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
              this.words[i10] += 67108864;
              this.words[i10 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i10;
          this._expand(len2);
          var w10;
          var carry = 0;
          for (i10 = 0; i10 < num.length; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            var right = (num.words[i10] | 0) * mul;
            w10 -= right & 67108863;
            carry = (w10 >> 26) - (right / 67108864 | 0);
            this.words[i10 + shift] = w10 & 67108863;
          }
          for (; i10 < this.length - shift; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10 + shift] = w10 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            w10 = -(this.words[i10] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10] = w10 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i10 = 0; i10 < q.length; i10++) {
              q.words[i10] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj2;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm2 = this.divmod(num);
          if (dm2.mod.isZero())
            return dm2.div;
          var mod = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
          var half2 = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half2);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm2.div;
          return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            acc = (p * acc + (this.words[i10] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var w10 = (this.words[i10] | 0) + carry * 67108864;
            this.words[i10] = w10 / num | 0;
            carry = w10 % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y10 = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A10 = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y10.isEven()) {
            x.iushrn(1);
            y10.iushrn(1);
            ++g;
          }
          var yp2 = y10.clone();
          var xp2 = x.clone();
          while (!x.isZero()) {
            for (var i10 = 0, im2 = 1; (x.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              x.iushrn(i10);
              while (i10-- > 0) {
                if (A10.isOdd() || B.isOdd()) {
                  A10.iadd(yp2);
                  B.isub(xp2);
                }
                A10.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (y10.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              y10.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp2);
                  D.isub(xp2);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y10) >= 0) {
              x.isub(y10);
              A10.isub(C);
              B.isub(D);
            } else {
              y10.isub(x);
              C.isub(A10);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y10.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x12 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i10 = 0, im2 = 1; (a.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              a.iushrn(i10);
              while (i10-- > 0) {
                if (x12.isOdd()) {
                  x12.iadd(delta);
                }
                x12.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (b.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x12.isub(x22);
            } else {
              b.isub(a);
              x22.isub(x12);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x12;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r8 = a.cmp(b);
            if (r8 < 0) {
              var t8 = a;
              a = b;
              b = t8;
            } else if (r8 === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i10 = s; carry !== 0 && i10 < this.length; i10++) {
            var w10 = this.words[i10] | 0;
            w10 += carry;
            carry = w10 >>> 26;
            w10 &= 67108863;
            this.words[i10] = w10;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w10 = this.words[0] | 0;
            res = w10 === num ? 0 : w10 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var a = this.words[i10] | 0;
            var b = num.words[i10] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte2(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte2(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i10 = 0; i10 < outLen; i10++) {
            output.words[i10] = input.words[i10];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i10 = 10; i10 < input.length; i10++) {
            var next = input.words[i10] | 0;
            input.words[i10 - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i10 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo2 = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var w10 = num.words[i10] | 0;
            lo2 += w10 * 977;
            num.words[i10] = lo2 & 67108863;
            lo2 = w10 * 64 + (lo2 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var hi2 = (num.words[i10] | 0) * 19 + carry;
            var lo2 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i10] = lo2;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one2 = new BN2(1).toRed(this);
          var nOne = one2.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r8 = this.pow(a, q.addn(1).iushrn(1));
          var t8 = this.pow(a, q);
          var m = s;
          while (t8.cmp(one2) !== 0) {
            var tmp = t8;
            for (var i10 = 0; tmp.cmp(one2) !== 0; i10++) {
              tmp = tmp.redSqr();
            }
            assert(i10 < m);
            var b = this.pow(c, new BN2(1).iushln(m - i10 - 1));
            r8 = r8.redMul(b);
            c = b.redSqr();
            t8 = t8.redMul(c);
            m = i10;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i10 = 2; i10 < wnd.length; i10++) {
            wnd[i10] = this.mul(wnd[i10 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i10 = num.length - 1; i10 >= 0; i10--) {
            var word = num.words[i10];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i10 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont2(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t8 = a.imul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t8 = a.mul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn$6);
    return bn$6.exports;
  }
  var brorand = { exports: {} };
  var hasRequiredBrorand;
  function requireBrorand() {
    if (hasRequiredBrorand)
      return brorand.exports;
    hasRequiredBrorand = 1;
    var r8;
    brorand.exports = function rand(len2) {
      if (!r8)
        r8 = new Rand(null);
      return r8.generate(len2);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    brorand.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len2) {
      return this._rand(len2);
    };
    Rand.prototype._rand = function _rand(n8) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n8);
      var res = new Uint8Array(n8);
      for (var i10 = 0; i10 < res.length; i10++)
        res[i10] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n8) {
          var arr = new Uint8Array(n8);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n8) {
          var arr = new Uint8Array(n8);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        var crypto = requireCryptoBrowserify();
        if (typeof crypto.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n8) {
          return crypto.randomBytes(n8);
        };
      } catch (e8) {
      }
    }
    return brorand.exports;
  }
  var mr$1;
  var hasRequiredMr;
  function requireMr() {
    if (hasRequiredMr)
      return mr$1;
    hasRequiredMr = 1;
    var bn2 = requireBn$5();
    var brorand2 = requireBrorand();
    function MillerRabin(rand) {
      this.rand = rand || new brorand2.Rand();
    }
    mr$1 = MillerRabin;
    MillerRabin.create = function create(rand) {
      return new MillerRabin(rand);
    };
    MillerRabin.prototype._randbelow = function _randbelow(n8) {
      var len2 = n8.bitLength();
      var min_bytes = Math.ceil(len2 / 8);
      do
        var a = new bn2(this.rand.generate(min_bytes));
      while (a.cmp(n8) >= 0);
      return a;
    };
    MillerRabin.prototype._randrange = function _randrange(start, stop) {
      var size2 = stop.sub(start);
      return start.add(this._randbelow(size2));
    };
    MillerRabin.prototype.test = function test(n8, k, cb) {
      var len2 = n8.bitLength();
      var red = bn2.mont(n8);
      var rone = new bn2(1).toRed(red);
      if (!k)
        k = Math.max(1, len2 / 48 | 0);
      var n1 = n8.subn(1);
      for (var s = 0; !n1.testn(s); s++) {
      }
      var d = n8.shrn(s);
      var rn1 = n1.toRed(red);
      var prime = true;
      for (; k > 0; k--) {
        var a = this._randrange(new bn2(2), n1);
        if (cb)
          cb(a);
        var x = a.toRed(red).redPow(d);
        if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
          continue;
        for (var i10 = 1; i10 < s; i10++) {
          x = x.redSqr();
          if (x.cmp(rone) === 0)
            return false;
          if (x.cmp(rn1) === 0)
            break;
        }
        if (i10 === s)
          return false;
      }
      return prime;
    };
    MillerRabin.prototype.getDivisor = function getDivisor(n8, k) {
      var len2 = n8.bitLength();
      var red = bn2.mont(n8);
      var rone = new bn2(1).toRed(red);
      if (!k)
        k = Math.max(1, len2 / 48 | 0);
      var n1 = n8.subn(1);
      for (var s = 0; !n1.testn(s); s++) {
      }
      var d = n8.shrn(s);
      var rn1 = n1.toRed(red);
      for (; k > 0; k--) {
        var a = this._randrange(new bn2(2), n1);
        var g = n8.gcd(a);
        if (g.cmpn(1) !== 0)
          return g;
        var x = a.toRed(red).redPow(d);
        if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
          continue;
        for (var i10 = 1; i10 < s; i10++) {
          x = x.redSqr();
          if (x.cmp(rone) === 0)
            return x.fromRed().subn(1).gcd(n8);
          if (x.cmp(rn1) === 0)
            break;
        }
        if (i10 === s) {
          x = x.redSqr();
          return x.fromRed().subn(1).gcd(n8);
        }
      }
      return false;
    };
    return mr$1;
  }
  var generatePrime;
  var hasRequiredGeneratePrime;
  function requireGeneratePrime() {
    if (hasRequiredGeneratePrime)
      return generatePrime;
    hasRequiredGeneratePrime = 1;
    var randomBytes = requireBrowser$b();
    generatePrime = findPrime;
    findPrime.simpleSieve = simpleSieve;
    findPrime.fermatTest = fermatTest;
    var BN2 = requireBn$6();
    var TWENTYFOUR = new BN2(24);
    var MillerRabin = requireMr();
    var millerRabin = new MillerRabin();
    var ONE = new BN2(1);
    var TWO = new BN2(2);
    var FIVE = new BN2(5);
    new BN2(16);
    new BN2(8);
    var TEN = new BN2(10);
    var THREE = new BN2(3);
    new BN2(7);
    var ELEVEN = new BN2(11);
    var FOUR = new BN2(4);
    new BN2(12);
    var primes = null;
    function _getPrimes() {
      if (primes !== null)
        return primes;
      var limit = 1048576;
      var res = [];
      res[0] = 2;
      for (var i10 = 1, k = 3; k < limit; k += 2) {
        var sqrt = Math.ceil(Math.sqrt(k));
        for (var j = 0; j < i10 && res[j] <= sqrt; j++)
          if (k % res[j] === 0)
            break;
        if (i10 !== j && res[j] <= sqrt)
          continue;
        res[i10++] = k;
      }
      primes = res;
      return res;
    }
    function simpleSieve(p) {
      var primes2 = _getPrimes();
      for (var i10 = 0; i10 < primes2.length; i10++)
        if (p.modn(primes2[i10]) === 0) {
          if (p.cmpn(primes2[i10]) === 0) {
            return true;
          } else {
            return false;
          }
        }
      return true;
    }
    function fermatTest(p) {
      var red = BN2.mont(p);
      return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
    }
    function findPrime(bits, gen) {
      if (bits < 16) {
        if (gen === 2 || gen === 5) {
          return new BN2([140, 123]);
        } else {
          return new BN2([140, 39]);
        }
      }
      gen = new BN2(gen);
      var num, n22;
      while (true) {
        num = new BN2(randomBytes(Math.ceil(bits / 8)));
        while (num.bitLength() > bits) {
          num.ishrn(1);
        }
        if (num.isEven()) {
          num.iadd(ONE);
        }
        if (!num.testn(1)) {
          num.iadd(TWO);
        }
        if (!gen.cmp(TWO)) {
          while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
            num.iadd(FOUR);
          }
        } else if (!gen.cmp(FIVE)) {
          while (num.mod(TEN).cmp(THREE)) {
            num.iadd(FOUR);
          }
        }
        n22 = num.shrn(1);
        if (simpleSieve(n22) && simpleSieve(num) && fermatTest(n22) && fermatTest(num) && millerRabin.test(n22) && millerRabin.test(num)) {
          return num;
        }
      }
    }
    return generatePrime;
  }
  const modp1 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
  };
  const modp2 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
  };
  const modp5 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
  };
  const modp14 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
  };
  const modp15 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
  };
  const modp16 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
  };
  const modp17 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
  };
  const modp18 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
  };
  const require$$1$1 = {
    modp1,
    modp2,
    modp5,
    modp14,
    modp15,
    modp16,
    modp17,
    modp18
  };
  var dh$1;
  var hasRequiredDh;
  function requireDh() {
    if (hasRequiredDh)
      return dh$1;
    hasRequiredDh = 1;
    var BN2 = requireBn$6();
    var MillerRabin = requireMr();
    var millerRabin = new MillerRabin();
    var TWENTYFOUR = new BN2(24);
    var ELEVEN = new BN2(11);
    var TEN = new BN2(10);
    var THREE = new BN2(3);
    var SEVEN = new BN2(7);
    var primes = requireGeneratePrime();
    var randomBytes = requireBrowser$b();
    dh$1 = DH2;
    function setPublicKey(pub, enc) {
      enc = enc || "utf8";
      if (!buffer$1.Buffer.isBuffer(pub)) {
        pub = new buffer$1.Buffer(pub, enc);
      }
      this._pub = new BN2(pub);
      return this;
    }
    function setPrivateKey(priv, enc) {
      enc = enc || "utf8";
      if (!buffer$1.Buffer.isBuffer(priv)) {
        priv = new buffer$1.Buffer(priv, enc);
      }
      this._priv = new BN2(priv);
      return this;
    }
    var primeCache = {};
    function checkPrime(prime, generator) {
      var gen = generator.toString("hex");
      var hex = [gen, prime.toString(16)].join("_");
      if (hex in primeCache) {
        return primeCache[hex];
      }
      var error = 0;
      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
        error += 1;
        if (gen === "02" || gen === "05") {
          error += 8;
        } else {
          error += 4;
        }
        primeCache[hex] = error;
        return error;
      }
      if (!millerRabin.test(prime.shrn(1))) {
        error += 2;
      }
      var rem;
      switch (gen) {
        case "02":
          if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
            error += 8;
          }
          break;
        case "05":
          rem = prime.mod(TEN);
          if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
            error += 8;
          }
          break;
        default:
          error += 4;
      }
      primeCache[hex] = error;
      return error;
    }
    function DH2(prime, generator, malleable) {
      this.setGenerator(generator);
      this.__prime = new BN2(prime);
      this._prime = BN2.mont(this.__prime);
      this._primeLen = prime.length;
      this._pub = void 0;
      this._priv = void 0;
      this._primeCode = void 0;
      if (malleable) {
        this.setPublicKey = setPublicKey;
        this.setPrivateKey = setPrivateKey;
      } else {
        this._primeCode = 8;
      }
    }
    Object.defineProperty(DH2.prototype, "verifyError", {
      enumerable: true,
      get: function() {
        if (typeof this._primeCode !== "number") {
          this._primeCode = checkPrime(this.__prime, this.__gen);
        }
        return this._primeCode;
      }
    });
    DH2.prototype.generateKeys = function() {
      if (!this._priv) {
        this._priv = new BN2(randomBytes(this._primeLen));
      }
      this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
      return this.getPublicKey();
    };
    DH2.prototype.computeSecret = function(other) {
      other = new BN2(other);
      other = other.toRed(this._prime);
      var secret = other.redPow(this._priv).fromRed();
      var out = new buffer$1.Buffer(secret.toArray());
      var prime = this.getPrime();
      if (out.length < prime.length) {
        var front = new buffer$1.Buffer(prime.length - out.length);
        front.fill(0);
        out = buffer$1.Buffer.concat([front, out]);
      }
      return out;
    };
    DH2.prototype.getPublicKey = function getPublicKey(enc) {
      return formatReturnValue(this._pub, enc);
    };
    DH2.prototype.getPrivateKey = function getPrivateKey(enc) {
      return formatReturnValue(this._priv, enc);
    };
    DH2.prototype.getPrime = function(enc) {
      return formatReturnValue(this.__prime, enc);
    };
    DH2.prototype.getGenerator = function(enc) {
      return formatReturnValue(this._gen, enc);
    };
    DH2.prototype.setGenerator = function(gen, enc) {
      enc = enc || "utf8";
      if (!buffer$1.Buffer.isBuffer(gen)) {
        gen = new buffer$1.Buffer(gen, enc);
      }
      this.__gen = gen;
      this._gen = new BN2(gen);
      return this;
    };
    function formatReturnValue(bn2, enc) {
      var buf = new buffer$1.Buffer(bn2.toArray());
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
    return dh$1;
  }
  var hasRequiredBrowser$4;
  function requireBrowser$4() {
    if (hasRequiredBrowser$4)
      return browser$4;
    hasRequiredBrowser$4 = 1;
    var generatePrime2 = requireGeneratePrime();
    var primes = require$$1$1;
    var DH2 = requireDh();
    function getDiffieHellman(mod) {
      var prime = new buffer$1.Buffer(primes[mod].prime, "hex");
      var gen = new buffer$1.Buffer(primes[mod].gen, "hex");
      return new DH2(prime, gen);
    }
    var ENCODINGS = {
      "binary": true,
      "hex": true,
      "base64": true
    };
    function createDiffieHellman(prime, enc, generator, genc) {
      if (buffer$1.Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
        return createDiffieHellman(prime, "binary", enc, generator);
      }
      enc = enc || "binary";
      genc = genc || "binary";
      generator = generator || new buffer$1.Buffer([2]);
      if (!buffer$1.Buffer.isBuffer(generator)) {
        generator = new buffer$1.Buffer(generator, genc);
      }
      if (typeof prime === "number") {
        return new DH2(generatePrime2(prime, generator), generator, true);
      }
      if (!buffer$1.Buffer.isBuffer(prime)) {
        prime = new buffer$1.Buffer(prime, enc);
      }
      return new DH2(prime, generator, true);
    }
    browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = getDiffieHellman;
    browser$4.createDiffieHellman = browser$4.DiffieHellman = createDiffieHellman;
    return browser$4;
  }
  var sign = { exports: {} };
  var bn$5 = { exports: {} };
  bn$5.exports;
  var hasRequiredBn$4;
  function requireBn$4() {
    if (hasRequiredBn$4)
      return bn$5.exports;
    hasRequiredBn$4 = 1;
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base2, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = buffer$1.Buffer;
          }
        } catch (e8) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init4(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var j, w10;
          var off = 0;
          if (endian === "be") {
            for (i10 = number.length - 1, j = 0; i10 >= 0; i10 -= 3) {
              w10 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i10 = 0, j = 0; i10 < number.length; i10 += 3) {
              w10 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r8 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r8;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var off = 0;
          var j = 0;
          var w10;
          if (endian === "be") {
            for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r8 = 0;
          var b = 0;
          var len2 = Math.min(str.length, end);
          for (var i10 = start; i10 < len2; i10++) {
            var c = str.charCodeAt(i10) - 48;
            r8 *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r8 += b;
          }
          return r8;
        }
        BN2.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i10 = start; i10 < end; i10 += limbLen) {
            word = parseBase(number, i10, i10 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i10, number.length, base2);
            for (i10 = 0; i10 < mod; i10++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            dest.words[i10] = this.words[i10];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src2) {
          dest.words = src2.words;
          dest.length = src2.length;
          dest.negative = src2.negative;
          dest.red = src2.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone() {
          var r8 = new BN2(null);
          this.copy(r8);
          return r8;
        };
        BN2.prototype._expand = function _expand(size2) {
          while (this.length < size2) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e8) {
            BN2.prototype.inspect = inspect;
          }
        } else {
          BN2.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i10 = 0; i10 < this.length; i10++) {
              var w10 = this.words[i10];
              var word = ((w10 << off | carry) & 16777215).toString(16);
              carry = w10 >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i10--;
              }
              if (carry !== 0 || i10 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r8 = c.modrn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer2(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size2) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size2);
          }
          return new ArrayType(size2);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength2 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength2);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
          var position = 0;
          var carry = 0;
          for (var i10 = 0, shift = 0; i10 < this.length; i10++) {
            var word = this.words[i10] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
          var position = res.length - 1;
          var carry = 0;
          for (var i10 = 0, shift = 0; i10 < this.length; i10++) {
            var word = this.words[i10] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w10) {
            return 32 - Math.clz32(w10);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w10) {
            var t8 = w10;
            var r8 = 0;
            if (t8 >= 4096) {
              r8 += 13;
              t8 >>>= 13;
            }
            if (t8 >= 64) {
              r8 += 7;
              t8 >>>= 7;
            }
            if (t8 >= 8) {
              r8 += 4;
              t8 >>>= 4;
            }
            if (t8 >= 2) {
              r8 += 2;
              t8 >>>= 2;
            }
            return r8 + t8;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w10) {
          if (w10 === 0)
            return 26;
          var t8 = w10;
          var r8 = 0;
          if ((t8 & 8191) === 0) {
            r8 += 13;
            t8 >>>= 13;
          }
          if ((t8 & 127) === 0) {
            r8 += 7;
            t8 >>>= 7;
          }
          if ((t8 & 15) === 0) {
            r8 += 4;
            t8 >>>= 4;
          }
          if ((t8 & 3) === 0) {
            r8 += 2;
            t8 >>>= 2;
          }
          if ((t8 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w10 = this.words[this.length - 1];
          var hi2 = this._countBits(w10);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w10 = new Array(num.bitLength());
          for (var bit = 0; bit < w10.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w10[bit] = num.words[off] >>> wbit & 1;
          }
          return w10;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var b = this._zeroBits(this.words[i10]);
            r8 += b;
            if (b !== 26)
              break;
          }
          return r8;
        };
        BN2.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i10 = 0; i10 < num.length; i10++) {
            this.words[i10] = this.words[i10] | num.words[i10];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = this.words[i10] & num.words[i10];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = a.words[i10] ^ b.words[i10];
          }
          if (this !== a) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i10 = 0; i10 < bytesNeeded; i10++) {
            this.words[i10] = ~this.words[i10] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) + (b.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) - (b.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          if (carry === 0 && i10 < a.length && a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = Math.max(this.length, i10);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r8 = a * b;
          var lo2 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo2;
          for (var k = 1; k < len2; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j | 0;
              a = self2.words[i10] | 0;
              b = num.words[j] | 0;
              r8 = a * b + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o8 = out.words;
          var c = 0;
          var lo2;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a12 = a[1] | 0;
          var al1 = a12 & 8191;
          var ah1 = a12 >>> 13;
          var a22 = a[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a72 = a[7] | 0;
          var al7 = a72 & 8191;
          var ah7 = a72 >>> 13;
          var a82 = a[8] | 0;
          var al8 = a82 & 8191;
          var ah8 = a82 >>> 13;
          var a92 = a[9] | 0;
          var al9 = a92 & 8191;
          var ah9 = a92 >>> 13;
          var b02 = b[0] | 0;
          var bl0 = b02 & 8191;
          var bh0 = b02 >>> 13;
          var b12 = b[1] | 0;
          var bl1 = b12 & 8191;
          var bh1 = b12 >>> 13;
          var b22 = b[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b82 = b[8] | 0;
          var bl8 = b82 & 8191;
          var bh8 = b82 >>> 13;
          var b92 = b[9] | 0;
          var bl9 = b92 & 8191;
          var bh9 = b92 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo2 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w02 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
          w02 &= 67108863;
          lo2 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo2 = lo2 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo2 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo2 = lo2 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo2 = lo2 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo2 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo2 = lo2 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo2 = lo2 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo2 = lo2 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo2 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo2 = lo2 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo2 = lo2 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo2 = lo2 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo2 = lo2 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo2 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo2 = lo2 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo2 = lo2 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo2 = lo2 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo2 = lo2 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo2 = lo2 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo2 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo2 = lo2 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo2 = lo2 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo2 = lo2 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo2 = lo2 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo2 = lo2 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo2 = lo2 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo2 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo2 = lo2 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo2 = lo2 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo2 = lo2 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo2 = lo2 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo2 = lo2 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo2 = lo2 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo2 = lo2 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo2 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo2 = lo2 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo2 = lo2 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo2 = lo2 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo2 = lo2 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo2 = lo2 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo2 = lo2 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo2 = lo2 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo2 = lo2 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w82 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
          w82 &= 67108863;
          lo2 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo2 = lo2 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo2 = lo2 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo2 = lo2 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo2 = lo2 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo2 = lo2 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo2 = lo2 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo2 = lo2 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo2 = lo2 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo2 = lo2 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w92 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
          w92 &= 67108863;
          lo2 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo2 = lo2 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo2 = lo2 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo2 = lo2 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo2 = lo2 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo2 = lo2 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo2 = lo2 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo2 = lo2 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo2 = lo2 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo2 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo2 = lo2 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo2 = lo2 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo2 = lo2 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo2 = lo2 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo2 = lo2 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo2 = lo2 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo2 = lo2 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo2 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo2 = lo2 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo2 = lo2 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo2 = lo2 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo2 = lo2 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo2 = lo2 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo2 = lo2 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w122 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
          w122 &= 67108863;
          lo2 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo2 = lo2 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo2 = lo2 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo2 = lo2 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo2 = lo2 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo2 = lo2 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo2 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo2 = lo2 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo2 = lo2 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo2 = lo2 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo2 = lo2 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo2 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo2 = lo2 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo2 = lo2 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo2 = lo2 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo2 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo2 = lo2 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo2 = lo2 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo2 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo2 = lo2 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo2 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o8[0] = w02;
          o8[1] = w12;
          o8[2] = w22;
          o8[3] = w32;
          o8[4] = w42;
          o8[5] = w52;
          o8[6] = w62;
          o8[7] = w72;
          o8[8] = w82;
          o8[9] = w92;
          o8[10] = w10;
          o8[11] = w11;
          o8[12] = w122;
          o8[13] = w13;
          o8[14] = w14;
          o8[15] = w15;
          o8[16] = w16;
          o8[17] = w17;
          o8[18] = w18;
          if (c !== 0) {
            o8[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j;
              var a = self2.words[i10] | 0;
              var b = num.words[j] | 0;
              var r8 = a * b;
              var lo2 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo2 = lo2 + rword | 0;
              rword = lo2 & 67108863;
              ncarry = ncarry + (lo2 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w10 = (this.words[i10] | 0) * num;
            var lo2 = (w10 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w10 / 67108864 | 0;
            carry += lo2 >>> 26;
            this.words[i10] = lo2 & 67108863;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w10 = toBitArray(num);
          if (w10.length === 0)
            return new BN2(1);
          var res = this;
          for (var i10 = 0; i10 < w10.length; i10++, res = res.sqr()) {
            if (w10[i10] !== 0)
              break;
          }
          if (++i10 < w10.length) {
            for (var q = res.sqr(); i10 < w10.length; i10++, q = q.sqr()) {
              if (w10[i10] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i10;
          if (r8 !== 0) {
            var carry = 0;
            for (i10 = 0; i10 < this.length; i10++) {
              var newCarry = this.words[i10] & carryMask;
              var c = (this.words[i10] | 0) - newCarry << r8;
              this.words[i10] = c | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i10] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i10 = this.length - 1; i10 >= 0; i10--) {
              this.words[i10 + s] = this.words[i10];
            }
            for (i10 = 0; i10 < s; i10++) {
              this.words[i10] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r8 = bits % 26;
          var s = Math.min((bits - r8) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i10 = 0; i10 < s; i10++) {
              maskedWords.words[i10] = this.words[i10];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i10 = 0; i10 < this.length; i10++) {
              this.words[i10] = this.words[i10 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h); i10--) {
            var word = this.words[i10] | 0;
            this.words[i10] = carry << 26 - r8 | word >>> r8;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s)
            return false;
          var w10 = this.words[s];
          return !!(w10 & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r8 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r8 !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask2;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
            this.words[i10] -= 67108864;
            if (i10 === this.length - 1) {
              this.words[i10 + 1] = 1;
            } else {
              this.words[i10 + 1]++;
            }
          }
          this.length = Math.max(this.length, i10 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
              this.words[i10] += 67108864;
              this.words[i10 + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i10;
          this._expand(len2);
          var w10;
          var carry = 0;
          for (i10 = 0; i10 < num.length; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            var right = (num.words[i10] | 0) * mul;
            w10 -= right & 67108863;
            carry = (w10 >> 26) - (right / 67108864 | 0);
            this.words[i10 + shift] = w10 & 67108863;
          }
          for (; i10 < this.length - shift; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10 + shift] = w10 & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            w10 = -(this.words[i10] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10] = w10 & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i10 = 0; i10 < q.length; i10++) {
              q.words[i10] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj2;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm2 = this.divmod(num);
          if (dm2.mod.isZero())
            return dm2.div;
          var mod = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
          var half2 = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half2);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm2.div;
          return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            acc = (p * acc + (this.words[i10] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var w10 = (this.words[i10] | 0) + carry * 67108864;
            this.words[i10] = w10 / num | 0;
            carry = w10 % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y10 = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A10 = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y10.isEven()) {
            x.iushrn(1);
            y10.iushrn(1);
            ++g;
          }
          var yp2 = y10.clone();
          var xp2 = x.clone();
          while (!x.isZero()) {
            for (var i10 = 0, im2 = 1; (x.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              x.iushrn(i10);
              while (i10-- > 0) {
                if (A10.isOdd() || B.isOdd()) {
                  A10.iadd(yp2);
                  B.isub(xp2);
                }
                A10.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (y10.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              y10.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp2);
                  D.isub(xp2);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y10) >= 0) {
              x.isub(y10);
              A10.isub(C);
              B.isub(D);
            } else {
              y10.isub(x);
              C.isub(A10);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y10.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x12 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i10 = 0, im2 = 1; (a.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              a.iushrn(i10);
              while (i10-- > 0) {
                if (x12.isOdd()) {
                  x12.iadd(delta);
                }
                x12.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (b.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x12.isub(x22);
            } else {
              b.isub(a);
              x22.isub(x12);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x12;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r8 = a.cmp(b);
            if (r8 < 0) {
              var t8 = a;
              a = b;
              b = t8;
            } else if (r8 === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i10 = s; carry !== 0 && i10 < this.length; i10++) {
            var w10 = this.words[i10] | 0;
            w10 += carry;
            carry = w10 >>> 26;
            w10 &= 67108863;
            this.words[i10] = w10;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w10 = this.words[0] | 0;
            res = w10 === num ? 0 : w10 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var a = this.words[i10] | 0;
            var b = num.words[i10] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte2(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte2(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i10 = 0; i10 < outLen; i10++) {
            output.words[i10] = input.words[i10];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i10 = 10; i10 < input.length; i10++) {
            var next = input.words[i10] | 0;
            input.words[i10 - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i10 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo2 = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var w10 = num.words[i10] | 0;
            lo2 += w10 * 977;
            num.words[i10] = lo2 & 67108863;
            lo2 = w10 * 64 + (lo2 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var hi2 = (num.words[i10] | 0) * 19 + carry;
            var lo2 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i10] = lo2;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one2 = new BN2(1).toRed(this);
          var nOne = one2.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r8 = this.pow(a, q.addn(1).iushrn(1));
          var t8 = this.pow(a, q);
          var m = s;
          while (t8.cmp(one2) !== 0) {
            var tmp = t8;
            for (var i10 = 0; tmp.cmp(one2) !== 0; i10++) {
              tmp = tmp.redSqr();
            }
            assert(i10 < m);
            var b = this.pow(c, new BN2(1).iushln(m - i10 - 1));
            r8 = r8.redMul(b);
            c = b.redSqr();
            t8 = t8.redMul(c);
            m = i10;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i10 = 2; i10 < wnd.length; i10++) {
            wnd[i10] = this.mul(wnd[i10 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i10 = num.length - 1; i10 >= 0; i10--) {
            var word = num.words[i10];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i10 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont2(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t8 = a.imul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t8 = a.mul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn$5);
    return bn$5.exports;
  }
  var browserifyRsa;
  var hasRequiredBrowserifyRsa;
  function requireBrowserifyRsa() {
    if (hasRequiredBrowserifyRsa)
      return browserifyRsa;
    hasRequiredBrowserifyRsa = 1;
    var BN2 = requireBn$4();
    var randomBytes = requireBrowser$b();
    function blind(priv) {
      var r8 = getr(priv);
      var blinder = r8.toRed(BN2.mont(priv.modulus)).redPow(new BN2(priv.publicExponent)).fromRed();
      return { blinder, unblinder: r8.invm(priv.modulus) };
    }
    function getr(priv) {
      var len2 = priv.modulus.byteLength();
      var r8;
      do {
        r8 = new BN2(randomBytes(len2));
      } while (r8.cmp(priv.modulus) >= 0 || !r8.umod(priv.prime1) || !r8.umod(priv.prime2));
      return r8;
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len2 = priv.modulus.byteLength();
      var blinded = new BN2(msg).mul(blinds.blinder).umod(priv.modulus);
      var c12 = blinded.toRed(BN2.mont(priv.prime1));
      var c22 = blinded.toRed(BN2.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m12 = c12.redPow(priv.exponent1).fromRed();
      var m22 = c22.redPow(priv.exponent2).fromRed();
      var h = m12.isub(m22).imul(qinv).umod(p).imul(q);
      return m22.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(buffer$1.Buffer, "be", len2);
    }
    crt.getr = getr;
    browserifyRsa = crt;
    return browserifyRsa;
  }
  var elliptic = {};
  const name = "elliptic";
  const version$1 = "6.5.4";
  const description = "EC cryptography";
  const main = "lib/elliptic.js";
  const files = [
    "lib"
  ];
  const scripts = {
    lint: "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    unit: "istanbul test _mocha --reporter=spec test/index.js",
    test: "npm run lint && npm run unit",
    version: "grunt dist && git add dist/"
  };
  const repository = {
    type: "git",
    url: "git@github.com:indutny/elliptic"
  };
  const keywords = [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ];
  const author = "Fedor Indutny <fedor@indutny.com>";
  const license = "MIT";
  const bugs = {
    url: "https://github.com/indutny/elliptic/issues"
  };
  const homepage = "https://github.com/indutny/elliptic";
  const devDependencies = {
    brfs: "^2.0.2",
    coveralls: "^3.1.0",
    eslint: "^7.6.0",
    grunt: "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    istanbul: "^0.4.5",
    mocha: "^8.0.1"
  };
  const dependencies = {
    "bn.js": "^4.11.9",
    brorand: "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    inherits: "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  };
  const require$$0 = {
    name,
    version: version$1,
    description,
    main,
    files,
    scripts,
    repository,
    keywords,
    author,
    license,
    bugs,
    homepage,
    devDependencies,
    dependencies
  };
  var utils$2 = {};
  var bn$4 = { exports: {} };
  bn$4.exports;
  var hasRequiredBn$3;
  function requireBn$3() {
    if (hasRequiredBn$3)
      return bn$4.exports;
    hasRequiredBn$3 = 1;
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base2, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = buffer$1.Buffer;
          }
        } catch (e8) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init4(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var j, w10;
          var off = 0;
          if (endian === "be") {
            for (i10 = number.length - 1, j = 0; i10 >= 0; i10 -= 3) {
              w10 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i10 = 0, j = 0; i10 < number.length; i10 += 3) {
              w10 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r8 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r8;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var off = 0;
          var j = 0;
          var w10;
          if (endian === "be") {
            for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r8 = 0;
          var len2 = Math.min(str.length, end);
          for (var i10 = start; i10 < len2; i10++) {
            var c = str.charCodeAt(i10) - 48;
            r8 *= mul;
            if (c >= 49) {
              r8 += c - 49 + 10;
            } else if (c >= 17) {
              r8 += c - 17 + 10;
            } else {
              r8 += c;
            }
          }
          return r8;
        }
        BN2.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i10 = start; i10 < end; i10 += limbLen) {
            word = parseBase(number, i10, i10 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i10, number.length, base2);
            for (i10 = 0; i10 < mod; i10++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN2.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            dest.words[i10] = this.words[i10];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r8 = new BN2(null);
          this.copy(r8);
          return r8;
        };
        BN2.prototype._expand = function _expand(size2) {
          while (this.length < size2) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i10 = 0; i10 < this.length; i10++) {
              var w10 = this.words[i10];
              var word = ((w10 << off | carry) & 16777215).toString(16);
              carry = w10 >>> 24 - off & 16777215;
              if (carry !== 0 || i10 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i10--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r8 = c.modn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength2 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i10;
          var q = this.clone();
          if (!littleEndian) {
            for (i10 = 0; i10 < reqLength - byteLength2; i10++) {
              res[i10] = 0;
            }
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i10 - 1] = b;
            }
          } else {
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i10] = b;
            }
            for (; i10 < reqLength; i10++) {
              res[i10] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w10) {
            return 32 - Math.clz32(w10);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w10) {
            var t8 = w10;
            var r8 = 0;
            if (t8 >= 4096) {
              r8 += 13;
              t8 >>>= 13;
            }
            if (t8 >= 64) {
              r8 += 7;
              t8 >>>= 7;
            }
            if (t8 >= 8) {
              r8 += 4;
              t8 >>>= 4;
            }
            if (t8 >= 2) {
              r8 += 2;
              t8 >>>= 2;
            }
            return r8 + t8;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w10) {
          if (w10 === 0)
            return 26;
          var t8 = w10;
          var r8 = 0;
          if ((t8 & 8191) === 0) {
            r8 += 13;
            t8 >>>= 13;
          }
          if ((t8 & 127) === 0) {
            r8 += 7;
            t8 >>>= 7;
          }
          if ((t8 & 15) === 0) {
            r8 += 4;
            t8 >>>= 4;
          }
          if ((t8 & 3) === 0) {
            r8 += 2;
            t8 >>>= 2;
          }
          if ((t8 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w10 = this.words[this.length - 1];
          var hi2 = this._countBits(w10);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w10 = new Array(num.bitLength());
          for (var bit = 0; bit < w10.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w10[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w10;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var b = this._zeroBits(this.words[i10]);
            r8 += b;
            if (b !== 26)
              break;
          }
          return r8;
        };
        BN2.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i10 = 0; i10 < num.length; i10++) {
            this.words[i10] = this.words[i10] | num.words[i10];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = this.words[i10] & num.words[i10];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = a.words[i10] ^ b.words[i10];
          }
          if (this !== a) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i10 = 0; i10 < bytesNeeded; i10++) {
            this.words[i10] = ~this.words[i10] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) + (b.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) - (b.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          if (carry === 0 && i10 < a.length && a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = Math.max(this.length, i10);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r8 = a * b;
          var lo2 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo2;
          for (var k = 1; k < len2; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j | 0;
              a = self2.words[i10] | 0;
              b = num.words[j] | 0;
              r8 = a * b + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o8 = out.words;
          var c = 0;
          var lo2;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a12 = a[1] | 0;
          var al1 = a12 & 8191;
          var ah1 = a12 >>> 13;
          var a22 = a[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a72 = a[7] | 0;
          var al7 = a72 & 8191;
          var ah7 = a72 >>> 13;
          var a82 = a[8] | 0;
          var al8 = a82 & 8191;
          var ah8 = a82 >>> 13;
          var a92 = a[9] | 0;
          var al9 = a92 & 8191;
          var ah9 = a92 >>> 13;
          var b02 = b[0] | 0;
          var bl0 = b02 & 8191;
          var bh0 = b02 >>> 13;
          var b12 = b[1] | 0;
          var bl1 = b12 & 8191;
          var bh1 = b12 >>> 13;
          var b22 = b[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b82 = b[8] | 0;
          var bl8 = b82 & 8191;
          var bh8 = b82 >>> 13;
          var b92 = b[9] | 0;
          var bl9 = b92 & 8191;
          var bh9 = b92 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo2 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w02 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
          w02 &= 67108863;
          lo2 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo2 = lo2 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo2 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo2 = lo2 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo2 = lo2 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo2 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo2 = lo2 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo2 = lo2 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo2 = lo2 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo2 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo2 = lo2 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo2 = lo2 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo2 = lo2 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo2 = lo2 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo2 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo2 = lo2 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo2 = lo2 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo2 = lo2 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo2 = lo2 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo2 = lo2 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo2 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo2 = lo2 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo2 = lo2 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo2 = lo2 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo2 = lo2 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo2 = lo2 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo2 = lo2 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo2 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo2 = lo2 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo2 = lo2 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo2 = lo2 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo2 = lo2 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo2 = lo2 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo2 = lo2 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo2 = lo2 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo2 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo2 = lo2 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo2 = lo2 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo2 = lo2 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo2 = lo2 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo2 = lo2 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo2 = lo2 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo2 = lo2 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo2 = lo2 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w82 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
          w82 &= 67108863;
          lo2 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo2 = lo2 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo2 = lo2 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo2 = lo2 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo2 = lo2 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo2 = lo2 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo2 = lo2 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo2 = lo2 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo2 = lo2 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo2 = lo2 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w92 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
          w92 &= 67108863;
          lo2 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo2 = lo2 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo2 = lo2 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo2 = lo2 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo2 = lo2 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo2 = lo2 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo2 = lo2 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo2 = lo2 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo2 = lo2 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo2 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo2 = lo2 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo2 = lo2 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo2 = lo2 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo2 = lo2 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo2 = lo2 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo2 = lo2 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo2 = lo2 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo2 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo2 = lo2 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo2 = lo2 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo2 = lo2 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo2 = lo2 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo2 = lo2 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo2 = lo2 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w122 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
          w122 &= 67108863;
          lo2 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo2 = lo2 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo2 = lo2 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo2 = lo2 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo2 = lo2 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo2 = lo2 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo2 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo2 = lo2 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo2 = lo2 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo2 = lo2 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo2 = lo2 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo2 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo2 = lo2 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo2 = lo2 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo2 = lo2 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo2 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo2 = lo2 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo2 = lo2 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo2 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo2 = lo2 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo2 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o8[0] = w02;
          o8[1] = w12;
          o8[2] = w22;
          o8[3] = w32;
          o8[4] = w42;
          o8[5] = w52;
          o8[6] = w62;
          o8[7] = w72;
          o8[8] = w82;
          o8[9] = w92;
          o8[10] = w10;
          o8[11] = w11;
          o8[12] = w122;
          o8[13] = w13;
          o8[14] = w14;
          o8[15] = w15;
          o8[16] = w16;
          o8[17] = w17;
          o8[18] = w18;
          if (c !== 0) {
            o8[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j;
              var a = self2.words[i10] | 0;
              var b = num.words[j] | 0;
              var r8 = a * b;
              var lo2 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo2 = lo2 + rword | 0;
              rword = lo2 & 67108863;
              ncarry = ncarry + (lo2 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y10) {
          this.x = x;
          this.y = y10;
        }
        FFTM.prototype.makeRBT = function makeRBT(N10) {
          var t8 = new Array(N10);
          var l = BN2.prototype._countBits(N10) - 1;
          for (var i10 = 0; i10 < N10; i10++) {
            t8[i10] = this.revBin(i10, l, N10);
          }
          return t8;
        };
        FFTM.prototype.revBin = function revBin(x, l, N10) {
          if (x === 0 || x === N10 - 1)
            return x;
          var rb = 0;
          for (var i10 = 0; i10 < l; i10++) {
            rb |= (x & 1) << l - i10 - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
          for (var i10 = 0; i10 < N10; i10++) {
            rtws[i10] = rws[rbt[i10]];
            itws[i10] = iws[rbt[i10]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N10);
          for (var s = 1; s < N10; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N10; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io2 = itws[p + j + s];
                var rx2 = rtwdf_ * ro - itwdf_ * io2;
                io2 = rtwdf_ * io2 + itwdf_ * ro;
                ro = rx2;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io2;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io2;
                if (j !== l) {
                  rx2 = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx2;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n8, m) {
          var N10 = Math.max(m, n8) | 1;
          var odd = N10 & 1;
          var i10 = 0;
          for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
            i10++;
          }
          return 1 << i10 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
          if (N10 <= 1)
            return;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var t8 = rws[i10];
            rws[i10] = rws[N10 - i10 - 1];
            rws[N10 - i10 - 1] = t8;
            t8 = iws[i10];
            iws[i10] = -iws[N10 - i10 - 1];
            iws[N10 - i10 - 1] = -t8;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var w10 = Math.round(ws2[2 * i10 + 1] / N10) * 8192 + Math.round(ws2[2 * i10] / N10) + carry;
            ws2[i10] = w10 & 67108863;
            if (w10 < 67108864) {
              carry = 0;
            } else {
              carry = w10 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len2, rws, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < len2; i10++) {
            carry = carry + (ws2[i10] | 0);
            rws[2 * i10] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i10 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i10 = 2 * len2; i10 < N10; ++i10) {
            rws[i10] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N10) {
          var ph2 = new Array(N10);
          for (var i10 = 0; i10 < N10; i10++) {
            ph2[i10] = 0;
          }
          return ph2;
        };
        FFTM.prototype.mulp = function mulp(x, y10, out) {
          var N10 = 2 * this.guessLen13b(x.length, y10.length);
          var rbt = this.makeRBT(N10);
          var _ = this.stub(N10);
          var rws = new Array(N10);
          var rwst = new Array(N10);
          var iwst = new Array(N10);
          var nrws = new Array(N10);
          var nrwst = new Array(N10);
          var niwst = new Array(N10);
          var rmws = out.words;
          rmws.length = N10;
          this.convert13b(x.words, x.length, rws, N10);
          this.convert13b(y10.words, y10.length, nrws, N10);
          this.transform(rws, _, rwst, iwst, N10, rbt);
          this.transform(nrws, _, nrwst, niwst, N10, rbt);
          for (var i10 = 0; i10 < N10; i10++) {
            var rx2 = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
            iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
            rwst[i10] = rx2;
          }
          this.conjugate(rwst, iwst, N10);
          this.transform(rwst, iwst, rmws, _, N10, rbt);
          this.conjugate(rmws, _, N10);
          this.normalize13b(rmws, N10);
          out.negative = x.negative ^ y10.negative;
          out.length = x.length + y10.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w10 = (this.words[i10] | 0) * num;
            var lo2 = (w10 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w10 / 67108864 | 0;
            carry += lo2 >>> 26;
            this.words[i10] = lo2 & 67108863;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w10 = toBitArray(num);
          if (w10.length === 0)
            return new BN2(1);
          var res = this;
          for (var i10 = 0; i10 < w10.length; i10++, res = res.sqr()) {
            if (w10[i10] !== 0)
              break;
          }
          if (++i10 < w10.length) {
            for (var q = res.sqr(); i10 < w10.length; i10++, q = q.sqr()) {
              if (w10[i10] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i10;
          if (r8 !== 0) {
            var carry = 0;
            for (i10 = 0; i10 < this.length; i10++) {
              var newCarry = this.words[i10] & carryMask;
              var c = (this.words[i10] | 0) - newCarry << r8;
              this.words[i10] = c | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i10] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i10 = this.length - 1; i10 >= 0; i10--) {
              this.words[i10 + s] = this.words[i10];
            }
            for (i10 = 0; i10 < s; i10++) {
              this.words[i10] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r8 = bits % 26;
          var s = Math.min((bits - r8) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i10 = 0; i10 < s; i10++) {
              maskedWords.words[i10] = this.words[i10];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i10 = 0; i10 < this.length; i10++) {
              this.words[i10] = this.words[i10 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h); i10--) {
            var word = this.words[i10] | 0;
            this.words[i10] = carry << 26 - r8 | word >>> r8;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s)
            return false;
          var w10 = this.words[s];
          return !!(w10 & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r8 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r8 !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask2;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
            this.words[i10] -= 67108864;
            if (i10 === this.length - 1) {
              this.words[i10 + 1] = 1;
            } else {
              this.words[i10 + 1]++;
            }
          }
          this.length = Math.max(this.length, i10 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
              this.words[i10] += 67108864;
              this.words[i10 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i10;
          this._expand(len2);
          var w10;
          var carry = 0;
          for (i10 = 0; i10 < num.length; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            var right = (num.words[i10] | 0) * mul;
            w10 -= right & 67108863;
            carry = (w10 >> 26) - (right / 67108864 | 0);
            this.words[i10 + shift] = w10 & 67108863;
          }
          for (; i10 < this.length - shift; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10 + shift] = w10 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            w10 = -(this.words[i10] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10] = w10 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i10 = 0; i10 < q.length; i10++) {
              q.words[i10] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj2;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm2 = this.divmod(num);
          if (dm2.mod.isZero())
            return dm2.div;
          var mod = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
          var half2 = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half2);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm2.div;
          return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            acc = (p * acc + (this.words[i10] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var w10 = (this.words[i10] | 0) + carry * 67108864;
            this.words[i10] = w10 / num | 0;
            carry = w10 % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y10 = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A10 = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y10.isEven()) {
            x.iushrn(1);
            y10.iushrn(1);
            ++g;
          }
          var yp2 = y10.clone();
          var xp2 = x.clone();
          while (!x.isZero()) {
            for (var i10 = 0, im2 = 1; (x.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              x.iushrn(i10);
              while (i10-- > 0) {
                if (A10.isOdd() || B.isOdd()) {
                  A10.iadd(yp2);
                  B.isub(xp2);
                }
                A10.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (y10.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              y10.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp2);
                  D.isub(xp2);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y10) >= 0) {
              x.isub(y10);
              A10.isub(C);
              B.isub(D);
            } else {
              y10.isub(x);
              C.isub(A10);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y10.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x12 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i10 = 0, im2 = 1; (a.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              a.iushrn(i10);
              while (i10-- > 0) {
                if (x12.isOdd()) {
                  x12.iadd(delta);
                }
                x12.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (b.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x12.isub(x22);
            } else {
              b.isub(a);
              x22.isub(x12);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x12;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r8 = a.cmp(b);
            if (r8 < 0) {
              var t8 = a;
              a = b;
              b = t8;
            } else if (r8 === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i10 = s; carry !== 0 && i10 < this.length; i10++) {
            var w10 = this.words[i10] | 0;
            w10 += carry;
            carry = w10 >>> 26;
            w10 &= 67108863;
            this.words[i10] = w10;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w10 = this.words[0] | 0;
            res = w10 === num ? 0 : w10 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var a = this.words[i10] | 0;
            var b = num.words[i10] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte2(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte2(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i10 = 0; i10 < outLen; i10++) {
            output.words[i10] = input.words[i10];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i10 = 10; i10 < input.length; i10++) {
            var next = input.words[i10] | 0;
            input.words[i10 - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i10 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo2 = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var w10 = num.words[i10] | 0;
            lo2 += w10 * 977;
            num.words[i10] = lo2 & 67108863;
            lo2 = w10 * 64 + (lo2 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var hi2 = (num.words[i10] | 0) * 19 + carry;
            var lo2 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i10] = lo2;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one2 = new BN2(1).toRed(this);
          var nOne = one2.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r8 = this.pow(a, q.addn(1).iushrn(1));
          var t8 = this.pow(a, q);
          var m = s;
          while (t8.cmp(one2) !== 0) {
            var tmp = t8;
            for (var i10 = 0; tmp.cmp(one2) !== 0; i10++) {
              tmp = tmp.redSqr();
            }
            assert(i10 < m);
            var b = this.pow(c, new BN2(1).iushln(m - i10 - 1));
            r8 = r8.redMul(b);
            c = b.redSqr();
            t8 = t8.redMul(c);
            m = i10;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i10 = 2; i10 < wnd.length; i10++) {
            wnd[i10] = this.mul(wnd[i10 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i10 = num.length - 1; i10 >= 0; i10--) {
            var word = num.words[i10];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i10 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont2(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t8 = a.imul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t8 = a.mul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn$4);
    return bn$4.exports;
  }
  var utils$1 = {};
  var hasRequiredUtils$2;
  function requireUtils$2() {
    if (hasRequiredUtils$2)
      return utils$1;
    hasRequiredUtils$2 = 1;
    (function(exports2) {
      var utils2 = exports2;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i10 = 0; i10 < msg.length; i10++)
            res[i10] = msg[i10] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i10 = 0; i10 < msg.length; i10 += 2)
            res.push(parseInt(msg[i10] + msg[i10 + 1], 16));
        } else {
          for (var i10 = 0; i10 < msg.length; i10++) {
            var c = msg.charCodeAt(i10);
            var hi2 = c >> 8;
            var lo2 = c & 255;
            if (hi2)
              res.push(hi2, lo2);
            else
              res.push(lo2);
          }
        }
        return res;
      }
      utils2.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils2.zero2 = zero2;
      function toHex(msg) {
        var res = "";
        for (var i10 = 0; i10 < msg.length; i10++)
          res += zero2(msg[i10].toString(16));
        return res;
      }
      utils2.toHex = toHex;
      utils2.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex(arr);
        else
          return arr;
      };
    })(utils$1);
    return utils$1;
  }
  var hasRequiredUtils$1;
  function requireUtils$1() {
    if (hasRequiredUtils$1)
      return utils$2;
    hasRequiredUtils$1 = 1;
    (function(exports2) {
      var utils2 = exports2;
      var BN2 = requireBn$3();
      var minAssert = requireMinimalisticAssert();
      var minUtils = requireUtils$2();
      utils2.assert = minAssert;
      utils2.toArray = minUtils.toArray;
      utils2.zero2 = minUtils.zero2;
      utils2.toHex = minUtils.toHex;
      utils2.encode = minUtils.encode;
      function getNAF(num, w10, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws2 = 1 << w10 + 1;
        var k = num.clone();
        for (var i10 = 0; i10 < naf.length; i10++) {
          var z;
          var mod = k.andln(ws2 - 1);
          if (k.isOdd()) {
            if (mod > (ws2 >> 1) - 1)
              z = (ws2 >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i10] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils2.getNAF = getNAF;
      function getJSF(k12, k22) {
        var jsf = [
          [],
          []
        ];
        k12 = k12.clone();
        k22 = k22.clone();
        var d12 = 0;
        var d22 = 0;
        var m82;
        while (k12.cmpn(-d12) > 0 || k22.cmpn(-d22) > 0) {
          var m14 = k12.andln(3) + d12 & 3;
          var m24 = k22.andln(3) + d22 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u12;
          if ((m14 & 1) === 0) {
            u12 = 0;
          } else {
            m82 = k12.andln(7) + d12 & 7;
            if ((m82 === 3 || m82 === 5) && m24 === 2)
              u12 = -m14;
            else
              u12 = m14;
          }
          jsf[0].push(u12);
          var u22;
          if ((m24 & 1) === 0) {
            u22 = 0;
          } else {
            m82 = k22.andln(7) + d22 & 7;
            if ((m82 === 3 || m82 === 5) && m14 === 2)
              u22 = -m24;
            else
              u22 = m24;
          }
          jsf[1].push(u22);
          if (2 * d12 === u12 + 1)
            d12 = 1 - d12;
          if (2 * d22 === u22 + 1)
            d22 = 1 - d22;
          k12.iushrn(1);
          k22.iushrn(1);
        }
        return jsf;
      }
      utils2.getJSF = getJSF;
      function cachedProperty(obj, name2, computer) {
        var key2 = "_" + name2;
        obj.prototype[name2] = function cachedProperty2() {
          return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
        };
      }
      utils2.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
      }
      utils2.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN2(bytes, "hex", "le");
      }
      utils2.intFromLE = intFromLE;
    })(utils$2);
    return utils$2;
  }
  var curve = {};
  var base$1;
  var hasRequiredBase$1;
  function requireBase$1() {
    if (hasRequiredBase$1)
      return base$1;
    hasRequiredBase$1 = 1;
    var BN2 = requireBn$3();
    var utils2 = requireUtils$1();
    var getNAF = utils2.getNAF;
    var getJSF = utils2.getJSF;
    var assert = utils2.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN2(conf.p, 16);
      this.red = conf.prime ? BN2.red(conf.prime) : BN2.mont(this.p);
      this.zero = new BN2(0).toRed(this.red);
      this.one = new BN2(1).toRed(this.red);
      this.two = new BN2(2).toRed(this.red);
      this.n = conf.n && new BN2(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    base$1 = BaseCurve;
    BaseCurve.prototype.point = function point2() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate2() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I10 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I10 /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i10 = I10; i10 > 0; i10--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i10)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i10)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w10 = 4;
      var nafPoints = p._getNAFPoints(w10);
      w10 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w10, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i10 = naf.length - 1; i10 >= 0; i10--) {
        for (var l = 0; i10 >= 0 && naf[i10] === 0; i10--)
          l++;
        if (i10 >= 0)
          l++;
        acc = acc.dblp(l);
        if (i10 < 0)
          break;
        var z = naf[i10];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i10;
      var j;
      var p;
      for (i10 = 0; i10 < len2; i10++) {
        p = points[i10];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i10] = nafPoints.wnd;
        wnd[i10] = nafPoints.points;
      }
      for (i10 = len2 - 1; i10 >= 1; i10 -= 2) {
        var a = i10 - 1;
        var b = i10;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index2 = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja2 = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index2[(ja2 + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i10 = max; i10 >= 0; i10--) {
        var k = 0;
        while (i10 >= 0) {
          var zero = true;
          for (j = 0; j < len2; j++) {
            tmp[j] = naf[j][i10] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i10--;
        }
        if (i10 >= 0)
          k++;
        acc = acc.dblp(k);
        if (i10 < 0)
          break;
        for (j = 0; j < len2; j++) {
          var z = tmp[j];
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i10 = 0; i10 < len2; i10++)
        wnd[i10] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve2, type) {
      this.curve = curve2;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq2() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate2() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils2.toArray(bytes, enc);
      var len2 = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len2),
          bytes.slice(1 + len2, 1 + 2 * len2)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2) {
        return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len2 = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len2);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len2));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils2.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i10 = 0; i10 < power; i10 += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i10 = 1; i10 < max; i10++)
        res[i10] = res[i10 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r8 = this;
      for (var i10 = 0; i10 < k; i10++)
        r8 = r8.dbl();
      return r8;
    };
    return base$1;
  }
  var short;
  var hasRequiredShort;
  function requireShort() {
    if (hasRequiredShort)
      return short;
    hasRequiredShort = 1;
    var utils2 = requireUtils$1();
    var BN2 = requireBn$3();
    var inherits = requireInherits_browser();
    var Base = requireBase$1();
    var assert = utils2.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    short = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN2(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN2(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN2(vec.a, 16),
            b: new BN2(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN2.mont(num);
      var tinv = new BN2(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN2(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l12 = ntinv.redAdd(s).fromRed();
      var l22 = ntinv.redSub(s).fromRed();
      return [l12, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v10 = this.n.clone();
      var x12 = new BN2(1);
      var y12 = new BN2(0);
      var x22 = new BN2(0);
      var y22 = new BN2(1);
      var a0;
      var b02;
      var a12;
      var b12;
      var a22;
      var b22;
      var prevR;
      var i10 = 0;
      var r8;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v10.div(u);
        r8 = v10.sub(q.mul(u));
        x = x22.sub(q.mul(x12));
        var y10 = y22.sub(q.mul(y12));
        if (!a12 && r8.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b02 = x12;
          a12 = r8.neg();
          b12 = x;
        } else if (a12 && ++i10 === 2) {
          break;
        }
        prevR = r8;
        v10 = u;
        u = r8;
        x22 = x12;
        x12 = x;
        y22 = y12;
        y12 = y10;
      }
      a22 = r8.neg();
      b22 = x;
      var len1 = a12.sqr().add(b12.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b02;
      }
      if (a12.negative) {
        a12 = a12.neg();
        b12 = b12.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a12, b: b12 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v12 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k).divRound(this.n);
      var c22 = v12.b.neg().mul(k).divRound(this.n);
      var p12 = c12.mul(v12.a);
      var p22 = c22.mul(v22.a);
      var q12 = c12.mul(v12.b);
      var q2 = c22.mul(v22.b);
      var k12 = k.sub(p12).sub(p22);
      var k22 = q12.add(q2).neg();
      return { k1: k12, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN2(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y22 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y10 = y22.redSqrt();
      if (y10.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y10.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y10 = y10.redNeg();
      return this.point(x, y10);
    };
    ShortCurve.prototype.validate = function validate2(point2) {
      if (point2.inf)
        return true;
      var x = point2.x;
      var y10 = point2.y;
      var ax2 = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax2).redIAdd(this.b);
      return y10.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i10 = 0; i10 < points.length; i10++) {
        var split = this._endoSplit(coeffs[i10]);
        var p = points[i10];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i10 * 2] = p;
        npoints[i10 * 2 + 1] = beta;
        ncoeffs[i10 * 2] = split.k1;
        ncoeffs[i10 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i10 * 2, jacobianResult);
      for (var j = 0; j < i10 * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point2(curve2, x, y10, isRed) {
      Base.BasePoint.call(this, curve2, "affine");
      if (x === null && y10 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN2(x, 16);
        this.y = new BN2(y10, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point2, Base.BasePoint);
    ShortCurve.prototype.point = function point2(x, y10, isRed) {
      return new Point2(this, x, y10, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point2.fromJSON(this, obj, red);
    };
    Point2.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre2 = this.precomputed;
      if (pre2 && pre2.beta)
        return pre2.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre2) {
        var curve2 = this.curve;
        var endoMul = function(p) {
          return curve2.point(p.x.redMul(curve2.endo.beta), p.y);
        };
        pre2.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre2.naf && {
            wnd: pre2.naf.wnd,
            points: pre2.naf.points.map(endoMul)
          },
          doubles: pre2.doubles && {
            step: pre2.doubles.step,
            points: pre2.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point2.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point2.fromJSON = function fromJSON(curve2, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve2.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve2.point(obj2[0], obj2[1], red);
      }
      var pre2 = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre2.doubles && {
          step: pre2.doubles.step,
          points: [res].concat(pre2.doubles.points.map(obj2point))
        },
        naf: pre2.naf && {
          wnd: pre2.naf.wnd,
          points: [res].concat(pre2.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point2.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx2 = c.redSqr().redISub(this.x).redISub(p.x);
      var ny2 = c.redMul(this.x.redSub(nx2)).redISub(this.y);
      return this.curve.point(nx2, ny2);
    };
    Point2.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x22.redAdd(x22).redIAdd(x22).redIAdd(a).redMul(dyinv);
      var nx2 = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny2 = c.redMul(this.x.redSub(nx2)).redISub(this.y);
      return this.curve.point(nx2, ny2);
    };
    Point2.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point2.prototype.mul = function mul(k) {
      k = new BN2(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point2.prototype.mulAdd = function mulAdd(k12, p22, k22) {
      var points = [this, p22];
      var coeffs = [k12, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point2.prototype.jmulAdd = function jmulAdd(k12, p22, k22) {
      var points = [this, p22];
      var coeffs = [k12, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point2.prototype.eq = function eq2(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point2.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre2 = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre2.naf && {
            wnd: pre2.naf.wnd,
            points: pre2.naf.points.map(negate)
          },
          doubles: pre2.doubles && {
            step: pre2.doubles.step,
            points: pre2.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point2.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve2, x, y10, z) {
      Base.BasePoint.call(this, curve2, "jacobian");
      if (x === null && y10 === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN2(0);
      } else {
        this.x = new BN2(x, 16);
        this.y = new BN2(y10, 16);
        this.z = new BN2(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y10, z) {
      return new JPoint(this, x, y10, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax2 = this.x.redMul(zinv2);
      var ay2 = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax2, ay2);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z22 = this.z.redSqr();
      var u12 = this.x.redMul(pz2);
      var u22 = p.x.redMul(z22);
      var s12 = this.y.redMul(pz2.redMul(p.z));
      var s22 = p.y.redMul(z22.redMul(this.z));
      var h = u12.redSub(u22);
      var r8 = s12.redSub(s22);
      if (h.cmpn(0) === 0) {
        if (r8.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h.redSqr();
      var h32 = h22.redMul(h);
      var v10 = u12.redMul(h22);
      var nx2 = r8.redSqr().redIAdd(h32).redISub(v10).redISub(v10);
      var ny2 = r8.redMul(v10.redISub(nx2)).redISub(s12.redMul(h32));
      var nz2 = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx2, ny2, nz2);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u12 = this.x;
      var u22 = p.x.redMul(z22);
      var s12 = this.y;
      var s22 = p.y.redMul(z22).redMul(this.z);
      var h = u12.redSub(u22);
      var r8 = s12.redSub(s22);
      if (h.cmpn(0) === 0) {
        if (r8.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h.redSqr();
      var h32 = h22.redMul(h);
      var v10 = u12.redMul(h22);
      var nx2 = r8.redSqr().redIAdd(h32).redISub(v10).redISub(v10);
      var ny2 = r8.redMul(v10.redISub(nx2)).redISub(s12.redMul(h32));
      var nz2 = this.z.redMul(h);
      return this.curve.jpoint(nx2, ny2, nz2);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i10;
      if (this.curve.zeroA || this.curve.threeA) {
        var r8 = this;
        for (i10 = 0; i10 < pow; i10++)
          r8 = r8.dbl();
        return r8;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx2 = this.x;
      var jy = this.y;
      var jz2 = this.z;
      var jz4 = jz2.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i10 = 0; i10 < pow; i10++) {
        var jx22 = jx2.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx22.redAdd(jx22).redIAdd(jx22).redIAdd(a.redMul(jz4));
        var t12 = jx2.redMul(jyd2);
        var nx2 = c.redSqr().redISub(t12.redAdd(t12));
        var t22 = t12.redISub(nx2);
        var dny = c.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz2 = jyd.redMul(jz2);
        if (i10 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx2 = nx2;
        jz2 = nz2;
        jyd = dny;
      }
      return this.curve.jpoint(jx2, jyd.redMul(tinv), jz2);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx2;
      var ny2;
      var nz2;
      if (this.zOne) {
        var xx2 = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx2).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx2.redAdd(xx2).redIAdd(xx2);
        var t8 = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx2 = t8;
        ny2 = m.redMul(s.redISub(t8)).redISub(yyyy8);
        nz2 = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e8 = a.redAdd(a).redIAdd(a);
        var f = e8.redSqr();
        var c82 = c.redIAdd(c);
        c82 = c82.redIAdd(c82);
        c82 = c82.redIAdd(c82);
        nx2 = f.redISub(d).redISub(d);
        ny2 = e8.redMul(d.redISub(nx2)).redISub(c82);
        nz2 = this.y.redMul(this.z);
        nz2 = nz2.redIAdd(nz2);
      }
      return this.curve.jpoint(nx2, ny2, nz2);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx2;
      var ny2;
      var nz2;
      if (this.zOne) {
        var xx2 = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx2).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx2.redAdd(xx2).redIAdd(xx2).redIAdd(this.curve.a);
        var t8 = m.redSqr().redISub(s).redISub(s);
        nx2 = t8;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny2 = m.redMul(s.redISub(t8)).redISub(yyyy8);
        nz2 = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha2 = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha2 = alpha2.redAdd(alpha2).redIAdd(alpha2);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx2 = alpha2.redSqr().redISub(beta8);
        nz2 = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny2 = alpha2.redMul(beta4.redISub(nx2)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx2, ny2, nz2);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx2 = this.x;
      var jy = this.y;
      var jz2 = this.z;
      var jz4 = jz2.redSqr().redSqr();
      var jx22 = jx2.redSqr();
      var jy2 = jy.redSqr();
      var c = jx22.redAdd(jx22).redIAdd(jx22).redIAdd(a.redMul(jz4));
      var jxd4 = jx2.redAdd(jx2);
      jxd4 = jxd4.redIAdd(jxd4);
      var t12 = jxd4.redMul(jy2);
      var nx2 = c.redSqr().redISub(t12.redAdd(t12));
      var t22 = t12.redISub(nx2);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny2 = c.redMul(t22).redISub(jyd8);
      var nz2 = jy.redAdd(jy).redMul(jz2);
      return this.curve.jpoint(nx2, ny2, nz2);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx2 = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz2 = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx2.redAdd(xx2).redIAdd(xx2);
      var mm2 = m.redSqr();
      var e8 = this.x.redAdd(yy).redSqr().redISub(xx2).redISub(yyyy);
      e8 = e8.redIAdd(e8);
      e8 = e8.redAdd(e8).redIAdd(e8);
      e8 = e8.redISub(mm2);
      var ee = e8.redSqr();
      var t8 = yyyy.redIAdd(yyyy);
      t8 = t8.redIAdd(t8);
      t8 = t8.redIAdd(t8);
      t8 = t8.redIAdd(t8);
      var u = m.redIAdd(e8).redSqr().redISub(mm2).redISub(ee).redISub(t8);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx2 = this.x.redMul(ee).redISub(yyu4);
      nx2 = nx2.redIAdd(nx2);
      nx2 = nx2.redIAdd(nx2);
      var ny2 = this.y.redMul(u.redMul(t8.redISub(u)).redISub(e8.redMul(ee)));
      ny2 = ny2.redIAdd(ny2);
      ny2 = ny2.redIAdd(ny2);
      ny2 = ny2.redIAdd(ny2);
      var nz2 = this.z.redAdd(e8).redSqr().redISub(zz2).redISub(ee);
      return this.curve.jpoint(nx2, ny2, nz2);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN2(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq2(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs2 = this.z.redSqr();
      var rx2 = x.toRed(this.curve.red).redMul(zs2);
      if (this.x.cmp(rx2) === 0)
        return true;
      var xc2 = x.clone();
      var t8 = this.curve.redN.redMul(zs2);
      for (; ; ) {
        xc2.iadd(this.curve.n);
        if (xc2.cmp(this.curve.p) >= 0)
          return false;
        rx2.redIAdd(t8);
        if (this.x.cmp(rx2) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    return short;
  }
  var mont;
  var hasRequiredMont;
  function requireMont() {
    if (hasRequiredMont)
      return mont;
    hasRequiredMont = 1;
    var BN2 = requireBn$3();
    var inherits = requireInherits_browser();
    var Base = requireBase$1();
    var utils2 = requireUtils$1();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.i4 = new BN2(4).toRed(this.red).redInvm();
      this.two = new BN2(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    mont = MontCurve;
    MontCurve.prototype.validate = function validate2(point2) {
      var x = point2.normalize().x;
      var x22 = x.redSqr();
      var rhs = x22.redMul(x).redAdd(x22.redMul(this.a)).redAdd(x);
      var y10 = rhs.redSqrt();
      return y10.redSqr().cmp(rhs) === 0;
    };
    function Point2(curve2, x, z) {
      Base.BasePoint.call(this, curve2, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN2(x, 16);
        this.z = new BN2(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point2, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils2.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point2(x, z) {
      return new Point2(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point2.fromJSON(this, obj);
    };
    Point2.prototype.precompute = function precompute() {
    };
    Point2.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point2.fromJSON = function fromJSON(curve2, obj) {
      return new Point2(curve2, obj[0], obj[1] || curve2.one);
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point2.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa2 = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa2.redSub(bb);
      var nx2 = aa2.redMul(bb);
      var nz2 = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx2, nz2);
    };
    Point2.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da2 = d.redMul(a);
      var cb = c.redMul(b);
      var nx2 = diff.z.redMul(da2.redAdd(cb).redSqr());
      var nz2 = diff.x.redMul(da2.redISub(cb).redSqr());
      return this.curve.point(nx2, nz2);
    };
    Point2.prototype.mul = function mul(k) {
      var t8 = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t8.cmpn(0) !== 0; t8.iushrn(1))
        bits.push(t8.andln(1));
      for (var i10 = bits.length - 1; i10 >= 0; i10--) {
        if (bits[i10] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point2.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.eq = function eq2(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point2.prototype.normalize = function normalize2() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point2.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    return mont;
  }
  var edwards;
  var hasRequiredEdwards;
  function requireEdwards() {
    if (hasRequiredEdwards)
      return edwards;
    hasRequiredEdwards = 1;
    var utils2 = requireUtils$1();
    var BN2 = requireBn$3();
    var inherits = requireInherits_browser();
    var Base = requireBase$1();
    var assert = utils2.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN2(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN2(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN2(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    edwards = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y10, z, t8) {
      return this.point(x, y10, z, t8);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN2(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x22 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y10 = y22.redSqrt();
      if (y10.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y10.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y10 = y10.redNeg();
      return this.point(x, y10);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y10, odd) {
      y10 = new BN2(y10, 16);
      if (!y10.red)
        y10 = y10.toRed(this.red);
      var y22 = y10.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y10);
      }
      var x = x22.redSqrt();
      if (x.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y10);
    };
    EdwardsCurve.prototype.validate = function validate2(point2) {
      if (point2.isInfinity())
        return true;
      point2.normalize();
      var x22 = point2.x.redSqr();
      var y22 = point2.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point2(curve2, x, y10, z, t8) {
      Base.BasePoint.call(this, curve2, "projective");
      if (x === null && y10 === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN2(x, 16);
        this.y = new BN2(y10, 16);
        this.z = z ? new BN2(z, 16) : this.curve.one;
        this.t = t8 && new BN2(t8, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point2, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point2.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point2(x, y10, z, t8) {
      return new Point2(this, x, y10, z, t8);
    };
    Point2.fromJSON = function fromJSON(curve2, obj) {
      return new Point2(curve2, obj[0], obj[1], obj[2]);
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point2.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e8 = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx2 = e8.redMul(f);
      var ny2 = g.redMul(h);
      var nt2 = e8.redMul(h);
      var nz2 = f.redMul(g);
      return this.curve.point(nx2, ny2, nz2, nt2);
    };
    Point2.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx2;
      var ny2;
      var nz2;
      var e8;
      var h;
      var j;
      if (this.curve.twisted) {
        e8 = this.curve._mulA(c);
        var f = e8.redAdd(d);
        if (this.zOne) {
          nx2 = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny2 = f.redMul(e8.redSub(d));
          nz2 = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx2 = b.redSub(c).redISub(d).redMul(j);
          ny2 = f.redMul(e8.redSub(d));
          nz2 = f.redMul(j);
        }
      } else {
        e8 = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e8.redSub(h).redSub(h);
        nx2 = this.curve._mulC(b.redISub(e8)).redMul(j);
        ny2 = this.curve._mulC(e8).redMul(c.redISub(d));
        nz2 = e8.redMul(j);
      }
      return this.curve.point(nx2, ny2, nz2);
    };
    Point2.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point2.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e8 = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx2 = e8.redMul(f);
      var ny2 = g.redMul(h);
      var nt2 = e8.redMul(h);
      var nz2 = f.redMul(g);
      return this.curve.point(nx2, ny2, nz2, nt2);
    };
    Point2.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e8 = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e8);
      var g = b.redAdd(e8);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx2 = a.redMul(f).redMul(tmp);
      var ny2;
      var nz2;
      if (this.curve.twisted) {
        ny2 = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz2 = f.redMul(g);
      } else {
        ny2 = a.redMul(g).redMul(d.redSub(c));
        nz2 = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx2, ny2, nz2);
    };
    Point2.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point2.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point2.prototype.mulAdd = function mulAdd(k12, p, k22) {
      return this.curve._wnafMulAdd(1, [this, p], [k12, k22], 2, false);
    };
    Point2.prototype.jmulAdd = function jmulAdd(k12, p, k22) {
      return this.curve._wnafMulAdd(1, [this, p], [k12, k22], 2, true);
    };
    Point2.prototype.normalize = function normalize2() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point2.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point2.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point2.prototype.eq = function eq2(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point2.prototype.eqXToP = function eqXToP(x) {
      var rx2 = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx2) === 0)
        return true;
      var xc2 = x.clone();
      var t8 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc2.iadd(this.curve.n);
        if (xc2.cmp(this.curve.p) >= 0)
          return false;
        rx2.redIAdd(t8);
        if (this.x.cmp(rx2) === 0)
          return true;
      }
    };
    Point2.prototype.toP = Point2.prototype.normalize;
    Point2.prototype.mixedAdd = Point2.prototype.add;
    return edwards;
  }
  var hasRequiredCurve;
  function requireCurve() {
    if (hasRequiredCurve)
      return curve;
    hasRequiredCurve = 1;
    (function(exports2) {
      var curve2 = exports2;
      curve2.base = requireBase$1();
      curve2.short = requireShort();
      curve2.mont = requireMont();
      curve2.edwards = requireEdwards();
    })(curve);
    return curve;
  }
  var curves$1 = {};
  var hash = {};
  var utils = {};
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils)
      return utils;
    hasRequiredUtils = 1;
    var assert = requireMinimalisticAssert();
    var inherits = requireInherits_browser();
    utils.inherits = inherits;
    function isSurrogatePair(msg, i10) {
      if ((msg.charCodeAt(i10) & 64512) !== 55296) {
        return false;
      }
      if (i10 < 0 || i10 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i10 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i10 = 0; i10 < msg.length; i10++) {
            var c = msg.charCodeAt(i10);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i10)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i10) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i10 = 0; i10 < msg.length; i10 += 2)
            res.push(parseInt(msg[i10] + msg[i10 + 1], 16));
        }
      } else {
        for (i10 = 0; i10 < msg.length; i10++)
          res[i10] = msg[i10] | 0;
      }
      return res;
    }
    utils.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i10 = 0; i10 < msg.length; i10++)
        res += zero2(msg[i10].toString(16));
      return res;
    }
    utils.toHex = toHex;
    function htonl(w10) {
      var res = w10 >>> 24 | w10 >>> 8 & 65280 | w10 << 8 & 16711680 | (w10 & 255) << 24;
      return res >>> 0;
    }
    utils.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i10 = 0; i10 < msg.length; i10++) {
        var w10 = msg[i10];
        if (endian === "little")
          w10 = htonl(w10);
        res += zero8(w10.toString(16));
      }
      return res;
    }
    utils.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    utils.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len2 = end - start;
      assert(len2 % 4 === 0);
      var res = new Array(len2 / 4);
      for (var i10 = 0, k = start; i10 < res.length; i10++, k += 4) {
        var w10;
        if (endian === "big")
          w10 = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w10 = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i10] = w10 >>> 0;
      }
      return res;
    }
    utils.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i10 = 0, k = 0; i10 < msg.length; i10++, k += 4) {
        var m = msg[i10];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    utils.split32 = split32;
    function rotr32(w10, b) {
      return w10 >>> b | w10 << 32 - b;
    }
    utils.rotr32 = rotr32;
    function rotl32(w10, b) {
      return w10 << b | w10 >>> 32 - b;
    }
    utils.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    utils.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    utils.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    utils.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e8) {
      return a + b + c + d + e8 >>> 0;
    }
    utils.sum32_5 = sum32_5;
    function sum64(buf, pos, ah2, al) {
      var bh2 = buf[pos];
      var bl2 = buf[pos + 1];
      var lo2 = al + bl2 >>> 0;
      var hi2 = (lo2 < al ? 1 : 0) + ah2 + bh2;
      buf[pos] = hi2 >>> 0;
      buf[pos + 1] = lo2;
    }
    utils.sum64 = sum64;
    function sum64_hi(ah2, al, bh2, bl2) {
      var lo2 = al + bl2 >>> 0;
      var hi2 = (lo2 < al ? 1 : 0) + ah2 + bh2;
      return hi2 >>> 0;
    }
    utils.sum64_hi = sum64_hi;
    function sum64_lo(ah2, al, bh2, bl2) {
      var lo2 = al + bl2;
      return lo2 >>> 0;
    }
    utils.sum64_lo = sum64_lo;
    function sum64_4_hi(ah2, al, bh2, bl2, ch2, cl2, dh2, dl2) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl2 >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl2 >>> 0;
      carry += lo2 < cl2 ? 1 : 0;
      lo2 = lo2 + dl2 >>> 0;
      carry += lo2 < dl2 ? 1 : 0;
      var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
      return hi2 >>> 0;
    }
    utils.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah2, al, bh2, bl2, ch2, cl2, dh2, dl2) {
      var lo2 = al + bl2 + cl2 + dl2;
      return lo2 >>> 0;
    }
    utils.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah2, al, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl2 >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl2 >>> 0;
      carry += lo2 < cl2 ? 1 : 0;
      lo2 = lo2 + dl2 >>> 0;
      carry += lo2 < dl2 ? 1 : 0;
      lo2 = lo2 + el2 >>> 0;
      carry += lo2 < el2 ? 1 : 0;
      var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
      return hi2 >>> 0;
    }
    utils.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah2, al, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
      var lo2 = al + bl2 + cl2 + dl2 + el2;
      return lo2 >>> 0;
    }
    utils.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah2, al, num) {
      var r8 = al << 32 - num | ah2 >>> num;
      return r8 >>> 0;
    }
    utils.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah2, al, num) {
      var r8 = ah2 << 32 - num | al >>> num;
      return r8 >>> 0;
    }
    utils.rotr64_lo = rotr64_lo;
    function shr64_hi(ah2, al, num) {
      return ah2 >>> num;
    }
    utils.shr64_hi = shr64_hi;
    function shr64_lo(ah2, al, num) {
      var r8 = ah2 << 32 - num | al >>> num;
      return r8 >>> 0;
    }
    utils.shr64_lo = shr64_lo;
    return utils;
  }
  var common$1 = {};
  var hasRequiredCommon$1;
  function requireCommon$1() {
    if (hasRequiredCommon$1)
      return common$1;
    hasRequiredCommon$1 = 1;
    var utils2 = requireUtils();
    var assert = requireMinimalisticAssert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    common$1.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils2.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r8 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r8, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils2.join32(msg, 0, msg.length - r8, this.endian);
        for (var i10 = 0; i10 < msg.length; i10 += this._delta32)
          this._update(msg, i10, i10 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len2 = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len2 + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i10 = 1; i10 < k; i10++)
        res[i10] = 0;
      len2 <<= 3;
      if (this.endian === "big") {
        for (var t8 = 8; t8 < this.padLength; t8++)
          res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = len2 >>> 24 & 255;
        res[i10++] = len2 >>> 16 & 255;
        res[i10++] = len2 >>> 8 & 255;
        res[i10++] = len2 & 255;
      } else {
        res[i10++] = len2 & 255;
        res[i10++] = len2 >>> 8 & 255;
        res[i10++] = len2 >>> 16 & 255;
        res[i10++] = len2 >>> 24 & 255;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        res[i10++] = 0;
        for (t8 = 8; t8 < this.padLength; t8++)
          res[i10++] = 0;
      }
      return res;
    };
    return common$1;
  }
  var sha = {};
  var common = {};
  var hasRequiredCommon;
  function requireCommon() {
    if (hasRequiredCommon)
      return common;
    hasRequiredCommon = 1;
    var utils2 = requireUtils();
    var rotr32 = utils2.rotr32;
    function ft_1(s, x, y10, z) {
      if (s === 0)
        return ch32(x, y10, z);
      if (s === 1 || s === 3)
        return p32(x, y10, z);
      if (s === 2)
        return maj32(x, y10, z);
    }
    common.ft_1 = ft_1;
    function ch32(x, y10, z) {
      return x & y10 ^ ~x & z;
    }
    common.ch32 = ch32;
    function maj32(x, y10, z) {
      return x & y10 ^ x & z ^ y10 & z;
    }
    common.maj32 = maj32;
    function p32(x, y10, z) {
      return x ^ y10 ^ z;
    }
    common.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    common.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    common.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    common.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    common.g1_256 = g1_256;
    return common;
  }
  var _1$1;
  var hasRequired_1;
  function require_1() {
    if (hasRequired_1)
      return _1$1;
    hasRequired_1 = 1;
    var utils2 = requireUtils();
    var common2 = requireCommon$1();
    var shaCommon = requireCommon();
    var rotl32 = utils2.rotl32;
    var sum32 = utils2.sum32;
    var sum32_5 = utils2.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common2.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils2.inherits(SHA1, BlockHash);
    _1$1 = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W5 = this.W;
      for (var i10 = 0; i10 < 16; i10++)
        W5[i10] = msg[start + i10];
      for (; i10 < W5.length; i10++)
        W5[i10] = rotl32(W5[i10 - 3] ^ W5[i10 - 8] ^ W5[i10 - 14] ^ W5[i10 - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e8 = this.h[4];
      for (i10 = 0; i10 < W5.length; i10++) {
        var s = ~~(i10 / 20);
        var t8 = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e8, W5[i10], sha1_K[s]);
        e8 = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t8;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e8);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "big");
      else
        return utils2.split32(this.h, "big");
    };
    return _1$1;
  }
  var _256;
  var hasRequired_256;
  function require_256() {
    if (hasRequired_256)
      return _256;
    hasRequired_256 = 1;
    var utils2 = requireUtils();
    var common2 = requireCommon$1();
    var shaCommon = requireCommon();
    var assert = requireMinimalisticAssert();
    var sum32 = utils2.sum32;
    var sum32_4 = utils2.sum32_4;
    var sum32_5 = utils2.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common2.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils2.inherits(SHA256, BlockHash);
    _256 = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W5 = this.W;
      for (var i10 = 0; i10 < 16; i10++)
        W5[i10] = msg[start + i10];
      for (; i10 < W5.length; i10++)
        W5[i10] = sum32_4(g1_256(W5[i10 - 2]), W5[i10 - 7], g0_256(W5[i10 - 15]), W5[i10 - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e8 = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W5.length);
      for (i10 = 0; i10 < W5.length; i10++) {
        var T12 = sum32_5(h, s1_256(e8), ch32(e8, f, g), this.k[i10], W5[i10]);
        var T22 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e8;
        e8 = sum32(d, T12);
        d = c;
        c = b;
        b = a;
        a = sum32(T12, T22);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e8);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "big");
      else
        return utils2.split32(this.h, "big");
    };
    return _256;
  }
  var _224;
  var hasRequired_224;
  function require_224() {
    if (hasRequired_224)
      return _224;
    hasRequired_224 = 1;
    var utils2 = requireUtils();
    var SHA256 = require_256();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils2.inherits(SHA224, SHA256);
    _224 = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h.slice(0, 7), "big");
      else
        return utils2.split32(this.h.slice(0, 7), "big");
    };
    return _224;
  }
  var _512;
  var hasRequired_512;
  function require_512() {
    if (hasRequired_512)
      return _512;
    hasRequired_512 = 1;
    var utils2 = requireUtils();
    var common2 = requireCommon$1();
    var assert = requireMinimalisticAssert();
    var rotr64_hi = utils2.rotr64_hi;
    var rotr64_lo = utils2.rotr64_lo;
    var shr64_hi = utils2.shr64_hi;
    var shr64_lo = utils2.shr64_lo;
    var sum64 = utils2.sum64;
    var sum64_hi = utils2.sum64_hi;
    var sum64_lo = utils2.sum64_lo;
    var sum64_4_hi = utils2.sum64_4_hi;
    var sum64_4_lo = utils2.sum64_4_lo;
    var sum64_5_hi = utils2.sum64_5_hi;
    var sum64_5_lo = utils2.sum64_5_lo;
    var BlockHash = common2.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils2.inherits(SHA512, BlockHash);
    _512 = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W5 = this.W;
      for (var i10 = 0; i10 < 32; i10++)
        W5[i10] = msg[start + i10];
      for (; i10 < W5.length; i10 += 2) {
        var c0_hi = g1_512_hi(W5[i10 - 4], W5[i10 - 3]);
        var c0_lo = g1_512_lo(W5[i10 - 4], W5[i10 - 3]);
        var c1_hi = W5[i10 - 14];
        var c1_lo = W5[i10 - 13];
        var c2_hi = g0_512_hi(W5[i10 - 30], W5[i10 - 29]);
        var c2_lo = g0_512_lo(W5[i10 - 30], W5[i10 - 29]);
        var c3_hi = W5[i10 - 32];
        var c3_lo = W5[i10 - 31];
        W5[i10] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W5[i10 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W5 = this.W;
      var ah2 = this.h[0];
      var al = this.h[1];
      var bh2 = this.h[2];
      var bl2 = this.h[3];
      var ch2 = this.h[4];
      var cl2 = this.h[5];
      var dh2 = this.h[6];
      var dl2 = this.h[7];
      var eh2 = this.h[8];
      var el2 = this.h[9];
      var fh2 = this.h[10];
      var fl2 = this.h[11];
      var gh2 = this.h[12];
      var gl2 = this.h[13];
      var hh2 = this.h[14];
      var hl2 = this.h[15];
      assert(this.k.length === W5.length);
      for (var i10 = 0; i10 < W5.length; i10 += 2) {
        var c0_hi = hh2;
        var c0_lo = hl2;
        var c1_hi = s1_512_hi(eh2, el2);
        var c1_lo = s1_512_lo(eh2, el2);
        var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
        var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
        var c3_hi = this.k[i10];
        var c3_lo = this.k[i10 + 1];
        var c4_hi = W5[i10];
        var c4_lo = W5[i10 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah2, al);
        c0_lo = s0_512_lo(ah2, al);
        c1_hi = maj64_hi(ah2, al, bh2, bl2, ch2);
        c1_lo = maj64_lo(ah2, al, bh2, bl2, ch2, cl2);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh2 = gh2;
        hl2 = gl2;
        gh2 = fh2;
        gl2 = fl2;
        fh2 = eh2;
        fl2 = el2;
        eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
        el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
        dh2 = ch2;
        dl2 = cl2;
        ch2 = bh2;
        cl2 = bl2;
        bh2 = ah2;
        bl2 = al;
        ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah2, al);
      sum64(this.h, 2, bh2, bl2);
      sum64(this.h, 4, ch2, cl2);
      sum64(this.h, 6, dh2, dl2);
      sum64(this.h, 8, eh2, el2);
      sum64(this.h, 10, fh2, fl2);
      sum64(this.h, 12, gh2, gl2);
      sum64(this.h, 14, hh2, hl2);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "big");
      else
        return utils2.split32(this.h, "big");
    };
    function ch64_hi(xh2, xl2, yh2, yl2, zh2) {
      var r8 = xh2 & yh2 ^ ~xh2 & zh2;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function ch64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
      var r8 = xl2 & yl2 ^ ~xl2 & zl2;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function maj64_hi(xh2, xl2, yh2, yl2, zh2) {
      var r8 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function maj64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
      var r8 = xl2 & yl2 ^ xl2 & zl2 ^ yl2 & zl2;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function s0_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 28);
      var c1_hi = rotr64_hi(xl2, xh2, 2);
      var c2_hi = rotr64_hi(xl2, xh2, 7);
      var r8 = c0_hi ^ c1_hi ^ c2_hi;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function s0_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 28);
      var c1_lo = rotr64_lo(xl2, xh2, 2);
      var c2_lo = rotr64_lo(xl2, xh2, 7);
      var r8 = c0_lo ^ c1_lo ^ c2_lo;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function s1_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 14);
      var c1_hi = rotr64_hi(xh2, xl2, 18);
      var c2_hi = rotr64_hi(xl2, xh2, 9);
      var r8 = c0_hi ^ c1_hi ^ c2_hi;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function s1_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 14);
      var c1_lo = rotr64_lo(xh2, xl2, 18);
      var c2_lo = rotr64_lo(xl2, xh2, 9);
      var r8 = c0_lo ^ c1_lo ^ c2_lo;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function g0_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 1);
      var c1_hi = rotr64_hi(xh2, xl2, 8);
      var c2_hi = shr64_hi(xh2, xl2, 7);
      var r8 = c0_hi ^ c1_hi ^ c2_hi;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function g0_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 1);
      var c1_lo = rotr64_lo(xh2, xl2, 8);
      var c2_lo = shr64_lo(xh2, xl2, 7);
      var r8 = c0_lo ^ c1_lo ^ c2_lo;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function g1_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 19);
      var c1_hi = rotr64_hi(xl2, xh2, 29);
      var c2_hi = shr64_hi(xh2, xl2, 6);
      var r8 = c0_hi ^ c1_hi ^ c2_hi;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    function g1_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 19);
      var c1_lo = rotr64_lo(xl2, xh2, 29);
      var c2_lo = shr64_lo(xh2, xl2, 6);
      var r8 = c0_lo ^ c1_lo ^ c2_lo;
      if (r8 < 0)
        r8 += 4294967296;
      return r8;
    }
    return _512;
  }
  var _384;
  var hasRequired_384;
  function require_384() {
    if (hasRequired_384)
      return _384;
    hasRequired_384 = 1;
    var utils2 = requireUtils();
    var SHA512 = require_512();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils2.inherits(SHA384, SHA512);
    _384 = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h.slice(0, 12), "big");
      else
        return utils2.split32(this.h.slice(0, 12), "big");
    };
    return _384;
  }
  var hasRequiredSha;
  function requireSha() {
    if (hasRequiredSha)
      return sha;
    hasRequiredSha = 1;
    sha.sha1 = require_1();
    sha.sha224 = require_224();
    sha.sha256 = require_256();
    sha.sha384 = require_384();
    sha.sha512 = require_512();
    return sha;
  }
  var ripemd = {};
  var hasRequiredRipemd;
  function requireRipemd() {
    if (hasRequiredRipemd)
      return ripemd;
    hasRequiredRipemd = 1;
    var utils2 = requireUtils();
    var common2 = requireCommon$1();
    var rotl32 = utils2.rotl32;
    var sum32 = utils2.sum32;
    var sum32_3 = utils2.sum32_3;
    var sum32_4 = utils2.sum32_4;
    var BlockHash = common2.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils2.inherits(RIPEMD160, BlockHash);
    ripemd.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A10 = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah2 = A10;
      var Bh2 = B;
      var Ch2 = C;
      var Dh2 = D;
      var Eh2 = E;
      for (var j = 0; j < 80; j++) {
        var T10 = sum32(
          rotl32(
            sum32_4(A10, f(j, B, C, D), msg[r8[j] + start], K5(j)),
            s[j]
          ),
          E
        );
        A10 = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T10;
        T10 = sum32(
          rotl32(
            sum32_4(Ah2, f(79 - j, Bh2, Ch2, Dh2), msg[rh2[j] + start], Kh2(j)),
            sh2[j]
          ),
          Eh2
        );
        Ah2 = Eh2;
        Eh2 = Dh2;
        Dh2 = rotl32(Ch2, 10);
        Ch2 = Bh2;
        Bh2 = T10;
      }
      T10 = sum32_3(this.h[1], C, Dh2);
      this.h[1] = sum32_3(this.h[2], D, Eh2);
      this.h[2] = sum32_3(this.h[3], E, Ah2);
      this.h[3] = sum32_3(this.h[4], A10, Bh2);
      this.h[4] = sum32_3(this.h[0], B, Ch2);
      this.h[0] = T10;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "little");
      else
        return utils2.split32(this.h, "little");
    };
    function f(j, x, y10, z) {
      if (j <= 15)
        return x ^ y10 ^ z;
      else if (j <= 31)
        return x & y10 | ~x & z;
      else if (j <= 47)
        return (x | ~y10) ^ z;
      else if (j <= 63)
        return x & z | y10 & ~z;
      else
        return x ^ (y10 | ~z);
    }
    function K5(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh2(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh2 = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh2 = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    return ripemd;
  }
  var hmac;
  var hasRequiredHmac;
  function requireHmac() {
    if (hasRequiredHmac)
      return hmac;
    hasRequiredHmac = 1;
    var utils2 = requireUtils();
    var assert = requireMinimalisticAssert();
    function Hmac(hash2, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash2, key2, enc);
      this.Hash = hash2;
      this.blockSize = hash2.blockSize / 8;
      this.outSize = hash2.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils2.toArray(key2, enc));
    }
    hmac = Hmac;
    Hmac.prototype._init = function init4(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert(key2.length <= this.blockSize);
      for (var i10 = key2.length; i10 < this.blockSize; i10++)
        key2.push(0);
      for (i10 = 0; i10 < key2.length; i10++)
        key2[i10] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i10 = 0; i10 < key2.length; i10++)
        key2[i10] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
    return hmac;
  }
  var hasRequiredHash;
  function requireHash() {
    if (hasRequiredHash)
      return hash;
    hasRequiredHash = 1;
    (function(exports2) {
      var hash2 = exports2;
      hash2.utils = requireUtils();
      hash2.common = requireCommon$1();
      hash2.sha = requireSha();
      hash2.ripemd = requireRipemd();
      hash2.hmac = requireHmac();
      hash2.sha1 = hash2.sha.sha1;
      hash2.sha256 = hash2.sha.sha256;
      hash2.sha224 = hash2.sha.sha224;
      hash2.sha384 = hash2.sha.sha384;
      hash2.sha512 = hash2.sha.sha512;
      hash2.ripemd160 = hash2.ripemd.ripemd160;
    })(hash);
    return hash;
  }
  var secp256k1;
  var hasRequiredSecp256k1;
  function requireSecp256k1() {
    if (hasRequiredSecp256k1)
      return secp256k1;
    hasRequiredSecp256k1 = 1;
    secp256k1 = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
    return secp256k1;
  }
  var hasRequiredCurves;
  function requireCurves() {
    if (hasRequiredCurves)
      return curves$1;
    hasRequiredCurves = 1;
    (function(exports2) {
      var curves2 = exports2;
      var hash2 = requireHash();
      var curve2 = requireCurve();
      var utils2 = requireUtils$1();
      var assert = utils2.assert;
      function PresetCurve(options4) {
        if (options4.type === "short")
          this.curve = new curve2.short(options4);
        else if (options4.type === "edwards")
          this.curve = new curve2.edwards(options4);
        else
          this.curve = new curve2.mont(options4);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options4.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves2.PresetCurve = PresetCurve;
      function defineCurve(name2, options4) {
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve3 = new PresetCurve(options4);
            Object.defineProperty(curves2, name2, {
              configurable: true,
              enumerable: true,
              value: curve3
            });
            return curve3;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash2.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash2.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash2.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash2.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash2.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash2.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash2.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre2;
      try {
        pre2 = requireSecp256k1();
      } catch (e8) {
        pre2 = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash2.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre2
        ]
      });
    })(curves$1);
    return curves$1;
  }
  var hmacDrbg;
  var hasRequiredHmacDrbg;
  function requireHmacDrbg() {
    if (hasRequiredHmacDrbg)
      return hmacDrbg;
    hasRequiredHmacDrbg = 1;
    var hash2 = requireHash();
    var utils2 = requireUtils$2();
    var assert = requireMinimalisticAssert();
    function HmacDRBG(options4) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options4);
      this.hash = options4.hash;
      this.predResist = !!options4.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options4.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils2.toArray(options4.entropy, options4.entropyEnc || "hex");
      var nonce = utils2.toArray(options4.nonce, options4.nonceEnc || "hex");
      var pers = utils2.toArray(options4.pers, options4.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    hmacDrbg = HmacDRBG;
    HmacDRBG.prototype._init = function init4(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i10 = 0; i10 < this.V.length; i10++) {
        this.K[i10] = 0;
        this.V[i10] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac2() {
      return new hash2.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils2.toArray(entropy, entropyEnc);
      add = utils2.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len2, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils2.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len2) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len2);
      this._update(add);
      this._reseed++;
      return utils2.encode(res, enc);
    };
    return hmacDrbg;
  }
  var key$1;
  var hasRequiredKey$1;
  function requireKey$1() {
    if (hasRequiredKey$1)
      return key$1;
    hasRequiredKey$1 = 1;
    var BN2 = requireBn$3();
    var utils2 = requireUtils$1();
    var assert = utils2.assert;
    function KeyPair(ec2, options4) {
      this.ec = ec2;
      this.priv = null;
      this.pub = null;
      if (options4.priv)
        this._importPrivate(options4.priv, options4.privEnc);
      if (options4.pub)
        this._importPublic(options4.pub, options4.pubEnc);
    }
    key$1 = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate2() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
      this.priv = new BN2(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options4) {
      return this.ec.sign(msg, this, enc, options4);
    };
    KeyPair.prototype.verify = function verify(msg, signature2) {
      return this.ec.verify(msg, signature2, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    return key$1;
  }
  var signature$1;
  var hasRequiredSignature$1;
  function requireSignature$1() {
    if (hasRequiredSignature$1)
      return signature$1;
    hasRequiredSignature$1 = 1;
    var BN2 = requireBn$3();
    var utils2 = requireUtils$1();
    var assert = utils2.assert;
    function Signature(options4, enc) {
      if (options4 instanceof Signature)
        return options4;
      if (this._importDER(options4, enc))
        return;
      assert(options4.r && options4.s, "Signature without r or s");
      this.r = new BN2(options4.r, 16);
      this.s = new BN2(options4.s, 16);
      if (options4.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options4.recoveryParam;
    }
    signature$1 = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i10 = 0, off = p.place; i10 < octetLen; i10++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i10 = 0;
      var len2 = buf.length - 1;
      while (!buf[i10] && !(buf[i10 + 1] & 128) && i10 < len2) {
        i10++;
      }
      if (i10 === 0) {
        return buf;
      }
      return buf.slice(i10);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils2.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len2 = getLength(data, p);
      if (len2 === false) {
        return false;
      }
      if (len2 + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r8 = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r8[0] === 0) {
        if (r8[1] & 128) {
          r8 = r8.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN2(r8);
      this.s = new BN2(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len2) {
      if (len2 < 128) {
        arr.push(len2);
        return;
      }
      var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len2 >>> (octets << 3) & 255);
      }
      arr.push(len2);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r8 = this.r.toArray();
      var s = this.s.toArray();
      if (r8[0] & 128)
        r8 = [0].concat(r8);
      if (s[0] & 128)
        s = [0].concat(s);
      r8 = rmPadding(r8);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r8.length);
      arr = arr.concat(r8);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils2.encode(res, enc);
    };
    return signature$1;
  }
  var ec$1;
  var hasRequiredEc;
  function requireEc() {
    if (hasRequiredEc)
      return ec$1;
    hasRequiredEc = 1;
    var BN2 = requireBn$3();
    var HmacDRBG = requireHmacDrbg();
    var utils2 = requireUtils$1();
    var curves2 = requireCurves();
    var rand = requireBrorand();
    var assert = utils2.assert;
    var KeyPair = requireKey$1();
    var Signature = requireSignature$1();
    function EC(options4) {
      if (!(this instanceof EC))
        return new EC(options4);
      if (typeof options4 === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves2, options4),
          "Unknown curve " + options4
        );
        options4 = curves2[options4];
      }
      if (options4 instanceof curves2.PresetCurve)
        options4 = { curve: options4 };
      this.curve = options4.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options4.curve.g;
      this.g.precompute(options4.curve.n.bitLength() + 1);
      this.hash = options4.hash || options4.curve.hash;
    }
    ec$1 = EC;
    EC.prototype.keyPair = function keyPair(options4) {
      return new KeyPair(this, options4);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options4) {
      if (!options4)
        options4 = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options4.pers,
        persEnc: options4.persEnc || "utf8",
        entropy: options4.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options4.entropy && options4.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN2(2));
      for (; ; ) {
        var priv = new BN2(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key2, enc, options4) {
      if (typeof enc === "object") {
        options4 = enc;
        enc = null;
      }
      if (!options4)
        options4 = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new BN2(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options4.pers,
        persEnc: options4.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN2(1));
      for (var iter = 0; ; iter++) {
        var k = options4.k ? options4.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp2 = this.g.mul(k);
        if (kp2.isInfinity())
          continue;
        var kpX = kp2.getX();
        var r8 = kpX.umod(this.n);
        if (r8.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r8.mul(key2.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp2.getY().isOdd() ? 1 : 0) | (kpX.cmp(r8) !== 0 ? 2 : 0);
        if (options4.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r8, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature2, key2, enc) {
      msg = this._truncateToN(new BN2(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature2 = new Signature(signature2, "hex");
      var r8 = signature2.r;
      var s = signature2.s;
      if (r8.cmpn(1) < 0 || r8.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u12 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r8).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u12, key2.getPublic(), u22);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r8) === 0;
      }
      p = this.g.jmulAdd(u12, key2.getPublic(), u22);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r8);
    };
    EC.prototype.recoverPubKey = function(msg, signature2, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature2 = new Signature(signature2, enc);
      var n8 = this.n;
      var e8 = new BN2(msg);
      var r8 = signature2.r;
      var s = signature2.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r8.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r8 = this.curve.pointFromX(r8.add(this.curve.n), isYOdd);
      else
        r8 = this.curve.pointFromX(r8, isYOdd);
      var rInv = signature2.r.invm(n8);
      var s12 = n8.sub(e8).mul(rInv).umod(n8);
      var s22 = s.mul(rInv).umod(n8);
      return this.g.mulAdd(s12, r8, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e8, signature2, Q2, enc) {
      signature2 = new Signature(signature2, enc);
      if (signature2.recoveryParam !== null)
        return signature2.recoveryParam;
      for (var i10 = 0; i10 < 4; i10++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e8, signature2, i10);
        } catch (e10) {
          continue;
        }
        if (Qprime.eq(Q2))
          return i10;
      }
      throw new Error("Unable to find valid recovery factor");
    };
    return ec$1;
  }
  var key;
  var hasRequiredKey;
  function requireKey() {
    if (hasRequiredKey)
      return key;
    hasRequiredKey = 1;
    var utils2 = requireUtils$1();
    var assert = utils2.assert;
    var parseBytes = utils2.parseBytes;
    var cachedProperty = utils2.cachedProperty;
    function KeyPair(eddsa2, params) {
      this.eddsa = eddsa2;
      this._secret = parseBytes(params.secret);
      if (eddsa2.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa2, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa2, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa2, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa2, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa2 = this.eddsa;
      var hash2 = this.hash();
      var lastIx = eddsa2.encodingLength - 1;
      var a = hash2.slice(0, eddsa2.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash2() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils2.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils2.encode(this.pubBytes(), enc);
    };
    key = KeyPair;
    return key;
  }
  var signature;
  var hasRequiredSignature;
  function requireSignature() {
    if (hasRequiredSignature)
      return signature;
    hasRequiredSignature = 1;
    var BN2 = requireBn$3();
    var utils2 = requireUtils$1();
    var assert = utils2.assert;
    var cachedProperty = utils2.cachedProperty;
    var parseBytes = utils2.parseBytes;
    function Signature(eddsa2, sig) {
      this.eddsa = eddsa2;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa2.encodingLength),
          S: sig.slice(eddsa2.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa2.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN2)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils2.encode(this.toBytes(), "hex").toUpperCase();
    };
    signature = Signature;
    return signature;
  }
  var eddsa;
  var hasRequiredEddsa;
  function requireEddsa() {
    if (hasRequiredEddsa)
      return eddsa;
    hasRequiredEddsa = 1;
    var hash2 = requireHash();
    var curves2 = requireCurves();
    var utils2 = requireUtils$1();
    var assert = utils2.assert;
    var parseBytes = utils2.parseBytes;
    var KeyPair = requireKey();
    var Signature = requireSignature();
    function EDDSA(curve2) {
      assert(curve2 === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve2);
      curve2 = curves2[curve2].curve;
      this.curve = curve2;
      this.g = curve2.g;
      this.g.precompute(curve2.n.bitLength() + 1);
      this.pointClass = curve2.point().constructor;
      this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
      this.hash = hash2.sha512;
    }
    eddsa = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key2 = this.keyFromSecret(secret);
      var r8 = this.hashInt(key2.messagePrefix(), message);
      var R = this.g.mul(r8);
      var Rencoded = this.encodePoint(R);
      var s_2 = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
      var S = r8.add(s_2).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key2 = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
      var SG2 = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key2.pub().mul(h));
      return RplusAh.eq(SG2);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash3 = this.hash();
      for (var i10 = 0; i10 < arguments.length; i10++)
        hash3.update(arguments[i10]);
      return utils2.intFromLE(hash3.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point2) {
      var enc = point2.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point2.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils2.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y10 = utils2.intFromLE(normed);
      return this.curve.pointFromY(y10, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils2.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
    return eddsa;
  }
  var hasRequiredElliptic;
  function requireElliptic() {
    if (hasRequiredElliptic)
      return elliptic;
    hasRequiredElliptic = 1;
    (function(exports2) {
      var elliptic2 = exports2;
      elliptic2.version = require$$0.version;
      elliptic2.utils = requireUtils$1();
      elliptic2.rand = requireBrorand();
      elliptic2.curve = requireCurve();
      elliptic2.curves = requireCurves();
      elliptic2.ec = requireEc();
      elliptic2.eddsa = requireEddsa();
    })(elliptic);
    return elliptic;
  }
  var asn1$1 = {};
  var asn1 = {};
  var bn$3 = { exports: {} };
  bn$3.exports;
  var hasRequiredBn$2;
  function requireBn$2() {
    if (hasRequiredBn$2)
      return bn$3.exports;
    hasRequiredBn$2 = 1;
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base2, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = buffer$1.Buffer;
          }
        } catch (e8) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init4(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var j, w10;
          var off = 0;
          if (endian === "be") {
            for (i10 = number.length - 1, j = 0; i10 >= 0; i10 -= 3) {
              w10 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i10 = 0, j = 0; i10 < number.length; i10 += 3) {
              w10 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r8 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r8;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var off = 0;
          var j = 0;
          var w10;
          if (endian === "be") {
            for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r8 = 0;
          var len2 = Math.min(str.length, end);
          for (var i10 = start; i10 < len2; i10++) {
            var c = str.charCodeAt(i10) - 48;
            r8 *= mul;
            if (c >= 49) {
              r8 += c - 49 + 10;
            } else if (c >= 17) {
              r8 += c - 17 + 10;
            } else {
              r8 += c;
            }
          }
          return r8;
        }
        BN2.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i10 = start; i10 < end; i10 += limbLen) {
            word = parseBase(number, i10, i10 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i10, number.length, base2);
            for (i10 = 0; i10 < mod; i10++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN2.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            dest.words[i10] = this.words[i10];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r8 = new BN2(null);
          this.copy(r8);
          return r8;
        };
        BN2.prototype._expand = function _expand(size2) {
          while (this.length < size2) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i10 = 0; i10 < this.length; i10++) {
              var w10 = this.words[i10];
              var word = ((w10 << off | carry) & 16777215).toString(16);
              carry = w10 >>> 24 - off & 16777215;
              if (carry !== 0 || i10 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i10--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r8 = c.modn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength2 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i10;
          var q = this.clone();
          if (!littleEndian) {
            for (i10 = 0; i10 < reqLength - byteLength2; i10++) {
              res[i10] = 0;
            }
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i10 - 1] = b;
            }
          } else {
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i10] = b;
            }
            for (; i10 < reqLength; i10++) {
              res[i10] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w10) {
            return 32 - Math.clz32(w10);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w10) {
            var t8 = w10;
            var r8 = 0;
            if (t8 >= 4096) {
              r8 += 13;
              t8 >>>= 13;
            }
            if (t8 >= 64) {
              r8 += 7;
              t8 >>>= 7;
            }
            if (t8 >= 8) {
              r8 += 4;
              t8 >>>= 4;
            }
            if (t8 >= 2) {
              r8 += 2;
              t8 >>>= 2;
            }
            return r8 + t8;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w10) {
          if (w10 === 0)
            return 26;
          var t8 = w10;
          var r8 = 0;
          if ((t8 & 8191) === 0) {
            r8 += 13;
            t8 >>>= 13;
          }
          if ((t8 & 127) === 0) {
            r8 += 7;
            t8 >>>= 7;
          }
          if ((t8 & 15) === 0) {
            r8 += 4;
            t8 >>>= 4;
          }
          if ((t8 & 3) === 0) {
            r8 += 2;
            t8 >>>= 2;
          }
          if ((t8 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w10 = this.words[this.length - 1];
          var hi2 = this._countBits(w10);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w10 = new Array(num.bitLength());
          for (var bit = 0; bit < w10.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w10[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w10;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var b = this._zeroBits(this.words[i10]);
            r8 += b;
            if (b !== 26)
              break;
          }
          return r8;
        };
        BN2.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i10 = 0; i10 < num.length; i10++) {
            this.words[i10] = this.words[i10] | num.words[i10];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = this.words[i10] & num.words[i10];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = a.words[i10] ^ b.words[i10];
          }
          if (this !== a) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i10 = 0; i10 < bytesNeeded; i10++) {
            this.words[i10] = ~this.words[i10] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) + (b.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) - (b.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          if (carry === 0 && i10 < a.length && a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = Math.max(this.length, i10);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r8 = a * b;
          var lo2 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo2;
          for (var k = 1; k < len2; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j | 0;
              a = self2.words[i10] | 0;
              b = num.words[j] | 0;
              r8 = a * b + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o8 = out.words;
          var c = 0;
          var lo2;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a12 = a[1] | 0;
          var al1 = a12 & 8191;
          var ah1 = a12 >>> 13;
          var a22 = a[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a72 = a[7] | 0;
          var al7 = a72 & 8191;
          var ah7 = a72 >>> 13;
          var a82 = a[8] | 0;
          var al8 = a82 & 8191;
          var ah8 = a82 >>> 13;
          var a92 = a[9] | 0;
          var al9 = a92 & 8191;
          var ah9 = a92 >>> 13;
          var b02 = b[0] | 0;
          var bl0 = b02 & 8191;
          var bh0 = b02 >>> 13;
          var b12 = b[1] | 0;
          var bl1 = b12 & 8191;
          var bh1 = b12 >>> 13;
          var b22 = b[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b82 = b[8] | 0;
          var bl8 = b82 & 8191;
          var bh8 = b82 >>> 13;
          var b92 = b[9] | 0;
          var bl9 = b92 & 8191;
          var bh9 = b92 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo2 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w02 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
          w02 &= 67108863;
          lo2 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo2 = lo2 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo2 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo2 = lo2 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo2 = lo2 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo2 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo2 = lo2 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo2 = lo2 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo2 = lo2 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo2 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo2 = lo2 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo2 = lo2 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo2 = lo2 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo2 = lo2 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo2 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo2 = lo2 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo2 = lo2 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo2 = lo2 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo2 = lo2 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo2 = lo2 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo2 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo2 = lo2 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo2 = lo2 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo2 = lo2 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo2 = lo2 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo2 = lo2 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo2 = lo2 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo2 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo2 = lo2 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo2 = lo2 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo2 = lo2 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo2 = lo2 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo2 = lo2 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo2 = lo2 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo2 = lo2 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo2 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo2 = lo2 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo2 = lo2 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo2 = lo2 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo2 = lo2 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo2 = lo2 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo2 = lo2 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo2 = lo2 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo2 = lo2 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w82 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
          w82 &= 67108863;
          lo2 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo2 = lo2 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo2 = lo2 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo2 = lo2 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo2 = lo2 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo2 = lo2 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo2 = lo2 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo2 = lo2 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo2 = lo2 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo2 = lo2 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w92 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
          w92 &= 67108863;
          lo2 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo2 = lo2 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo2 = lo2 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo2 = lo2 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo2 = lo2 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo2 = lo2 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo2 = lo2 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo2 = lo2 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo2 = lo2 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo2 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo2 = lo2 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo2 = lo2 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo2 = lo2 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo2 = lo2 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo2 = lo2 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo2 = lo2 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo2 = lo2 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo2 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo2 = lo2 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo2 = lo2 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo2 = lo2 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo2 = lo2 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo2 = lo2 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo2 = lo2 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w122 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
          w122 &= 67108863;
          lo2 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo2 = lo2 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo2 = lo2 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo2 = lo2 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo2 = lo2 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo2 = lo2 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo2 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo2 = lo2 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo2 = lo2 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo2 = lo2 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo2 = lo2 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo2 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo2 = lo2 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo2 = lo2 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo2 = lo2 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo2 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo2 = lo2 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo2 = lo2 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo2 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo2 = lo2 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo2 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o8[0] = w02;
          o8[1] = w12;
          o8[2] = w22;
          o8[3] = w32;
          o8[4] = w42;
          o8[5] = w52;
          o8[6] = w62;
          o8[7] = w72;
          o8[8] = w82;
          o8[9] = w92;
          o8[10] = w10;
          o8[11] = w11;
          o8[12] = w122;
          o8[13] = w13;
          o8[14] = w14;
          o8[15] = w15;
          o8[16] = w16;
          o8[17] = w17;
          o8[18] = w18;
          if (c !== 0) {
            o8[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j;
              var a = self2.words[i10] | 0;
              var b = num.words[j] | 0;
              var r8 = a * b;
              var lo2 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo2 = lo2 + rword | 0;
              rword = lo2 & 67108863;
              ncarry = ncarry + (lo2 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y10) {
          this.x = x;
          this.y = y10;
        }
        FFTM.prototype.makeRBT = function makeRBT(N10) {
          var t8 = new Array(N10);
          var l = BN2.prototype._countBits(N10) - 1;
          for (var i10 = 0; i10 < N10; i10++) {
            t8[i10] = this.revBin(i10, l, N10);
          }
          return t8;
        };
        FFTM.prototype.revBin = function revBin(x, l, N10) {
          if (x === 0 || x === N10 - 1)
            return x;
          var rb = 0;
          for (var i10 = 0; i10 < l; i10++) {
            rb |= (x & 1) << l - i10 - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
          for (var i10 = 0; i10 < N10; i10++) {
            rtws[i10] = rws[rbt[i10]];
            itws[i10] = iws[rbt[i10]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N10);
          for (var s = 1; s < N10; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N10; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io2 = itws[p + j + s];
                var rx2 = rtwdf_ * ro - itwdf_ * io2;
                io2 = rtwdf_ * io2 + itwdf_ * ro;
                ro = rx2;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io2;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io2;
                if (j !== l) {
                  rx2 = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx2;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n8, m) {
          var N10 = Math.max(m, n8) | 1;
          var odd = N10 & 1;
          var i10 = 0;
          for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
            i10++;
          }
          return 1 << i10 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
          if (N10 <= 1)
            return;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var t8 = rws[i10];
            rws[i10] = rws[N10 - i10 - 1];
            rws[N10 - i10 - 1] = t8;
            t8 = iws[i10];
            iws[i10] = -iws[N10 - i10 - 1];
            iws[N10 - i10 - 1] = -t8;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var w10 = Math.round(ws2[2 * i10 + 1] / N10) * 8192 + Math.round(ws2[2 * i10] / N10) + carry;
            ws2[i10] = w10 & 67108863;
            if (w10 < 67108864) {
              carry = 0;
            } else {
              carry = w10 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len2, rws, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < len2; i10++) {
            carry = carry + (ws2[i10] | 0);
            rws[2 * i10] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i10 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i10 = 2 * len2; i10 < N10; ++i10) {
            rws[i10] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N10) {
          var ph2 = new Array(N10);
          for (var i10 = 0; i10 < N10; i10++) {
            ph2[i10] = 0;
          }
          return ph2;
        };
        FFTM.prototype.mulp = function mulp(x, y10, out) {
          var N10 = 2 * this.guessLen13b(x.length, y10.length);
          var rbt = this.makeRBT(N10);
          var _ = this.stub(N10);
          var rws = new Array(N10);
          var rwst = new Array(N10);
          var iwst = new Array(N10);
          var nrws = new Array(N10);
          var nrwst = new Array(N10);
          var niwst = new Array(N10);
          var rmws = out.words;
          rmws.length = N10;
          this.convert13b(x.words, x.length, rws, N10);
          this.convert13b(y10.words, y10.length, nrws, N10);
          this.transform(rws, _, rwst, iwst, N10, rbt);
          this.transform(nrws, _, nrwst, niwst, N10, rbt);
          for (var i10 = 0; i10 < N10; i10++) {
            var rx2 = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
            iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
            rwst[i10] = rx2;
          }
          this.conjugate(rwst, iwst, N10);
          this.transform(rwst, iwst, rmws, _, N10, rbt);
          this.conjugate(rmws, _, N10);
          this.normalize13b(rmws, N10);
          out.negative = x.negative ^ y10.negative;
          out.length = x.length + y10.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w10 = (this.words[i10] | 0) * num;
            var lo2 = (w10 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w10 / 67108864 | 0;
            carry += lo2 >>> 26;
            this.words[i10] = lo2 & 67108863;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w10 = toBitArray(num);
          if (w10.length === 0)
            return new BN2(1);
          var res = this;
          for (var i10 = 0; i10 < w10.length; i10++, res = res.sqr()) {
            if (w10[i10] !== 0)
              break;
          }
          if (++i10 < w10.length) {
            for (var q = res.sqr(); i10 < w10.length; i10++, q = q.sqr()) {
              if (w10[i10] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i10;
          if (r8 !== 0) {
            var carry = 0;
            for (i10 = 0; i10 < this.length; i10++) {
              var newCarry = this.words[i10] & carryMask;
              var c = (this.words[i10] | 0) - newCarry << r8;
              this.words[i10] = c | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i10] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i10 = this.length - 1; i10 >= 0; i10--) {
              this.words[i10 + s] = this.words[i10];
            }
            for (i10 = 0; i10 < s; i10++) {
              this.words[i10] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r8 = bits % 26;
          var s = Math.min((bits - r8) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i10 = 0; i10 < s; i10++) {
              maskedWords.words[i10] = this.words[i10];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i10 = 0; i10 < this.length; i10++) {
              this.words[i10] = this.words[i10 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h); i10--) {
            var word = this.words[i10] | 0;
            this.words[i10] = carry << 26 - r8 | word >>> r8;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s)
            return false;
          var w10 = this.words[s];
          return !!(w10 & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r8 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r8 !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask2;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
            this.words[i10] -= 67108864;
            if (i10 === this.length - 1) {
              this.words[i10 + 1] = 1;
            } else {
              this.words[i10 + 1]++;
            }
          }
          this.length = Math.max(this.length, i10 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
              this.words[i10] += 67108864;
              this.words[i10 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i10;
          this._expand(len2);
          var w10;
          var carry = 0;
          for (i10 = 0; i10 < num.length; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            var right = (num.words[i10] | 0) * mul;
            w10 -= right & 67108863;
            carry = (w10 >> 26) - (right / 67108864 | 0);
            this.words[i10 + shift] = w10 & 67108863;
          }
          for (; i10 < this.length - shift; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10 + shift] = w10 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            w10 = -(this.words[i10] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10] = w10 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i10 = 0; i10 < q.length; i10++) {
              q.words[i10] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj2;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm2 = this.divmod(num);
          if (dm2.mod.isZero())
            return dm2.div;
          var mod = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
          var half2 = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half2);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm2.div;
          return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            acc = (p * acc + (this.words[i10] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var w10 = (this.words[i10] | 0) + carry * 67108864;
            this.words[i10] = w10 / num | 0;
            carry = w10 % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y10 = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A10 = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y10.isEven()) {
            x.iushrn(1);
            y10.iushrn(1);
            ++g;
          }
          var yp2 = y10.clone();
          var xp2 = x.clone();
          while (!x.isZero()) {
            for (var i10 = 0, im2 = 1; (x.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              x.iushrn(i10);
              while (i10-- > 0) {
                if (A10.isOdd() || B.isOdd()) {
                  A10.iadd(yp2);
                  B.isub(xp2);
                }
                A10.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (y10.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              y10.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp2);
                  D.isub(xp2);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y10) >= 0) {
              x.isub(y10);
              A10.isub(C);
              B.isub(D);
            } else {
              y10.isub(x);
              C.isub(A10);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y10.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x12 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i10 = 0, im2 = 1; (a.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              a.iushrn(i10);
              while (i10-- > 0) {
                if (x12.isOdd()) {
                  x12.iadd(delta);
                }
                x12.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (b.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x12.isub(x22);
            } else {
              b.isub(a);
              x22.isub(x12);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x12;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r8 = a.cmp(b);
            if (r8 < 0) {
              var t8 = a;
              a = b;
              b = t8;
            } else if (r8 === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i10 = s; carry !== 0 && i10 < this.length; i10++) {
            var w10 = this.words[i10] | 0;
            w10 += carry;
            carry = w10 >>> 26;
            w10 &= 67108863;
            this.words[i10] = w10;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w10 = this.words[0] | 0;
            res = w10 === num ? 0 : w10 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var a = this.words[i10] | 0;
            var b = num.words[i10] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte2(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte2(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i10 = 0; i10 < outLen; i10++) {
            output.words[i10] = input.words[i10];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i10 = 10; i10 < input.length; i10++) {
            var next = input.words[i10] | 0;
            input.words[i10 - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i10 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo2 = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var w10 = num.words[i10] | 0;
            lo2 += w10 * 977;
            num.words[i10] = lo2 & 67108863;
            lo2 = w10 * 64 + (lo2 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var hi2 = (num.words[i10] | 0) * 19 + carry;
            var lo2 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i10] = lo2;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one2 = new BN2(1).toRed(this);
          var nOne = one2.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r8 = this.pow(a, q.addn(1).iushrn(1));
          var t8 = this.pow(a, q);
          var m = s;
          while (t8.cmp(one2) !== 0) {
            var tmp = t8;
            for (var i10 = 0; tmp.cmp(one2) !== 0; i10++) {
              tmp = tmp.redSqr();
            }
            assert(i10 < m);
            var b = this.pow(c, new BN2(1).iushln(m - i10 - 1));
            r8 = r8.redMul(b);
            c = b.redSqr();
            t8 = t8.redMul(c);
            m = i10;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i10 = 2; i10 < wnd.length; i10++) {
            wnd[i10] = this.mul(wnd[i10 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i10 = num.length - 1; i10 >= 0; i10--) {
            var word = num.words[i10];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i10 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont2(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t8 = a.imul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t8 = a.mul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn$3);
    return bn$3.exports;
  }
  var api = {};
  var encoders = {};
  var safer_1;
  var hasRequiredSafer;
  function requireSafer() {
    if (hasRequiredSafer)
      return safer_1;
    hasRequiredSafer = 1;
    var buffer2 = buffer$1;
    var Buffer2 = buffer2.Buffer;
    var safer = {};
    var key2;
    for (key2 in buffer2) {
      if (!buffer2.hasOwnProperty(key2))
        continue;
      if (key2 === "SlowBuffer" || key2 === "Buffer")
        continue;
      safer[key2] = buffer2[key2];
    }
    var Safer = safer.Buffer = {};
    for (key2 in Buffer2) {
      if (!Buffer2.hasOwnProperty(key2))
        continue;
      if (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow")
        continue;
      Safer[key2] = Buffer2[key2];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size2, fill, encoding) {
        if (typeof size2 !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size2);
        }
        if (size2 < 0 || size2 >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
        }
        var buf = Buffer2(size2);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process$1.binding("buffer").kStringMaxLength;
      } catch (e8) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    safer_1 = safer;
    return safer_1;
  }
  var reporter = {};
  var hasRequiredReporter;
  function requireReporter() {
    if (hasRequiredReporter)
      return reporter;
    hasRequiredReporter = 1;
    const inherits = requireInherits_browser();
    function Reporter(options4) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options4 || {},
        errors: []
      };
    }
    reporter.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      const state2 = this._reporterState;
      return { obj: state2.obj, pathLen: state2.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      const state2 = this._reporterState;
      state2.obj = data.obj;
      state2.path = state2.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key2) {
      return this._reporterState.path.push(key2);
    };
    Reporter.prototype.exitKey = function exitKey(index2) {
      const state2 = this._reporterState;
      state2.path = state2.path.slice(0, index2 - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index2, key2, value) {
      const state2 = this._reporterState;
      this.exitKey(index2);
      if (state2.obj !== null)
        state2.obj[key2] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      const state2 = this._reporterState;
      const prev = state2.obj;
      state2.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      const state2 = this._reporterState;
      const now2 = state2.obj;
      state2.obj = prev;
      return now2;
    };
    Reporter.prototype.error = function error(msg) {
      let err;
      const state2 = this._reporterState;
      const inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state2.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state2.options.partial)
        throw err;
      if (!inherited)
        state2.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      const state2 = this._reporterState;
      if (!state2.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state2.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e8) {
          this.stack = e8.stack;
        }
      }
      return this;
    };
    return reporter;
  }
  var buffer = {};
  var hasRequiredBuffer;
  function requireBuffer() {
    if (hasRequiredBuffer)
      return buffer;
    hasRequiredBuffer = 1;
    const inherits = requireInherits_browser();
    const Reporter = requireReporter().Reporter;
    const Buffer2 = requireSafer().Buffer;
    function DecoderBuffer(base2, options4) {
      Reporter.call(this, options4);
      if (!Buffer2.isBuffer(base2)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base2;
      this.offset = 0;
      this.length = base2.length;
    }
    inherits(DecoderBuffer, Reporter);
    buffer.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
      if (data instanceof DecoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && Buffer2.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
      return isCompatible;
    };
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      const res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip2(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      const res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter2) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!EncoderBuffer.isEncoderBuffer(item))
            item = new EncoderBuffer(item, reporter2);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter2.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer2.byteLength(value);
      } else if (Buffer2.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter2.error("Unsupported type: " + typeof value);
      }
    }
    buffer.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
      if (data instanceof EncoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
      return isCompatible;
    };
    EncoderBuffer.prototype.join = function join3(out, offset) {
      if (!out)
        out = Buffer2.alloc(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer2.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
    return buffer;
  }
  var node;
  var hasRequiredNode;
  function requireNode() {
    if (hasRequiredNode)
      return node;
    hasRequiredNode = 1;
    const Reporter = requireReporter().Reporter;
    const EncoderBuffer = requireBuffer().EncoderBuffer;
    const DecoderBuffer = requireBuffer().DecoderBuffer;
    const assert = requireMinimalisticAssert();
    const tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    const methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    const overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent, name2) {
      const state2 = {};
      this._baseState = state2;
      state2.name = name2;
      state2.enc = enc;
      state2.parent = parent || null;
      state2.children = null;
      state2.tag = null;
      state2.args = null;
      state2.reverseArgs = null;
      state2.choice = null;
      state2.optional = false;
      state2.any = false;
      state2.obj = false;
      state2.use = null;
      state2.useDecoder = null;
      state2.key = null;
      state2["default"] = null;
      state2.explicit = null;
      state2.implicit = null;
      state2.contains = null;
      if (!state2.parent) {
        state2.children = [];
        this._wrap();
      }
    }
    node = Node;
    const stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      const state2 = this._baseState;
      const cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state2[prop];
      });
      const res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      const state2 = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          const clone = new this.constructor(this);
          state2.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init4(body4) {
      const state2 = this._baseState;
      assert(state2.parent === null);
      body4.call(this);
      state2.children = state2.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert.equal(state2.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      const state2 = this._baseState;
      const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert(state2.children === null);
        state2.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state2.args === null);
        state2.args = args;
        state2.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          const res = {};
          Object.keys(arg).forEach(function(key2) {
            if (key2 == (key2 | 0))
              key2 |= 0;
            const value = arg[key2];
            res[value] = key2;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        const state2 = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state2.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        const state2 = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state2.tag === null);
        state2.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      const state2 = this._baseState;
      assert(state2.use === null);
      state2.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      const state2 = this._baseState;
      state2.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      const state2 = this._baseState;
      assert(state2["default"] === null);
      state2["default"] = val;
      state2.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      const state2 = this._baseState;
      assert(state2.explicit === null && state2.implicit === null);
      state2.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      const state2 = this._baseState;
      assert(state2.explicit === null && state2.implicit === null);
      state2.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      const state2 = this._baseState;
      const args = Array.prototype.slice.call(arguments);
      state2.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key2(newKey) {
      const state2 = this._baseState;
      assert(state2.key === null);
      state2.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      const state2 = this._baseState;
      state2.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      const state2 = this._baseState;
      assert(state2.choice === null);
      state2.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key2) {
        return obj[key2];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      const state2 = this._baseState;
      assert(state2.use === null);
      state2.contains = item;
      return this;
    };
    Node.prototype._decode = function decode2(input, options4) {
      const state2 = this._baseState;
      if (state2.parent === null)
        return input.wrapResult(state2.children[0]._decode(input, options4));
      let result = state2["default"];
      let present = true;
      let prevKey = null;
      if (state2.key !== null)
        prevKey = input.enterKey(state2.key);
      if (state2.optional) {
        let tag = null;
        if (state2.explicit !== null)
          tag = state2.explicit;
        else if (state2.implicit !== null)
          tag = state2.implicit;
        else if (state2.tag !== null)
          tag = state2.tag;
        if (tag === null && !state2.any) {
          const save = input.save();
          try {
            if (state2.choice === null)
              this._decodeGeneric(state2.tag, input, options4);
            else
              this._decodeChoice(input, options4);
            present = true;
          } catch (e8) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state2.any);
          if (input.isError(present))
            return present;
        }
      }
      let prevObj;
      if (state2.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state2.explicit !== null) {
          const explicit = this._decodeTag(input, state2.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        const start = input.offset;
        if (state2.use === null && state2.choice === null) {
          let save;
          if (state2.any)
            save = input.save();
          const body4 = this._decodeTag(
            input,
            state2.implicit !== null ? state2.implicit : state2.tag,
            state2.any
          );
          if (input.isError(body4))
            return body4;
          if (state2.any)
            result = input.raw(save);
          else
            input = body4;
        }
        if (options4 && options4.track && state2.tag !== null)
          options4.track(input.path(), start, input.length, "tagged");
        if (options4 && options4.track && state2.tag !== null)
          options4.track(input.path(), input.offset, input.length, "content");
        if (state2.any)
          ;
        else if (state2.choice === null) {
          result = this._decodeGeneric(state2.tag, input, options4);
        } else {
          result = this._decodeChoice(input, options4);
        }
        if (input.isError(result))
          return result;
        if (!state2.any && state2.choice === null && state2.children !== null) {
          state2.children.forEach(function decodeChildren(child) {
            child._decode(input, options4);
          });
        }
        if (state2.contains && (state2.tag === "octstr" || state2.tag === "bitstr")) {
          const data = new DecoderBuffer(result);
          result = this._getUse(state2.contains, input._reporterState.obj)._decode(data, options4);
        }
      }
      if (state2.obj && present)
        result = input.leaveObject(prevObj);
      if (state2.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state2.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options4) {
      const state2 = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state2.args[0], options4);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options4);
      else if (tag === "objid" && state2.args)
        return this._decodeObjid(input, state2.args[0], state2.args[1], options4);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options4);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options4);
      else if (tag === "null_")
        return this._decodeNull(input, options4);
      else if (tag === "bool")
        return this._decodeBool(input, options4);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options4);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state2.args && state2.args[0], options4);
      if (state2.use !== null) {
        return this._getUse(state2.use, input._reporterState.obj)._decode(input, options4);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      const state2 = this._baseState;
      state2.useDecoder = this._use(entity, obj);
      assert(state2.useDecoder._baseState.parent === null);
      state2.useDecoder = state2.useDecoder._baseState.children[0];
      if (state2.implicit !== state2.useDecoder._baseState.implicit) {
        state2.useDecoder = state2.useDecoder.clone();
        state2.useDecoder._baseState.implicit = state2.implicit;
      }
      return state2.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options4) {
      const state2 = this._baseState;
      let result = null;
      let match2 = false;
      Object.keys(state2.choice).some(function(key2) {
        const save = input.save();
        const node2 = state2.choice[key2];
        try {
          const value = node2._decode(input, options4);
          if (input.isError(value))
            return false;
          result = { type: key2, value };
          match2 = true;
        } catch (e8) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match2)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter2, parent) {
      const state2 = this._baseState;
      if (state2["default"] !== null && state2["default"] === data)
        return;
      const result = this._encodeValue(data, reporter2, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter2, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter2, parent) {
      const state2 = this._baseState;
      if (state2.parent === null)
        return state2.children[0]._encode(data, reporter2 || new Reporter());
      let result = null;
      this.reporter = reporter2;
      if (state2.optional && data === void 0) {
        if (state2["default"] !== null)
          data = state2["default"];
        else
          return;
      }
      let content = null;
      let primitive = false;
      if (state2.any) {
        result = this._createEncoderBuffer(data);
      } else if (state2.choice) {
        result = this._encodeChoice(data, reporter2);
      } else if (state2.contains) {
        content = this._getUse(state2.contains, parent)._encode(data, reporter2);
        primitive = true;
      } else if (state2.children) {
        content = state2.children.map(function(child) {
          if (child._baseState.tag === "null_")
            return child._encode(null, reporter2, data);
          if (child._baseState.key === null)
            return reporter2.error("Child should have a key");
          const prevKey = reporter2.enterKey(child._baseState.key);
          if (typeof data !== "object")
            return reporter2.error("Child expected, but input is not object");
          const res = child._encode(data[child._baseState.key], reporter2, data);
          reporter2.leaveKey(prevKey);
          return res;
        }, this).filter(function(child) {
          return child;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state2.tag === "seqof" || state2.tag === "setof") {
          if (!(state2.args && state2.args.length === 1))
            return reporter2.error("Too many args for : " + state2.tag);
          if (!Array.isArray(data))
            return reporter2.error("seqof/setof, but data is not Array");
          const child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            const state3 = this._baseState;
            return this._getUse(state3.args[0], data)._encode(item, reporter2);
          }, child));
        } else if (state2.use !== null) {
          result = this._getUse(state2.use, parent)._encode(data, reporter2);
        } else {
          content = this._encodePrimitive(state2.tag, data);
          primitive = true;
        }
      }
      if (!state2.any && state2.choice === null) {
        const tag = state2.implicit !== null ? state2.implicit : state2.tag;
        const cls = state2.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state2.use === null)
            reporter2.error("Tag could be omitted only for .use()");
        } else {
          if (state2.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state2.explicit !== null)
        result = this._encodeComposite(state2.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter2) {
      const state2 = this._baseState;
      const node2 = state2.choice[data.type];
      if (!node2) {
        assert(
          false,
          data.type + " not found in " + JSON.stringify(Object.keys(state2.choice))
        );
      }
      return node2._encode(data.value, reporter2);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      const state2 = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state2.args)
        return this._encodeObjid(data, state2.reverseArgs[0], state2.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state2.args && state2.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
    };
    return node;
  }
  var der = {};
  var hasRequiredDer$2;
  function requireDer$2() {
    if (hasRequiredDer$2)
      return der;
    hasRequiredDer$2 = 1;
    (function(exports2) {
      function reverse(map) {
        const res = {};
        Object.keys(map).forEach(function(key2) {
          if ((key2 | 0) == key2)
            key2 = key2 | 0;
          const value = map[key2];
          res[value] = key2;
        });
        return res;
      }
      exports2.tagClass = {
        0: "universal",
        1: "application",
        2: "context",
        3: "private"
      };
      exports2.tagClassByName = reverse(exports2.tagClass);
      exports2.tag = {
        0: "end",
        1: "bool",
        2: "int",
        3: "bitstr",
        4: "octstr",
        5: "null_",
        6: "objid",
        7: "objDesc",
        8: "external",
        9: "real",
        10: "enum",
        11: "embed",
        12: "utf8str",
        13: "relativeOid",
        16: "seq",
        17: "set",
        18: "numstr",
        19: "printstr",
        20: "t61str",
        21: "videostr",
        22: "ia5str",
        23: "utctime",
        24: "gentime",
        25: "graphstr",
        26: "iso646str",
        27: "genstr",
        28: "unistr",
        29: "charstr",
        30: "bmpstr"
      };
      exports2.tagByName = reverse(exports2.tag);
    })(der);
    return der;
  }
  var der_1$1;
  var hasRequiredDer$1;
  function requireDer$1() {
    if (hasRequiredDer$1)
      return der_1$1;
    hasRequiredDer$1 = 1;
    const inherits = requireInherits_browser();
    const Buffer2 = requireSafer().Buffer;
    const Node = requireNode();
    const der2 = requireDer$2();
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    der_1$1 = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter2) {
      return this.tree._encode(data, reporter2).join();
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        const header2 = Buffer2.alloc(2);
        header2[0] = encodedTag;
        header2[1] = content.length;
        return this._createEncoderBuffer([header2, content]);
      }
      let lenOctets = 1;
      for (let i10 = content.length; i10 >= 256; i10 >>= 8)
        lenOctets++;
      const header = Buffer2.alloc(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (let i10 = 1 + lenOctets, j = content.length; j > 0; i10--, j >>= 8)
        header[i10] = j & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        const buf = Buffer2.alloc(str.length * 2);
        for (let i10 = 0; i10 < str.length; i10++) {
          buf.writeUInt16BE(str.charCodeAt(i10), i10 * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id2, values, relative2) {
      if (typeof id2 === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id2))
          return this.reporter.error("objid not found in values map");
        id2 = values[id2].split(/[\s.]+/g);
        for (let i10 = 0; i10 < id2.length; i10++)
          id2[i10] |= 0;
      } else if (Array.isArray(id2)) {
        id2 = id2.slice();
        for (let i10 = 0; i10 < id2.length; i10++)
          id2[i10] |= 0;
      }
      if (!Array.isArray(id2)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id2));
      }
      if (!relative2) {
        if (id2[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id2.splice(0, 2, id2[0] * 40 + id2[1]);
      }
      let size2 = 0;
      for (let i10 = 0; i10 < id2.length; i10++) {
        let ident = id2[i10];
        for (size2++; ident >= 128; ident >>= 7)
          size2++;
      }
      const objid = Buffer2.alloc(size2);
      let offset = objid.length - 1;
      for (let i10 = id2.length - 1; i10 >= 0; i10--) {
        let ident = id2[i10];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      let str;
      const date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getUTCFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getUTCFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = Buffer2.from(numArray);
      }
      if (Buffer2.isBuffer(num)) {
        let size3 = num.length;
        if (num.length === 0)
          size3++;
        const out2 = Buffer2.alloc(size3);
        num.copy(out2);
        if (num.length === 0)
          out2[0] = 0;
        return this._createEncoderBuffer(out2);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      let size2 = 1;
      for (let i10 = num; i10 >= 256; i10 >>= 8)
        size2++;
      const out = new Array(size2);
      for (let i10 = out.length - 1; i10 >= 0; i10--) {
        out[i10] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(Buffer2.from(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter2, parent) {
      const state2 = this._baseState;
      let i10;
      if (state2["default"] === null)
        return false;
      const data = dataBuffer.join();
      if (state2.defaultBuffer === void 0)
        state2.defaultBuffer = this._encodeValue(state2["default"], reporter2, parent).join();
      if (data.length !== state2.defaultBuffer.length)
        return false;
      for (i10 = 0; i10 < data.length; i10++)
        if (data[i10] !== state2.defaultBuffer[i10])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter2) {
      let res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der2.tagByName.hasOwnProperty(tag))
        res = der2.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter2.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter2.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der2.tagClassByName[cls || "universal"] << 6;
      return res;
    }
    return der_1$1;
  }
  var pem$1;
  var hasRequiredPem$1;
  function requirePem$1() {
    if (hasRequiredPem$1)
      return pem$1;
    hasRequiredPem$1 = 1;
    const inherits = requireInherits_browser();
    const DEREncoder = requireDer$1();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    pem$1 = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options4) {
      const buf = DEREncoder.prototype.encode.call(this, data);
      const p = buf.toString("base64");
      const out = ["-----BEGIN " + options4.label + "-----"];
      for (let i10 = 0; i10 < p.length; i10 += 64)
        out.push(p.slice(i10, i10 + 64));
      out.push("-----END " + options4.label + "-----");
      return out.join("\n");
    };
    return pem$1;
  }
  var hasRequiredEncoders;
  function requireEncoders() {
    if (hasRequiredEncoders)
      return encoders;
    hasRequiredEncoders = 1;
    (function(exports2) {
      const encoders2 = exports2;
      encoders2.der = requireDer$1();
      encoders2.pem = requirePem$1();
    })(encoders);
    return encoders;
  }
  var decoders = {};
  var der_1;
  var hasRequiredDer;
  function requireDer() {
    if (hasRequiredDer)
      return der_1;
    hasRequiredDer = 1;
    const inherits = requireInherits_browser();
    const bignum = requireBn$2();
    const DecoderBuffer = requireBuffer().DecoderBuffer;
    const Node = requireNode();
    const der2 = requireDer$2();
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    der_1 = DERDecoder;
    DERDecoder.prototype.decode = function decode2(data, options4) {
      if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options4);
      }
      return this.tree._decode(data, options4);
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._peekTag = function peekTag(buffer2, tag, any) {
      if (buffer2.isEmpty())
        return false;
      const state2 = buffer2.save();
      const decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
      if (buffer2.isError(decodedTag))
        return decodedTag;
      buffer2.restore(state2);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any) {
      const decodedTag = derDecodeTag(
        buffer2,
        'Failed to decode tag of "' + tag + '"'
      );
      if (buffer2.isError(decodedTag))
        return decodedTag;
      let len2 = derDecodeLen(
        buffer2,
        decodedTag.primitive,
        'Failed to get length of "' + tag + '"'
      );
      if (buffer2.isError(len2))
        return len2;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer2.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len2 !== null)
        return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
      const state2 = buffer2.save();
      const res = this._skipUntilEnd(
        buffer2,
        'Failed to skip indefinite length body: "' + this.tag + '"'
      );
      if (buffer2.isError(res))
        return res;
      len2 = buffer2.offset - state2.offset;
      buffer2.restore(state2);
      return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail) {
      for (; ; ) {
        const tag = derDecodeTag(buffer2, fail);
        if (buffer2.isError(tag))
          return tag;
        const len2 = derDecodeLen(buffer2, tag.primitive, fail);
        if (buffer2.isError(len2))
          return len2;
        let res;
        if (tag.primitive || len2 !== null)
          res = buffer2.skip(len2);
        else
          res = this._skipUntilEnd(buffer2, fail);
        if (buffer2.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options4) {
      const result = [];
      while (!buffer2.isEmpty()) {
        const possibleEnd = this._peekTag(buffer2, "end");
        if (buffer2.isError(possibleEnd))
          return possibleEnd;
        const res = decoder.decode(buffer2, "der", options4);
        if (buffer2.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
      if (tag === "bitstr") {
        const unused = buffer2.readUInt8();
        if (buffer2.isError(unused))
          return unused;
        return { unused, data: buffer2.raw() };
      } else if (tag === "bmpstr") {
        const raw = buffer2.raw();
        if (raw.length % 2 === 1)
          return buffer2.error("Decoding of string type: bmpstr length mismatch");
        let str = "";
        for (let i10 = 0; i10 < raw.length / 2; i10++) {
          str += String.fromCharCode(raw.readUInt16BE(i10 * 2));
        }
        return str;
      } else if (tag === "numstr") {
        const numstr = buffer2.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer2.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer2.raw();
      } else if (tag === "objDesc") {
        return buffer2.raw();
      } else if (tag === "printstr") {
        const printstr = buffer2.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer2.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer2.raw().toString();
      } else {
        return buffer2.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values, relative2) {
      let result;
      const identifiers = [];
      let ident = 0;
      let subident = 0;
      while (!buffer2.isEmpty()) {
        subident = buffer2.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      const first = identifiers[0] / 40 | 0;
      const second = identifiers[0] % 40;
      if (relative2)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
      const str = buffer2.raw().toString();
      let year;
      let mon;
      let day;
      let hour;
      let min;
      let sec;
      if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer2.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull() {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer2) {
      const res = buffer2.readUInt8();
      if (buffer2.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer2, values) {
      const raw = buffer2.raw();
      let res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      let tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      const cls = der2.tagClass[tag >> 6];
      const primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        let oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail);
          if (buf.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      const tagStr = der2.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf, primitive, fail) {
      let len2 = buf.readUInt8(fail);
      if (buf.isError(len2))
        return len2;
      if (!primitive && len2 === 128)
        return null;
      if ((len2 & 128) === 0) {
        return len2;
      }
      const num = len2 & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len2 = 0;
      for (let i10 = 0; i10 < num; i10++) {
        len2 <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j))
          return j;
        len2 |= j;
      }
      return len2;
    }
    return der_1;
  }
  var pem;
  var hasRequiredPem;
  function requirePem() {
    if (hasRequiredPem)
      return pem;
    hasRequiredPem = 1;
    const inherits = requireInherits_browser();
    const Buffer2 = requireSafer().Buffer;
    const DERDecoder = requireDer();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    pem = PEMDecoder;
    PEMDecoder.prototype.decode = function decode2(data, options4) {
      const lines2 = data.toString().split(/[\r\n]+/g);
      const label = options4.label.toUpperCase();
      const re = /^-----(BEGIN|END) ([^-]+)-----$/;
      let start = -1;
      let end = -1;
      for (let i10 = 0; i10 < lines2.length; i10++) {
        const match2 = lines2[i10].match(re);
        if (match2 === null)
          continue;
        if (match2[2] !== label)
          continue;
        if (start === -1) {
          if (match2[1] !== "BEGIN")
            break;
          start = i10;
        } else {
          if (match2[1] !== "END")
            break;
          end = i10;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      const base64 = lines2.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9+/=]+/gi, "");
      const input = Buffer2.from(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options4);
    };
    return pem;
  }
  var hasRequiredDecoders;
  function requireDecoders() {
    if (hasRequiredDecoders)
      return decoders;
    hasRequiredDecoders = 1;
    (function(exports2) {
      const decoders2 = exports2;
      decoders2.der = requireDer();
      decoders2.pem = requirePem();
    })(decoders);
    return decoders;
  }
  var hasRequiredApi;
  function requireApi() {
    if (hasRequiredApi)
      return api;
    hasRequiredApi = 1;
    (function(exports2) {
      const encoders2 = requireEncoders();
      const decoders2 = requireDecoders();
      const inherits = requireInherits_browser();
      const api2 = exports2;
      api2.define = function define2(name2, body4) {
        return new Entity(name2, body4);
      };
      function Entity(name2, body4) {
        this.name = name2;
        this.body = body4;
        this.decoders = {};
        this.encoders = {};
      }
      Entity.prototype._createNamed = function createNamed(Base) {
        const name2 = this.name;
        function Generated(entity) {
          this._initNamed(entity, name2);
        }
        inherits(Generated, Base);
        Generated.prototype._initNamed = function _initNamed(entity, name3) {
          Base.call(this, entity, name3);
        };
        return new Generated(this);
      };
      Entity.prototype._getDecoder = function _getDecoder(enc) {
        enc = enc || "der";
        if (!this.decoders.hasOwnProperty(enc))
          this.decoders[enc] = this._createNamed(decoders2[enc]);
        return this.decoders[enc];
      };
      Entity.prototype.decode = function decode2(data, enc, options4) {
        return this._getDecoder(enc).decode(data, options4);
      };
      Entity.prototype._getEncoder = function _getEncoder(enc) {
        enc = enc || "der";
        if (!this.encoders.hasOwnProperty(enc))
          this.encoders[enc] = this._createNamed(encoders2[enc]);
        return this.encoders[enc];
      };
      Entity.prototype.encode = function encode(data, enc, reporter2) {
        return this._getEncoder(enc).encode(data, reporter2);
      };
    })(api);
    return api;
  }
  var base = {};
  var hasRequiredBase;
  function requireBase() {
    if (hasRequiredBase)
      return base;
    hasRequiredBase = 1;
    (function(exports2) {
      const base2 = exports2;
      base2.Reporter = requireReporter().Reporter;
      base2.DecoderBuffer = requireBuffer().DecoderBuffer;
      base2.EncoderBuffer = requireBuffer().EncoderBuffer;
      base2.Node = requireNode();
    })(base);
    return base;
  }
  var constants$1 = {};
  var hasRequiredConstants;
  function requireConstants() {
    if (hasRequiredConstants)
      return constants$1;
    hasRequiredConstants = 1;
    (function(exports2) {
      const constants2 = exports2;
      constants2._reverse = function reverse(map) {
        const res = {};
        Object.keys(map).forEach(function(key2) {
          if ((key2 | 0) == key2)
            key2 = key2 | 0;
          const value = map[key2];
          res[value] = key2;
        });
        return res;
      };
      constants2.der = requireDer$2();
    })(constants$1);
    return constants$1;
  }
  var hasRequiredAsn1$1;
  function requireAsn1$1() {
    if (hasRequiredAsn1$1)
      return asn1;
    hasRequiredAsn1$1 = 1;
    (function(exports2) {
      const asn12 = exports2;
      asn12.bignum = requireBn$2();
      asn12.define = requireApi().define;
      asn12.base = requireBase();
      asn12.constants = requireConstants();
      asn12.decoders = requireDecoders();
      asn12.encoders = requireEncoders();
    })(asn1);
    return asn1;
  }
  var certificate;
  var hasRequiredCertificate;
  function requireCertificate() {
    if (hasRequiredCertificate)
      return certificate;
    hasRequiredCertificate = 1;
    var asn = requireAsn1$1();
    var Time = asn.define("Time", function() {
      this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
      });
    });
    var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
      this.seq().obj(
        this.key("type").objid(),
        this.key("value").any()
      );
    });
    var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("parameters").optional(),
        this.key("curve").objid().optional()
      );
    });
    var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
      this.setof(AttributeTypeValue);
    });
    var RDNSequence = asn.define("RDNSequence", function() {
      this.seqof(RelativeDistinguishedName);
    });
    var Name = asn.define("Name", function() {
      this.choice({
        rdnSequence: this.use(RDNSequence)
      });
    });
    var Validity = asn.define("Validity", function() {
      this.seq().obj(
        this.key("notBefore").use(Time),
        this.key("notAfter").use(Time)
      );
    });
    var Extension = asn.define("Extension", function() {
      this.seq().obj(
        this.key("extnID").objid(),
        this.key("critical").bool().def(false),
        this.key("extnValue").octstr()
      );
    });
    var TBSCertificate = asn.define("TBSCertificate", function() {
      this.seq().obj(
        this.key("version").explicit(0).int().optional(),
        this.key("serialNumber").int(),
        this.key("signature").use(AlgorithmIdentifier),
        this.key("issuer").use(Name),
        this.key("validity").use(Validity),
        this.key("subject").use(Name),
        this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
        this.key("issuerUniqueID").implicit(1).bitstr().optional(),
        this.key("subjectUniqueID").implicit(2).bitstr().optional(),
        this.key("extensions").explicit(3).seqof(Extension).optional()
      );
    });
    var X509Certificate = asn.define("X509Certificate", function() {
      this.seq().obj(
        this.key("tbsCertificate").use(TBSCertificate),
        this.key("signatureAlgorithm").use(AlgorithmIdentifier),
        this.key("signatureValue").bitstr()
      );
    });
    certificate = X509Certificate;
    return certificate;
  }
  var hasRequiredAsn1;
  function requireAsn1() {
    if (hasRequiredAsn1)
      return asn1$1;
    hasRequiredAsn1 = 1;
    var asn12 = requireAsn1$1();
    asn1$1.certificate = requireCertificate();
    var RSAPrivateKey = asn12.define("RSAPrivateKey", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("modulus").int(),
        this.key("publicExponent").int(),
        this.key("privateExponent").int(),
        this.key("prime1").int(),
        this.key("prime2").int(),
        this.key("exponent1").int(),
        this.key("exponent2").int(),
        this.key("coefficient").int()
      );
    });
    asn1$1.RSAPrivateKey = RSAPrivateKey;
    var RSAPublicKey = asn12.define("RSAPublicKey", function() {
      this.seq().obj(
        this.key("modulus").int(),
        this.key("publicExponent").int()
      );
    });
    asn1$1.RSAPublicKey = RSAPublicKey;
    var PublicKey = asn12.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    asn1$1.PublicKey = PublicKey;
    var AlgorithmIdentifier = asn12.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("none").null_().optional(),
        this.key("curve").objid().optional(),
        this.key("params").seq().obj(
          this.key("p").int(),
          this.key("q").int(),
          this.key("g").int()
        ).optional()
      );
    });
    var PrivateKeyInfo = asn12.define("PrivateKeyInfo", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPrivateKey").octstr()
      );
    });
    asn1$1.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn12.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").seq().obj(
          this.key("id").objid(),
          this.key("decrypt").seq().obj(
            this.key("kde").seq().obj(
              this.key("id").objid(),
              this.key("kdeparams").seq().obj(
                this.key("salt").octstr(),
                this.key("iters").int()
              )
            ),
            this.key("cipher").seq().obj(
              this.key("algo").objid(),
              this.key("iv").octstr()
            )
          )
        ),
        this.key("subjectPrivateKey").octstr()
      );
    });
    asn1$1.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPrivateKey = asn12.define("DSAPrivateKey", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int(),
        this.key("pub_key").int(),
        this.key("priv_key").int()
      );
    });
    asn1$1.DSAPrivateKey = DSAPrivateKey;
    asn1$1.DSAparam = asn12.define("DSAparam", function() {
      this.int();
    });
    var ECPrivateKey = asn12.define("ECPrivateKey", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("privateKey").octstr(),
        this.key("parameters").optional().explicit(0).use(ECParameters),
        this.key("publicKey").optional().explicit(1).bitstr()
      );
    });
    asn1$1.ECPrivateKey = ECPrivateKey;
    var ECParameters = asn12.define("ECParameters", function() {
      this.choice({
        namedCurve: this.objid()
      });
    });
    asn1$1.signature = asn12.define("signature", function() {
      this.seq().obj(
        this.key("r").int(),
        this.key("s").int()
      );
    });
    return asn1$1;
  }
  const require$$1 = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
  };
  var fixProc;
  var hasRequiredFixProc;
  function requireFixProc() {
    if (hasRequiredFixProc)
      return fixProc;
    hasRequiredFixProc = 1;
    var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
    var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
    var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
    var evp = requireEvp_bytestokey();
    var ciphers = requireBrowser$6();
    var Buffer2 = requireSafeBuffer().Buffer;
    fixProc = function(okey, password) {
      var key2 = okey.toString();
      var match2 = key2.match(findProc);
      var decrypted;
      if (!match2) {
        var match22 = key2.match(fullRegex);
        decrypted = Buffer2.from(match22[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var suite = "aes" + match2[1];
        var iv2 = Buffer2.from(match2[2], "hex");
        var cipherText = Buffer2.from(match2[3].replace(/[\r\n]/g, ""), "base64");
        var cipherKey = evp(password, iv2.slice(0, 8), parseInt(match2[1], 10)).key;
        var out = [];
        var cipher2 = ciphers.createDecipheriv(suite, cipherKey, iv2);
        out.push(cipher2.update(cipherText));
        out.push(cipher2.final());
        decrypted = Buffer2.concat(out);
      }
      var tag = key2.match(startRegex)[1];
      return {
        tag,
        data: decrypted
      };
    };
    return fixProc;
  }
  var parseAsn1;
  var hasRequiredParseAsn1;
  function requireParseAsn1() {
    if (hasRequiredParseAsn1)
      return parseAsn1;
    hasRequiredParseAsn1 = 1;
    var asn12 = requireAsn1();
    var aesid = require$$1;
    var fixProc2 = requireFixProc();
    var ciphers = requireBrowser$6();
    var compat = requireBrowser$7();
    var Buffer2 = requireSafeBuffer().Buffer;
    parseAsn1 = parseKeys;
    function parseKeys(buffer2) {
      var password;
      if (typeof buffer2 === "object" && !Buffer2.isBuffer(buffer2)) {
        password = buffer2.passphrase;
        buffer2 = buffer2.key;
      }
      if (typeof buffer2 === "string") {
        buffer2 = Buffer2.from(buffer2);
      }
      var stripped = fixProc2(buffer2, password);
      var type = stripped.tag;
      var data = stripped.data;
      var subtype, ndata;
      switch (type) {
        case "CERTIFICATE":
          ndata = asn12.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          if (!ndata) {
            ndata = asn12.PublicKey.decode(data, "der");
          }
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn12.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: "ec",
                data: ndata
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.pub_key = asn12.DSAparam.decode(ndata.subjectPublicKey.data, "der");
              return {
                type: "dsa",
                data: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "ENCRYPTED PRIVATE KEY":
          data = asn12.EncryptedPrivateKey.decode(data, "der");
          data = decrypt(data, password);
        case "PRIVATE KEY":
          ndata = asn12.PrivateKey.decode(data, "der");
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn12.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn12.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.priv_key = asn12.DSAparam.decode(ndata.subjectPrivateKey, "der");
              return {
                type: "dsa",
                params: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "RSA PUBLIC KEY":
          return asn12.RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
          return asn12.RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
          return {
            type: "dsa",
            params: asn12.DSAPrivateKey.decode(data, "der")
          };
        case "EC PRIVATE KEY":
          data = asn12.ECPrivateKey.decode(data, "der");
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          };
        default:
          throw new Error("unknown key type " + type);
      }
    }
    parseKeys.signature = asn12.signature;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt;
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
      var iv2 = data.algorithm.decrypt.cipher.iv;
      var cipherText = data.subjectPrivateKey;
      var keylen = parseInt(algo.split("-")[1], 10) / 8;
      var key2 = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
      var cipher2 = ciphers.createDecipheriv(algo, key2, iv2);
      var out = [];
      out.push(cipher2.update(cipherText));
      out.push(cipher2.final());
      return Buffer2.concat(out);
    }
    return parseAsn1;
  }
  const require$$4 = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
  };
  var hasRequiredSign;
  function requireSign() {
    if (hasRequiredSign)
      return sign.exports;
    hasRequiredSign = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var createHmac = requireBrowser$8();
    var crt = requireBrowserifyRsa();
    var EC = requireElliptic().ec;
    var BN2 = requireBn$4();
    var parseKeys = requireParseAsn1();
    var curves2 = require$$4;
    function sign$1(hash2, key2, hashType, signType, tag) {
      var priv = parseKeys(key2);
      if (priv.curve) {
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return ecSign(hash2, priv);
      } else if (priv.type === "dsa") {
        if (signType !== "dsa")
          throw new Error("wrong private key type");
        return dsaSign(hash2, priv, hashType);
      } else {
        if (signType !== "rsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong private key type");
      }
      hash2 = Buffer2.concat([tag, hash2]);
      var len2 = priv.modulus.byteLength();
      var pad = [0, 1];
      while (hash2.length + pad.length + 1 < len2)
        pad.push(255);
      pad.push(0);
      var i10 = -1;
      while (++i10 < hash2.length)
        pad.push(hash2[i10]);
      var out = crt(pad, priv);
      return out;
    }
    function ecSign(hash2, priv) {
      var curveId = curves2[priv.curve.join(".")];
      if (!curveId)
        throw new Error("unknown curve " + priv.curve.join("."));
      var curve2 = new EC(curveId);
      var key2 = curve2.keyFromPrivate(priv.privateKey);
      var out = key2.sign(hash2);
      return Buffer2.from(out.toDER());
    }
    function dsaSign(hash2, priv, algo) {
      var x = priv.params.priv_key;
      var p = priv.params.p;
      var q = priv.params.q;
      var g = priv.params.g;
      var r8 = new BN2(0);
      var k;
      var H2 = bits2int(hash2, q).mod(q);
      var s = false;
      var kv2 = getKey(x, q, hash2, algo);
      while (s === false) {
        k = makeKey(q, kv2, algo);
        r8 = makeR(g, k, p, q);
        s = k.invm(q).imul(H2.add(x.mul(r8))).mod(q);
        if (s.cmpn(0) === 0) {
          s = false;
          r8 = new BN2(0);
        }
      }
      return toDER(r8, s);
    }
    function toDER(r8, s) {
      r8 = r8.toArray();
      s = s.toArray();
      if (r8[0] & 128)
        r8 = [0].concat(r8);
      if (s[0] & 128)
        s = [0].concat(s);
      var total = r8.length + s.length + 4;
      var res = [48, total, 2, r8.length];
      res = res.concat(r8, [2, s.length], s);
      return Buffer2.from(res);
    }
    function getKey(x, q, hash2, algo) {
      x = Buffer2.from(x.toArray());
      if (x.length < q.byteLength()) {
        var zeros = Buffer2.alloc(q.byteLength() - x.length);
        x = Buffer2.concat([zeros, x]);
      }
      var hlen = hash2.length;
      var hbits = bits2octets(hash2, q);
      var v10 = Buffer2.alloc(hlen);
      v10.fill(1);
      var k = Buffer2.alloc(hlen);
      k = createHmac(algo, k).update(v10).update(Buffer2.from([0])).update(x).update(hbits).digest();
      v10 = createHmac(algo, k).update(v10).digest();
      k = createHmac(algo, k).update(v10).update(Buffer2.from([1])).update(x).update(hbits).digest();
      v10 = createHmac(algo, k).update(v10).digest();
      return { k, v: v10 };
    }
    function bits2int(obits, q) {
      var bits = new BN2(obits);
      var shift = (obits.length << 3) - q.bitLength();
      if (shift > 0)
        bits.ishrn(shift);
      return bits;
    }
    function bits2octets(bits, q) {
      bits = bits2int(bits, q);
      bits = bits.mod(q);
      var out = Buffer2.from(bits.toArray());
      if (out.length < q.byteLength()) {
        var zeros = Buffer2.alloc(q.byteLength() - out.length);
        out = Buffer2.concat([zeros, out]);
      }
      return out;
    }
    function makeKey(q, kv2, algo) {
      var t8;
      var k;
      do {
        t8 = Buffer2.alloc(0);
        while (t8.length * 8 < q.bitLength()) {
          kv2.v = createHmac(algo, kv2.k).update(kv2.v).digest();
          t8 = Buffer2.concat([t8, kv2.v]);
        }
        k = bits2int(t8, q);
        kv2.k = createHmac(algo, kv2.k).update(kv2.v).update(Buffer2.from([0])).digest();
        kv2.v = createHmac(algo, kv2.k).update(kv2.v).digest();
      } while (k.cmp(q) !== -1);
      return k;
    }
    function makeR(g, k, p, q) {
      return g.toRed(BN2.mont(p)).redPow(k).fromRed().mod(q);
    }
    sign.exports = sign$1;
    sign.exports.getKey = getKey;
    sign.exports.makeKey = makeKey;
    return sign.exports;
  }
  var verify_1;
  var hasRequiredVerify;
  function requireVerify() {
    if (hasRequiredVerify)
      return verify_1;
    hasRequiredVerify = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var BN2 = requireBn$4();
    var EC = requireElliptic().ec;
    var parseKeys = requireParseAsn1();
    var curves2 = require$$4;
    function verify(sig, hash2, key2, signType, tag) {
      var pub = parseKeys(key2);
      if (pub.type === "ec") {
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return ecVerify(sig, hash2, pub);
      } else if (pub.type === "dsa") {
        if (signType !== "dsa")
          throw new Error("wrong public key type");
        return dsaVerify(sig, hash2, pub);
      } else {
        if (signType !== "rsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong public key type");
      }
      hash2 = Buffer2.concat([tag, hash2]);
      var len2 = pub.modulus.byteLength();
      var pad = [1];
      var padNum = 0;
      while (hash2.length + pad.length + 2 < len2) {
        pad.push(255);
        padNum++;
      }
      pad.push(0);
      var i10 = -1;
      while (++i10 < hash2.length) {
        pad.push(hash2[i10]);
      }
      pad = Buffer2.from(pad);
      var red = BN2.mont(pub.modulus);
      sig = new BN2(sig).toRed(red);
      sig = sig.redPow(new BN2(pub.publicExponent));
      sig = Buffer2.from(sig.fromRed().toArray());
      var out = padNum < 8 ? 1 : 0;
      len2 = Math.min(sig.length, pad.length);
      if (sig.length !== pad.length)
        out = 1;
      i10 = -1;
      while (++i10 < len2)
        out |= sig[i10] ^ pad[i10];
      return out === 0;
    }
    function ecVerify(sig, hash2, pub) {
      var curveId = curves2[pub.data.algorithm.curve.join(".")];
      if (!curveId)
        throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
      var curve2 = new EC(curveId);
      var pubkey = pub.data.subjectPrivateKey.data;
      return curve2.verify(hash2, sig, pubkey);
    }
    function dsaVerify(sig, hash2, pub) {
      var p = pub.data.p;
      var q = pub.data.q;
      var g = pub.data.g;
      var y10 = pub.data.pub_key;
      var unpacked = parseKeys.signature.decode(sig, "der");
      var s = unpacked.s;
      var r8 = unpacked.r;
      checkValue(s, q);
      checkValue(r8, q);
      var montp = BN2.mont(p);
      var w10 = s.invm(q);
      var v10 = g.toRed(montp).redPow(new BN2(hash2).mul(w10).mod(q)).fromRed().mul(y10.toRed(montp).redPow(r8.mul(w10).mod(q)).fromRed()).mod(p).mod(q);
      return v10.cmp(r8) === 0;
    }
    function checkValue(b, q) {
      if (b.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (b.cmp(q) >= q)
        throw new Error("invalid sig");
    }
    verify_1 = verify;
    return verify_1;
  }
  var browser$3;
  var hasRequiredBrowser$3;
  function requireBrowser$3() {
    if (hasRequiredBrowser$3)
      return browser$3;
    hasRequiredBrowser$3 = 1;
    var Buffer2 = requireSafeBuffer().Buffer;
    var createHash = requireBrowser$9();
    var stream = requireReadableBrowser();
    var inherits = requireInherits_browser();
    var sign2 = requireSign();
    var verify = requireVerify();
    var algorithms = require$$6;
    Object.keys(algorithms).forEach(function(key2) {
      algorithms[key2].id = Buffer2.from(algorithms[key2].id, "hex");
      algorithms[key2.toLowerCase()] = algorithms[key2];
    });
    function Sign(algorithm) {
      stream.Writable.call(this);
      var data = algorithms[algorithm];
      if (!data)
        throw new Error("Unknown message digest");
      this._hashType = data.hash;
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Sign, stream.Writable);
    Sign.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Sign.prototype.update = function update(data, enc) {
      if (typeof data === "string")
        data = Buffer2.from(data, enc);
      this._hash.update(data);
      return this;
    };
    Sign.prototype.sign = function signMethod(key2, enc) {
      this.end();
      var hash2 = this._hash.digest();
      var sig = sign2(hash2, key2, this._hashType, this._signType, this._tag);
      return enc ? sig.toString(enc) : sig;
    };
    function Verify(algorithm) {
      stream.Writable.call(this);
      var data = algorithms[algorithm];
      if (!data)
        throw new Error("Unknown message digest");
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Verify, stream.Writable);
    Verify.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Verify.prototype.update = function update(data, enc) {
      if (typeof data === "string")
        data = Buffer2.from(data, enc);
      this._hash.update(data);
      return this;
    };
    Verify.prototype.verify = function verifyMethod(key2, sig, enc) {
      if (typeof sig === "string")
        sig = Buffer2.from(sig, enc);
      this.end();
      var hash2 = this._hash.digest();
      return verify(sig, hash2, key2, this._signType, this._tag);
    };
    function createSign(algorithm) {
      return new Sign(algorithm);
    }
    function createVerify(algorithm) {
      return new Verify(algorithm);
    }
    browser$3 = {
      Sign: createSign,
      Verify: createVerify,
      createSign,
      createVerify
    };
    return browser$3;
  }
  var bn$2 = { exports: {} };
  bn$2.exports;
  var hasRequiredBn$1;
  function requireBn$1() {
    if (hasRequiredBn$1)
      return bn$2.exports;
    hasRequiredBn$1 = 1;
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base2, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = buffer$1.Buffer;
          }
        } catch (e8) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init4(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var j, w10;
          var off = 0;
          if (endian === "be") {
            for (i10 = number.length - 1, j = 0; i10 >= 0; i10 -= 3) {
              w10 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i10 = 0, j = 0; i10 < number.length; i10 += 3) {
              w10 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r8 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r8;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var off = 0;
          var j = 0;
          var w10;
          if (endian === "be") {
            for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r8 = 0;
          var len2 = Math.min(str.length, end);
          for (var i10 = start; i10 < len2; i10++) {
            var c = str.charCodeAt(i10) - 48;
            r8 *= mul;
            if (c >= 49) {
              r8 += c - 49 + 10;
            } else if (c >= 17) {
              r8 += c - 17 + 10;
            } else {
              r8 += c;
            }
          }
          return r8;
        }
        BN2.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i10 = start; i10 < end; i10 += limbLen) {
            word = parseBase(number, i10, i10 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i10, number.length, base2);
            for (i10 = 0; i10 < mod; i10++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN2.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            dest.words[i10] = this.words[i10];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r8 = new BN2(null);
          this.copy(r8);
          return r8;
        };
        BN2.prototype._expand = function _expand(size2) {
          while (this.length < size2) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i10 = 0; i10 < this.length; i10++) {
              var w10 = this.words[i10];
              var word = ((w10 << off | carry) & 16777215).toString(16);
              carry = w10 >>> 24 - off & 16777215;
              if (carry !== 0 || i10 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i10--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r8 = c.modn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength2 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i10;
          var q = this.clone();
          if (!littleEndian) {
            for (i10 = 0; i10 < reqLength - byteLength2; i10++) {
              res[i10] = 0;
            }
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i10 - 1] = b;
            }
          } else {
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i10] = b;
            }
            for (; i10 < reqLength; i10++) {
              res[i10] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w10) {
            return 32 - Math.clz32(w10);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w10) {
            var t8 = w10;
            var r8 = 0;
            if (t8 >= 4096) {
              r8 += 13;
              t8 >>>= 13;
            }
            if (t8 >= 64) {
              r8 += 7;
              t8 >>>= 7;
            }
            if (t8 >= 8) {
              r8 += 4;
              t8 >>>= 4;
            }
            if (t8 >= 2) {
              r8 += 2;
              t8 >>>= 2;
            }
            return r8 + t8;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w10) {
          if (w10 === 0)
            return 26;
          var t8 = w10;
          var r8 = 0;
          if ((t8 & 8191) === 0) {
            r8 += 13;
            t8 >>>= 13;
          }
          if ((t8 & 127) === 0) {
            r8 += 7;
            t8 >>>= 7;
          }
          if ((t8 & 15) === 0) {
            r8 += 4;
            t8 >>>= 4;
          }
          if ((t8 & 3) === 0) {
            r8 += 2;
            t8 >>>= 2;
          }
          if ((t8 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w10 = this.words[this.length - 1];
          var hi2 = this._countBits(w10);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w10 = new Array(num.bitLength());
          for (var bit = 0; bit < w10.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w10[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w10;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var b = this._zeroBits(this.words[i10]);
            r8 += b;
            if (b !== 26)
              break;
          }
          return r8;
        };
        BN2.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i10 = 0; i10 < num.length; i10++) {
            this.words[i10] = this.words[i10] | num.words[i10];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = this.words[i10] & num.words[i10];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = a.words[i10] ^ b.words[i10];
          }
          if (this !== a) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i10 = 0; i10 < bytesNeeded; i10++) {
            this.words[i10] = ~this.words[i10] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) + (b.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) - (b.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          if (carry === 0 && i10 < a.length && a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = Math.max(this.length, i10);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r8 = a * b;
          var lo2 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo2;
          for (var k = 1; k < len2; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j | 0;
              a = self2.words[i10] | 0;
              b = num.words[j] | 0;
              r8 = a * b + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o8 = out.words;
          var c = 0;
          var lo2;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a12 = a[1] | 0;
          var al1 = a12 & 8191;
          var ah1 = a12 >>> 13;
          var a22 = a[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a72 = a[7] | 0;
          var al7 = a72 & 8191;
          var ah7 = a72 >>> 13;
          var a82 = a[8] | 0;
          var al8 = a82 & 8191;
          var ah8 = a82 >>> 13;
          var a92 = a[9] | 0;
          var al9 = a92 & 8191;
          var ah9 = a92 >>> 13;
          var b02 = b[0] | 0;
          var bl0 = b02 & 8191;
          var bh0 = b02 >>> 13;
          var b12 = b[1] | 0;
          var bl1 = b12 & 8191;
          var bh1 = b12 >>> 13;
          var b22 = b[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b82 = b[8] | 0;
          var bl8 = b82 & 8191;
          var bh8 = b82 >>> 13;
          var b92 = b[9] | 0;
          var bl9 = b92 & 8191;
          var bh9 = b92 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo2 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w02 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
          w02 &= 67108863;
          lo2 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo2 = lo2 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo2 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo2 = lo2 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo2 = lo2 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo2 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo2 = lo2 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo2 = lo2 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo2 = lo2 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo2 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo2 = lo2 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo2 = lo2 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo2 = lo2 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo2 = lo2 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo2 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo2 = lo2 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo2 = lo2 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo2 = lo2 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo2 = lo2 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo2 = lo2 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo2 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo2 = lo2 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo2 = lo2 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo2 = lo2 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo2 = lo2 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo2 = lo2 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo2 = lo2 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo2 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo2 = lo2 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo2 = lo2 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo2 = lo2 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo2 = lo2 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo2 = lo2 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo2 = lo2 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo2 = lo2 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo2 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo2 = lo2 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo2 = lo2 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo2 = lo2 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo2 = lo2 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo2 = lo2 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo2 = lo2 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo2 = lo2 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo2 = lo2 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w82 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
          w82 &= 67108863;
          lo2 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo2 = lo2 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo2 = lo2 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo2 = lo2 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo2 = lo2 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo2 = lo2 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo2 = lo2 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo2 = lo2 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo2 = lo2 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo2 = lo2 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w92 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
          w92 &= 67108863;
          lo2 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo2 = lo2 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo2 = lo2 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo2 = lo2 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo2 = lo2 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo2 = lo2 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo2 = lo2 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo2 = lo2 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo2 = lo2 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo2 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo2 = lo2 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo2 = lo2 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo2 = lo2 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo2 = lo2 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo2 = lo2 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo2 = lo2 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo2 = lo2 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo2 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo2 = lo2 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo2 = lo2 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo2 = lo2 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo2 = lo2 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo2 = lo2 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo2 = lo2 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w122 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
          w122 &= 67108863;
          lo2 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo2 = lo2 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo2 = lo2 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo2 = lo2 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo2 = lo2 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo2 = lo2 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo2 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo2 = lo2 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo2 = lo2 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo2 = lo2 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo2 = lo2 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo2 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo2 = lo2 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo2 = lo2 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo2 = lo2 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo2 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo2 = lo2 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo2 = lo2 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo2 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo2 = lo2 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo2 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o8[0] = w02;
          o8[1] = w12;
          o8[2] = w22;
          o8[3] = w32;
          o8[4] = w42;
          o8[5] = w52;
          o8[6] = w62;
          o8[7] = w72;
          o8[8] = w82;
          o8[9] = w92;
          o8[10] = w10;
          o8[11] = w11;
          o8[12] = w122;
          o8[13] = w13;
          o8[14] = w14;
          o8[15] = w15;
          o8[16] = w16;
          o8[17] = w17;
          o8[18] = w18;
          if (c !== 0) {
            o8[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j;
              var a = self2.words[i10] | 0;
              var b = num.words[j] | 0;
              var r8 = a * b;
              var lo2 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo2 = lo2 + rword | 0;
              rword = lo2 & 67108863;
              ncarry = ncarry + (lo2 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y10) {
          this.x = x;
          this.y = y10;
        }
        FFTM.prototype.makeRBT = function makeRBT(N10) {
          var t8 = new Array(N10);
          var l = BN2.prototype._countBits(N10) - 1;
          for (var i10 = 0; i10 < N10; i10++) {
            t8[i10] = this.revBin(i10, l, N10);
          }
          return t8;
        };
        FFTM.prototype.revBin = function revBin(x, l, N10) {
          if (x === 0 || x === N10 - 1)
            return x;
          var rb = 0;
          for (var i10 = 0; i10 < l; i10++) {
            rb |= (x & 1) << l - i10 - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
          for (var i10 = 0; i10 < N10; i10++) {
            rtws[i10] = rws[rbt[i10]];
            itws[i10] = iws[rbt[i10]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N10);
          for (var s = 1; s < N10; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N10; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io2 = itws[p + j + s];
                var rx2 = rtwdf_ * ro - itwdf_ * io2;
                io2 = rtwdf_ * io2 + itwdf_ * ro;
                ro = rx2;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io2;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io2;
                if (j !== l) {
                  rx2 = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx2;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n8, m) {
          var N10 = Math.max(m, n8) | 1;
          var odd = N10 & 1;
          var i10 = 0;
          for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
            i10++;
          }
          return 1 << i10 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
          if (N10 <= 1)
            return;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var t8 = rws[i10];
            rws[i10] = rws[N10 - i10 - 1];
            rws[N10 - i10 - 1] = t8;
            t8 = iws[i10];
            iws[i10] = -iws[N10 - i10 - 1];
            iws[N10 - i10 - 1] = -t8;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var w10 = Math.round(ws2[2 * i10 + 1] / N10) * 8192 + Math.round(ws2[2 * i10] / N10) + carry;
            ws2[i10] = w10 & 67108863;
            if (w10 < 67108864) {
              carry = 0;
            } else {
              carry = w10 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len2, rws, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < len2; i10++) {
            carry = carry + (ws2[i10] | 0);
            rws[2 * i10] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i10 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i10 = 2 * len2; i10 < N10; ++i10) {
            rws[i10] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N10) {
          var ph2 = new Array(N10);
          for (var i10 = 0; i10 < N10; i10++) {
            ph2[i10] = 0;
          }
          return ph2;
        };
        FFTM.prototype.mulp = function mulp(x, y10, out) {
          var N10 = 2 * this.guessLen13b(x.length, y10.length);
          var rbt = this.makeRBT(N10);
          var _ = this.stub(N10);
          var rws = new Array(N10);
          var rwst = new Array(N10);
          var iwst = new Array(N10);
          var nrws = new Array(N10);
          var nrwst = new Array(N10);
          var niwst = new Array(N10);
          var rmws = out.words;
          rmws.length = N10;
          this.convert13b(x.words, x.length, rws, N10);
          this.convert13b(y10.words, y10.length, nrws, N10);
          this.transform(rws, _, rwst, iwst, N10, rbt);
          this.transform(nrws, _, nrwst, niwst, N10, rbt);
          for (var i10 = 0; i10 < N10; i10++) {
            var rx2 = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
            iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
            rwst[i10] = rx2;
          }
          this.conjugate(rwst, iwst, N10);
          this.transform(rwst, iwst, rmws, _, N10, rbt);
          this.conjugate(rmws, _, N10);
          this.normalize13b(rmws, N10);
          out.negative = x.negative ^ y10.negative;
          out.length = x.length + y10.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w10 = (this.words[i10] | 0) * num;
            var lo2 = (w10 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w10 / 67108864 | 0;
            carry += lo2 >>> 26;
            this.words[i10] = lo2 & 67108863;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w10 = toBitArray(num);
          if (w10.length === 0)
            return new BN2(1);
          var res = this;
          for (var i10 = 0; i10 < w10.length; i10++, res = res.sqr()) {
            if (w10[i10] !== 0)
              break;
          }
          if (++i10 < w10.length) {
            for (var q = res.sqr(); i10 < w10.length; i10++, q = q.sqr()) {
              if (w10[i10] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i10;
          if (r8 !== 0) {
            var carry = 0;
            for (i10 = 0; i10 < this.length; i10++) {
              var newCarry = this.words[i10] & carryMask;
              var c = (this.words[i10] | 0) - newCarry << r8;
              this.words[i10] = c | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i10] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i10 = this.length - 1; i10 >= 0; i10--) {
              this.words[i10 + s] = this.words[i10];
            }
            for (i10 = 0; i10 < s; i10++) {
              this.words[i10] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r8 = bits % 26;
          var s = Math.min((bits - r8) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i10 = 0; i10 < s; i10++) {
              maskedWords.words[i10] = this.words[i10];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i10 = 0; i10 < this.length; i10++) {
              this.words[i10] = this.words[i10 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h); i10--) {
            var word = this.words[i10] | 0;
            this.words[i10] = carry << 26 - r8 | word >>> r8;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s)
            return false;
          var w10 = this.words[s];
          return !!(w10 & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r8 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r8 !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask2;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
            this.words[i10] -= 67108864;
            if (i10 === this.length - 1) {
              this.words[i10 + 1] = 1;
            } else {
              this.words[i10 + 1]++;
            }
          }
          this.length = Math.max(this.length, i10 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
              this.words[i10] += 67108864;
              this.words[i10 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i10;
          this._expand(len2);
          var w10;
          var carry = 0;
          for (i10 = 0; i10 < num.length; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            var right = (num.words[i10] | 0) * mul;
            w10 -= right & 67108863;
            carry = (w10 >> 26) - (right / 67108864 | 0);
            this.words[i10 + shift] = w10 & 67108863;
          }
          for (; i10 < this.length - shift; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10 + shift] = w10 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            w10 = -(this.words[i10] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10] = w10 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i10 = 0; i10 < q.length; i10++) {
              q.words[i10] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj2;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm2 = this.divmod(num);
          if (dm2.mod.isZero())
            return dm2.div;
          var mod = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
          var half2 = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half2);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm2.div;
          return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            acc = (p * acc + (this.words[i10] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var w10 = (this.words[i10] | 0) + carry * 67108864;
            this.words[i10] = w10 / num | 0;
            carry = w10 % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y10 = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A10 = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y10.isEven()) {
            x.iushrn(1);
            y10.iushrn(1);
            ++g;
          }
          var yp2 = y10.clone();
          var xp2 = x.clone();
          while (!x.isZero()) {
            for (var i10 = 0, im2 = 1; (x.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              x.iushrn(i10);
              while (i10-- > 0) {
                if (A10.isOdd() || B.isOdd()) {
                  A10.iadd(yp2);
                  B.isub(xp2);
                }
                A10.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (y10.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              y10.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp2);
                  D.isub(xp2);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y10) >= 0) {
              x.isub(y10);
              A10.isub(C);
              B.isub(D);
            } else {
              y10.isub(x);
              C.isub(A10);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y10.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x12 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i10 = 0, im2 = 1; (a.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              a.iushrn(i10);
              while (i10-- > 0) {
                if (x12.isOdd()) {
                  x12.iadd(delta);
                }
                x12.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (b.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x12.isub(x22);
            } else {
              b.isub(a);
              x22.isub(x12);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x12;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r8 = a.cmp(b);
            if (r8 < 0) {
              var t8 = a;
              a = b;
              b = t8;
            } else if (r8 === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i10 = s; carry !== 0 && i10 < this.length; i10++) {
            var w10 = this.words[i10] | 0;
            w10 += carry;
            carry = w10 >>> 26;
            w10 &= 67108863;
            this.words[i10] = w10;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w10 = this.words[0] | 0;
            res = w10 === num ? 0 : w10 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var a = this.words[i10] | 0;
            var b = num.words[i10] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte2(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte2(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i10 = 0; i10 < outLen; i10++) {
            output.words[i10] = input.words[i10];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i10 = 10; i10 < input.length; i10++) {
            var next = input.words[i10] | 0;
            input.words[i10 - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i10 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo2 = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var w10 = num.words[i10] | 0;
            lo2 += w10 * 977;
            num.words[i10] = lo2 & 67108863;
            lo2 = w10 * 64 + (lo2 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var hi2 = (num.words[i10] | 0) * 19 + carry;
            var lo2 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i10] = lo2;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one2 = new BN2(1).toRed(this);
          var nOne = one2.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r8 = this.pow(a, q.addn(1).iushrn(1));
          var t8 = this.pow(a, q);
          var m = s;
          while (t8.cmp(one2) !== 0) {
            var tmp = t8;
            for (var i10 = 0; tmp.cmp(one2) !== 0; i10++) {
              tmp = tmp.redSqr();
            }
            assert(i10 < m);
            var b = this.pow(c, new BN2(1).iushln(m - i10 - 1));
            r8 = r8.redMul(b);
            c = b.redSqr();
            t8 = t8.redMul(c);
            m = i10;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i10 = 2; i10 < wnd.length; i10++) {
            wnd[i10] = this.mul(wnd[i10 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i10 = num.length - 1; i10 >= 0; i10--) {
            var word = num.words[i10];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i10 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont2(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t8 = a.imul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t8 = a.mul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn$2);
    return bn$2.exports;
  }
  var browser$2;
  var hasRequiredBrowser$2;
  function requireBrowser$2() {
    if (hasRequiredBrowser$2)
      return browser$2;
    hasRequiredBrowser$2 = 1;
    var elliptic2 = requireElliptic();
    var BN2 = requireBn$1();
    browser$2 = function createECDH(curve2) {
      return new ECDH(curve2);
    };
    var aliases = {
      secp256k1: {
        name: "secp256k1",
        byteLength: 32
      },
      secp224r1: {
        name: "p224",
        byteLength: 28
      },
      prime256v1: {
        name: "p256",
        byteLength: 32
      },
      prime192v1: {
        name: "p192",
        byteLength: 24
      },
      ed25519: {
        name: "ed25519",
        byteLength: 32
      },
      secp384r1: {
        name: "p384",
        byteLength: 48
      },
      secp521r1: {
        name: "p521",
        byteLength: 66
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve2) {
      this.curveType = aliases[curve2];
      if (!this.curveType) {
        this.curveType = {
          name: curve2
        };
      }
      this.curve = new elliptic2.ec(this.curveType.name);
      this.keys = void 0;
    }
    ECDH.prototype.generateKeys = function(enc, format) {
      this.keys = this.curve.genKeyPair();
      return this.getPublicKey(enc, format);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      inenc = inenc || "utf8";
      if (!buffer$1.Buffer.isBuffer(other)) {
        other = new buffer$1.Buffer(other, inenc);
      }
      var otherPub = this.curve.keyFromPublic(other).getPublic();
      var out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format) {
      var key2 = this.keys.getPublic(format === "compressed", true);
      if (format === "hybrid") {
        if (key2[key2.length - 1] % 2) {
          key2[0] = 7;
        } else {
          key2[0] = 6;
        }
      }
      return formatReturnValue(key2, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      enc = enc || "utf8";
      if (!buffer$1.Buffer.isBuffer(pub)) {
        pub = new buffer$1.Buffer(pub, enc);
      }
      this.keys._importPublic(pub);
      return this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      enc = enc || "utf8";
      if (!buffer$1.Buffer.isBuffer(priv)) {
        priv = new buffer$1.Buffer(priv, enc);
      }
      var _priv = new BN2(priv);
      _priv = _priv.toString(16);
      this.keys = this.curve.genKeyPair();
      this.keys._importPrivate(_priv);
      return this;
    };
    function formatReturnValue(bn2, enc, len2) {
      if (!Array.isArray(bn2)) {
        bn2 = bn2.toArray();
      }
      var buf = new buffer$1.Buffer(bn2);
      if (len2 && buf.length < len2) {
        var zeros = new buffer$1.Buffer(len2 - buf.length);
        zeros.fill(0);
        buf = buffer$1.Buffer.concat([zeros, buf]);
      }
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
    return browser$2;
  }
  var browser$1 = {};
  var mgf;
  var hasRequiredMgf;
  function requireMgf() {
    if (hasRequiredMgf)
      return mgf;
    hasRequiredMgf = 1;
    var createHash = requireBrowser$9();
    var Buffer2 = requireSafeBuffer().Buffer;
    mgf = function(seed, len2) {
      var t8 = Buffer2.alloc(0);
      var i10 = 0;
      var c;
      while (t8.length < len2) {
        c = i2ops(i10++);
        t8 = Buffer2.concat([t8, createHash("sha1").update(seed).update(c).digest()]);
      }
      return t8.slice(0, len2);
    };
    function i2ops(c) {
      var out = Buffer2.allocUnsafe(4);
      out.writeUInt32BE(c, 0);
      return out;
    }
    return mgf;
  }
  var xor;
  var hasRequiredXor;
  function requireXor() {
    if (hasRequiredXor)
      return xor;
    hasRequiredXor = 1;
    xor = function xor2(a, b) {
      var len2 = a.length;
      var i10 = -1;
      while (++i10 < len2) {
        a[i10] ^= b[i10];
      }
      return a;
    };
    return xor;
  }
  var bn$1 = { exports: {} };
  bn$1.exports;
  var hasRequiredBn;
  function requireBn() {
    if (hasRequiredBn)
      return bn$1.exports;
    hasRequiredBn = 1;
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base2, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = buffer$1.Buffer;
          }
        } catch (e8) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init4(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var j, w10;
          var off = 0;
          if (endian === "be") {
            for (i10 = number.length - 1, j = 0; i10 >= 0; i10 -= 3) {
              w10 = number[i10] | number[i10 - 1] << 8 | number[i10 - 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i10 = 0, j = 0; i10 < number.length; i10 += 3) {
              w10 = number[i10] | number[i10 + 1] << 8 | number[i10 + 2] << 16;
              this.words[j] |= w10 << off & 67108863;
              this.words[j + 1] = w10 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r8 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r8;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            this.words[i10] = 0;
          }
          var off = 0;
          var j = 0;
          var w10;
          if (endian === "be") {
            for (i10 = number.length - 1; i10 >= start; i10 -= 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i10 = parseLength % 2 === 0 ? start + 1 : start; i10 < number.length; i10 += 2) {
              w10 = parseHexByte(number, start, i10) << off;
              this.words[j] |= w10 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w10 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r8 = 0;
          var len2 = Math.min(str.length, end);
          for (var i10 = start; i10 < len2; i10++) {
            var c = str.charCodeAt(i10) - 48;
            r8 *= mul;
            if (c >= 49) {
              r8 += c - 49 + 10;
            } else if (c >= 17) {
              r8 += c - 17 + 10;
            } else {
              r8 += c;
            }
          }
          return r8;
        }
        BN2.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i10 = start; i10 < end; i10 += limbLen) {
            word = parseBase(number, i10, i10 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i10, number.length, base2);
            for (i10 = 0; i10 < mod; i10++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN2.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i10 = 0; i10 < this.length; i10++) {
            dest.words[i10] = this.words[i10];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r8 = new BN2(null);
          this.copy(r8);
          return r8;
        };
        BN2.prototype._expand = function _expand(size2) {
          while (this.length < size2) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base2, padding2) {
          base2 = base2 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i10 = 0; i10 < this.length; i10++) {
              var w10 = this.words[i10];
              var word = ((w10 << off | carry) & 16777215).toString(16);
              carry = w10 >>> 24 - off & 16777215;
              if (carry !== 0 || i10 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i10--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r8 = c.modn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength2 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i10;
          var q = this.clone();
          if (!littleEndian) {
            for (i10 = 0; i10 < reqLength - byteLength2; i10++) {
              res[i10] = 0;
            }
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i10 - 1] = b;
            }
          } else {
            for (i10 = 0; !q.isZero(); i10++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i10] = b;
            }
            for (; i10 < reqLength; i10++) {
              res[i10] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w10) {
            return 32 - Math.clz32(w10);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w10) {
            var t8 = w10;
            var r8 = 0;
            if (t8 >= 4096) {
              r8 += 13;
              t8 >>>= 13;
            }
            if (t8 >= 64) {
              r8 += 7;
              t8 >>>= 7;
            }
            if (t8 >= 8) {
              r8 += 4;
              t8 >>>= 4;
            }
            if (t8 >= 2) {
              r8 += 2;
              t8 >>>= 2;
            }
            return r8 + t8;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w10) {
          if (w10 === 0)
            return 26;
          var t8 = w10;
          var r8 = 0;
          if ((t8 & 8191) === 0) {
            r8 += 13;
            t8 >>>= 13;
          }
          if ((t8 & 127) === 0) {
            r8 += 7;
            t8 >>>= 7;
          }
          if ((t8 & 15) === 0) {
            r8 += 4;
            t8 >>>= 4;
          }
          if ((t8 & 3) === 0) {
            r8 += 2;
            t8 >>>= 2;
          }
          if ((t8 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w10 = this.words[this.length - 1];
          var hi2 = this._countBits(w10);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w10 = new Array(num.bitLength());
          for (var bit = 0; bit < w10.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w10[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w10;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var b = this._zeroBits(this.words[i10]);
            r8 += b;
            if (b !== 26)
              break;
          }
          return r8;
        };
        BN2.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i10 = 0; i10 < num.length; i10++) {
            this.words[i10] = this.words[i10] | num.words[i10];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = this.words[i10] & num.words[i10];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i10 = 0; i10 < b.length; i10++) {
            this.words[i10] = a.words[i10] ^ b.words[i10];
          }
          if (this !== a) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i10 = 0; i10 < bytesNeeded; i10++) {
            this.words[i10] = ~this.words[i10] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i10] = ~this.words[i10] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) + (b.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            this.words[i10] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i10 = 0; i10 < b.length; i10++) {
            r8 = (a.words[i10] | 0) - (b.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          for (; carry !== 0 && i10 < a.length; i10++) {
            r8 = (a.words[i10] | 0) + carry;
            carry = r8 >> 26;
            this.words[i10] = r8 & 67108863;
          }
          if (carry === 0 && i10 < a.length && a !== this) {
            for (; i10 < a.length; i10++) {
              this.words[i10] = a.words[i10];
            }
          }
          this.length = Math.max(this.length, i10);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r8 = a * b;
          var lo2 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo2;
          for (var k = 1; k < len2; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j | 0;
              a = self2.words[i10] | 0;
              b = num.words[j] | 0;
              r8 = a * b + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o8 = out.words;
          var c = 0;
          var lo2;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a12 = a[1] | 0;
          var al1 = a12 & 8191;
          var ah1 = a12 >>> 13;
          var a22 = a[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a72 = a[7] | 0;
          var al7 = a72 & 8191;
          var ah7 = a72 >>> 13;
          var a82 = a[8] | 0;
          var al8 = a82 & 8191;
          var ah8 = a82 >>> 13;
          var a92 = a[9] | 0;
          var al9 = a92 & 8191;
          var ah9 = a92 >>> 13;
          var b02 = b[0] | 0;
          var bl0 = b02 & 8191;
          var bh0 = b02 >>> 13;
          var b12 = b[1] | 0;
          var bl1 = b12 & 8191;
          var bh1 = b12 >>> 13;
          var b22 = b[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b82 = b[8] | 0;
          var bl8 = b82 & 8191;
          var bh8 = b82 >>> 13;
          var b92 = b[9] | 0;
          var bl9 = b92 & 8191;
          var bh9 = b92 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo2 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w02 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
          w02 &= 67108863;
          lo2 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo2 = lo2 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo2 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo2 = lo2 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo2 = lo2 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo2 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo2 = lo2 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo2 = lo2 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo2 = lo2 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo2 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo2 = lo2 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo2 = lo2 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo2 = lo2 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo2 = lo2 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo2 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo2 = lo2 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo2 = lo2 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo2 = lo2 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo2 = lo2 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo2 = lo2 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo2 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo2 = lo2 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo2 = lo2 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo2 = lo2 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo2 = lo2 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo2 = lo2 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo2 = lo2 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo2 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo2 = lo2 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo2 = lo2 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo2 = lo2 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo2 = lo2 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo2 = lo2 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo2 = lo2 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo2 = lo2 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo2 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo2 = lo2 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo2 = lo2 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo2 = lo2 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo2 = lo2 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo2 = lo2 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo2 = lo2 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo2 = lo2 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo2 = lo2 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w82 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
          w82 &= 67108863;
          lo2 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo2 = lo2 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo2 = lo2 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo2 = lo2 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo2 = lo2 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo2 = lo2 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo2 = lo2 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo2 = lo2 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo2 = lo2 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo2 = lo2 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w92 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
          w92 &= 67108863;
          lo2 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo2 = lo2 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo2 = lo2 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo2 = lo2 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo2 = lo2 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo2 = lo2 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo2 = lo2 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo2 = lo2 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo2 = lo2 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo2 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo2 = lo2 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo2 = lo2 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo2 = lo2 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo2 = lo2 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo2 = lo2 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo2 = lo2 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo2 = lo2 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo2 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo2 = lo2 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo2 = lo2 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo2 = lo2 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo2 = lo2 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo2 = lo2 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo2 = lo2 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w122 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
          w122 &= 67108863;
          lo2 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo2 = lo2 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo2 = lo2 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo2 = lo2 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo2 = lo2 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo2 = lo2 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo2 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo2 = lo2 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo2 = lo2 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo2 = lo2 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo2 = lo2 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo2 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo2 = lo2 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo2 = lo2 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo2 = lo2 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo2 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo2 = lo2 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo2 = lo2 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo2 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo2 = lo2 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo2 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
          c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o8[0] = w02;
          o8[1] = w12;
          o8[2] = w22;
          o8[3] = w32;
          o8[4] = w42;
          o8[5] = w52;
          o8[6] = w62;
          o8[7] = w72;
          o8[8] = w82;
          o8[9] = w92;
          o8[10] = w10;
          o8[11] = w11;
          o8[12] = w122;
          o8[13] = w13;
          o8[14] = w14;
          o8[15] = w15;
          o8[16] = w16;
          o8[17] = w17;
          o8[18] = w18;
          if (c !== 0) {
            o8[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i10 = k - j;
              var a = self2.words[i10] | 0;
              var b = num.words[j] | 0;
              var r8 = a * b;
              var lo2 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo2 = lo2 + rword | 0;
              rword = lo2 & 67108863;
              ncarry = ncarry + (lo2 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y10) {
          this.x = x;
          this.y = y10;
        }
        FFTM.prototype.makeRBT = function makeRBT(N10) {
          var t8 = new Array(N10);
          var l = BN2.prototype._countBits(N10) - 1;
          for (var i10 = 0; i10 < N10; i10++) {
            t8[i10] = this.revBin(i10, l, N10);
          }
          return t8;
        };
        FFTM.prototype.revBin = function revBin(x, l, N10) {
          if (x === 0 || x === N10 - 1)
            return x;
          var rb = 0;
          for (var i10 = 0; i10 < l; i10++) {
            rb |= (x & 1) << l - i10 - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
          for (var i10 = 0; i10 < N10; i10++) {
            rtws[i10] = rws[rbt[i10]];
            itws[i10] = iws[rbt[i10]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N10);
          for (var s = 1; s < N10; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N10; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io2 = itws[p + j + s];
                var rx2 = rtwdf_ * ro - itwdf_ * io2;
                io2 = rtwdf_ * io2 + itwdf_ * ro;
                ro = rx2;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io2;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io2;
                if (j !== l) {
                  rx2 = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx2;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n8, m) {
          var N10 = Math.max(m, n8) | 1;
          var odd = N10 & 1;
          var i10 = 0;
          for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
            i10++;
          }
          return 1 << i10 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
          if (N10 <= 1)
            return;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var t8 = rws[i10];
            rws[i10] = rws[N10 - i10 - 1];
            rws[N10 - i10 - 1] = t8;
            t8 = iws[i10];
            iws[i10] = -iws[N10 - i10 - 1];
            iws[N10 - i10 - 1] = -t8;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < N10 / 2; i10++) {
            var w10 = Math.round(ws2[2 * i10 + 1] / N10) * 8192 + Math.round(ws2[2 * i10] / N10) + carry;
            ws2[i10] = w10 & 67108863;
            if (w10 < 67108864) {
              carry = 0;
            } else {
              carry = w10 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len2, rws, N10) {
          var carry = 0;
          for (var i10 = 0; i10 < len2; i10++) {
            carry = carry + (ws2[i10] | 0);
            rws[2 * i10] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i10 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i10 = 2 * len2; i10 < N10; ++i10) {
            rws[i10] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N10) {
          var ph2 = new Array(N10);
          for (var i10 = 0; i10 < N10; i10++) {
            ph2[i10] = 0;
          }
          return ph2;
        };
        FFTM.prototype.mulp = function mulp(x, y10, out) {
          var N10 = 2 * this.guessLen13b(x.length, y10.length);
          var rbt = this.makeRBT(N10);
          var _ = this.stub(N10);
          var rws = new Array(N10);
          var rwst = new Array(N10);
          var iwst = new Array(N10);
          var nrws = new Array(N10);
          var nrwst = new Array(N10);
          var niwst = new Array(N10);
          var rmws = out.words;
          rmws.length = N10;
          this.convert13b(x.words, x.length, rws, N10);
          this.convert13b(y10.words, y10.length, nrws, N10);
          this.transform(rws, _, rwst, iwst, N10, rbt);
          this.transform(nrws, _, nrwst, niwst, N10, rbt);
          for (var i10 = 0; i10 < N10; i10++) {
            var rx2 = rwst[i10] * nrwst[i10] - iwst[i10] * niwst[i10];
            iwst[i10] = rwst[i10] * niwst[i10] + iwst[i10] * nrwst[i10];
            rwst[i10] = rx2;
          }
          this.conjugate(rwst, iwst, N10);
          this.transform(rwst, iwst, rmws, _, N10, rbt);
          this.conjugate(rmws, _, N10);
          this.normalize13b(rmws, N10);
          out.negative = x.negative ^ y10.negative;
          out.length = x.length + y10.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i10 = 0; i10 < this.length; i10++) {
            var w10 = (this.words[i10] | 0) * num;
            var lo2 = (w10 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w10 / 67108864 | 0;
            carry += lo2 >>> 26;
            this.words[i10] = lo2 & 67108863;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w10 = toBitArray(num);
          if (w10.length === 0)
            return new BN2(1);
          var res = this;
          for (var i10 = 0; i10 < w10.length; i10++, res = res.sqr()) {
            if (w10[i10] !== 0)
              break;
          }
          if (++i10 < w10.length) {
            for (var q = res.sqr(); i10 < w10.length; i10++, q = q.sqr()) {
              if (w10[i10] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i10;
          if (r8 !== 0) {
            var carry = 0;
            for (i10 = 0; i10 < this.length; i10++) {
              var newCarry = this.words[i10] & carryMask;
              var c = (this.words[i10] | 0) - newCarry << r8;
              this.words[i10] = c | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i10] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i10 = this.length - 1; i10 >= 0; i10--) {
              this.words[i10 + s] = this.words[i10];
            }
            for (i10 = 0; i10 < s; i10++) {
              this.words[i10] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r8 = bits % 26;
          var s = Math.min((bits - r8) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i10 = 0; i10 < s; i10++) {
              maskedWords.words[i10] = this.words[i10];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i10 = 0; i10 < this.length; i10++) {
              this.words[i10] = this.words[i10 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i10 = this.length - 1; i10 >= 0 && (carry !== 0 || i10 >= h); i10--) {
            var word = this.words[i10] | 0;
            this.words[i10] = carry << 26 - r8 | word >>> r8;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s)
            return false;
          var w10 = this.words[s];
          return !!(w10 & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s = (bits - r8) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r8 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r8 !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask2;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i10 = 0; i10 < this.length && this.words[i10] >= 67108864; i10++) {
            this.words[i10] -= 67108864;
            if (i10 === this.length - 1) {
              this.words[i10 + 1] = 1;
            } else {
              this.words[i10 + 1]++;
            }
          }
          this.length = Math.max(this.length, i10 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i10 = 0; i10 < this.length && this.words[i10] < 0; i10++) {
              this.words[i10] += 67108864;
              this.words[i10 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i10;
          this._expand(len2);
          var w10;
          var carry = 0;
          for (i10 = 0; i10 < num.length; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            var right = (num.words[i10] | 0) * mul;
            w10 -= right & 67108863;
            carry = (w10 >> 26) - (right / 67108864 | 0);
            this.words[i10 + shift] = w10 & 67108863;
          }
          for (; i10 < this.length - shift; i10++) {
            w10 = (this.words[i10 + shift] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10 + shift] = w10 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i10 = 0; i10 < this.length; i10++) {
            w10 = -(this.words[i10] | 0) + carry;
            carry = w10 >> 26;
            this.words[i10] = w10 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i10 = 0; i10 < q.length; i10++) {
              q.words[i10] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj2 = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj2;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm2 = this.divmod(num);
          if (dm2.mod.isZero())
            return dm2.div;
          var mod = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
          var half2 = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half2);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm2.div;
          return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            acc = (p * acc + (this.words[i10] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var w10 = (this.words[i10] | 0) + carry * 67108864;
            this.words[i10] = w10 / num | 0;
            carry = w10 % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y10 = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A10 = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y10.isEven()) {
            x.iushrn(1);
            y10.iushrn(1);
            ++g;
          }
          var yp2 = y10.clone();
          var xp2 = x.clone();
          while (!x.isZero()) {
            for (var i10 = 0, im2 = 1; (x.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              x.iushrn(i10);
              while (i10-- > 0) {
                if (A10.isOdd() || B.isOdd()) {
                  A10.iadd(yp2);
                  B.isub(xp2);
                }
                A10.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (y10.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              y10.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp2);
                  D.isub(xp2);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y10) >= 0) {
              x.isub(y10);
              A10.isub(C);
              B.isub(D);
            } else {
              y10.isub(x);
              C.isub(A10);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y10.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x12 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i10 = 0, im2 = 1; (a.words[0] & im2) === 0 && i10 < 26; ++i10, im2 <<= 1)
              ;
            if (i10 > 0) {
              a.iushrn(i10);
              while (i10-- > 0) {
                if (x12.isOdd()) {
                  x12.iadd(delta);
                }
                x12.iushrn(1);
              }
            }
            for (var j = 0, jm2 = 1; (b.words[0] & jm2) === 0 && j < 26; ++j, jm2 <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x12.isub(x22);
            } else {
              b.isub(a);
              x22.isub(x12);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x12;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r8 = a.cmp(b);
            if (r8 < 0) {
              var t8 = a;
              a = b;
              b = t8;
            } else if (r8 === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r8 = bit % 26;
          var s = (bit - r8) / 26;
          var q = 1 << r8;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i10 = s; carry !== 0 && i10 < this.length; i10++) {
            var w10 = this.words[i10] | 0;
            w10 += carry;
            carry = w10 >>> 26;
            w10 &= 67108863;
            this.words[i10] = w10;
          }
          if (carry !== 0) {
            this.words[i10] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w10 = this.words[0] | 0;
            res = w10 === num ? 0 : w10 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i10 = this.length - 1; i10 >= 0; i10--) {
            var a = this.words[i10] | 0;
            var b = num.words[i10] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte2(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte2(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p) {
          this.name = name2;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i10 = 0; i10 < outLen; i10++) {
            output.words[i10] = input.words[i10];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i10 = 10; i10 < input.length; i10++) {
            var next = input.words[i10] | 0;
            input.words[i10 - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i10 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo2 = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var w10 = num.words[i10] | 0;
            lo2 += w10 * 977;
            num.words[i10] = lo2 & 67108863;
            lo2 = w10 * 64 + (lo2 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i10 = 0; i10 < num.length; i10++) {
            var hi2 = (num.words[i10] | 0) * 19 + carry;
            var lo2 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i10] = lo2;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one2 = new BN2(1).toRed(this);
          var nOne = one2.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r8 = this.pow(a, q.addn(1).iushrn(1));
          var t8 = this.pow(a, q);
          var m = s;
          while (t8.cmp(one2) !== 0) {
            var tmp = t8;
            for (var i10 = 0; tmp.cmp(one2) !== 0; i10++) {
              tmp = tmp.redSqr();
            }
            assert(i10 < m);
            var b = this.pow(c, new BN2(1).iushln(m - i10 - 1));
            r8 = r8.redMul(b);
            c = b.redSqr();
            t8 = t8.redMul(c);
            m = i10;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i10 = 2; i10 < wnd.length; i10++) {
            wnd[i10] = this.mul(wnd[i10 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i10 = num.length - 1; i10 >= 0; i10--) {
            var word = num.words[i10];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i10 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont2(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t8 = a.imul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t8 = a.mul(b);
          var c = t8.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t8.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn$1);
    return bn$1.exports;
  }
  var withPublic_1;
  var hasRequiredWithPublic;
  function requireWithPublic() {
    if (hasRequiredWithPublic)
      return withPublic_1;
    hasRequiredWithPublic = 1;
    var BN2 = requireBn();
    var Buffer2 = requireSafeBuffer().Buffer;
    function withPublic(paddedMsg, key2) {
      return Buffer2.from(paddedMsg.toRed(BN2.mont(key2.modulus)).redPow(new BN2(key2.publicExponent)).fromRed().toArray());
    }
    withPublic_1 = withPublic;
    return withPublic_1;
  }
  var publicEncrypt;
  var hasRequiredPublicEncrypt;
  function requirePublicEncrypt() {
    if (hasRequiredPublicEncrypt)
      return publicEncrypt;
    hasRequiredPublicEncrypt = 1;
    var parseKeys = requireParseAsn1();
    var randomBytes = requireBrowser$b();
    var createHash = requireBrowser$9();
    var mgf2 = requireMgf();
    var xor2 = requireXor();
    var BN2 = requireBn();
    var withPublic = requireWithPublic();
    var crt = requireBrowserifyRsa();
    var Buffer2 = requireSafeBuffer().Buffer;
    publicEncrypt = function publicEncrypt2(publicKey, msg, reverse) {
      var padding2;
      if (publicKey.padding) {
        padding2 = publicKey.padding;
      } else if (reverse) {
        padding2 = 1;
      } else {
        padding2 = 4;
      }
      var key2 = parseKeys(publicKey);
      var paddedMsg;
      if (padding2 === 4) {
        paddedMsg = oaep(key2, msg);
      } else if (padding2 === 1) {
        paddedMsg = pkcs1(key2, msg, reverse);
      } else if (padding2 === 3) {
        paddedMsg = new BN2(msg);
        if (paddedMsg.cmp(key2.modulus) >= 0) {
          throw new Error("data too long for modulus");
        }
      } else {
        throw new Error("unknown padding");
      }
      if (reverse) {
        return crt(paddedMsg, key2);
      } else {
        return withPublic(paddedMsg, key2);
      }
    };
    function oaep(key2, msg) {
      var k = key2.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error("message too long");
      }
      var ps2 = Buffer2.alloc(k - mLen - hLen2 - 2);
      var dblen = k - hLen - 1;
      var seed = randomBytes(hLen);
      var maskedDb = xor2(Buffer2.concat([iHash, ps2, Buffer2.alloc(1, 1), msg], dblen), mgf2(seed, dblen));
      var maskedSeed = xor2(seed, mgf2(maskedDb, hLen));
      return new BN2(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));
    }
    function pkcs1(key2, msg, reverse) {
      var mLen = msg.length;
      var k = key2.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error("message too long");
      }
      var ps2;
      if (reverse) {
        ps2 = Buffer2.alloc(k - mLen - 3, 255);
      } else {
        ps2 = nonZero(k - mLen - 3);
      }
      return new BN2(Buffer2.concat([Buffer2.from([0, reverse ? 1 : 2]), ps2, Buffer2.alloc(1), msg], k));
    }
    function nonZero(len2) {
      var out = Buffer2.allocUnsafe(len2);
      var i10 = 0;
      var cache7 = randomBytes(len2 * 2);
      var cur = 0;
      var num;
      while (i10 < len2) {
        if (cur === cache7.length) {
          cache7 = randomBytes(len2 * 2);
          cur = 0;
        }
        num = cache7[cur++];
        if (num) {
          out[i10++] = num;
        }
      }
      return out;
    }
    return publicEncrypt;
  }
  var privateDecrypt;
  var hasRequiredPrivateDecrypt;
  function requirePrivateDecrypt() {
    if (hasRequiredPrivateDecrypt)
      return privateDecrypt;
    hasRequiredPrivateDecrypt = 1;
    var parseKeys = requireParseAsn1();
    var mgf2 = requireMgf();
    var xor2 = requireXor();
    var BN2 = requireBn();
    var crt = requireBrowserifyRsa();
    var createHash = requireBrowser$9();
    var withPublic = requireWithPublic();
    var Buffer2 = requireSafeBuffer().Buffer;
    privateDecrypt = function privateDecrypt2(privateKey, enc, reverse) {
      var padding2;
      if (privateKey.padding) {
        padding2 = privateKey.padding;
      } else if (reverse) {
        padding2 = 1;
      } else {
        padding2 = 4;
      }
      var key2 = parseKeys(privateKey);
      var k = key2.modulus.byteLength();
      if (enc.length > k || new BN2(enc).cmp(key2.modulus) >= 0) {
        throw new Error("decryption error");
      }
      var msg;
      if (reverse) {
        msg = withPublic(new BN2(enc), key2);
      } else {
        msg = crt(enc, key2);
      }
      var zBuffer = Buffer2.alloc(k - msg.length);
      msg = Buffer2.concat([zBuffer, msg], k);
      if (padding2 === 4) {
        return oaep(key2, msg);
      } else if (padding2 === 1) {
        return pkcs1(key2, msg, reverse);
      } else if (padding2 === 3) {
        return msg;
      } else {
        throw new Error("unknown padding");
      }
    };
    function oaep(key2, msg) {
      var k = key2.modulus.byteLength();
      var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
      var hLen = iHash.length;
      if (msg[0] !== 0) {
        throw new Error("decryption error");
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb = msg.slice(hLen + 1);
      var seed = xor2(maskedSeed, mgf2(maskedDb, hLen));
      var db = xor2(maskedDb, mgf2(seed, k - hLen - 1));
      if (compare2(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
      }
      var i10 = hLen;
      while (db[i10] === 0) {
        i10++;
      }
      if (db[i10++] !== 1) {
        throw new Error("decryption error");
      }
      return db.slice(i10);
    }
    function pkcs1(key2, msg, reverse) {
      var p12 = msg.slice(0, 2);
      var i10 = 2;
      var status = 0;
      while (msg[i10++] !== 0) {
        if (i10 >= msg.length) {
          status++;
          break;
        }
      }
      var ps2 = msg.slice(2, i10 - 1);
      if (p12.toString("hex") !== "0002" && !reverse || p12.toString("hex") !== "0001" && reverse) {
        status++;
      }
      if (ps2.length < 8) {
        status++;
      }
      if (status) {
        throw new Error("decryption error");
      }
      return msg.slice(i10);
    }
    function compare2(a, b) {
      a = Buffer2.from(a);
      b = Buffer2.from(b);
      var dif = 0;
      var len2 = a.length;
      if (a.length !== b.length) {
        dif++;
        len2 = Math.min(a.length, b.length);
      }
      var i10 = -1;
      while (++i10 < len2) {
        dif += a[i10] ^ b[i10];
      }
      return dif;
    }
    return privateDecrypt;
  }
  var hasRequiredBrowser$1;
  function requireBrowser$1() {
    if (hasRequiredBrowser$1)
      return browser$1;
    hasRequiredBrowser$1 = 1;
    (function(exports2) {
      exports2.publicEncrypt = requirePublicEncrypt();
      exports2.privateDecrypt = requirePrivateDecrypt();
      exports2.privateEncrypt = function privateEncrypt(key2, buf) {
        return exports2.publicEncrypt(key2, buf, true);
      };
      exports2.publicDecrypt = function publicDecrypt(key2, buf) {
        return exports2.privateDecrypt(key2, buf, true);
      };
    })(browser$1);
    return browser$1;
  }
  var browser = {};
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser)
      return browser;
    hasRequiredBrowser = 1;
    function oldBrowser() {
      throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
    }
    var safeBuffer2 = requireSafeBuffer();
    var randombytes = requireBrowser$b();
    var Buffer2 = safeBuffer2.Buffer;
    var kBufferMaxLength = safeBuffer2.kMaxLength;
    var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
    var kMaxUint32 = Math.pow(2, 32) - 1;
    function assertOffset(offset, length) {
      if (typeof offset !== "number" || offset !== offset) {
        throw new TypeError("offset must be a number");
      }
      if (offset > kMaxUint32 || offset < 0) {
        throw new TypeError("offset must be a uint32");
      }
      if (offset > kBufferMaxLength || offset > length) {
        throw new RangeError("offset out of range");
      }
    }
    function assertSize(size2, offset, length) {
      if (typeof size2 !== "number" || size2 !== size2) {
        throw new TypeError("size must be a number");
      }
      if (size2 > kMaxUint32 || size2 < 0) {
        throw new TypeError("size must be a uint32");
      }
      if (size2 + offset > length || size2 > kBufferMaxLength) {
        throw new RangeError("buffer too small");
      }
    }
    if (crypto && crypto.getRandomValues || !process$1.browser) {
      browser.randomFill = randomFill;
      browser.randomFillSync = randomFillSync;
    } else {
      browser.randomFill = oldBrowser;
      browser.randomFillSync = oldBrowser;
    }
    function randomFill(buf, offset, size2, cb) {
      if (!Buffer2.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size2 = buf.length;
      } else if (typeof size2 === "function") {
        cb = size2;
        size2 = buf.length - offset;
      } else if (typeof cb !== "function") {
        throw new TypeError('"cb" argument must be a function');
      }
      assertOffset(offset, buf.length);
      assertSize(size2, offset, buf.length);
      return actualFill(buf, offset, size2, cb);
    }
    function actualFill(buf, offset, size2, cb) {
      if (process$1.browser) {
        var ourBuf = buf.buffer;
        var uint = new Uint8Array(ourBuf, offset, size2);
        crypto.getRandomValues(uint);
        if (cb) {
          process$1.nextTick(function() {
            cb(null, buf);
          });
          return;
        }
        return buf;
      }
      if (cb) {
        randombytes(size2, function(err, bytes2) {
          if (err) {
            return cb(err);
          }
          bytes2.copy(buf, offset);
          cb(null, buf);
        });
        return;
      }
      var bytes = randombytes(size2);
      bytes.copy(buf, offset);
      return buf;
    }
    function randomFillSync(buf, offset, size2) {
      if (typeof offset === "undefined") {
        offset = 0;
      }
      if (!Buffer2.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      assertOffset(offset, buf.length);
      if (size2 === void 0)
        size2 = buf.length - offset;
      assertSize(size2, offset, buf.length);
      return actualFill(buf, offset, size2);
    }
    return browser;
  }
  var hasRequiredCryptoBrowserify;
  function requireCryptoBrowserify() {
    if (hasRequiredCryptoBrowserify)
      return cryptoBrowserify;
    hasRequiredCryptoBrowserify = 1;
    cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b();
    cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9();
    cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
    var algos2 = requireAlgos();
    var algoKeys = Object.keys(algos2);
    var hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
    cryptoBrowserify.getHashes = function() {
      return hashes;
    };
    var p = requireBrowser$7();
    cryptoBrowserify.pbkdf2 = p.pbkdf2;
    cryptoBrowserify.pbkdf2Sync = p.pbkdf2Sync;
    var aes2 = requireBrowser$5();
    cryptoBrowserify.Cipher = aes2.Cipher;
    cryptoBrowserify.createCipher = aes2.createCipher;
    cryptoBrowserify.Cipheriv = aes2.Cipheriv;
    cryptoBrowserify.createCipheriv = aes2.createCipheriv;
    cryptoBrowserify.Decipher = aes2.Decipher;
    cryptoBrowserify.createDecipher = aes2.createDecipher;
    cryptoBrowserify.Decipheriv = aes2.Decipheriv;
    cryptoBrowserify.createDecipheriv = aes2.createDecipheriv;
    cryptoBrowserify.getCiphers = aes2.getCiphers;
    cryptoBrowserify.listCiphers = aes2.listCiphers;
    var dh2 = requireBrowser$4();
    cryptoBrowserify.DiffieHellmanGroup = dh2.DiffieHellmanGroup;
    cryptoBrowserify.createDiffieHellmanGroup = dh2.createDiffieHellmanGroup;
    cryptoBrowserify.getDiffieHellman = dh2.getDiffieHellman;
    cryptoBrowserify.createDiffieHellman = dh2.createDiffieHellman;
    cryptoBrowserify.DiffieHellman = dh2.DiffieHellman;
    var sign2 = requireBrowser$3();
    cryptoBrowserify.createSign = sign2.createSign;
    cryptoBrowserify.Sign = sign2.Sign;
    cryptoBrowserify.createVerify = sign2.createVerify;
    cryptoBrowserify.Verify = sign2.Verify;
    cryptoBrowserify.createECDH = requireBrowser$2();
    var publicEncrypt2 = requireBrowser$1();
    cryptoBrowserify.publicEncrypt = publicEncrypt2.publicEncrypt;
    cryptoBrowserify.privateEncrypt = publicEncrypt2.privateEncrypt;
    cryptoBrowserify.publicDecrypt = publicEncrypt2.publicDecrypt;
    cryptoBrowserify.privateDecrypt = publicEncrypt2.privateDecrypt;
    var rf2 = requireBrowser();
    cryptoBrowserify.randomFill = rf2.randomFill;
    cryptoBrowserify.randomFillSync = rf2.randomFillSync;
    cryptoBrowserify.createCredentials = function() {
      throw new Error([
        "sorry, createCredentials is not implemented yet",
        "we accept pull requests",
        "https://github.com/crypto-browserify/crypto-browserify"
      ].join("\n"));
    };
    cryptoBrowserify.constants = {
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "NPN_ENABLED": 1,
      "ALPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_SSLV23_PADDING": 2,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6
    };
    return cryptoBrowserify;
  }
  (function(module2, exports2) {
    (function(root, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined$1) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto = commonjsGlobal.crypto;
        }
        if (!crypto && typeof commonjsRequire === "function") {
          try {
            crypto = requireCryptoBrowserify();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i10 = 0; i10 < thatSigBytes; i10++) {
                var thatByte = thatWords[i10 >>> 2] >>> 24 - i10 % 4 * 8 & 255;
                thisWords[thisSigBytes + i10 >>> 2] |= thatByte << 24 - (thisSigBytes + i10) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i10 = 0; i10 < nBytes; i10 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i10 = 0; i10 < sigBytes; i10++) {
              var bite = words[i10 >>> 2] >>> 24 - i10 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i10 = 0; i10 < hexStrLength; i10 += 2) {
              words[i10 >>> 3] |= parseInt(hexStr.substr(i10, 2), 16) << 24 - i10 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i10 = 0; i10 < sigBytes; i10++) {
              var bite = words[i10 >>> 2] >>> 24 - i10 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i10 = 0; i10 < latin1StrLength; i10++) {
              words[i10 >>> 2] |= (latin1Str.charCodeAt(i10) & 255) << 24 - i10 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf82 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e8) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf82.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key2) {
              return new C_algo.HMAC.init(hasher, key2).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  })(core);
  var coreExports = core.exports;
  const CryptoJS = /* @__PURE__ */ getDefaultExportFromCjs(coreExports);
  var sha256$1 = { exports: {} };
  (function(module2, exports2) {
    (function(root, factory) {
      {
        module2.exports = factory(coreExports);
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H2 = [];
        var K5 = [];
        (function() {
          function isPrime(n10) {
            var sqrtN = Math2.sqrt(n10);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n10 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n10) {
            return (n10 - (n10 | 0)) * 4294967296 | 0;
          }
          var n8 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n8)) {
              if (nPrime < 8) {
                H2[nPrime] = getFractionalBits(Math2.pow(n8, 1 / 2));
              }
              K5[nPrime] = getFractionalBits(Math2.pow(n8, 1 / 3));
              nPrime++;
            }
            n8++;
          }
        })();
        var W5 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H2.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H5 = this._hash.words;
            var a = H5[0];
            var b = H5[1];
            var c = H5[2];
            var d = H5[3];
            var e8 = H5[4];
            var f = H5[5];
            var g = H5[6];
            var h = H5[7];
            for (var i10 = 0; i10 < 64; i10++) {
              if (i10 < 16) {
                W5[i10] = M[offset + i10] | 0;
              } else {
                var gamma0x = W5[i10 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W5[i10 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W5[i10] = gamma0 + W5[i10 - 7] + gamma1 + W5[i10 - 16];
              }
              var ch2 = e8 & f ^ ~e8 & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e8 << 26 | e8 >>> 6) ^ (e8 << 21 | e8 >>> 11) ^ (e8 << 7 | e8 >>> 25);
              var t12 = h + sigma1 + ch2 + K5[i10] + W5[i10];
              var t22 = sigma0 + maj;
              h = g;
              g = f;
              f = e8;
              e8 = d + t12 | 0;
              d = c;
              c = b;
              b = a;
              a = t12 + t22 | 0;
            }
            H5[0] = H5[0] + a | 0;
            H5[1] = H5[1] + b | 0;
            H5[2] = H5[2] + c | 0;
            H5[3] = H5[3] + d | 0;
            H5[4] = H5[4] + e8 | 0;
            H5[5] = H5[5] + f | 0;
            H5[6] = H5[6] + g | 0;
            H5[7] = H5[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  })(sha256$1);
  var sha256Exports = sha256$1.exports;
  const sha256 = /* @__PURE__ */ getDefaultExportFromCjs(sha256Exports);
  var encBase64 = { exports: {} };
  (function(module2, exports2) {
    (function(root, factory) {
      {
        module2.exports = factory(coreExports);
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i10 = 0; i10 < sigBytes; i10 += 3) {
              var byte1 = words[i10 >>> 2] >>> 24 - i10 % 4 * 8 & 255;
              var byte2 = words[i10 + 1 >>> 2] >>> 24 - (i10 + 1) % 4 * 8 & 255;
              var byte3 = words[i10 + 2 >>> 2] >>> 24 - (i10 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i10 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i10 = 0; i10 < base64StrLength; i10++) {
            if (i10 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i10 - 1)] << i10 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i10)] >>> 6 - i10 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  })(encBase64);
  var encBase64Exports = encBase64.exports;
  const Base64 = /* @__PURE__ */ getDefaultExportFromCjs(encBase64Exports);
  var encUtf8 = { exports: {} };
  (function(module2, exports2) {
    (function(root, factory) {
      {
        module2.exports = factory(coreExports);
      }
    })(commonjsGlobal, function(CryptoJS2) {
      return CryptoJS2.enc.Utf8;
    });
  })(encUtf8);
  var encUtf8Exports = encUtf8.exports;
  const Utf8 = /* @__PURE__ */ getDefaultExportFromCjs(encUtf8Exports);
  function e(e8) {
    this.message = e8;
  }
  e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
  var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r8) {
    var t8 = String(r8).replace(/=+$/, "");
    if (t8.length % 4 == 1)
      throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var n8, o8, a = 0, i10 = 0, c = ""; o8 = t8.charAt(i10++); ~o8 && (n8 = a % 4 ? 64 * n8 + o8 : o8, a++ % 4) ? c += String.fromCharCode(255 & n8 >> (-2 * a & 6)) : 0)
      o8 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o8);
    return c;
  };
  function t$1(e8) {
    var t8 = e8.replace(/-/g, "+").replace(/_/g, "/");
    switch (t8.length % 4) {
      case 0:
        break;
      case 2:
        t8 += "==";
        break;
      case 3:
        t8 += "=";
        break;
      default:
        throw "Illegal base64url string!";
    }
    try {
      return function(e10) {
        return decodeURIComponent(r(e10).replace(/(.)/g, function(e11, r8) {
          var t10 = r8.charCodeAt(0).toString(16).toUpperCase();
          return t10.length < 2 && (t10 = "0" + t10), "%" + t10;
        }));
      }(t8);
    } catch (e10) {
      return r(t8);
    }
  }
  function n(e8) {
    this.message = e8;
  }
  function o(e8, r8) {
    if ("string" != typeof e8)
      throw new n("Invalid token specified");
    var o8 = true === (r8 = r8 || {}).header ? 0 : 1;
    try {
      return JSON.parse(t$1(e8.split(".")[o8]));
    } catch (e10) {
      throw new n("Invalid token specified: " + e10.message);
    }
  }
  n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
  var nopLogger = {
    debug: () => void 0,
    info: () => void 0,
    warn: () => void 0,
    error: () => void 0
  };
  var level;
  var logger;
  var Log = /* @__PURE__ */ ((Log2) => {
    Log2[Log2["NONE"] = 0] = "NONE";
    Log2[Log2["ERROR"] = 1] = "ERROR";
    Log2[Log2["WARN"] = 2] = "WARN";
    Log2[Log2["INFO"] = 3] = "INFO";
    Log2[Log2["DEBUG"] = 4] = "DEBUG";
    return Log2;
  })(Log || {});
  ((Log2) => {
    function reset2() {
      level = 3;
      logger = nopLogger;
    }
    Log2.reset = reset2;
    function setLevel(value) {
      if (!(0 <= value && value <= 4)) {
        throw new Error("Invalid log level");
      }
      level = value;
    }
    Log2.setLevel = setLevel;
    function setLogger(value) {
      logger = value;
    }
    Log2.setLogger = setLogger;
  })(Log || (Log = {}));
  var Logger = class {
    constructor(_name) {
      this._name = _name;
    }
    debug(...args) {
      if (level >= 4) {
        logger.debug(Logger._format(this._name, this._method), ...args);
      }
    }
    info(...args) {
      if (level >= 3) {
        logger.info(Logger._format(this._name, this._method), ...args);
      }
    }
    warn(...args) {
      if (level >= 2) {
        logger.warn(Logger._format(this._name, this._method), ...args);
      }
    }
    error(...args) {
      if (level >= 1) {
        logger.error(Logger._format(this._name, this._method), ...args);
      }
    }
    throw(err) {
      this.error(err);
      throw err;
    }
    create(method) {
      const methodLogger = Object.create(this);
      methodLogger._method = method;
      methodLogger.debug("begin");
      return methodLogger;
    }
    static createStatic(name2, staticMethod) {
      const staticLogger = new Logger(`${name2}.${staticMethod}`);
      staticLogger.debug("begin");
      return staticLogger;
    }
    static _format(name2, method) {
      const prefix = `[${name2}]`;
      return method ? `${prefix} ${method}:` : prefix;
    }
    // helpers for static class methods
    static debug(name2, ...args) {
      if (level >= 4) {
        logger.debug(Logger._format(name2), ...args);
      }
    }
    static info(name2, ...args) {
      if (level >= 3) {
        logger.info(Logger._format(name2), ...args);
      }
    }
    static warn(name2, ...args) {
      if (level >= 2) {
        logger.warn(Logger._format(name2), ...args);
      }
    }
    static error(name2, ...args) {
      if (level >= 1) {
        logger.error(Logger._format(name2), ...args);
      }
    }
  };
  Log.reset();
  var UUID_V4_TEMPLATE = "10000000-1000-4000-8000-100000000000";
  var CryptoUtils = class {
    static _randomWord() {
      return CryptoJS.lib.WordArray.random(1).words[0];
    }
    /**
     * Generates RFC4122 version 4 guid
     */
    static generateUUIDv4() {
      const uuid = UUID_V4_TEMPLATE.replace(
        /[018]/g,
        (c) => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)
      );
      return uuid.replace(/-/g, "");
    }
    /**
     * PKCE: Generate a code verifier
     */
    static generateCodeVerifier() {
      return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();
    }
    /**
     * PKCE: Generate a code challenge
     */
    static generateCodeChallenge(code_verifier) {
      try {
        const hashed = sha256(code_verifier);
        return Base64.stringify(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
      } catch (err) {
        Logger.error("CryptoUtils.generateCodeChallenge", err);
        throw err;
      }
    }
    /**
     * Generates a base64-encoded string for a basic auth header
     */
    static generateBasicAuth(client_id, client_secret) {
      const basicAuth = Utf8.parse([client_id, client_secret].join(":"));
      return Base64.stringify(basicAuth);
    }
  };
  var Event$1 = class Event {
    constructor(_name) {
      this._name = _name;
      this._logger = new Logger(`Event('${this._name}')`);
      this._callbacks = [];
    }
    addHandler(cb) {
      this._callbacks.push(cb);
      return () => this.removeHandler(cb);
    }
    removeHandler(cb) {
      const idx = this._callbacks.lastIndexOf(cb);
      if (idx >= 0) {
        this._callbacks.splice(idx, 1);
      }
    }
    raise(...ev2) {
      this._logger.debug("raise:", ...ev2);
      for (const cb of this._callbacks) {
        void cb(...ev2);
      }
    }
  };
  var JwtUtils = class {
    // IMPORTANT: doesn't validate the token
    static decode(token) {
      try {
        return o(token);
      } catch (err) {
        Logger.error("JwtUtils.decode", err);
        throw err;
      }
    }
  };
  var PopupUtils = class {
    /**
     * Populates a map of window features with a placement centered in front of
     * the current window. If no explicit width is given, a default value is
     * binned into [800, 720, 600, 480, 360] based on the current window's width.
     */
    static center({ ...features }) {
      var _a3, _b2, _c3;
      if (features.width == null)
        features.width = (_a3 = [800, 720, 600, 480].find((width) => width <= window.outerWidth / 1.618)) != null ? _a3 : 360;
      (_b2 = features.left) != null ? _b2 : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));
      if (features.height != null)
        (_c3 = features.top) != null ? _c3 : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));
      return features;
    }
    static serialize(features) {
      return Object.entries(features).filter(([, value]) => value != null).map(([key2, value]) => `${key2}=${typeof value !== "boolean" ? value : value ? "yes" : "no"}`).join(",");
    }
  };
  var Timer = class extends Event$1 {
    constructor() {
      super(...arguments);
      this._logger = new Logger(`Timer('${this._name}')`);
      this._timerHandle = null;
      this._expiration = 0;
      this._callback = () => {
        const diff = this._expiration - Timer.getEpochTime();
        this._logger.debug("timer completes in", diff);
        if (this._expiration <= Timer.getEpochTime()) {
          this.cancel();
          super.raise();
        }
      };
    }
    // get the time
    static getEpochTime() {
      return Math.floor(Date.now() / 1e3);
    }
    init(durationInSeconds) {
      const logger2 = this._logger.create("init");
      durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);
      const expiration = Timer.getEpochTime() + durationInSeconds;
      if (this.expiration === expiration && this._timerHandle) {
        logger2.debug("skipping since already initialized for expiration at", this.expiration);
        return;
      }
      this.cancel();
      logger2.debug("using duration", durationInSeconds);
      this._expiration = expiration;
      const timerDurationInSeconds = Math.min(durationInSeconds, 5);
      this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);
    }
    get expiration() {
      return this._expiration;
    }
    cancel() {
      this._logger.create("cancel");
      if (this._timerHandle) {
        clearInterval(this._timerHandle);
        this._timerHandle = null;
      }
    }
  };
  var UrlUtils = class {
    static readParams(url2, responseMode = "query") {
      if (!url2)
        throw new TypeError("Invalid URL");
      const parsedUrl = new URL(url2, "http://127.0.0.1");
      const params = parsedUrl[responseMode === "fragment" ? "hash" : "search"];
      return new URLSearchParams(params.slice(1));
    }
  };
  var ErrorResponse = class extends Error {
    constructor(args, form) {
      var _a3, _b2, _c3;
      super(args.error_description || args.error || "");
      this.form = form;
      this.name = "ErrorResponse";
      if (!args.error) {
        Logger.error("ErrorResponse", "No error passed");
        throw new Error("No error passed");
      }
      this.error = args.error;
      this.error_description = (_a3 = args.error_description) != null ? _a3 : null;
      this.error_uri = (_b2 = args.error_uri) != null ? _b2 : null;
      this.state = args.userState;
      this.session_state = (_c3 = args.session_state) != null ? _c3 : null;
    }
  };
  var ErrorTimeout = class extends Error {
    constructor(message) {
      super(message);
      this.name = "ErrorTimeout";
    }
  };
  var AccessTokenEvents = class {
    constructor(args) {
      this._logger = new Logger("AccessTokenEvents");
      this._expiringTimer = new Timer("Access token expiring");
      this._expiredTimer = new Timer("Access token expired");
      this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;
    }
    load(container) {
      const logger2 = this._logger.create("load");
      if (container.access_token && container.expires_in !== void 0) {
        const duration = container.expires_in;
        logger2.debug("access token present, remaining duration:", duration);
        if (duration > 0) {
          let expiring = duration - this._expiringNotificationTimeInSeconds;
          if (expiring <= 0) {
            expiring = 1;
          }
          logger2.debug("registering expiring timer, raising in", expiring, "seconds");
          this._expiringTimer.init(expiring);
        } else {
          logger2.debug("canceling existing expiring timer because we're past expiration.");
          this._expiringTimer.cancel();
        }
        const expired = duration + 1;
        logger2.debug("registering expired timer, raising in", expired, "seconds");
        this._expiredTimer.init(expired);
      } else {
        this._expiringTimer.cancel();
        this._expiredTimer.cancel();
      }
    }
    unload() {
      this._logger.debug("unload: canceling existing access token timers");
      this._expiringTimer.cancel();
      this._expiredTimer.cancel();
    }
    /**
     * Add callback: Raised prior to the access token expiring.
     */
    addAccessTokenExpiring(cb) {
      return this._expiringTimer.addHandler(cb);
    }
    /**
     * Remove callback: Raised prior to the access token expiring.
     */
    removeAccessTokenExpiring(cb) {
      this._expiringTimer.removeHandler(cb);
    }
    /**
     * Add callback: Raised after the access token has expired.
     */
    addAccessTokenExpired(cb) {
      return this._expiredTimer.addHandler(cb);
    }
    /**
     * Remove callback: Raised after the access token has expired.
     */
    removeAccessTokenExpired(cb) {
      this._expiredTimer.removeHandler(cb);
    }
  };
  var CheckSessionIFrame = class {
    constructor(_callback, _client_id, url2, _intervalInSeconds, _stopOnError) {
      this._callback = _callback;
      this._client_id = _client_id;
      this._intervalInSeconds = _intervalInSeconds;
      this._stopOnError = _stopOnError;
      this._logger = new Logger("CheckSessionIFrame");
      this._timer = null;
      this._session_state = null;
      this._message = (e8) => {
        if (e8.origin === this._frame_origin && e8.source === this._frame.contentWindow) {
          if (e8.data === "error") {
            this._logger.error("error message from check session op iframe");
            if (this._stopOnError) {
              this.stop();
            }
          } else if (e8.data === "changed") {
            this._logger.debug("changed message from check session op iframe");
            this.stop();
            void this._callback();
          } else {
            this._logger.debug(e8.data + " message from check session op iframe");
          }
        }
      };
      const parsedUrl = new URL(url2);
      this._frame_origin = parsedUrl.origin;
      this._frame = window.document.createElement("iframe");
      this._frame.style.visibility = "hidden";
      this._frame.style.position = "fixed";
      this._frame.style.left = "-1000px";
      this._frame.style.top = "0";
      this._frame.width = "0";
      this._frame.height = "0";
      this._frame.src = parsedUrl.href;
    }
    load() {
      return new Promise((resolve) => {
        this._frame.onload = () => {
          resolve();
        };
        window.document.body.appendChild(this._frame);
        window.addEventListener("message", this._message, false);
      });
    }
    start(session_state) {
      if (this._session_state === session_state) {
        return;
      }
      this._logger.create("start");
      this.stop();
      this._session_state = session_state;
      const send = () => {
        if (!this._frame.contentWindow || !this._session_state) {
          return;
        }
        this._frame.contentWindow.postMessage(this._client_id + " " + this._session_state, this._frame_origin);
      };
      send();
      this._timer = setInterval(send, this._intervalInSeconds * 1e3);
    }
    stop() {
      this._logger.create("stop");
      this._session_state = null;
      if (this._timer) {
        clearInterval(this._timer);
        this._timer = null;
      }
    }
  };
  var InMemoryWebStorage = class {
    constructor() {
      this._logger = new Logger("InMemoryWebStorage");
      this._data = {};
    }
    clear() {
      this._logger.create("clear");
      this._data = {};
    }
    getItem(key2) {
      this._logger.create(`getItem('${key2}')`);
      return this._data[key2];
    }
    setItem(key2, value) {
      this._logger.create(`setItem('${key2}')`);
      this._data[key2] = value;
    }
    removeItem(key2) {
      this._logger.create(`removeItem('${key2}')`);
      delete this._data[key2];
    }
    get length() {
      return Object.getOwnPropertyNames(this._data).length;
    }
    key(index2) {
      return Object.getOwnPropertyNames(this._data)[index2];
    }
  };
  var JsonService = class {
    constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {
      this._jwtHandler = _jwtHandler;
      this._extraHeaders = _extraHeaders;
      this._logger = new Logger("JsonService");
      this._contentTypes = [];
      this._contentTypes.push(...additionalContentTypes, "application/json");
      if (_jwtHandler) {
        this._contentTypes.push("application/jwt");
      }
    }
    async fetchWithTimeout(input, init4 = {}) {
      const { timeoutInSeconds, ...initFetch } = init4;
      if (!timeoutInSeconds) {
        return await fetch(input, initFetch);
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);
      try {
        const response = await fetch(input, {
          ...init4,
          signal: controller.signal
        });
        return response;
      } catch (err) {
        if (err instanceof DOMException && err.name === "AbortError") {
          throw new ErrorTimeout("Network timed out");
        }
        throw err;
      } finally {
        clearTimeout(timeoutId);
      }
    }
    async getJson(url2, {
      token,
      credentials
    } = {}) {
      const logger2 = this._logger.create("getJson");
      const headers = {
        "Accept": this._contentTypes.join(", ")
      };
      if (token) {
        logger2.debug("token passed, setting Authorization header");
        headers["Authorization"] = "Bearer " + token;
      }
      this.appendExtraHeaders(headers);
      let response;
      try {
        logger2.debug("url:", url2);
        response = await this.fetchWithTimeout(url2, { method: "GET", headers, credentials });
      } catch (err) {
        logger2.error("Network Error");
        throw err;
      }
      logger2.debug("HTTP response received, status", response.status);
      const contentType = response.headers.get("Content-Type");
      if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {
        logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : "undefined"}, from URL: ${url2}`));
      }
      if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith("application/jwt"))) {
        return await this._jwtHandler(await response.text());
      }
      let json;
      try {
        json = await response.json();
      } catch (err) {
        logger2.error("Error parsing JSON response", err);
        if (response.ok)
          throw err;
        throw new Error(`${response.statusText} (${response.status})`);
      }
      if (!response.ok) {
        logger2.error("Error from server:", json);
        if (json.error) {
          throw new ErrorResponse(json);
        }
        throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);
      }
      return json;
    }
    async postForm(url2, {
      body: body4,
      basicAuth,
      timeoutInSeconds,
      initCredentials
    }) {
      const logger2 = this._logger.create("postForm");
      const headers = {
        "Accept": this._contentTypes.join(", "),
        "Content-Type": "application/x-www-form-urlencoded"
      };
      if (basicAuth !== void 0) {
        headers["Authorization"] = "Basic " + basicAuth;
      }
      this.appendExtraHeaders(headers);
      let response;
      try {
        logger2.debug("url:", url2);
        response = await this.fetchWithTimeout(url2, { method: "POST", headers, body: body4, timeoutInSeconds, credentials: initCredentials });
      } catch (err) {
        logger2.error("Network error");
        throw err;
      }
      logger2.debug("HTTP response received, status", response.status);
      const contentType = response.headers.get("Content-Type");
      if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {
        throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : "undefined"}, from URL: ${url2}`);
      }
      const responseText = await response.text();
      let json = {};
      if (responseText) {
        try {
          json = JSON.parse(responseText);
        } catch (err) {
          logger2.error("Error parsing JSON response", err);
          if (response.ok)
            throw err;
          throw new Error(`${response.statusText} (${response.status})`);
        }
      }
      if (!response.ok) {
        logger2.error("Error from server:", json);
        if (json.error) {
          throw new ErrorResponse(json, body4);
        }
        throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);
      }
      return json;
    }
    appendExtraHeaders(headers) {
      const logger2 = this._logger.create("appendExtraHeaders");
      const customKeys = Object.keys(this._extraHeaders);
      const protectedHeaders = [
        "authorization",
        "accept",
        "content-type"
      ];
      if (customKeys.length === 0) {
        return;
      }
      customKeys.forEach((headerName) => {
        if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {
          logger2.warn("Protected header could not be overridden", headerName, protectedHeaders);
          return;
        }
        const content = typeof this._extraHeaders[headerName] === "function" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];
        if (content && content !== "") {
          headers[headerName] = content;
        }
      });
    }
  };
  var MetadataService = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("MetadataService");
      this._signingKeys = null;
      this._metadata = null;
      this._metadataUrl = this._settings.metadataUrl;
      this._jsonService = new JsonService(
        ["application/jwk-set+json"],
        null,
        this._settings.extraHeaders
      );
      if (this._settings.signingKeys) {
        this._logger.debug("using signingKeys from settings");
        this._signingKeys = this._settings.signingKeys;
      }
      if (this._settings.metadata) {
        this._logger.debug("using metadata from settings");
        this._metadata = this._settings.metadata;
      }
      if (this._settings.fetchRequestCredentials) {
        this._logger.debug("using fetchRequestCredentials from settings");
        this._fetchRequestCredentials = this._settings.fetchRequestCredentials;
      }
    }
    resetSigningKeys() {
      this._signingKeys = null;
    }
    async getMetadata() {
      const logger2 = this._logger.create("getMetadata");
      if (this._metadata) {
        logger2.debug("using cached values");
        return this._metadata;
      }
      if (!this._metadataUrl) {
        logger2.throw(new Error("No authority or metadataUrl configured on settings"));
        throw null;
      }
      logger2.debug("getting metadata from", this._metadataUrl);
      const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });
      logger2.debug("merging remote JSON with seed metadata");
      this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);
      return this._metadata;
    }
    getIssuer() {
      return this._getMetadataProperty("issuer");
    }
    getAuthorizationEndpoint() {
      return this._getMetadataProperty("authorization_endpoint");
    }
    getUserInfoEndpoint() {
      return this._getMetadataProperty("userinfo_endpoint");
    }
    getTokenEndpoint(optional = true) {
      return this._getMetadataProperty("token_endpoint", optional);
    }
    getCheckSessionIframe() {
      return this._getMetadataProperty("check_session_iframe", true);
    }
    getEndSessionEndpoint() {
      return this._getMetadataProperty("end_session_endpoint", true);
    }
    getRevocationEndpoint(optional = true) {
      return this._getMetadataProperty("revocation_endpoint", optional);
    }
    getKeysEndpoint(optional = true) {
      return this._getMetadataProperty("jwks_uri", optional);
    }
    async _getMetadataProperty(name2, optional = false) {
      const logger2 = this._logger.create(`_getMetadataProperty('${name2}')`);
      const metadata = await this.getMetadata();
      logger2.debug("resolved");
      if (metadata[name2] === void 0) {
        if (optional === true) {
          logger2.warn("Metadata does not contain optional property");
          return void 0;
        }
        logger2.throw(new Error("Metadata does not contain property " + name2));
      }
      return metadata[name2];
    }
    async getSigningKeys() {
      const logger2 = this._logger.create("getSigningKeys");
      if (this._signingKeys) {
        logger2.debug("returning signingKeys from cache");
        return this._signingKeys;
      }
      const jwks_uri = await this.getKeysEndpoint(false);
      logger2.debug("got jwks_uri", jwks_uri);
      const keySet = await this._jsonService.getJson(jwks_uri);
      logger2.debug("got key set", keySet);
      if (!Array.isArray(keySet.keys)) {
        logger2.throw(new Error("Missing keys on keyset"));
        throw null;
      }
      this._signingKeys = keySet.keys;
      return this._signingKeys;
    }
  };
  var WebStorageStateStore = class {
    constructor({
      prefix = "oidc.",
      store = localStorage
    } = {}) {
      this._logger = new Logger("WebStorageStateStore");
      this._store = store;
      this._prefix = prefix;
    }
    async set(key2, value) {
      this._logger.create(`set('${key2}')`);
      key2 = this._prefix + key2;
      await this._store.setItem(key2, value);
    }
    async get(key2) {
      this._logger.create(`get('${key2}')`);
      key2 = this._prefix + key2;
      const item = await this._store.getItem(key2);
      return item;
    }
    async remove(key2) {
      this._logger.create(`remove('${key2}')`);
      key2 = this._prefix + key2;
      const item = await this._store.getItem(key2);
      await this._store.removeItem(key2);
      return item;
    }
    async getAllKeys() {
      this._logger.create("getAllKeys");
      const len2 = await this._store.length;
      const keys = [];
      for (let index2 = 0; index2 < len2; index2++) {
        const key2 = await this._store.key(index2);
        if (key2 && key2.indexOf(this._prefix) === 0) {
          keys.push(key2.substr(this._prefix.length));
        }
      }
      return keys;
    }
  };
  var DefaultResponseType = "code";
  var DefaultScope = "openid";
  var DefaultClientAuthentication = "client_secret_post";
  var DefaultResponseMode = "query";
  var DefaultStaleStateAgeInSeconds = 60 * 15;
  var DefaultClockSkewInSeconds = 60 * 5;
  var OidcClientSettingsStore = class {
    constructor({
      // metadata related
      authority,
      metadataUrl,
      metadata,
      signingKeys,
      metadataSeed,
      // client related
      client_id,
      client_secret,
      response_type = DefaultResponseType,
      scope = DefaultScope,
      redirect_uri,
      post_logout_redirect_uri,
      client_authentication = DefaultClientAuthentication,
      // optional protocol
      prompt,
      display,
      max_age,
      ui_locales,
      acr_values,
      resource,
      response_mode = DefaultResponseMode,
      // behavior flags
      filterProtocolClaims = true,
      loadUserInfo = false,
      staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,
      clockSkewInSeconds = DefaultClockSkewInSeconds,
      userInfoJwtIssuer = "OP",
      mergeClaims = false,
      disablePKCE = false,
      // other behavior
      stateStore,
      refreshTokenCredentials,
      revokeTokenAdditionalContentTypes,
      fetchRequestCredentials,
      refreshTokenAllowedScope,
      // extra
      extraQueryParams = {},
      extraTokenParams = {},
      extraHeaders = {}
    }) {
      this.authority = authority;
      if (metadataUrl) {
        this.metadataUrl = metadataUrl;
      } else {
        this.metadataUrl = authority;
        if (authority) {
          if (!this.metadataUrl.endsWith("/")) {
            this.metadataUrl += "/";
          }
          this.metadataUrl += ".well-known/openid-configuration";
        }
      }
      this.metadata = metadata;
      this.metadataSeed = metadataSeed;
      this.signingKeys = signingKeys;
      this.client_id = client_id;
      this.client_secret = client_secret;
      this.response_type = response_type;
      this.scope = scope;
      this.redirect_uri = redirect_uri;
      this.post_logout_redirect_uri = post_logout_redirect_uri;
      this.client_authentication = client_authentication;
      this.prompt = prompt;
      this.display = display;
      this.max_age = max_age;
      this.ui_locales = ui_locales;
      this.acr_values = acr_values;
      this.resource = resource;
      this.response_mode = response_mode;
      this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;
      this.loadUserInfo = !!loadUserInfo;
      this.staleStateAgeInSeconds = staleStateAgeInSeconds;
      this.clockSkewInSeconds = clockSkewInSeconds;
      this.userInfoJwtIssuer = userInfoJwtIssuer;
      this.mergeClaims = !!mergeClaims;
      this.disablePKCE = !!disablePKCE;
      this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;
      if (fetchRequestCredentials && refreshTokenCredentials) {
        console.warn("Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.");
      }
      this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : refreshTokenCredentials ? refreshTokenCredentials : "same-origin";
      if (stateStore) {
        this.stateStore = stateStore;
      } else {
        const store = typeof window !== "undefined" ? window.localStorage : new InMemoryWebStorage();
        this.stateStore = new WebStorageStateStore({ store });
      }
      this.refreshTokenAllowedScope = refreshTokenAllowedScope;
      this.extraQueryParams = extraQueryParams;
      this.extraTokenParams = extraTokenParams;
      this.extraHeaders = extraHeaders;
    }
  };
  var UserInfoService = class {
    constructor(_settings, _metadataService) {
      this._settings = _settings;
      this._metadataService = _metadataService;
      this._logger = new Logger("UserInfoService");
      this._getClaimsFromJwt = async (responseText) => {
        const logger2 = this._logger.create("_getClaimsFromJwt");
        try {
          const payload = JwtUtils.decode(responseText);
          logger2.debug("JWT decoding successful");
          return payload;
        } catch (err) {
          logger2.error("Error parsing JWT response");
          throw err;
        }
      };
      this._jsonService = new JsonService(
        void 0,
        this._getClaimsFromJwt,
        this._settings.extraHeaders
      );
    }
    async getClaims(token) {
      const logger2 = this._logger.create("getClaims");
      if (!token) {
        this._logger.throw(new Error("No token passed"));
      }
      const url2 = await this._metadataService.getUserInfoEndpoint();
      logger2.debug("got userinfo url", url2);
      const claims = await this._jsonService.getJson(url2, {
        token,
        credentials: this._settings.fetchRequestCredentials
      });
      logger2.debug("got claims", claims);
      return claims;
    }
  };
  var TokenClient = class {
    constructor(_settings, _metadataService) {
      this._settings = _settings;
      this._metadataService = _metadataService;
      this._logger = new Logger("TokenClient");
      this._jsonService = new JsonService(
        this._settings.revokeTokenAdditionalContentTypes,
        null,
        this._settings.extraHeaders
      );
    }
    /**
     * Exchange code.
     *
     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3
     */
    async exchangeCode({
      grant_type = "authorization_code",
      redirect_uri = this._settings.redirect_uri,
      client_id = this._settings.client_id,
      client_secret = this._settings.client_secret,
      ...args
    }) {
      const logger2 = this._logger.create("exchangeCode");
      if (!client_id) {
        logger2.throw(new Error("A client_id is required"));
      }
      if (!redirect_uri) {
        logger2.throw(new Error("A redirect_uri is required"));
      }
      if (!args.code) {
        logger2.throw(new Error("A code is required"));
      }
      const params = new URLSearchParams({ grant_type, redirect_uri });
      for (const [key2, value] of Object.entries(args)) {
        if (value != null) {
          params.set(key2, value);
        }
      }
      let basicAuth;
      switch (this._settings.client_authentication) {
        case "client_secret_basic":
          if (!client_secret) {
            logger2.throw(new Error("A client_secret is required"));
            throw null;
          }
          basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);
          break;
        case "client_secret_post":
          params.append("client_id", client_id);
          if (client_secret) {
            params.append("client_secret", client_secret);
          }
          break;
      }
      const url2 = await this._metadataService.getTokenEndpoint(false);
      logger2.debug("got token endpoint");
      const response = await this._jsonService.postForm(url2, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });
      logger2.debug("got response");
      return response;
    }
    /**
     * Exchange credentials.
     *
     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2
     */
    async exchangeCredentials({
      grant_type = "password",
      client_id = this._settings.client_id,
      client_secret = this._settings.client_secret,
      scope = this._settings.scope,
      ...args
    }) {
      const logger2 = this._logger.create("exchangeCredentials");
      if (!client_id) {
        logger2.throw(new Error("A client_id is required"));
      }
      const params = new URLSearchParams({ grant_type, scope });
      for (const [key2, value] of Object.entries(args)) {
        if (value != null) {
          params.set(key2, value);
        }
      }
      let basicAuth;
      switch (this._settings.client_authentication) {
        case "client_secret_basic":
          if (!client_secret) {
            logger2.throw(new Error("A client_secret is required"));
            throw null;
          }
          basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);
          break;
        case "client_secret_post":
          params.append("client_id", client_id);
          if (client_secret) {
            params.append("client_secret", client_secret);
          }
          break;
      }
      const url2 = await this._metadataService.getTokenEndpoint(false);
      logger2.debug("got token endpoint");
      const response = await this._jsonService.postForm(url2, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });
      logger2.debug("got response");
      return response;
    }
    /**
     * Exchange a refresh token.
     *
     * @see https://www.rfc-editor.org/rfc/rfc6749#section-6
     */
    async exchangeRefreshToken({
      grant_type = "refresh_token",
      client_id = this._settings.client_id,
      client_secret = this._settings.client_secret,
      timeoutInSeconds,
      ...args
    }) {
      const logger2 = this._logger.create("exchangeRefreshToken");
      if (!client_id) {
        logger2.throw(new Error("A client_id is required"));
      }
      if (!args.refresh_token) {
        logger2.throw(new Error("A refresh_token is required"));
      }
      const params = new URLSearchParams({ grant_type });
      for (const [key2, value] of Object.entries(args)) {
        if (value != null) {
          params.set(key2, value);
        }
      }
      let basicAuth;
      switch (this._settings.client_authentication) {
        case "client_secret_basic":
          if (!client_secret) {
            logger2.throw(new Error("A client_secret is required"));
            throw null;
          }
          basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);
          break;
        case "client_secret_post":
          params.append("client_id", client_id);
          if (client_secret) {
            params.append("client_secret", client_secret);
          }
          break;
      }
      const url2 = await this._metadataService.getTokenEndpoint(false);
      logger2.debug("got token endpoint");
      const response = await this._jsonService.postForm(url2, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });
      logger2.debug("got response");
      return response;
    }
    /**
     * Revoke an access or refresh token.
     *
     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1
     */
    async revoke(args) {
      var _a3;
      const logger2 = this._logger.create("revoke");
      if (!args.token) {
        logger2.throw(new Error("A token is required"));
      }
      const url2 = await this._metadataService.getRevocationEndpoint(false);
      logger2.debug(`got revocation endpoint, revoking ${(_a3 = args.token_type_hint) != null ? _a3 : "default token type"}`);
      const params = new URLSearchParams();
      for (const [key2, value] of Object.entries(args)) {
        if (value != null) {
          params.set(key2, value);
        }
      }
      params.set("client_id", this._settings.client_id);
      if (this._settings.client_secret) {
        params.set("client_secret", this._settings.client_secret);
      }
      await this._jsonService.postForm(url2, { body: params });
      logger2.debug("got response");
    }
  };
  var ResponseValidator = class {
    constructor(_settings, _metadataService, _claimsService) {
      this._settings = _settings;
      this._metadataService = _metadataService;
      this._claimsService = _claimsService;
      this._logger = new Logger("ResponseValidator");
      this._userInfoService = new UserInfoService(this._settings, this._metadataService);
      this._tokenClient = new TokenClient(this._settings, this._metadataService);
    }
    async validateSigninResponse(response, state2) {
      const logger2 = this._logger.create("validateSigninResponse");
      this._processSigninState(response, state2);
      logger2.debug("state processed");
      await this._processCode(response, state2);
      logger2.debug("code processed");
      if (response.isOpenId) {
        this._validateIdTokenAttributes(response);
      }
      logger2.debug("tokens validated");
      await this._processClaims(response, state2 == null ? void 0 : state2.skipUserInfo, response.isOpenId);
      logger2.debug("claims processed");
    }
    async validateCredentialsResponse(response, skipUserInfo) {
      const logger2 = this._logger.create("validateCredentialsResponse");
      if (response.isOpenId) {
        this._validateIdTokenAttributes(response);
      }
      logger2.debug("tokens validated");
      await this._processClaims(response, skipUserInfo, response.isOpenId);
      logger2.debug("claims processed");
    }
    async validateRefreshResponse(response, state2) {
      var _a3, _b2;
      const logger2 = this._logger.create("validateRefreshResponse");
      response.userState = state2.data;
      (_a3 = response.session_state) != null ? _a3 : response.session_state = state2.session_state;
      (_b2 = response.scope) != null ? _b2 : response.scope = state2.scope;
      if (response.isOpenId && !!response.id_token) {
        this._validateIdTokenAttributes(response, state2.id_token);
        logger2.debug("ID Token validated");
      }
      if (!response.id_token) {
        response.id_token = state2.id_token;
        response.profile = state2.profile;
      }
      const hasIdToken = response.isOpenId && !!response.id_token;
      await this._processClaims(response, false, hasIdToken);
      logger2.debug("claims processed");
    }
    validateSignoutResponse(response, state2) {
      const logger2 = this._logger.create("validateSignoutResponse");
      if (state2.id !== response.state) {
        logger2.throw(new Error("State does not match"));
      }
      logger2.debug("state validated");
      response.userState = state2.data;
      if (response.error) {
        logger2.warn("Response was error", response.error);
        throw new ErrorResponse(response);
      }
    }
    _processSigninState(response, state2) {
      var _a3;
      const logger2 = this._logger.create("_processSigninState");
      if (state2.id !== response.state) {
        logger2.throw(new Error("State does not match"));
      }
      if (!state2.client_id) {
        logger2.throw(new Error("No client_id on state"));
      }
      if (!state2.authority) {
        logger2.throw(new Error("No authority on state"));
      }
      if (this._settings.authority !== state2.authority) {
        logger2.throw(new Error("authority mismatch on settings vs. signin state"));
      }
      if (this._settings.client_id && this._settings.client_id !== state2.client_id) {
        logger2.throw(new Error("client_id mismatch on settings vs. signin state"));
      }
      logger2.debug("state validated");
      response.userState = state2.data;
      (_a3 = response.scope) != null ? _a3 : response.scope = state2.scope;
      if (response.error) {
        logger2.warn("Response was error", response.error);
        throw new ErrorResponse(response);
      }
      if (state2.code_verifier && !response.code) {
        logger2.throw(new Error("Expected code in response"));
      }
    }
    async _processClaims(response, skipUserInfo = false, validateSub = true) {
      const logger2 = this._logger.create("_processClaims");
      response.profile = this._claimsService.filterProtocolClaims(response.profile);
      if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {
        logger2.debug("not loading user info");
        return;
      }
      logger2.debug("loading user info");
      const claims = await this._userInfoService.getClaims(response.access_token);
      logger2.debug("user info claims received from user info endpoint");
      if (validateSub && claims.sub !== response.profile.sub) {
        logger2.throw(new Error("subject from UserInfo response does not match subject in ID Token"));
      }
      response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));
      logger2.debug("user info claims received, updated profile:", response.profile);
    }
    async _processCode(response, state2) {
      const logger2 = this._logger.create("_processCode");
      if (response.code) {
        logger2.debug("Validating code");
        const tokenResponse = await this._tokenClient.exchangeCode({
          client_id: state2.client_id,
          client_secret: state2.client_secret,
          code: response.code,
          redirect_uri: state2.redirect_uri,
          code_verifier: state2.code_verifier,
          ...state2.extraTokenParams
        });
        Object.assign(response, tokenResponse);
      } else {
        logger2.debug("No code to process");
      }
    }
    _validateIdTokenAttributes(response, existingToken) {
      var _a3;
      const logger2 = this._logger.create("_validateIdTokenAttributes");
      logger2.debug("decoding ID Token JWT");
      const incoming = JwtUtils.decode((_a3 = response.id_token) != null ? _a3 : "");
      if (!incoming.sub) {
        logger2.throw(new Error("ID Token is missing a subject claim"));
      }
      if (existingToken) {
        const existing = JwtUtils.decode(existingToken);
        if (incoming.sub !== existing.sub) {
          logger2.throw(new Error("sub in id_token does not match current sub"));
        }
        if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {
          logger2.throw(new Error("auth_time in id_token does not match original auth_time"));
        }
        if (incoming.azp && incoming.azp !== existing.azp) {
          logger2.throw(new Error("azp in id_token does not match original azp"));
        }
        if (!incoming.azp && existing.azp) {
          logger2.throw(new Error("azp not in id_token, but present in original id_token"));
        }
      }
      response.profile = incoming;
    }
  };
  var State = class {
    constructor(args) {
      this.id = args.id || CryptoUtils.generateUUIDv4();
      this.data = args.data;
      if (args.created && args.created > 0) {
        this.created = args.created;
      } else {
        this.created = Timer.getEpochTime();
      }
      this.request_type = args.request_type;
    }
    toStorageString() {
      new Logger("State").create("toStorageString");
      return JSON.stringify({
        id: this.id,
        data: this.data,
        created: this.created,
        request_type: this.request_type
      });
    }
    static fromStorageString(storageString) {
      Logger.createStatic("State", "fromStorageString");
      return new State(JSON.parse(storageString));
    }
    static async clearStaleState(storage, age2) {
      const logger2 = Logger.createStatic("State", "clearStaleState");
      const cutoff = Timer.getEpochTime() - age2;
      const keys = await storage.getAllKeys();
      logger2.debug("got keys", keys);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key2 = keys[i10];
        const item = await storage.get(key2);
        let remove = false;
        if (item) {
          try {
            const state2 = State.fromStorageString(item);
            logger2.debug("got item from key:", key2, state2.created);
            if (state2.created <= cutoff) {
              remove = true;
            }
          } catch (err) {
            logger2.error("Error parsing state for key:", key2, err);
            remove = true;
          }
        } else {
          logger2.debug("no item in storage for key:", key2);
          remove = true;
        }
        if (remove) {
          logger2.debug("removed item for key:", key2);
          void storage.remove(key2);
        }
      }
    }
  };
  var SigninState = class extends State {
    constructor(args) {
      super(args);
      if (args.code_verifier === true) {
        this.code_verifier = CryptoUtils.generateCodeVerifier();
      } else if (args.code_verifier) {
        this.code_verifier = args.code_verifier;
      }
      if (this.code_verifier) {
        this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);
      }
      this.authority = args.authority;
      this.client_id = args.client_id;
      this.redirect_uri = args.redirect_uri;
      this.scope = args.scope;
      this.client_secret = args.client_secret;
      this.extraTokenParams = args.extraTokenParams;
      this.response_mode = args.response_mode;
      this.skipUserInfo = args.skipUserInfo;
    }
    toStorageString() {
      new Logger("SigninState").create("toStorageString");
      return JSON.stringify({
        id: this.id,
        data: this.data,
        created: this.created,
        request_type: this.request_type,
        code_verifier: this.code_verifier,
        authority: this.authority,
        client_id: this.client_id,
        redirect_uri: this.redirect_uri,
        scope: this.scope,
        client_secret: this.client_secret,
        extraTokenParams: this.extraTokenParams,
        response_mode: this.response_mode,
        skipUserInfo: this.skipUserInfo
      });
    }
    static fromStorageString(storageString) {
      Logger.createStatic("SigninState", "fromStorageString");
      const data = JSON.parse(storageString);
      return new SigninState(data);
    }
  };
  var SigninRequest = class {
    constructor({
      // mandatory
      url: url2,
      authority,
      client_id,
      redirect_uri,
      response_type,
      scope,
      // optional
      state_data,
      response_mode,
      request_type,
      client_secret,
      nonce,
      resource,
      skipUserInfo,
      extraQueryParams,
      extraTokenParams,
      disablePKCE,
      ...optionalParams
    }) {
      this._logger = new Logger("SigninRequest");
      if (!url2) {
        this._logger.error("ctor: No url passed");
        throw new Error("url");
      }
      if (!client_id) {
        this._logger.error("ctor: No client_id passed");
        throw new Error("client_id");
      }
      if (!redirect_uri) {
        this._logger.error("ctor: No redirect_uri passed");
        throw new Error("redirect_uri");
      }
      if (!response_type) {
        this._logger.error("ctor: No response_type passed");
        throw new Error("response_type");
      }
      if (!scope) {
        this._logger.error("ctor: No scope passed");
        throw new Error("scope");
      }
      if (!authority) {
        this._logger.error("ctor: No authority passed");
        throw new Error("authority");
      }
      this.state = new SigninState({
        data: state_data,
        request_type,
        code_verifier: !disablePKCE,
        client_id,
        authority,
        redirect_uri,
        response_mode,
        client_secret,
        scope,
        extraTokenParams,
        skipUserInfo
      });
      const parsedUrl = new URL(url2);
      parsedUrl.searchParams.append("client_id", client_id);
      parsedUrl.searchParams.append("redirect_uri", redirect_uri);
      parsedUrl.searchParams.append("response_type", response_type);
      parsedUrl.searchParams.append("scope", scope);
      if (nonce) {
        parsedUrl.searchParams.append("nonce", nonce);
      }
      parsedUrl.searchParams.append("state", this.state.id);
      if (this.state.code_challenge) {
        parsedUrl.searchParams.append("code_challenge", this.state.code_challenge);
        parsedUrl.searchParams.append("code_challenge_method", "S256");
      }
      if (resource) {
        const resources = Array.isArray(resource) ? resource : [resource];
        resources.forEach((r8) => parsedUrl.searchParams.append("resource", r8));
      }
      for (const [key2, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {
        if (value != null) {
          parsedUrl.searchParams.append(key2, value.toString());
        }
      }
      this.url = parsedUrl.href;
    }
  };
  var OidcScope = "openid";
  var SigninResponse = class {
    constructor(params) {
      this.access_token = "";
      this.token_type = "";
      this.profile = {};
      this.state = params.get("state");
      this.session_state = params.get("session_state");
      this.error = params.get("error");
      this.error_description = params.get("error_description");
      this.error_uri = params.get("error_uri");
      this.code = params.get("code");
    }
    get expires_in() {
      if (this.expires_at === void 0) {
        return void 0;
      }
      return this.expires_at - Timer.getEpochTime();
    }
    set expires_in(value) {
      if (typeof value === "string")
        value = Number(value);
      if (value !== void 0 && value >= 0) {
        this.expires_at = Math.floor(value) + Timer.getEpochTime();
      }
    }
    get isOpenId() {
      var _a3;
      return ((_a3 = this.scope) == null ? void 0 : _a3.split(" ").includes(OidcScope)) || !!this.id_token;
    }
  };
  var SignoutRequest = class {
    constructor({
      url: url2,
      state_data,
      id_token_hint,
      post_logout_redirect_uri,
      extraQueryParams,
      request_type
    }) {
      this._logger = new Logger("SignoutRequest");
      if (!url2) {
        this._logger.error("ctor: No url passed");
        throw new Error("url");
      }
      const parsedUrl = new URL(url2);
      if (id_token_hint) {
        parsedUrl.searchParams.append("id_token_hint", id_token_hint);
      }
      if (post_logout_redirect_uri) {
        parsedUrl.searchParams.append("post_logout_redirect_uri", post_logout_redirect_uri);
        if (state_data) {
          this.state = new State({ data: state_data, request_type });
          parsedUrl.searchParams.append("state", this.state.id);
        }
      }
      for (const [key2, value] of Object.entries({ ...extraQueryParams })) {
        if (value != null) {
          parsedUrl.searchParams.append(key2, value.toString());
        }
      }
      this.url = parsedUrl.href;
    }
  };
  var SignoutResponse = class {
    constructor(params) {
      this.state = params.get("state");
      this.error = params.get("error");
      this.error_description = params.get("error_description");
      this.error_uri = params.get("error_uri");
    }
  };
  var DefaultProtocolClaims = [
    "nbf",
    "jti",
    "auth_time",
    "nonce",
    "acr",
    "amr",
    "azp",
    "at_hash"
    // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken
  ];
  var InternalRequiredProtocolClaims = ["sub", "iss", "aud", "exp", "iat"];
  var ClaimsService = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("ClaimsService");
    }
    filterProtocolClaims(claims) {
      const result = { ...claims };
      if (this._settings.filterProtocolClaims) {
        let protocolClaims;
        if (Array.isArray(this._settings.filterProtocolClaims)) {
          protocolClaims = this._settings.filterProtocolClaims;
        } else {
          protocolClaims = DefaultProtocolClaims;
        }
        for (const claim of protocolClaims) {
          if (!InternalRequiredProtocolClaims.includes(claim)) {
            delete result[claim];
          }
        }
      }
      return result;
    }
    mergeClaims(claims1, claims2) {
      const result = { ...claims1 };
      for (const [claim, values] of Object.entries(claims2)) {
        for (const value of Array.isArray(values) ? values : [values]) {
          const previousValue = result[claim];
          if (!previousValue) {
            result[claim] = value;
          } else if (Array.isArray(previousValue)) {
            if (!previousValue.includes(value)) {
              previousValue.push(value);
            }
          } else if (result[claim] !== value) {
            if (typeof value === "object" && this._settings.mergeClaims) {
              result[claim] = this.mergeClaims(previousValue, value);
            } else {
              result[claim] = [previousValue, value];
            }
          }
        }
      }
      return result;
    }
  };
  var OidcClient = class {
    constructor(settings) {
      this._logger = new Logger("OidcClient");
      this.settings = new OidcClientSettingsStore(settings);
      this.metadataService = new MetadataService(this.settings);
      this._claimsService = new ClaimsService(this.settings);
      this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);
      this._tokenClient = new TokenClient(this.settings, this.metadataService);
    }
    async createSigninRequest({
      state: state2,
      request,
      request_uri,
      request_type,
      id_token_hint,
      login_hint,
      skipUserInfo,
      nonce,
      response_type = this.settings.response_type,
      scope = this.settings.scope,
      redirect_uri = this.settings.redirect_uri,
      prompt = this.settings.prompt,
      display = this.settings.display,
      max_age = this.settings.max_age,
      ui_locales = this.settings.ui_locales,
      acr_values = this.settings.acr_values,
      resource = this.settings.resource,
      response_mode = this.settings.response_mode,
      extraQueryParams = this.settings.extraQueryParams,
      extraTokenParams = this.settings.extraTokenParams
    }) {
      const logger2 = this._logger.create("createSigninRequest");
      if (response_type !== "code") {
        throw new Error("Only the Authorization Code flow (with PKCE) is supported");
      }
      const url2 = await this.metadataService.getAuthorizationEndpoint();
      logger2.debug("Received authorization endpoint", url2);
      const signinRequest = new SigninRequest({
        url: url2,
        authority: this.settings.authority,
        client_id: this.settings.client_id,
        redirect_uri,
        response_type,
        scope,
        state_data: state2,
        prompt,
        display,
        max_age,
        ui_locales,
        id_token_hint,
        login_hint,
        acr_values,
        resource,
        request,
        request_uri,
        extraQueryParams,
        extraTokenParams,
        request_type,
        response_mode,
        client_secret: this.settings.client_secret,
        skipUserInfo,
        nonce,
        disablePKCE: this.settings.disablePKCE
      });
      await this.clearStaleState();
      const signinState = signinRequest.state;
      await this.settings.stateStore.set(signinState.id, signinState.toStorageString());
      return signinRequest;
    }
    async readSigninResponseState(url2, removeState = false) {
      const logger2 = this._logger.create("readSigninResponseState");
      const response = new SigninResponse(UrlUtils.readParams(url2, this.settings.response_mode));
      if (!response.state) {
        logger2.throw(new Error("No state in response"));
        throw null;
      }
      const storedStateString = await this.settings.stateStore[removeState ? "remove" : "get"](response.state);
      if (!storedStateString) {
        logger2.throw(new Error("No matching state found in storage"));
        throw null;
      }
      const state2 = SigninState.fromStorageString(storedStateString);
      return { state: state2, response };
    }
    async processSigninResponse(url2) {
      const logger2 = this._logger.create("processSigninResponse");
      const { state: state2, response } = await this.readSigninResponseState(url2, true);
      logger2.debug("received state from storage; validating response");
      await this._validator.validateSigninResponse(response, state2);
      return response;
    }
    async processResourceOwnerPasswordCredentials({
      username,
      password,
      skipUserInfo = false,
      extraTokenParams = {}
    }) {
      const tokenResponse = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });
      const signinResponse = new SigninResponse(new URLSearchParams());
      Object.assign(signinResponse, tokenResponse);
      await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);
      return signinResponse;
    }
    async useRefreshToken({
      state: state2,
      timeoutInSeconds
    }) {
      var _a3;
      const logger2 = this._logger.create("useRefreshToken");
      let scope;
      if (this.settings.refreshTokenAllowedScope === void 0) {
        scope = state2.scope;
      } else {
        const allowableScopes = this.settings.refreshTokenAllowedScope.split(" ");
        const providedScopes = ((_a3 = state2.scope) == null ? void 0 : _a3.split(" ")) || [];
        scope = providedScopes.filter((s) => allowableScopes.includes(s)).join(" ");
      }
      const result = await this._tokenClient.exchangeRefreshToken({
        refresh_token: state2.refresh_token,
        // provide the (possible filtered) scope list
        scope,
        timeoutInSeconds
      });
      const response = new SigninResponse(new URLSearchParams());
      Object.assign(response, result);
      logger2.debug("validating response", response);
      await this._validator.validateRefreshResponse(response, {
        ...state2,
        // overide the scope in the state handed over to the validator
        // so it can set the granted scope to the requested scope in case none is included in the response
        scope
      });
      return response;
    }
    async createSignoutRequest({
      state: state2,
      id_token_hint,
      request_type,
      post_logout_redirect_uri = this.settings.post_logout_redirect_uri,
      extraQueryParams = this.settings.extraQueryParams
    } = {}) {
      const logger2 = this._logger.create("createSignoutRequest");
      const url2 = await this.metadataService.getEndSessionEndpoint();
      if (!url2) {
        logger2.throw(new Error("No end session endpoint"));
        throw null;
      }
      logger2.debug("Received end session endpoint", url2);
      const request = new SignoutRequest({
        url: url2,
        id_token_hint,
        post_logout_redirect_uri,
        state_data: state2,
        extraQueryParams,
        request_type
      });
      await this.clearStaleState();
      const signoutState = request.state;
      if (signoutState) {
        logger2.debug("Signout request has state to persist");
        await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());
      }
      return request;
    }
    async readSignoutResponseState(url2, removeState = false) {
      const logger2 = this._logger.create("readSignoutResponseState");
      const response = new SignoutResponse(UrlUtils.readParams(url2, this.settings.response_mode));
      if (!response.state) {
        logger2.debug("No state in response");
        if (response.error) {
          logger2.warn("Response was error:", response.error);
          throw new ErrorResponse(response);
        }
        return { state: void 0, response };
      }
      const storedStateString = await this.settings.stateStore[removeState ? "remove" : "get"](response.state);
      if (!storedStateString) {
        logger2.throw(new Error("No matching state found in storage"));
        throw null;
      }
      const state2 = State.fromStorageString(storedStateString);
      return { state: state2, response };
    }
    async processSignoutResponse(url2) {
      const logger2 = this._logger.create("processSignoutResponse");
      const { state: state2, response } = await this.readSignoutResponseState(url2, true);
      if (state2) {
        logger2.debug("Received state from storage; validating response");
        this._validator.validateSignoutResponse(response, state2);
      } else {
        logger2.debug("No state from storage; skipping response validation");
      }
      return response;
    }
    clearStaleState() {
      this._logger.create("clearStaleState");
      return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);
    }
    async revokeToken(token, type) {
      this._logger.create("revokeToken");
      return await this._tokenClient.revoke({
        token,
        token_type_hint: type
      });
    }
  };
  var SessionMonitor = class {
    constructor(_userManager) {
      this._userManager = _userManager;
      this._logger = new Logger("SessionMonitor");
      this._start = async (user) => {
        const session_state = user.session_state;
        if (!session_state) {
          return;
        }
        const logger2 = this._logger.create("_start");
        if (user.profile) {
          this._sub = user.profile.sub;
          this._sid = user.profile.sid;
          logger2.debug("session_state", session_state, ", sub", this._sub);
        } else {
          this._sub = void 0;
          this._sid = void 0;
          logger2.debug("session_state", session_state, ", anonymous user");
        }
        if (this._checkSessionIFrame) {
          this._checkSessionIFrame.start(session_state);
          return;
        }
        try {
          const url2 = await this._userManager.metadataService.getCheckSessionIframe();
          if (url2) {
            logger2.debug("initializing check session iframe");
            const client_id = this._userManager.settings.client_id;
            const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;
            const stopOnError = this._userManager.settings.stopCheckSessionOnError;
            const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url2, intervalInSeconds, stopOnError);
            await checkSessionIFrame.load();
            this._checkSessionIFrame = checkSessionIFrame;
            checkSessionIFrame.start(session_state);
          } else {
            logger2.warn("no check session iframe found in the metadata");
          }
        } catch (err) {
          logger2.error("Error from getCheckSessionIframe:", err instanceof Error ? err.message : err);
        }
      };
      this._stop = () => {
        const logger2 = this._logger.create("_stop");
        this._sub = void 0;
        this._sid = void 0;
        if (this._checkSessionIFrame) {
          this._checkSessionIFrame.stop();
        }
        if (this._userManager.settings.monitorAnonymousSession) {
          const timerHandle = setInterval(async () => {
            clearInterval(timerHandle);
            try {
              const session = await this._userManager.querySessionStatus();
              if (session) {
                const tmpUser = {
                  session_state: session.session_state,
                  profile: session.sub && session.sid ? {
                    sub: session.sub,
                    sid: session.sid
                  } : null
                };
                void this._start(tmpUser);
              }
            } catch (err) {
              logger2.error("error from querySessionStatus", err instanceof Error ? err.message : err);
            }
          }, 1e3);
        }
      };
      this._callback = async () => {
        const logger2 = this._logger.create("_callback");
        try {
          const session = await this._userManager.querySessionStatus();
          let raiseEvent = true;
          if (session && this._checkSessionIFrame) {
            if (session.sub === this._sub) {
              raiseEvent = false;
              this._checkSessionIFrame.start(session.session_state);
              if (session.sid === this._sid) {
                logger2.debug("same sub still logged in at OP, restarting check session iframe; session_state", session.session_state);
              } else {
                logger2.debug("same sub still logged in at OP, session state has changed, restarting check session iframe; session_state", session.session_state);
                this._userManager.events._raiseUserSessionChanged();
              }
            } else {
              logger2.debug("different subject signed into OP", session.sub);
            }
          } else {
            logger2.debug("subject no longer signed into OP");
          }
          if (raiseEvent) {
            if (this._sub) {
              this._userManager.events._raiseUserSignedOut();
            } else {
              this._userManager.events._raiseUserSignedIn();
            }
          } else {
            logger2.debug("no change in session detected, no event to raise");
          }
        } catch (err) {
          if (this._sub) {
            logger2.debug("Error calling queryCurrentSigninSession; raising signed out event", err);
            this._userManager.events._raiseUserSignedOut();
          }
        }
      };
      if (!_userManager) {
        this._logger.throw(new Error("No user manager passed"));
      }
      this._userManager.events.addUserLoaded(this._start);
      this._userManager.events.addUserUnloaded(this._stop);
      this._init().catch((err) => {
        this._logger.error(err);
      });
    }
    async _init() {
      this._logger.create("_init");
      const user = await this._userManager.getUser();
      if (user) {
        void this._start(user);
      } else if (this._userManager.settings.monitorAnonymousSession) {
        const session = await this._userManager.querySessionStatus();
        if (session) {
          const tmpUser = {
            session_state: session.session_state,
            profile: session.sub && session.sid ? {
              sub: session.sub,
              sid: session.sid
            } : null
          };
          void this._start(tmpUser);
        }
      }
    }
  };
  var User = class {
    constructor(args) {
      var _a3;
      this.id_token = args.id_token;
      this.session_state = (_a3 = args.session_state) != null ? _a3 : null;
      this.access_token = args.access_token;
      this.refresh_token = args.refresh_token;
      this.token_type = args.token_type;
      this.scope = args.scope;
      this.profile = args.profile;
      this.expires_at = args.expires_at;
      this.state = args.userState;
    }
    /** Computed number of seconds the access token has remaining. */
    get expires_in() {
      if (this.expires_at === void 0) {
        return void 0;
      }
      return this.expires_at - Timer.getEpochTime();
    }
    set expires_in(value) {
      if (value !== void 0) {
        this.expires_at = Math.floor(value) + Timer.getEpochTime();
      }
    }
    /** Computed value indicating if the access token is expired. */
    get expired() {
      const expires_in = this.expires_in;
      if (expires_in === void 0) {
        return void 0;
      }
      return expires_in <= 0;
    }
    /** Array representing the parsed values from the `scope`. */
    get scopes() {
      var _a3, _b2;
      return (_b2 = (_a3 = this.scope) == null ? void 0 : _a3.split(" ")) != null ? _b2 : [];
    }
    toStorageString() {
      new Logger("User").create("toStorageString");
      return JSON.stringify({
        id_token: this.id_token,
        session_state: this.session_state,
        access_token: this.access_token,
        refresh_token: this.refresh_token,
        token_type: this.token_type,
        scope: this.scope,
        profile: this.profile,
        expires_at: this.expires_at
      });
    }
    static fromStorageString(storageString) {
      Logger.createStatic("User", "fromStorageString");
      return new User(JSON.parse(storageString));
    }
  };
  var messageSource = "oidc-client";
  var AbstractChildWindow = class {
    constructor() {
      this._abort = new Event$1("Window navigation aborted");
      this._disposeHandlers = /* @__PURE__ */ new Set();
      this._window = null;
    }
    async navigate(params) {
      const logger2 = this._logger.create("navigate");
      if (!this._window) {
        throw new Error("Attempted to navigate on a disposed window");
      }
      logger2.debug("setting URL in window");
      this._window.location.replace(params.url);
      const { url: url2, keepOpen } = await new Promise((resolve, reject) => {
        const listener = (e8) => {
          var _a3;
          const data = e8.data;
          const origin = (_a3 = params.scriptOrigin) != null ? _a3 : window.location.origin;
          if (e8.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {
            return;
          }
          try {
            const state2 = UrlUtils.readParams(data.url, params.response_mode).get("state");
            if (!state2) {
              logger2.warn("no state found in response url");
            }
            if (e8.source !== this._window && state2 !== params.state) {
              return;
            }
          } catch (err) {
            this._dispose();
            reject(new Error("Invalid response from window"));
          }
          resolve(data);
        };
        window.addEventListener("message", listener, false);
        this._disposeHandlers.add(() => window.removeEventListener("message", listener, false));
        this._disposeHandlers.add(this._abort.addHandler((reason) => {
          this._dispose();
          reject(reason);
        }));
      });
      logger2.debug("got response from window");
      this._dispose();
      if (!keepOpen) {
        this.close();
      }
      return { url: url2 };
    }
    _dispose() {
      this._logger.create("_dispose");
      for (const dispose of this._disposeHandlers) {
        dispose();
      }
      this._disposeHandlers.clear();
    }
    static _notifyParent(parent, url2, keepOpen = false, targetOrigin = window.location.origin) {
      parent.postMessage({
        source: messageSource,
        url: url2,
        keepOpen
      }, targetOrigin);
    }
  };
  var DefaultPopupWindowFeatures = {
    location: false,
    toolbar: false,
    height: 640
  };
  var DefaultPopupTarget = "_blank";
  var DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;
  var DefaultCheckSessionIntervalInSeconds = 2;
  var DefaultSilentRequestTimeoutInSeconds = 10;
  var UserManagerSettingsStore = class extends OidcClientSettingsStore {
    constructor(args) {
      const {
        popup_redirect_uri = args.redirect_uri,
        popup_post_logout_redirect_uri = args.post_logout_redirect_uri,
        popupWindowFeatures = DefaultPopupWindowFeatures,
        popupWindowTarget = DefaultPopupTarget,
        redirectMethod = "assign",
        redirectTarget = "self",
        iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,
        iframeScriptOrigin = args.iframeScriptOrigin,
        silent_redirect_uri = args.redirect_uri,
        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,
        automaticSilentRenew = true,
        validateSubOnSilentRenew = true,
        includeIdTokenInSilentRenew = false,
        monitorSession = false,
        monitorAnonymousSession = false,
        checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,
        query_status_response_type = "code",
        stopCheckSessionOnError = true,
        revokeTokenTypes = ["access_token", "refresh_token"],
        revokeTokensOnSignout = false,
        includeIdTokenInSilentSignout = false,
        accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,
        userStore
      } = args;
      super(args);
      this.popup_redirect_uri = popup_redirect_uri;
      this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;
      this.popupWindowFeatures = popupWindowFeatures;
      this.popupWindowTarget = popupWindowTarget;
      this.redirectMethod = redirectMethod;
      this.redirectTarget = redirectTarget;
      this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;
      this.iframeScriptOrigin = iframeScriptOrigin;
      this.silent_redirect_uri = silent_redirect_uri;
      this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;
      this.automaticSilentRenew = automaticSilentRenew;
      this.validateSubOnSilentRenew = validateSubOnSilentRenew;
      this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;
      this.monitorSession = monitorSession;
      this.monitorAnonymousSession = monitorAnonymousSession;
      this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;
      this.stopCheckSessionOnError = stopCheckSessionOnError;
      this.query_status_response_type = query_status_response_type;
      this.revokeTokenTypes = revokeTokenTypes;
      this.revokeTokensOnSignout = revokeTokensOnSignout;
      this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;
      this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;
      if (userStore) {
        this.userStore = userStore;
      } else {
        const store = typeof window !== "undefined" ? window.sessionStorage : new InMemoryWebStorage();
        this.userStore = new WebStorageStateStore({ store });
      }
    }
  };
  var IFrameWindow = class extends AbstractChildWindow {
    constructor({
      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds
    }) {
      super();
      this._logger = new Logger("IFrameWindow");
      this._timeoutInSeconds = silentRequestTimeoutInSeconds;
      this._frame = IFrameWindow.createHiddenIframe();
      this._window = this._frame.contentWindow;
    }
    static createHiddenIframe() {
      const iframe = window.document.createElement("iframe");
      iframe.style.visibility = "hidden";
      iframe.style.position = "fixed";
      iframe.style.left = "-1000px";
      iframe.style.top = "0";
      iframe.width = "0";
      iframe.height = "0";
      iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
      window.document.body.appendChild(iframe);
      return iframe;
    }
    async navigate(params) {
      this._logger.debug("navigate: Using timeout of:", this._timeoutInSeconds);
      const timer = setTimeout(() => this._abort.raise(new ErrorTimeout("IFrame timed out without a response")), this._timeoutInSeconds * 1e3);
      this._disposeHandlers.add(() => clearTimeout(timer));
      return await super.navigate(params);
    }
    close() {
      var _a3;
      if (this._frame) {
        if (this._frame.parentNode) {
          this._frame.addEventListener("load", (ev2) => {
            var _a22;
            const frame = ev2.target;
            (_a22 = frame.parentNode) == null ? void 0 : _a22.removeChild(frame);
            this._abort.raise(new Error("IFrame removed from DOM"));
          }, true);
          (_a3 = this._frame.contentWindow) == null ? void 0 : _a3.location.replace("about:blank");
        }
        this._frame = null;
      }
      this._window = null;
    }
    static notifyParent(url2, targetOrigin) {
      return super._notifyParent(window.parent, url2, false, targetOrigin);
    }
  };
  var IFrameNavigator = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("IFrameNavigator");
    }
    async prepare({
      silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds
    }) {
      return new IFrameWindow({ silentRequestTimeoutInSeconds });
    }
    async callback(url2) {
      this._logger.create("callback");
      IFrameWindow.notifyParent(url2, this._settings.iframeNotifyParentOrigin);
    }
  };
  var checkForPopupClosedInterval = 500;
  var PopupWindow = class extends AbstractChildWindow {
    constructor({
      popupWindowTarget = DefaultPopupTarget,
      popupWindowFeatures = {}
    }) {
      super();
      this._logger = new Logger("PopupWindow");
      const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });
      this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));
    }
    async navigate(params) {
      var _a3;
      (_a3 = this._window) == null ? void 0 : _a3.focus();
      const popupClosedInterval = setInterval(() => {
        if (!this._window || this._window.closed) {
          this._abort.raise(new Error("Popup closed by user"));
        }
      }, checkForPopupClosedInterval);
      this._disposeHandlers.add(() => clearInterval(popupClosedInterval));
      return await super.navigate(params);
    }
    close() {
      if (this._window) {
        if (!this._window.closed) {
          this._window.close();
          this._abort.raise(new Error("Popup closed"));
        }
      }
      this._window = null;
    }
    static notifyOpener(url2, keepOpen) {
      if (!window.opener) {
        throw new Error("No window.opener. Can't complete notification.");
      }
      return super._notifyParent(window.opener, url2, keepOpen);
    }
  };
  var PopupNavigator = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("PopupNavigator");
    }
    async prepare({
      popupWindowFeatures = this._settings.popupWindowFeatures,
      popupWindowTarget = this._settings.popupWindowTarget
    }) {
      return new PopupWindow({ popupWindowFeatures, popupWindowTarget });
    }
    async callback(url2, keepOpen = false) {
      this._logger.create("callback");
      PopupWindow.notifyOpener(url2, keepOpen);
    }
  };
  var RedirectNavigator = class {
    constructor(_settings) {
      this._settings = _settings;
      this._logger = new Logger("RedirectNavigator");
    }
    async prepare({
      redirectMethod = this._settings.redirectMethod,
      redirectTarget = this._settings.redirectTarget
    }) {
      var _a3;
      this._logger.create("prepare");
      let targetWindow = window.self;
      if (redirectTarget === "top") {
        targetWindow = (_a3 = window.top) != null ? _a3 : window.self;
      }
      const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);
      let abort;
      return {
        navigate: async (params) => {
          this._logger.create("navigate");
          const promise = new Promise((resolve, reject) => {
            abort = reject;
          });
          redirect(params.url);
          return await promise;
        },
        close: () => {
          this._logger.create("close");
          abort == null ? void 0 : abort(new Error("Redirect aborted"));
          targetWindow.stop();
        }
      };
    }
  };
  var UserManagerEvents = class extends AccessTokenEvents {
    constructor(settings) {
      super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });
      this._logger = new Logger("UserManagerEvents");
      this._userLoaded = new Event$1("User loaded");
      this._userUnloaded = new Event$1("User unloaded");
      this._silentRenewError = new Event$1("Silent renew error");
      this._userSignedIn = new Event$1("User signed in");
      this._userSignedOut = new Event$1("User signed out");
      this._userSessionChanged = new Event$1("User session changed");
    }
    load(user, raiseEvent = true) {
      super.load(user);
      if (raiseEvent) {
        this._userLoaded.raise(user);
      }
    }
    unload() {
      super.unload();
      this._userUnloaded.raise();
    }
    /**
     * Add callback: Raised when a user session has been established (or re-established).
     */
    addUserLoaded(cb) {
      return this._userLoaded.addHandler(cb);
    }
    /**
     * Remove callback: Raised when a user session has been established (or re-established).
     */
    removeUserLoaded(cb) {
      return this._userLoaded.removeHandler(cb);
    }
    /**
     * Add callback: Raised when a user session has been terminated.
     */
    addUserUnloaded(cb) {
      return this._userUnloaded.addHandler(cb);
    }
    /**
     * Remove callback: Raised when a user session has been terminated.
     */
    removeUserUnloaded(cb) {
      return this._userUnloaded.removeHandler(cb);
    }
    /**
     * Add callback: Raised when the automatic silent renew has failed.
     */
    addSilentRenewError(cb) {
      return this._silentRenewError.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the automatic silent renew has failed.
     */
    removeSilentRenewError(cb) {
      return this._silentRenewError.removeHandler(cb);
    }
    /**
     * @internal
     */
    _raiseSilentRenewError(e8) {
      this._silentRenewError.raise(e8);
    }
    /**
     * Add callback: Raised when the user is signed in (when `monitorSession` is set).
     * @see {@link UserManagerSettings.monitorSession}
     */
    addUserSignedIn(cb) {
      return this._userSignedIn.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).
     */
    removeUserSignedIn(cb) {
      this._userSignedIn.removeHandler(cb);
    }
    /**
     * @internal
     */
    _raiseUserSignedIn() {
      this._userSignedIn.raise();
    }
    /**
     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).
     * @see {@link UserManagerSettings.monitorSession}
     */
    addUserSignedOut(cb) {
      return this._userSignedOut.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).
     */
    removeUserSignedOut(cb) {
      this._userSignedOut.removeHandler(cb);
    }
    /**
     * @internal
     */
    _raiseUserSignedOut() {
      this._userSignedOut.raise();
    }
    /**
     * Add callback: Raised when the user session changed (when `monitorSession` is set).
     * @see {@link UserManagerSettings.monitorSession}
     */
    addUserSessionChanged(cb) {
      return this._userSessionChanged.addHandler(cb);
    }
    /**
     * Remove callback: Raised when the user session changed (when `monitorSession` is set).
     */
    removeUserSessionChanged(cb) {
      this._userSessionChanged.removeHandler(cb);
    }
    /**
     * @internal
     */
    _raiseUserSessionChanged() {
      this._userSessionChanged.raise();
    }
  };
  var SilentRenewService = class {
    constructor(_userManager) {
      this._userManager = _userManager;
      this._logger = new Logger("SilentRenewService");
      this._isStarted = false;
      this._retryTimer = new Timer("Retry Silent Renew");
      this._tokenExpiring = async () => {
        const logger2 = this._logger.create("_tokenExpiring");
        try {
          await this._userManager.signinSilent();
          logger2.debug("silent token renewal successful");
        } catch (err) {
          if (err instanceof ErrorTimeout) {
            logger2.warn("ErrorTimeout from signinSilent:", err, "retry in 5s");
            this._retryTimer.init(5);
            return;
          }
          logger2.error("Error from signinSilent:", err);
          this._userManager.events._raiseSilentRenewError(err);
        }
      };
    }
    async start() {
      const logger2 = this._logger.create("start");
      if (!this._isStarted) {
        this._isStarted = true;
        this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);
        this._retryTimer.addHandler(this._tokenExpiring);
        try {
          await this._userManager.getUser();
        } catch (err) {
          logger2.error("getUser error", err);
        }
      }
    }
    stop() {
      if (this._isStarted) {
        this._retryTimer.cancel();
        this._retryTimer.removeHandler(this._tokenExpiring);
        this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);
        this._isStarted = false;
      }
    }
  };
  var RefreshState = class {
    constructor(args) {
      this.refresh_token = args.refresh_token;
      this.id_token = args.id_token;
      this.session_state = args.session_state;
      this.scope = args.scope;
      this.profile = args.profile;
      this.data = args.state;
    }
  };
  var UserManager = class {
    constructor(settings) {
      this._logger = new Logger("UserManager");
      this.settings = new UserManagerSettingsStore(settings);
      this._client = new OidcClient(settings);
      this._redirectNavigator = new RedirectNavigator(this.settings);
      this._popupNavigator = new PopupNavigator(this.settings);
      this._iframeNavigator = new IFrameNavigator(this.settings);
      this._events = new UserManagerEvents(this.settings);
      this._silentRenewService = new SilentRenewService(this);
      if (this.settings.automaticSilentRenew) {
        this.startSilentRenew();
      }
      this._sessionMonitor = null;
      if (this.settings.monitorSession) {
        this._sessionMonitor = new SessionMonitor(this);
      }
    }
    /** Returns an object used to register for events raised by the `UserManager`. */
    get events() {
      return this._events;
    }
    /** Returns an object used to access the metadata configuration of the OIDC provider. */
    get metadataService() {
      return this._client.metadataService;
    }
    /**
     * Returns promise to load the `User` object for the currently authenticated user.
     */
    async getUser() {
      const logger2 = this._logger.create("getUser");
      const user = await this._loadUser();
      if (user) {
        logger2.info("user loaded");
        this._events.load(user, false);
        return user;
      }
      logger2.info("user not found in storage");
      return null;
    }
    /**
     * Returns promise to remove from any storage the currently authenticated user.
     */
    async removeUser() {
      const logger2 = this._logger.create("removeUser");
      await this.storeUser(null);
      logger2.info("user removed from storage");
      this._events.unload();
    }
    /**
     * Returns promise to trigger a redirect of the current window to the authorization endpoint.
     */
    async signinRedirect(args = {}) {
      this._logger.create("signinRedirect");
      const {
        redirectMethod,
        ...requestArgs
      } = args;
      const handle = await this._redirectNavigator.prepare({ redirectMethod });
      await this._signinStart({
        request_type: "si:r",
        ...requestArgs
      }, handle);
    }
    /**
     * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.
     */
    async signinRedirectCallback(url2 = window.location.href) {
      const logger2 = this._logger.create("signinRedirectCallback");
      const user = await this._signinEnd(url2);
      if (user.profile && user.profile.sub) {
        logger2.info("success, signed in subject", user.profile.sub);
      } else {
        logger2.info("no subject");
      }
      return user;
    }
    /**
     * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.
     *
     * Throws an ErrorResponse in case of wrong authentication.
     */
    async signinResourceOwnerCredentials({
      username,
      password,
      skipUserInfo = false
    }) {
      const logger2 = this._logger.create("signinResourceOwnerCredential");
      const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo, extraTokenParams: this.settings.extraTokenParams });
      logger2.debug("got signin response");
      const user = await this._buildUser(signinResponse);
      if (user.profile && user.profile.sub) {
        logger2.info("success, signed in subject", user.profile.sub);
      } else {
        logger2.info("no subject");
      }
      return user;
    }
    /**
     * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.
     */
    async signinPopup(args = {}) {
      const logger2 = this._logger.create("signinPopup");
      const {
        popupWindowFeatures,
        popupWindowTarget,
        ...requestArgs
      } = args;
      const url2 = this.settings.popup_redirect_uri;
      if (!url2) {
        logger2.throw(new Error("No popup_redirect_uri configured"));
      }
      const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });
      const user = await this._signin({
        request_type: "si:p",
        redirect_uri: url2,
        display: "popup",
        ...requestArgs
      }, handle);
      if (user) {
        if (user.profile && user.profile.sub) {
          logger2.info("success, signed in subject", user.profile.sub);
        } else {
          logger2.info("no subject");
        }
      }
      return user;
    }
    /**
     * Returns promise to notify the opening window of response from the authorization endpoint.
     */
    async signinPopupCallback(url2 = window.location.href, keepOpen = false) {
      const logger2 = this._logger.create("signinPopupCallback");
      await this._popupNavigator.callback(url2, keepOpen);
      logger2.info("success");
    }
    /**
     * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.
     * The result of the promise is the authenticated `User`.
     */
    async signinSilent(args = {}) {
      var _a3;
      const logger2 = this._logger.create("signinSilent");
      const {
        silentRequestTimeoutInSeconds,
        ...requestArgs
      } = args;
      let user = await this._loadUser();
      if (user == null ? void 0 : user.refresh_token) {
        logger2.debug("using refresh token");
        const state2 = new RefreshState(user);
        return await this._useRefreshToken(state2);
      }
      const url2 = this.settings.silent_redirect_uri;
      if (!url2) {
        logger2.throw(new Error("No silent_redirect_uri configured"));
      }
      let verifySub;
      if (user && this.settings.validateSubOnSilentRenew) {
        logger2.debug("subject prior to silent renew:", user.profile.sub);
        verifySub = user.profile.sub;
      }
      const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });
      user = await this._signin({
        request_type: "si:s",
        redirect_uri: url2,
        prompt: "none",
        id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,
        ...requestArgs
      }, handle, verifySub);
      if (user) {
        if ((_a3 = user.profile) == null ? void 0 : _a3.sub) {
          logger2.info("success, signed in subject", user.profile.sub);
        } else {
          logger2.info("no subject");
        }
      }
      return user;
    }
    async _useRefreshToken(state2) {
      const response = await this._client.useRefreshToken({
        state: state2,
        timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds
      });
      const user = new User({ ...state2, ...response });
      await this.storeUser(user);
      this._events.load(user);
      return user;
    }
    /**
     * Returns promise to notify the parent window of response from the authorization endpoint.
     */
    async signinSilentCallback(url2 = window.location.href) {
      const logger2 = this._logger.create("signinSilentCallback");
      await this._iframeNavigator.callback(url2);
      logger2.info("success");
    }
    async signinCallback(url2 = window.location.href) {
      const { state: state2 } = await this._client.readSigninResponseState(url2);
      switch (state2.request_type) {
        case "si:r":
          return await this.signinRedirectCallback(url2);
        case "si:p":
          return await this.signinPopupCallback(url2);
        case "si:s":
          return await this.signinSilentCallback(url2);
        default:
          throw new Error("invalid response_type in state");
      }
    }
    async signoutCallback(url2 = window.location.href, keepOpen = false) {
      const { state: state2 } = await this._client.readSignoutResponseState(url2);
      if (!state2) {
        return;
      }
      switch (state2.request_type) {
        case "so:r":
          await this.signoutRedirectCallback(url2);
          break;
        case "so:p":
          await this.signoutPopupCallback(url2, keepOpen);
          break;
        case "so:s":
          await this.signoutSilentCallback(url2);
          break;
        default:
          throw new Error("invalid response_type in state");
      }
    }
    /**
     * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.
     */
    async querySessionStatus(args = {}) {
      const logger2 = this._logger.create("querySessionStatus");
      const {
        silentRequestTimeoutInSeconds,
        ...requestArgs
      } = args;
      const url2 = this.settings.silent_redirect_uri;
      if (!url2) {
        logger2.throw(new Error("No silent_redirect_uri configured"));
      }
      const user = await this._loadUser();
      const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });
      const navResponse = await this._signinStart({
        request_type: "si:s",
        // this acts like a signin silent
        redirect_uri: url2,
        prompt: "none",
        id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,
        response_type: this.settings.query_status_response_type,
        scope: "openid",
        skipUserInfo: true,
        ...requestArgs
      }, handle);
      try {
        const signinResponse = await this._client.processSigninResponse(navResponse.url);
        logger2.debug("got signin response");
        if (signinResponse.session_state && signinResponse.profile.sub) {
          logger2.info("success for subject", signinResponse.profile.sub);
          return {
            session_state: signinResponse.session_state,
            sub: signinResponse.profile.sub,
            sid: signinResponse.profile.sid
          };
        }
        logger2.info("success, user not authenticated");
        return null;
      } catch (err) {
        if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {
          switch (err.error) {
            case "login_required":
            case "consent_required":
            case "interaction_required":
            case "account_selection_required":
              logger2.info("success for anonymous user");
              return {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                session_state: err.session_state
              };
          }
        }
        throw err;
      }
    }
    async _signin(args, handle, verifySub) {
      const navResponse = await this._signinStart(args, handle);
      return await this._signinEnd(navResponse.url, verifySub);
    }
    async _signinStart(args, handle) {
      const logger2 = this._logger.create("_signinStart");
      try {
        const signinRequest = await this._client.createSigninRequest(args);
        logger2.debug("got signin request");
        return await handle.navigate({
          url: signinRequest.url,
          state: signinRequest.state.id,
          response_mode: signinRequest.state.response_mode,
          scriptOrigin: this.settings.iframeScriptOrigin
        });
      } catch (err) {
        logger2.debug("error after preparing navigator, closing navigator window");
        handle.close();
        throw err;
      }
    }
    async _signinEnd(url2, verifySub) {
      const logger2 = this._logger.create("_signinEnd");
      const signinResponse = await this._client.processSigninResponse(url2);
      logger2.debug("got signin response");
      const user = await this._buildUser(signinResponse, verifySub);
      return user;
    }
    async _buildUser(signinResponse, verifySub) {
      const logger2 = this._logger.create("_buildUser");
      const user = new User(signinResponse);
      if (verifySub) {
        if (verifySub !== user.profile.sub) {
          logger2.debug("current user does not match user returned from signin. sub from signin:", user.profile.sub);
          throw new ErrorResponse({ ...signinResponse, error: "login_required" });
        }
        logger2.debug("current user matches user returned from signin");
      }
      await this.storeUser(user);
      logger2.debug("user stored");
      this._events.load(user);
      return user;
    }
    /**
     * Returns promise to trigger a redirect of the current window to the end session endpoint.
     */
    async signoutRedirect(args = {}) {
      const logger2 = this._logger.create("signoutRedirect");
      const {
        redirectMethod,
        ...requestArgs
      } = args;
      const handle = await this._redirectNavigator.prepare({ redirectMethod });
      await this._signoutStart({
        request_type: "so:r",
        post_logout_redirect_uri: this.settings.post_logout_redirect_uri,
        ...requestArgs
      }, handle);
      logger2.info("success");
    }
    /**
     * Returns promise to process response from the end session endpoint.
     */
    async signoutRedirectCallback(url2 = window.location.href) {
      const logger2 = this._logger.create("signoutRedirectCallback");
      const response = await this._signoutEnd(url2);
      logger2.info("success");
      return response;
    }
    /**
     * Returns promise to trigger a redirect of a popup window window to the end session endpoint.
     */
    async signoutPopup(args = {}) {
      const logger2 = this._logger.create("signoutPopup");
      const {
        popupWindowFeatures,
        popupWindowTarget,
        ...requestArgs
      } = args;
      const url2 = this.settings.popup_post_logout_redirect_uri;
      const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });
      await this._signout({
        request_type: "so:p",
        post_logout_redirect_uri: url2,
        // we're putting a dummy entry in here because we
        // need a unique id from the state for notification
        // to the parent window, which is necessary if we
        // plan to return back to the client after signout
        // and so we can close the popup after signout
        state: url2 == null ? void 0 : {},
        ...requestArgs
      }, handle);
      logger2.info("success");
    }
    /**
     * Returns promise to process response from the end session endpoint from a popup window.
     */
    async signoutPopupCallback(url2 = window.location.href, keepOpen = false) {
      const logger2 = this._logger.create("signoutPopupCallback");
      await this._popupNavigator.callback(url2, keepOpen);
      logger2.info("success");
    }
    async _signout(args, handle) {
      const navResponse = await this._signoutStart(args, handle);
      return await this._signoutEnd(navResponse.url);
    }
    async _signoutStart(args = {}, handle) {
      var _a3;
      const logger2 = this._logger.create("_signoutStart");
      try {
        const user = await this._loadUser();
        logger2.debug("loaded current user from storage");
        if (this.settings.revokeTokensOnSignout) {
          await this._revokeInternal(user);
        }
        const id_token = args.id_token_hint || user && user.id_token;
        if (id_token) {
          logger2.debug("setting id_token_hint in signout request");
          args.id_token_hint = id_token;
        }
        await this.removeUser();
        logger2.debug("user removed, creating signout request");
        const signoutRequest = await this._client.createSignoutRequest(args);
        logger2.debug("got signout request");
        return await handle.navigate({
          url: signoutRequest.url,
          state: (_a3 = signoutRequest.state) == null ? void 0 : _a3.id
        });
      } catch (err) {
        logger2.debug("error after preparing navigator, closing navigator window");
        handle.close();
        throw err;
      }
    }
    async _signoutEnd(url2) {
      const logger2 = this._logger.create("_signoutEnd");
      const signoutResponse = await this._client.processSignoutResponse(url2);
      logger2.debug("got signout response");
      return signoutResponse;
    }
    /**
     * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.
     */
    async signoutSilent(args = {}) {
      var _a3;
      const logger2 = this._logger.create("signoutSilent");
      const {
        silentRequestTimeoutInSeconds,
        ...requestArgs
      } = args;
      const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a3 = await this._loadUser()) == null ? void 0 : _a3.id_token : void 0;
      const url2 = this.settings.popup_post_logout_redirect_uri;
      const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });
      await this._signout({
        request_type: "so:s",
        post_logout_redirect_uri: url2,
        id_token_hint,
        ...requestArgs
      }, handle);
      logger2.info("success");
    }
    /**
     * Returns promise to notify the parent window of response from the end session endpoint.
     */
    async signoutSilentCallback(url2 = window.location.href) {
      const logger2 = this._logger.create("signoutSilentCallback");
      await this._iframeNavigator.callback(url2);
      logger2.info("success");
    }
    async revokeTokens(types2) {
      const user = await this._loadUser();
      await this._revokeInternal(user, types2);
    }
    async _revokeInternal(user, types2 = this.settings.revokeTokenTypes) {
      const logger2 = this._logger.create("_revokeInternal");
      if (!user)
        return;
      const typesPresent = types2.filter((type) => typeof user[type] === "string");
      if (!typesPresent.length) {
        logger2.debug("no need to revoke due to no token(s)");
        return;
      }
      for (const type of typesPresent) {
        await this._client.revokeToken(
          user[type],
          // eslint-disable-line @typescript-eslint/no-non-null-assertion
          type
        );
        logger2.info(`${type} revoked successfully`);
        if (type !== "access_token") {
          user[type] = null;
        }
      }
      await this.storeUser(user);
      logger2.debug("user stored");
      this._events.load(user);
    }
    /**
     * Enables silent renew for the `UserManager`.
     */
    startSilentRenew() {
      this._logger.create("startSilentRenew");
      void this._silentRenewService.start();
    }
    /**
     * Disables silent renew for the `UserManager`.
     */
    stopSilentRenew() {
      this._silentRenewService.stop();
    }
    get _userStoreKey() {
      return `user:${this.settings.authority}:${this.settings.client_id}`;
    }
    async _loadUser() {
      const logger2 = this._logger.create("_loadUser");
      const storageString = await this.settings.userStore.get(this._userStoreKey);
      if (storageString) {
        logger2.debug("user storageString loaded");
        return User.fromStorageString(storageString);
      }
      logger2.debug("no user storageString");
      return null;
    }
    async storeUser(user) {
      const logger2 = this._logger.create("storeUser");
      if (user) {
        logger2.debug("storing user");
        const storageString = user.toStorageString();
        await this.settings.userStore.set(this._userStoreKey, storageString);
      } else {
        this._logger.debug("removing user");
        await this.settings.userStore.remove(this._userStoreKey);
      }
    }
    /**
     * Removes stale state entries in storage for incomplete authorize requests.
     */
    async clearStaleState() {
      await this._client.clearStaleState();
    }
  };
  const DEFAULT_CLIENT_ID = "sc-app-beta";
  const DEFAULT_MESSAGE_OUTSINK = "messageOutput";
  Log.setLogger(console);
  Log.setLevel(Log.INFO);
  const whatPath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf("/"));
  const url = window.location.origin + whatPath;
  const SecureCitizenOIDC = {
    stateStore: new WebStorageStateStore({ store: window.localStorage }),
    userStore: new WebStorageStateStore({ store: window.localStorage }),
    authority: "https://sts.dev.securecitizen.cloud",
    client_id: DEFAULT_CLIENT_ID,
    //client_id: 'interactive.public.short',
    // redirect_uri: url + "/index.html",
    redirect_uri: url,
    // post_logout_redirect_uri: url + "/index.html",
    post_logout_redirect_uri: url,
    response_type: "code",
    //response_mode: 'fragment',
    scope: "openid profile offline_access",
    //scope: 'openid profile api offline_access',
    popup_redirect_uri: url + "/scauth/popup-signin.html",
    popup_post_logout_redirect_uri: url + "/scauth/popup-signout.html",
    popupWindowFeatures: { height: 768 },
    silent_redirect_uri: url + "/scauth/silent-renew.html",
    automaticSilentRenew: false,
    validateSubOnSilentRenew: true,
    //silentRequestTimeout: 10000,
    loadUserInfo: true,
    monitorAnonymousSession: true,
    filterProtocolClaims: true,
    revokeTokensOnSignout: true
    //metadata: {"issuer":"https://demo.duendesoftware.com","jwks_uri":"https://demo.duendesoftware.com/.well-known/openid-configuration/jwks","authorization_endpoint":"https://demo.duendesoftware.com/connect/authorize","token_endpoint":"https://demo.duendesoftware.com/connect/token","userinfo_endpoint":"https://demo.duendesoftware.com/connect/userinfo","end_session_endpoint":"https://demo.duendesoftware.com/connect/endsession","check_session_iframe":"https://demo.duendesoftware.com/connect/checksession","revocation_endpoint":"https://demo.duendesoftware.com/connect/revocation","introspection_endpoint":"https://demo.duendesoftware.com/connect/introspect","device_authorization_endpoint":"https://demo.duendesoftware.com/connect/deviceauthorization","frontchannel_logout_supported":true,"frontchannel_logout_session_supported":true,"backchannel_logout_supported":true,"backchannel_logout_session_supported":true,"scopes_supported":["openid","profile","email","api","api.scope1","api.scope2","scope2","policyserver.runtime","policyserver.management","offline_access"],"claims_supported":["sub","name","family_name","given_name","middle_name","nickname","preferred_username","profile","picture","website","gender","birthdate","zoneinfo","locale","updated_at","email","email_verified"],"grant_types_supported":["authorization_code","client_credentials","refresh_token","implicit","password","urn:ietf:params:oauth:grant-type:device_code"],"response_types_supported":["code","token","id_token","id_token token","code id_token","code token","code id_token token"],"response_modes_supported":["form_post","query","fragment"],"token_endpoint_auth_methods_supported":["client_secret_basic","client_secret_post"],"id_token_signing_alg_values_supported":["RS256"],"subject_types_supported":["public"],"code_challenge_methods_supported":["plain","S256"],"request_parameter_supported":true},
    //metadataSeed: {"some_extra_data":"some_value"},
    //signingKeys:[{"kty":"RSA","use":"sig","kid":"5CCAA03EDDE26D53104CC35D0D4B299C","e":"AQAB","n":"3fbgsZuL5Kp7HyliAznS6N0kTTAqApIzYqu0tORUk4T9m2f3uW5lDomNmwwPuZ3QDn0nwN3esx2NvZjL_g5DN407Pgl0ffHhARdtydJvdvNJIpW4CmyYGnI8H4ZdHtuW4wF8GbKadIGgwpI4UqcsHuPiWKARfWZMQfPKBT08SiIPwGncavlRRDgRVX1T94AgZE_fOTJ4Odko9RX9iNXghJIzJ_wEkY9GEkoHz5lQGdHYUplxOS6fcxL8j_N9urSBlnoYjPntBOwUfPsMoNcmIDXPARcq10miWTz8SHzUYRtsiSUMqimRJ9KdCucKcCmttB_p_EAWohJQDnav-Vqi3Q","alg":"RS256"}]
  };
  class SecureCitizenUserManager extends UserManager {
    constructor(clientId) {
      const settings = SecureCitizenOIDC;
      settings.client_id = clientId;
      super(settings);
      console.log("Client ID: " + clientId + " and authBase set to " + url);
    }
    // Auth methods
    clearState() {
      this.clearStaleState().then(function() {
        console.log("clearStateState success");
      }).catch(function(err) {
        console.error(err);
      });
    }
    sessionStatus() {
      this.querySessionStatus().then(function(status) {
        console.log("user's session status", status);
      }).catch(function(err) {
        console.error(err);
      });
    }
    getUserInfo() {
      this.getUser().then(function(user) {
        console.log("user object", user);
      }).catch(function(err) {
        console.error(err);
      });
    }
    revokeAccessToken() {
      this.revokeTokens().then(function() {
        console.log("access token revoked");
      }).catch(function(err) {
        console.error(err);
      });
    }
    startSigninMainWindow() {
      this.signinRedirect({
        state: { foo: "bar" }
        /*, useReplaceToNavigate: true*/
      }).then(function() {
        console.log("signinRedirect done");
      }).catch(function(err) {
        console.error(err);
      });
    }
    endSigninMainWindow() {
      this.signinRedirectCallback().then(function(user) {
        console.log("signed in", user);
        var customState = user.state;
        console.log("here's our post-login custom state", customState);
      }).catch(function(err) {
        console.error(err);
      });
    }
    popupSignin() {
      this.signinPopupCallback().then(function(user) {
        console.log("signed in", user);
      }).catch(function(err) {
        console.error(err);
      });
    }
    popupSignout() {
      this.signoutPopupCallback().then(function() {
        console.log("signed out");
      }).catch(function(err) {
        console.error(err);
      });
    }
    iframeSignin() {
      this.signinSilent().then(function(user) {
        console.log("signed in silent", user);
      }).catch(function(err) {
        console.error(err);
      });
    }
    startSignoutMainWindow() {
      this.signoutRedirect().then(function(resp) {
        console.log("signed out", resp);
      }).catch(function(err) {
        console.error(err);
      });
    }
    endSignoutMainWindow() {
      this.signoutRedirectCallback().then(function(resp) {
        console.log("signed out", resp);
      }).catch(function(err) {
        console.error(err);
      });
    }
  }
  class IDomContainer {
    constructor() {
      __publicField(this, "canvas");
      __publicField(this, "fps");
      __publicField(this, "ok");
    }
  }
  class IFullDomContainer extends IDomContainer {
    constructor() {
      super(...arguments);
      __publicField(this, "match");
      __publicField(this, "name");
      __publicField(this, "save");
      __publicField(this, "delete");
      __publicField(this, "retry");
      __publicField(this, "source");
    }
  }
  var ContainerType = /* @__PURE__ */ ((ContainerType2) => {
    ContainerType2[ContainerType2["Minimal"] = 0] = "Minimal";
    ContainerType2[ContainerType2["Full"] = 1] = "Full";
    return ContainerType2;
  })(ContainerType || {});
  const ok$1 = {
    // must meet all rules
    faceCount: { status: false, val: 0 },
    faceConfidence: { status: false, val: 0 },
    facingCenter: { status: false, val: 0 },
    lookingCenter: { status: false, val: 0 },
    blinkDetected: { status: false, val: 0 },
    faceSize: { status: false, val: 0 },
    antispoofCheck: { status: false, val: 0 },
    livenessCheck: { status: false, val: 0 },
    distance: { status: false, val: 0 },
    age: { status: false, val: 0 },
    gender: { status: false, val: 0 },
    timeout: { status: true, val: 0 },
    descriptor: { status: false, val: 0 },
    elapsedMs: { status: void 0, val: 0 },
    // total time while waiting for valid face
    detectFPS: { status: void 0, val: 0 },
    // mark detection fps performance
    drawFPS: { status: void 0, val: 0 }
    // mark redraw fps performance
  };
  const allOk = () => ok$1.faceCount.status && ok$1.faceSize.status && ok$1.blinkDetected.status && ok$1.facingCenter.status && ok$1.lookingCenter.status && ok$1.faceConfidence.status && ok$1.antispoofCheck.status && ok$1.livenessCheck.status && ok$1.distance.status && ok$1.descriptor.status && ok$1.age.status && ok$1.gender.status;
  function drawValidationTests(dom) {
    let y10 = 32;
    for (const [key2, val] of Object.entries(ok$1)) {
      let el2 = document.getElementById(`ok-${key2}`);
      if (!el2) {
        el2 = document.createElement("div");
        el2.id = `ok-${key2}`;
        el2.innerText = key2;
        el2.className = "ok";
        el2.style.top = `${y10}px`;
        dom.ok.appendChild(el2);
      }
      if (typeof val.status === "boolean")
        el2.style.backgroundColor = val.status ? "lightgreen" : "lightcoral";
      const status = val.status ? "ok" : "fail";
      el2.innerText = `${key2}: ${val.val === 0 ? status : val.val}`;
      y10 += 28;
    }
  }
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __export = (target, all2) => {
    for (var name2 in all2)
      __defProp2(target, name2, { get: all2[name2], enumerable: true });
  };
  var __publicField2 = (obj, key2, value) => {
    __defNormalProp2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var tfjs_esm_exports = {};
  __export(tfjs_esm_exports, {
    Abs: () => js,
    Acos: () => Vo,
    Acosh: () => Wo,
    AdadeltaOptimizer: () => ep,
    AdagradOptimizer: () => tp,
    AdamOptimizer: () => rp,
    AdamaxOptimizer: () => op,
    Add: () => io,
    AddN: () => Uo,
    All: () => Go,
    Any: () => Ho,
    ArgMax: () => Xs,
    ArgMin: () => Ys,
    Asin: () => Ko,
    Asinh: () => qo,
    Atan: () => jo,
    Atan2: () => Yo,
    Atanh: () => Xo,
    AvgPool: () => Qo,
    AvgPool3D: () => Qs,
    AvgPool3DGrad: () => Ei,
    AvgPoolGrad: () => $i,
    BackendWasm: () => am,
    BatchMatMul: () => Zo,
    BatchToSpaceND: () => Zs,
    Bincount: () => Jo,
    BitwiseAnd: () => Ha,
    BroadcastArgs: () => Js,
    BroadcastTo: () => _ce,
    Cast: () => yo,
    Ceil: () => en,
    ClipByValue: () => bo,
    Complex: () => Ri,
    ComplexAbs: () => Di,
    Concat: () => ea,
    Conv2D: () => tn,
    Conv2DBackpropFilter: () => Ai,
    Conv2DBackpropInput: () => rn,
    Conv3D: () => on,
    Conv3DBackpropFilterV2: () => Ka,
    Conv3DBackpropInputV2: () => nn,
    Cos: () => sn,
    Cosh: () => an,
    CropAndResize: () => cn,
    Cumprod: () => un,
    Cumsum: () => pn,
    DataStorage: () => Bo,
    DenseBincount: () => ta,
    DepthToSpace: () => ln,
    DepthwiseConv2dNative: () => mn,
    DepthwiseConv2dNativeBackpropFilter: () => Fi,
    DepthwiseConv2dNativeBackpropInput: () => Pi,
    Diag: () => ra,
    Dilation2D: () => dn,
    Dilation2DBackpropFilter: () => Mi,
    Dilation2DBackpropInput: () => Oi,
    Draw: () => qm,
    ENV: () => QC,
    Einsum: () => Li,
    Elu: () => hn,
    EluGrad: () => qa,
    Environment: () => ll,
    Equal: () => xn,
    Erf: () => gn,
    Exp: () => yn,
    ExpandDims: () => oa,
    Expm1: () => bn,
    FFT: () => Bi,
    Fill: () => na,
    FlipLeftRight: () => Cn,
    Floor: () => wn,
    FloorDiv: () => Sn,
    FromPixels: () => Au,
    FusedBatchNorm: () => In,
    FusedConv2D: () => Io,
    FusedDepthwiseConv2D: () => vo,
    GPGPUContext: () => wp,
    GatherNd: () => vn,
    GatherV2: () => sa,
    GraphModel: () => Ol,
    Greater: () => kn,
    GreaterEqual: () => Nn,
    IFFT: () => zi,
    Identity: () => Co,
    Imag: () => Vi,
    IsFinite: () => Tn,
    IsInf: () => _n,
    IsNan: () => $n,
    KernelBackend: () => so,
    LRN: () => Bn,
    LRNGrad: () => ja,
    LeakyRelu: () => En,
    Less: () => Rn,
    LessEqual: () => Dn,
    LinSpace: () => An,
    Log: () => Fn,
    Log1p: () => Pn,
    LogSoftmax: () => $ce,
    LogicalAnd: () => On,
    LogicalNot: () => Mn,
    LogicalOr: () => Ln,
    LogicalXor: () => w0,
    LowerBound: () => Ece,
    MathBackendCPU: () => hu,
    MathBackendWebGL: () => bu,
    MatrixBandPart: () => Rce,
    Max: () => zn,
    MaxPool: () => Wn,
    MaxPool3D: () => aa,
    MaxPool3DGrad: () => Ui,
    MaxPoolGrad: () => Wi,
    MaxPoolWithArgmax: () => ia,
    Maximum: () => Vn,
    Mean: () => Un,
    Min: () => Gn,
    Minimum: () => Hn,
    MirrorPad: () => Kn,
    Mod: () => qn,
    MomentumOptimizer: () => np,
    Multinomial: () => jn,
    Multiply: () => Xn,
    Neg: () => ua,
    NonMaxSuppressionV3: () => Qn,
    NonMaxSuppressionV4: () => Xa,
    NonMaxSuppressionV5: () => Zn,
    NotEqual: () => Yn,
    OP_SCOPE_SUFFIX: () => yw,
    OneHot: () => Jn,
    OnesLike: () => pa,
    Optimizer: () => Nr,
    OptimizerConstructors: () => Dl,
    Pack: () => ca,
    PadV2: () => es,
    Pool: () => Dce,
    Pow: () => ts,
    Prelu: () => rs,
    Prod: () => os,
    RMSPropOptimizer: () => sp,
    RaggedGather: () => jp,
    RaggedRange: () => Xp,
    RaggedTensorToTensor: () => Yp,
    Range: () => la,
    Rank: () => uw,
    Real: () => Gi,
    RealDiv: () => fn,
    Reciprocal: () => ns,
    Reduction: () => Et,
    Relu: () => ss,
    Relu6: () => us,
    Reshape: () => ma,
    ResizeBilinear: () => is,
    ResizeBilinearGrad: () => Qa,
    ResizeNearestNeighbor: () => as,
    ResizeNearestNeighborGrad: () => Ya,
    Reverse: () => ps,
    RotateWithOffset: () => Ds,
    Round: () => cs,
    Rsqrt: () => ls,
    SGDOptimizer: () => ci,
    ScatterNd: () => ms,
    SearchSorted: () => fs,
    Select: () => da,
    Selu: () => hs,
    Sigmoid: () => bs,
    Sign: () => ys,
    Sin: () => gs,
    Sinh: () => xs,
    Slice: () => fa,
    Softmax: () => Is,
    Softplus: () => Cs,
    SpaceToBatchND: () => ha,
    SparseFillEmptyRows: () => Hi,
    SparseReshape: () => Za,
    SparseSegmentMean: () => Ki,
    SparseSegmentSum: () => qi,
    SparseToDense: () => vs,
    SplitV: () => ga,
    Sqrt: () => ws,
    Square: () => ji,
    SquaredDifference: () => ks,
    StaticRegexReplace: () => Du,
    Step: () => wo,
    StridedSlice: () => Ns,
    StringNGrams: () => xa,
    StringSplit: () => Xi,
    StringToHashBucketFast: () => Yi,
    Sub: () => Ts,
    Sum: () => Ss,
    Tan: () => _s,
    Tanh: () => $s,
    Tensor: () => ut,
    TensorBuffer: () => tt,
    TensorScatterUpdate: () => ds,
    Tile: () => uo,
    TopK: () => Es,
    Transform: () => Rs,
    Transpose: () => po,
    Unique: () => Qi,
    Unpack: () => ya,
    UnsortedSegmentSum: () => Zi,
    UpperBound: () => Ace,
    Variable: () => ei,
    WebGPUBackend: () => vu,
    ZerosLike: () => ba,
    _FusedMatMul: () => So,
    abs: () => Jt,
    acos: () => xk,
    acosh: () => yk,
    add: () => Ce,
    addN: () => bk,
    all: () => Ck,
    any: () => wk,
    argMax: () => Sk,
    argMin: () => Ik,
    asin: () => vk,
    asinh: () => kk,
    atan: () => Nk,
    atan2: () => Tk,
    atanh: () => _k,
    avgPool: () => md,
    avgPool3d: () => Rk,
    backend: () => dde,
    backend_util: () => w,
    basicLSTMCell: () => Dk,
    batchNorm: () => su,
    batchNorm2d: () => Fk,
    batchNorm3d: () => Pk,
    batchNorm4d: () => Ok,
    batchToSpaceND: () => dd,
    bincount: () => fd,
    bitwiseAnd: () => Mk,
    booleanMaskAsync: () => b6,
    broadcastArgs: () => Lk,
    broadcastTo: () => au,
    broadcast_util: () => Ir,
    browser: () => XN,
    buffer: () => me,
    cast: () => qe,
    ceil: () => Bk,
    clipByValue: () => zk,
    clone: () => Ur,
    complex: () => Er,
    concat: () => bt,
    concat1d: () => Vk,
    concat2d: () => Wk,
    concat3d: () => Uk,
    concat4d: () => Gk,
    conv1d: () => Hk,
    conv2d: () => iu,
    conv2dTranspose: () => Kk,
    conv3d: () => qk,
    conv3dTranspose: () => Xk,
    copyRegisteredKernels: () => Vce,
    cos: () => Yk,
    cosh: () => Qk,
    cosineWindow: () => _l,
    cumprod: () => Zk,
    cumsum: () => Jk,
    customGrad: () => vr,
    denseBincount: () => e2,
    deprecationWarn: () => _w,
    depthToSpace: () => t2,
    depthwiseConv2d: () => ic,
    deregisterOp: () => b5,
    device_util: () => ru,
    diag: () => r2,
    dilation2d: () => o2,
    disableDeprecationWarnings: () => rde,
    dispose: () => Ot,
    disposeVariables: () => ode,
    div: () => je,
    divNoNan: () => s2,
    dot: () => a2,
    dropout: () => R6,
    einsum: () => i2,
    elu: () => yd,
    enableDebugMode: () => tde,
    enableProdMode: () => ede,
    enclosingPowerOfTwo: () => Gw,
    engine: () => ur,
    ensureShape: () => u2,
    env: () => A,
    equal: () => xd,
    erf: () => p2,
    euclideanNorm: () => m2,
    exp: () => _o,
    expandDims: () => ai,
    expm1: () => d2,
    eye: () => bd,
    fft: () => cc,
    fill: () => Ta,
    findBackend: () => lde,
    findBackendFactory: () => mde,
    floor: () => Cd,
    floorDiv: () => ld,
    forceHalfFloat: () => $D,
    fused: () => Hw,
    gather: () => wd,
    gatherND: () => $6,
    gather_util: () => nf,
    getBackend: () => pde,
    getGradient: () => ew,
    getKernel: () => fl,
    getKernelsForBackend: () => jm,
    getThreadsCount: () => Lse,
    gpgpu_util: () => rv,
    grad: () => SK,
    grads: () => IK,
    greater: () => Uu,
    greaterEqual: () => Sd,
    ifft: () => Xu,
    imag: () => pu,
    image: () => Fj,
    inTopKAsync: () => A6,
    io: () => mi,
    irfft: () => Gd,
    isFinite: () => f2,
    isInf: () => h2,
    isNaN: () => g2,
    keep: () => Rr,
    kernel_impls: () => Wt,
    leakyRelu: () => Id,
    less: () => kl,
    lessEqual: () => uc,
    linalg: () => Pj,
    linspace: () => x2,
    loadGraphModel: () => h8,
    loadGraphModelSync: () => g8,
    localResponseNormalization: () => y2,
    log: () => ii,
    log1p: () => vd,
    logSigmoid: () => b2,
    logSoftmax: () => C2,
    logSumExp: () => Td,
    logicalAnd: () => Gu,
    logicalNot: () => _d,
    logicalOr: () => $d,
    logicalXor: () => w2,
    losses: () => Oj,
    lowerBound: () => S2,
    matMul: () => Ze,
    math: () => HN,
    max: () => _a,
    maxPool: () => Rd,
    maxPool3d: () => I2,
    maxPoolWithArgmax: () => v2,
    maximum: () => Dd,
    mean: () => Hu,
    memory: () => nde,
    meshgrid: () => k2,
    min: () => vl,
    minimum: () => Ku,
    mirrorPad: () => N2,
    mod: () => T2,
    moments: () => _2,
    movingAverage: () => S6,
    mul: () => se,
    multiRNNCell: () => $2,
    multinomial: () => E2,
    neg: () => pr,
    nextFrame: () => tS,
    norm: () => Wu,
    notEqual: () => Ad,
    oneHot: () => Tl,
    ones: () => $a,
    onesLike: () => R2,
    op: () => N,
    outerProduct: () => D2,
    pad: () => Ea,
    pad1d: () => A2,
    pad2d: () => F2,
    pad3d: () => P2,
    pad4d: () => O2,
    pool: () => M2,
    pow: () => si,
    prelu: () => Pd,
    print: () => cd,
    prod: () => L2,
    profile: () => sde,
    raggedGather: () => B2,
    raggedRange: () => z2,
    raggedTensorToTensor: () => V2,
    rand: () => W2,
    randomGamma: () => p1,
    randomNormal: () => Vd,
    randomStandardNormal: () => c1,
    randomUniform: () => pc,
    randomUniformInt: () => l1,
    range: () => cu,
    ready: () => ude,
    real: () => ui,
    reciprocal: () => m1,
    registerBackend: () => nu,
    registerGradient: () => Lce,
    registerKernel: () => Ja,
    registerOp: () => y5,
    relu: () => lu,
    relu6: () => Wd,
    removeBackend: () => cde,
    reshape: () => W,
    reverse: () => lo,
    reverse1d: () => d1,
    reverse2d: () => f1,
    reverse3d: () => h1,
    reverse4d: () => g1,
    rfft: () => lc,
    round: () => Ud,
    rsqrt: () => x1,
    scalar: () => ke,
    scatterND: () => v6,
    scatter_util: () => du,
    searchSorted: () => Nl,
    selu: () => y1,
    separableConv2d: () => b1,
    serialization: () => FN,
    setBackend: () => ide,
    setPlatform: () => fde,
    setThreadsCount: () => Mse,
    setWasmPath: () => Pse,
    setWasmPaths: () => Ose,
    setWebGLContext: () => gI,
    setdiff1dAsync: () => C1,
    shared: () => Ic,
    sigmoid: () => Na,
    sign: () => w1,
    signal: () => Aj,
    sin: () => S1,
    sinh: () => I1,
    slice: () => Xe,
    slice1d: () => v1,
    slice2d: () => k1,
    slice3d: () => N1,
    slice4d: () => T1,
    slice_util: () => ct,
    softmax: () => _1,
    softplus: () => Nd,
    spaceToBatchND: () => Fd,
    sparse: () => Mj,
    sparseToDense: () => T6,
    spectral: () => Dj,
    split: () => pi,
    sqrt: () => Dr,
    square: () => er,
    squaredDifference: () => Hd,
    squeeze: () => mc,
    stack: () => kr,
    step: () => Kd,
    stridedSlice: () => $1,
    string: () => Lj,
    sub: () => Te,
    sum: () => ot,
    sumOutType: () => ti,
    tan: () => E1,
    tanh: () => Il,
    tensor: () => ir,
    tensor1d: () => xr,
    tensor2d: () => mu,
    tensor3d: () => qd,
    tensor4d: () => R1,
    tensor5d: () => D1,
    tensor6d: () => A1,
    tensorScatterUpdate: () => P1,
    tensor_util: () => K0,
    test_util: () => u1,
    tidy: () => De,
    tile: () => uu,
    time: () => ade,
    topk: () => O1,
    train: () => uGe,
    transpose: () => fc,
    truncatedNormal: () => M1,
    unique: () => L1,
    unregisterGradient: () => zce,
    unregisterKernel: () => Bce,
    unsortedSegmentSum: () => B1,
    unstack: () => mo,
    upcastType: () => dt,
    upperBound: () => z1,
    util: () => y,
    valueAndGrad: () => vK,
    valueAndGrads: () => kK,
    variable: () => V1,
    variableGrads: () => Aw,
    version: () => Sce,
    version_converter: () => y8,
    version_core: () => fX,
    version_cpu: () => Y8,
    version_wasm: () => Bse,
    version_webgl: () => HZ,
    webgl: () => tat,
    webgl_util: () => $c,
    webgpu_util: () => Wv,
    where: () => co,
    whereAsync: () => Xd,
    zeros: () => Gr,
    zerosLike: () => Ht
  });
  var cG = Object.create;
  var GC = Object.defineProperty;
  var lG = Object.getOwnPropertyDescriptor;
  var mG = Object.getOwnPropertyNames;
  var dG = Object.getPrototypeOf;
  var fG = Object.prototype.hasOwnProperty;
  var qt = (r8, e8) => () => (e8 || r8((e8 = { exports: {} }).exports, e8), e8.exports);
  var Ke = (r8, e8) => {
    for (var t8 in e8)
      GC(r8, t8, { get: e8[t8], enumerable: true });
  };
  var hG = (r8, e8, t8, o8) => {
    if (e8 && typeof e8 == "object" || typeof e8 == "function")
      for (let n8 of mG(e8))
        !fG.call(r8, n8) && n8 !== t8 && GC(r8, n8, { get: () => e8[n8], enumerable: !(o8 = lG(e8, n8)) || o8.enumerable });
    return r8;
  };
  var Up = (r8, e8, t8) => (t8 = r8 != null ? cG(dG(r8)) : {}, hG(e8 || !r8 || !r8.__esModule ? GC(t8, "default", { value: r8, enumerable: true }) : t8, r8));
  var A0 = qt((Gce, D0) => {
    D0.exports = kt;
    var ko = null;
    try {
      ko = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch (r8) {
    }
    function kt(r8, e8, t8) {
      this.low = r8 | 0, this.high = e8 | 0, this.unsigned = !!t8;
    }
    kt.prototype.__isLong__;
    Object.defineProperty(kt.prototype, "__isLong__", { value: true });
    function Wr(r8) {
      return (r8 && r8.__isLong__) === true;
    }
    kt.isLong = Wr;
    var I0 = {}, v0 = {};
    function Pu(r8, e8) {
      var t8, o8, n8;
      return e8 ? (r8 >>>= 0, (n8 = 0 <= r8 && r8 < 256) && (o8 = v0[r8], o8) ? o8 : (t8 = Nt(r8, (r8 | 0) < 0 ? -1 : 0, true), n8 && (v0[r8] = t8), t8)) : (r8 |= 0, (n8 = -128 <= r8 && r8 < 128) && (o8 = I0[r8], o8) ? o8 : (t8 = Nt(r8, r8 < 0 ? -1 : 0, false), n8 && (I0[r8] = t8), t8));
    }
    kt.fromInt = Pu;
    function No(r8, e8) {
      if (isNaN(r8))
        return e8 ? Fu : To;
      if (e8) {
        if (r8 < 0)
          return Fu;
        if (r8 >= _0)
          return R0;
      } else {
        if (r8 <= -N0)
          return Vr;
        if (r8 + 1 >= N0)
          return E0;
      }
      return r8 < 0 ? No(-r8, e8).neg() : Nt(r8 % Jp | 0, r8 / Jp | 0, e8);
    }
    kt.fromNumber = No;
    function Nt(r8, e8, t8) {
      return new kt(r8, e8, t8);
    }
    kt.fromBits = Nt;
    var Ym = Math.pow;
    function ow(r8, e8, t8) {
      if (r8.length === 0)
        throw Error("empty string");
      if (r8 === "NaN" || r8 === "Infinity" || r8 === "+Infinity" || r8 === "-Infinity")
        return To;
      if (typeof e8 == "number" ? (t8 = e8, e8 = false) : e8 = !!e8, t8 = t8 || 10, t8 < 2 || 36 < t8)
        throw RangeError("radix");
      var o8;
      if ((o8 = r8.indexOf("-")) > 0)
        throw Error("interior hyphen");
      if (o8 === 0)
        return ow(r8.substring(1), e8, t8).neg();
      for (var n8 = No(Ym(t8, 8)), s = To, a = 0; a < r8.length; a += 8) {
        var i10 = Math.min(8, r8.length - a), p = parseInt(r8.substring(a, a + i10), t8);
        if (i10 < 8) {
          var u = No(Ym(t8, i10));
          s = s.mul(u).add(No(p));
        } else
          s = s.mul(n8), s = s.add(No(p));
      }
      return s.unsigned = e8, s;
    }
    kt.fromString = ow;
    function As(r8, e8) {
      return typeof r8 == "number" ? No(r8, e8) : typeof r8 == "string" ? ow(r8, e8) : Nt(r8.low, r8.high, typeof e8 == "boolean" ? e8 : r8.unsigned);
    }
    kt.fromValue = As;
    var k0 = 65536, LG = 1 << 24, Jp = k0 * k0, _0 = Jp * Jp, N0 = _0 / 2, T0 = Pu(LG), To = Pu(0);
    kt.ZERO = To;
    var Fu = Pu(0, true);
    kt.UZERO = Fu;
    var Zp = Pu(1);
    kt.ONE = Zp;
    var $0 = Pu(1, true);
    kt.UONE = $0;
    var rw = Pu(-1);
    kt.NEG_ONE = rw;
    var E0 = Nt(-1, 2147483647, false);
    kt.MAX_VALUE = E0;
    var R0 = Nt(-1, -1, true);
    kt.MAX_UNSIGNED_VALUE = R0;
    var Vr = Nt(0, -2147483648, false);
    kt.MIN_VALUE = Vr;
    var de = kt.prototype;
    de.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    de.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * Jp + (this.low >>> 0) : this.high * Jp + (this.low >>> 0);
    };
    de.toString = function(e8) {
      if (e8 = e8 || 10, e8 < 2 || 36 < e8)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative())
        if (this.eq(Vr)) {
          var t8 = No(e8), o8 = this.div(t8), n8 = o8.mul(t8).sub(this);
          return o8.toString(e8) + n8.toInt().toString(e8);
        } else
          return "-" + this.neg().toString(e8);
      for (var s = No(Ym(e8, 6), this.unsigned), a = this, i10 = ""; ; ) {
        var p = a.div(s), u = a.sub(p.mul(s)).toInt() >>> 0, c = u.toString(e8);
        if (a = p, a.isZero())
          return c + i10;
        for (; c.length < 6; )
          c = "0" + c;
        i10 = "" + c + i10;
      }
    };
    de.getHighBits = function() {
      return this.high;
    };
    de.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    };
    de.getLowBits = function() {
      return this.low;
    };
    de.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    };
    de.getNumBitsAbs = function() {
      if (this.isNegative())
        return this.eq(Vr) ? 64 : this.neg().getNumBitsAbs();
      for (var e8 = this.high != 0 ? this.high : this.low, t8 = 31; t8 > 0 && !(e8 & 1 << t8); t8--)
        ;
      return this.high != 0 ? t8 + 33 : t8 + 1;
    };
    de.isZero = function() {
      return this.high === 0 && this.low === 0;
    };
    de.eqz = de.isZero;
    de.isNegative = function() {
      return !this.unsigned && this.high < 0;
    };
    de.isPositive = function() {
      return this.unsigned || this.high >= 0;
    };
    de.isOdd = function() {
      return (this.low & 1) === 1;
    };
    de.isEven = function() {
      return (this.low & 1) === 0;
    };
    de.equals = function(e8) {
      return Wr(e8) || (e8 = As(e8)), this.unsigned !== e8.unsigned && this.high >>> 31 === 1 && e8.high >>> 31 === 1 ? false : this.high === e8.high && this.low === e8.low;
    };
    de.eq = de.equals;
    de.notEquals = function(e8) {
      return !this.eq(e8);
    };
    de.neq = de.notEquals;
    de.ne = de.notEquals;
    de.lessThan = function(e8) {
      return this.comp(e8) < 0;
    };
    de.lt = de.lessThan;
    de.lessThanOrEqual = function(e8) {
      return this.comp(e8) <= 0;
    };
    de.lte = de.lessThanOrEqual;
    de.le = de.lessThanOrEqual;
    de.greaterThan = function(e8) {
      return this.comp(e8) > 0;
    };
    de.gt = de.greaterThan;
    de.greaterThanOrEqual = function(e8) {
      return this.comp(e8) >= 0;
    };
    de.gte = de.greaterThanOrEqual;
    de.ge = de.greaterThanOrEqual;
    de.compare = function(e8) {
      if (Wr(e8) || (e8 = As(e8)), this.eq(e8))
        return 0;
      var t8 = this.isNegative(), o8 = e8.isNegative();
      return t8 && !o8 ? -1 : !t8 && o8 ? 1 : this.unsigned ? e8.high >>> 0 > this.high >>> 0 || e8.high === this.high && e8.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e8).isNegative() ? -1 : 1;
    };
    de.comp = de.compare;
    de.negate = function() {
      return !this.unsigned && this.eq(Vr) ? Vr : this.not().add(Zp);
    };
    de.neg = de.negate;
    de.add = function(e8) {
      Wr(e8) || (e8 = As(e8));
      var t8 = this.high >>> 16, o8 = this.high & 65535, n8 = this.low >>> 16, s = this.low & 65535, a = e8.high >>> 16, i10 = e8.high & 65535, p = e8.low >>> 16, u = e8.low & 65535, c = 0, l = 0, m = 0, d = 0;
      return d += s + u, m += d >>> 16, d &= 65535, m += n8 + p, l += m >>> 16, m &= 65535, l += o8 + i10, c += l >>> 16, l &= 65535, c += t8 + a, c &= 65535, Nt(m << 16 | d, c << 16 | l, this.unsigned);
    };
    de.subtract = function(e8) {
      return Wr(e8) || (e8 = As(e8)), this.add(e8.neg());
    };
    de.sub = de.subtract;
    de.multiply = function(e8) {
      if (this.isZero())
        return To;
      if (Wr(e8) || (e8 = As(e8)), ko) {
        var t8 = ko.mul(this.low, this.high, e8.low, e8.high);
        return Nt(t8, ko.get_high(), this.unsigned);
      }
      if (e8.isZero())
        return To;
      if (this.eq(Vr))
        return e8.isOdd() ? Vr : To;
      if (e8.eq(Vr))
        return this.isOdd() ? Vr : To;
      if (this.isNegative())
        return e8.isNegative() ? this.neg().mul(e8.neg()) : this.neg().mul(e8).neg();
      if (e8.isNegative())
        return this.mul(e8.neg()).neg();
      if (this.lt(T0) && e8.lt(T0))
        return No(this.toNumber() * e8.toNumber(), this.unsigned);
      var o8 = this.high >>> 16, n8 = this.high & 65535, s = this.low >>> 16, a = this.low & 65535, i10 = e8.high >>> 16, p = e8.high & 65535, u = e8.low >>> 16, c = e8.low & 65535, l = 0, m = 0, d = 0, f = 0;
      return f += a * c, d += f >>> 16, f &= 65535, d += s * c, m += d >>> 16, d &= 65535, d += a * u, m += d >>> 16, d &= 65535, m += n8 * c, l += m >>> 16, m &= 65535, m += s * u, l += m >>> 16, m &= 65535, m += a * p, l += m >>> 16, m &= 65535, l += o8 * c + n8 * u + s * p + a * i10, l &= 65535, Nt(d << 16 | f, l << 16 | m, this.unsigned);
    };
    de.mul = de.multiply;
    de.divide = function(e8) {
      if (Wr(e8) || (e8 = As(e8)), e8.isZero())
        throw Error("division by zero");
      if (ko) {
        if (!this.unsigned && this.high === -2147483648 && e8.low === -1 && e8.high === -1)
          return this;
        var t8 = (this.unsigned ? ko.div_u : ko.div_s)(this.low, this.high, e8.low, e8.high);
        return Nt(t8, ko.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Fu : To;
      var o8, n8, s;
      if (this.unsigned) {
        if (e8.unsigned || (e8 = e8.toUnsigned()), e8.gt(this))
          return Fu;
        if (e8.gt(this.shru(1)))
          return $0;
        s = Fu;
      } else {
        if (this.eq(Vr)) {
          if (e8.eq(Zp) || e8.eq(rw))
            return Vr;
          if (e8.eq(Vr))
            return Zp;
          var a = this.shr(1);
          return o8 = a.div(e8).shl(1), o8.eq(To) ? e8.isNegative() ? Zp : rw : (n8 = this.sub(e8.mul(o8)), s = o8.add(n8.div(e8)), s);
        } else if (e8.eq(Vr))
          return this.unsigned ? Fu : To;
        if (this.isNegative())
          return e8.isNegative() ? this.neg().div(e8.neg()) : this.neg().div(e8).neg();
        if (e8.isNegative())
          return this.div(e8.neg()).neg();
        s = To;
      }
      for (n8 = this; n8.gte(e8); ) {
        o8 = Math.max(1, Math.floor(n8.toNumber() / e8.toNumber()));
        for (var i10 = Math.ceil(Math.log(o8) / Math.LN2), p = i10 <= 48 ? 1 : Ym(2, i10 - 48), u = No(o8), c = u.mul(e8); c.isNegative() || c.gt(n8); )
          o8 -= p, u = No(o8, this.unsigned), c = u.mul(e8);
        u.isZero() && (u = Zp), s = s.add(u), n8 = n8.sub(c);
      }
      return s;
    };
    de.div = de.divide;
    de.modulo = function(e8) {
      if (Wr(e8) || (e8 = As(e8)), ko) {
        var t8 = (this.unsigned ? ko.rem_u : ko.rem_s)(this.low, this.high, e8.low, e8.high);
        return Nt(t8, ko.get_high(), this.unsigned);
      }
      return this.sub(this.div(e8).mul(e8));
    };
    de.mod = de.modulo;
    de.rem = de.modulo;
    de.not = function() {
      return Nt(~this.low, ~this.high, this.unsigned);
    };
    de.and = function(e8) {
      return Wr(e8) || (e8 = As(e8)), Nt(this.low & e8.low, this.high & e8.high, this.unsigned);
    };
    de.or = function(e8) {
      return Wr(e8) || (e8 = As(e8)), Nt(this.low | e8.low, this.high | e8.high, this.unsigned);
    };
    de.xor = function(e8) {
      return Wr(e8) || (e8 = As(e8)), Nt(this.low ^ e8.low, this.high ^ e8.high, this.unsigned);
    };
    de.shiftLeft = function(e8) {
      return Wr(e8) && (e8 = e8.toInt()), (e8 &= 63) === 0 ? this : e8 < 32 ? Nt(this.low << e8, this.high << e8 | this.low >>> 32 - e8, this.unsigned) : Nt(0, this.low << e8 - 32, this.unsigned);
    };
    de.shl = de.shiftLeft;
    de.shiftRight = function(e8) {
      return Wr(e8) && (e8 = e8.toInt()), (e8 &= 63) === 0 ? this : e8 < 32 ? Nt(this.low >>> e8 | this.high << 32 - e8, this.high >> e8, this.unsigned) : Nt(this.high >> e8 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    de.shr = de.shiftRight;
    de.shiftRightUnsigned = function(e8) {
      if (Wr(e8) && (e8 = e8.toInt()), e8 &= 63, e8 === 0)
        return this;
      var t8 = this.high;
      if (e8 < 32) {
        var o8 = this.low;
        return Nt(o8 >>> e8 | t8 << 32 - e8, t8 >>> e8, this.unsigned);
      } else
        return e8 === 32 ? Nt(t8, 0, this.unsigned) : Nt(t8 >>> e8 - 32, 0, this.unsigned);
    };
    de.shru = de.shiftRightUnsigned;
    de.shr_u = de.shiftRightUnsigned;
    de.toSigned = function() {
      return this.unsigned ? Nt(this.low, this.high, false) : this;
    };
    de.toUnsigned = function() {
      return this.unsigned ? this : Nt(this.low, this.high, true);
    };
    de.toBytes = function(e8) {
      return e8 ? this.toBytesLE() : this.toBytesBE();
    };
    de.toBytesLE = function() {
      var e8 = this.high, t8 = this.low;
      return [t8 & 255, t8 >>> 8 & 255, t8 >>> 16 & 255, t8 >>> 24, e8 & 255, e8 >>> 8 & 255, e8 >>> 16 & 255, e8 >>> 24];
    };
    de.toBytesBE = function() {
      var e8 = this.high, t8 = this.low;
      return [e8 >>> 24, e8 >>> 16 & 255, e8 >>> 8 & 255, e8 & 255, t8 >>> 24, t8 >>> 16 & 255, t8 >>> 8 & 255, t8 & 255];
    };
    kt.fromBytes = function(e8, t8, o8) {
      return o8 ? kt.fromBytesLE(e8, t8) : kt.fromBytesBE(e8, t8);
    };
    kt.fromBytesLE = function(e8, t8) {
      return new kt(e8[0] | e8[1] << 8 | e8[2] << 16 | e8[3] << 24, e8[4] | e8[5] << 8 | e8[6] << 16 | e8[7] << 24, t8);
    };
    kt.fromBytesBE = function(e8, t8) {
      return new kt(e8[4] << 24 | e8[5] << 16 | e8[6] << 8 | e8[7], e8[0] << 24 | e8[1] << 16 | e8[2] << 8 | e8[3], t8);
    };
  });
  var hk = qt(() => {
  });
  var gk = qt(() => {
  });
  var G2 = qt((U2, Fw) => {
    (function(r8, e8, t8) {
      function o8(i10) {
        var p = this, u = a();
        p.next = function() {
          var c = 2091639 * p.s0 + p.c * 23283064365386963e-26;
          return p.s0 = p.s1, p.s1 = p.s2, p.s2 = c - (p.c = c | 0);
        }, p.c = 1, p.s0 = u(" "), p.s1 = u(" "), p.s2 = u(" "), p.s0 -= u(i10), p.s0 < 0 && (p.s0 += 1), p.s1 -= u(i10), p.s1 < 0 && (p.s1 += 1), p.s2 -= u(i10), p.s2 < 0 && (p.s2 += 1), u = null;
      }
      function n8(i10, p) {
        return p.c = i10.c, p.s0 = i10.s0, p.s1 = i10.s1, p.s2 = i10.s2, p;
      }
      function s(i10, p) {
        var u = new o8(i10), c = p && p.state, l = u.next;
        return l.int32 = function() {
          return u.next() * 4294967296 | 0;
        }, l.double = function() {
          return l() + (l() * 2097152 | 0) * 11102230246251565e-32;
        }, l.quick = l, c && (typeof c == "object" && n8(c, u), l.state = function() {
          return n8(u, {});
        }), l;
      }
      function a() {
        var i10 = 4022871197, p = function(u) {
          u = String(u);
          for (var c = 0; c < u.length; c++) {
            i10 += u.charCodeAt(c);
            var l = 0.02519603282416938 * i10;
            i10 = l >>> 0, l -= i10, l *= i10, i10 = l >>> 0, l -= i10, i10 += l * 4294967296;
          }
          return (i10 >>> 0) * 23283064365386963e-26;
        };
        return p;
      }
      e8 && e8.exports ? e8.exports = s : t8 && t8.amd ? t8(function() {
        return s;
      }) : this.alea = s;
    })(U2, typeof Fw == "object" && Fw, typeof define == "function" && define);
  });
  var K2 = qt((H2, Pw) => {
    (function(r8, e8, t8) {
      function o8(a) {
        var i10 = this, p = "";
        i10.x = 0, i10.y = 0, i10.z = 0, i10.w = 0, i10.next = function() {
          var c = i10.x ^ i10.x << 11;
          return i10.x = i10.y, i10.y = i10.z, i10.z = i10.w, i10.w ^= i10.w >>> 19 ^ c ^ c >>> 8;
        }, a === (a | 0) ? i10.x = a : p += a;
        for (var u = 0; u < p.length + 64; u++)
          i10.x ^= p.charCodeAt(u) | 0, i10.next();
      }
      function n8(a, i10) {
        return i10.x = a.x, i10.y = a.y, i10.z = a.z, i10.w = a.w, i10;
      }
      function s(a, i10) {
        var p = new o8(a), u = i10 && i10.state, c = function() {
          return (p.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var l = p.next() >>> 11, m = (p.next() >>> 0) / 4294967296, d = (l + m) / (1 << 21);
          while (d === 0);
          return d;
        }, c.int32 = p.next, c.quick = c, u && (typeof u == "object" && n8(u, p), c.state = function() {
          return n8(p, {});
        }), c;
      }
      e8 && e8.exports ? e8.exports = s : t8 && t8.amd ? t8(function() {
        return s;
      }) : this.xor128 = s;
    })(H2, typeof Pw == "object" && Pw, typeof define == "function" && define);
  });
  var j2 = qt((q2, Ow) => {
    (function(r8, e8, t8) {
      function o8(a) {
        var i10 = this, p = "";
        i10.next = function() {
          var c = i10.x ^ i10.x >>> 2;
          return i10.x = i10.y, i10.y = i10.z, i10.z = i10.w, i10.w = i10.v, (i10.d = i10.d + 362437 | 0) + (i10.v = i10.v ^ i10.v << 4 ^ (c ^ c << 1)) | 0;
        }, i10.x = 0, i10.y = 0, i10.z = 0, i10.w = 0, i10.v = 0, a === (a | 0) ? i10.x = a : p += a;
        for (var u = 0; u < p.length + 64; u++)
          i10.x ^= p.charCodeAt(u) | 0, u == p.length && (i10.d = i10.x << 10 ^ i10.x >>> 4), i10.next();
      }
      function n8(a, i10) {
        return i10.x = a.x, i10.y = a.y, i10.z = a.z, i10.w = a.w, i10.v = a.v, i10.d = a.d, i10;
      }
      function s(a, i10) {
        var p = new o8(a), u = i10 && i10.state, c = function() {
          return (p.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var l = p.next() >>> 11, m = (p.next() >>> 0) / 4294967296, d = (l + m) / (1 << 21);
          while (d === 0);
          return d;
        }, c.int32 = p.next, c.quick = c, u && (typeof u == "object" && n8(u, p), c.state = function() {
          return n8(p, {});
        }), c;
      }
      e8 && e8.exports ? e8.exports = s : t8 && t8.amd ? t8(function() {
        return s;
      }) : this.xorwow = s;
    })(q2, typeof Ow == "object" && Ow, typeof define == "function" && define);
  });
  var Y2 = qt((X2, Mw) => {
    (function(r8, e8, t8) {
      function o8(a) {
        var i10 = this;
        i10.next = function() {
          var u = i10.x, c = i10.i, l, m;
          return l = u[c], l ^= l >>> 7, m = l ^ l << 24, l = u[c + 1 & 7], m ^= l ^ l >>> 10, l = u[c + 3 & 7], m ^= l ^ l >>> 3, l = u[c + 4 & 7], m ^= l ^ l << 7, l = u[c + 7 & 7], l = l ^ l << 13, m ^= l ^ l << 9, u[c] = m, i10.i = c + 1 & 7, m;
        };
        function p(u, c) {
          var l, d = [];
          if (c === (c | 0))
            d[0] = c;
          else
            for (c = "" + c, l = 0; l < c.length; ++l)
              d[l & 7] = d[l & 7] << 15 ^ c.charCodeAt(l) + d[l + 1 & 7] << 13;
          for (; d.length < 8; )
            d.push(0);
          for (l = 0; l < 8 && d[l] === 0; ++l)
            ;
          for (l == 8 ? d[7] = -1 : d[l], u.x = d, u.i = 0, l = 256; l > 0; --l)
            u.next();
        }
        p(i10, a);
      }
      function n8(a, i10) {
        return i10.x = a.x.slice(), i10.i = a.i, i10;
      }
      function s(a, i10) {
        a == null && (a = +/* @__PURE__ */ new Date());
        var p = new o8(a), u = i10 && i10.state, c = function() {
          return (p.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var l = p.next() >>> 11, m = (p.next() >>> 0) / 4294967296, d = (l + m) / (1 << 21);
          while (d === 0);
          return d;
        }, c.int32 = p.next, c.quick = c, u && (u.x && n8(u, p), c.state = function() {
          return n8(p, {});
        }), c;
      }
      e8 && e8.exports ? e8.exports = s : t8 && t8.amd ? t8(function() {
        return s;
      }) : this.xorshift7 = s;
    })(X2, typeof Mw == "object" && Mw, typeof define == "function" && define);
  });
  var Z2 = qt((Q2, Lw) => {
    (function(r8, e8, t8) {
      function o8(a) {
        var i10 = this;
        i10.next = function() {
          var u = i10.w, c = i10.X, l = i10.i, m, d;
          return i10.w = u = u + 1640531527 | 0, d = c[l + 34 & 127], m = c[l = l + 1 & 127], d ^= d << 13, m ^= m << 17, d ^= d >>> 15, m ^= m >>> 12, d = c[l] = d ^ m, i10.i = l, d + (u ^ u >>> 16) | 0;
        };
        function p(u, c) {
          var l, m, d, f, h, g = [], x = 128;
          for (c === (c | 0) ? (m = c, c = null) : (c = c + "\0", m = 0, x = Math.max(x, c.length)), d = 0, f = -32; f < x; ++f)
            c && (m ^= c.charCodeAt((f + 32) % c.length)), f === 0 && (h = m), m ^= m << 10, m ^= m >>> 15, m ^= m << 4, m ^= m >>> 13, f >= 0 && (h = h + 1640531527 | 0, l = g[f & 127] ^= m + h, d = l == 0 ? d + 1 : 0);
          for (d >= 128 && (g[(c && c.length || 0) & 127] = -1), d = 127, f = 4 * 128; f > 0; --f)
            m = g[d + 34 & 127], l = g[d = d + 1 & 127], m ^= m << 13, l ^= l << 17, m ^= m >>> 15, l ^= l >>> 12, g[d] = m ^ l;
          u.w = h, u.X = g, u.i = d;
        }
        p(i10, a);
      }
      function n8(a, i10) {
        return i10.i = a.i, i10.w = a.w, i10.X = a.X.slice(), i10;
      }
      function s(a, i10) {
        a == null && (a = +/* @__PURE__ */ new Date());
        var p = new o8(a), u = i10 && i10.state, c = function() {
          return (p.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var l = p.next() >>> 11, m = (p.next() >>> 0) / 4294967296, d = (l + m) / (1 << 21);
          while (d === 0);
          return d;
        }, c.int32 = p.next, c.quick = c, u && (u.X && n8(u, p), c.state = function() {
          return n8(p, {});
        }), c;
      }
      e8 && e8.exports ? e8.exports = s : t8 && t8.amd ? t8(function() {
        return s;
      }) : this.xor4096 = s;
    })(Q2, typeof Lw == "object" && Lw, typeof define == "function" && define);
  });
  var e1 = qt((J2, Bw) => {
    (function(r8, e8, t8) {
      function o8(a) {
        var i10 = this, p = "";
        i10.next = function() {
          var c = i10.b, l = i10.c, m = i10.d, d = i10.a;
          return c = c << 25 ^ c >>> 7 ^ l, l = l - m | 0, m = m << 24 ^ m >>> 8 ^ d, d = d - c | 0, i10.b = c = c << 20 ^ c >>> 12 ^ l, i10.c = l = l - m | 0, i10.d = m << 16 ^ l >>> 16 ^ d, i10.a = d - c | 0;
        }, i10.a = 0, i10.b = 0, i10.c = -1640531527, i10.d = 1367130551, a === Math.floor(a) ? (i10.a = a / 4294967296 | 0, i10.b = a | 0) : p += a;
        for (var u = 0; u < p.length + 20; u++)
          i10.b ^= p.charCodeAt(u) | 0, i10.next();
      }
      function n8(a, i10) {
        return i10.a = a.a, i10.b = a.b, i10.c = a.c, i10.d = a.d, i10;
      }
      function s(a, i10) {
        var p = new o8(a), u = i10 && i10.state, c = function() {
          return (p.next() >>> 0) / 4294967296;
        };
        return c.double = function() {
          do
            var l = p.next() >>> 11, m = (p.next() >>> 0) / 4294967296, d = (l + m) / (1 << 21);
          while (d === 0);
          return d;
        }, c.int32 = p.next, c.quick = c, u && (typeof u == "object" && n8(u, p), c.state = function() {
          return n8(p, {});
        }), c;
      }
      e8 && e8.exports ? e8.exports = s : t8 && t8.amd ? t8(function() {
        return s;
      }) : this.tychei = s;
    })(J2, typeof Bw == "object" && Bw, typeof define == "function" && define);
  });
  var t1 = qt(() => {
  });
  var o1 = qt((r1, Od) => {
    (function(r8, e8, t8) {
      var o8 = 256, n8 = 6, s = 52, a = "random", i10 = t8.pow(o8, n8), p = t8.pow(2, s), u = p * 2, c = o8 - 1, l;
      function m(C, S, k) {
        var _ = [];
        S = S == true ? { entropy: true } : S || {};
        var E = g(h(S.entropy ? [C, b(e8)] : C == null ? x() : C, 3), _), R = new d(_), D = function() {
          for (var P = R.g(n8), O = i10, M = 0; P < p; )
            P = (P + M) * o8, O *= o8, M = R.g(1);
          for (; P >= u; )
            P /= 2, O /= 2, M >>>= 1;
          return (P + M) / O;
        };
        return D.int32 = function() {
          return R.g(4) | 0;
        }, D.quick = function() {
          return R.g(4) / 4294967296;
        }, D.double = D, g(b(R.S), e8), (S.pass || k || function(P, O, M, L) {
          return L && (L.S && f(L, R), P.state = function() {
            return f(R, {});
          }), M ? (t8[a] = P, O) : P;
        })(D, E, "global" in S ? S.global : this == t8, S.state);
      }
      function d(C) {
        var S, k = C.length, _ = this, E = 0, R = _.i = _.j = 0, D = _.S = [];
        for (k || (C = [k++]); E < o8; )
          D[E] = E++;
        for (E = 0; E < o8; E++)
          D[E] = D[R = c & R + C[E % k] + (S = D[E])], D[R] = S;
        (_.g = function(P) {
          for (var O, M = 0, L = _.i, B = _.j, z = _.S; P--; )
            O = z[L = c & L + 1], M = M * o8 + z[c & (z[L] = z[B = c & B + O]) + (z[B] = O)];
          return _.i = L, _.j = B, M;
        })(o8);
      }
      function f(C, S) {
        return S.i = C.i, S.j = C.j, S.S = C.S.slice(), S;
      }
      function h(C, S) {
        var k = [], _ = typeof C, E;
        if (S && _ == "object")
          for (E in C)
            try {
              k.push(h(C[E], S - 1));
            } catch (R) {
            }
        return k.length ? k : _ == "string" ? C : C + "\0";
      }
      function g(C, S) {
        for (var k = C + "", _, E = 0; E < k.length; )
          S[c & E] = c & (_ ^= S[c & E] * 19) + k.charCodeAt(E++);
        return b(S);
      }
      function x() {
        try {
          var C;
          return l && (C = l.randomBytes) ? C = C(o8) : (C = new Uint8Array(o8), (r8.crypto || r8.msCrypto).getRandomValues(C)), b(C);
        } catch (_) {
          var S = r8.navigator, k = S && S.plugins;
          return [+/* @__PURE__ */ new Date(), r8, k, r8.screen, b(e8)];
        }
      }
      function b(C) {
        return String.fromCharCode.apply(0, C);
      }
      if (g(t8.random(), e8), typeof Od == "object" && Od.exports) {
        Od.exports = m;
        try {
          l = t1();
        } catch (C) {
        }
      } else
        typeof define == "function" && define.amd ? define(function() {
          return m;
        }) : t8["seed" + a] = m;
    })(typeof self != "undefined" ? self : r1, [], Math);
  });
  var zw = qt((B2e, n1) => {
    var dq = G2(), fq = K2(), hq = j2(), gq = Y2(), xq = Z2(), yq = e1(), qu = o1();
    qu.alea = dq;
    qu.xor128 = fq;
    qu.xorwow = hq;
    qu.xorshift7 = gq;
    qu.xor4096 = xq;
    qu.tychei = yq;
    n1.exports = qu;
  });
  var Rv = qt(() => {
  });
  var Dv = qt(() => {
  });
  var IB = qt(() => {
  });
  var vB = qt(() => {
  });
  var kB = qt(() => {
  });
  var NB = qt((zg, Fv) => {
    var Av = (() => {
      var r8 = typeof document != "undefined" && document.currentScript ? document.currentScript.src : void 0;
      return typeof __filename != "undefined" && (r8 = r8 || __filename), function(e8) {
        e8 = e8 || {};
        function t8() {
          return oe.buffer != Ue && Tt(oe.buffer), mt;
        }
        function o8() {
          return oe.buffer != Ue && Tt(oe.buffer), it;
        }
        function s() {
          return oe.buffer != Ue && Tt(oe.buffer), Lr;
        }
        function a() {
          return oe.buffer != Ue && Tt(oe.buffer), Mt;
        }
        function p() {
          return oe.buffer != Ue && Tt(oe.buffer), or;
        }
        var u = typeof e8 != "undefined" ? e8 : {}, c, l;
        u.ready = new Promise(function(F, V) {
          c = F, l = V;
        });
        var m;
        typeof process$1 != "undefined" && process$1.listeners && (m = { uncaughtException: process$1.listeners("uncaughtException"), unhandledRejection: process$1.listeners("unhandledRejection") });
        var d = Object.assign({}, u), g = (F, V) => {
          throw V;
        }, x = typeof window == "object", b = typeof importScripts == "function", C = typeof process$1 == "object" && typeof process$1.versions == "object" && typeof process$1.versions.node == "string", S = u.ENVIRONMENT_IS_PTHREAD || false, k = "";
        function _(F) {
          return u.locateFile ? u.locateFile(F, k) : k + F;
        }
        var E, R, D;
        function O(F) {
          if (F instanceof Tu)
            return;
          j("exiting due to exception: " + F);
        }
        if (C) {
          var M = Rv(), L = Dv();
          b ? k = L.dirname(k) + "/" : k = __dirname + "/", E = (V, ue) => (V = Mp(V) ? new URL(V) : L.normalize(V), M.readFileSync(V, ue ? void 0 : "utf8")), D = (V) => {
            var ue = E(V, true);
            return ue.buffer || (ue = new Uint8Array(ue)), ue;
          }, R = (V, ue, Ee) => {
            V = Mp(V) ? new URL(V) : L.normalize(V), M.readFile(V, function(Be, Le) {
              Be ? Ee(Be) : ue(Le.buffer);
            });
          }, process$1.argv.length > 1 && process$1.argv[1].replace(/\\/g, "/"), process$1.argv.slice(2), process$1.on("uncaughtException", function(V) {
            if (!(V instanceof Tu))
              throw V;
          }), process$1.on("unhandledRejection", function(V) {
            throw V;
          }), g = (V, ue) => {
            if (Lo())
              throw process$1.exitCode = V, ue;
            O(ue), process$1.exit(V);
          }, u.inspect = function() {
            return "[Emscripten Module object]";
          };
          let F;
          try {
            F = IB();
          } catch (V) {
            throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), V;
          }
          _global.Worker = F.Worker;
        } else
          (x || b) && (b ? k = self.location.href : typeof document != "undefined" && document.currentScript && (k = document.currentScript.src), typeof r8 != "undefined" && r8 && (k = r8), k.indexOf("blob:") !== 0 ? k = k.substr(0, k.replace(/[?#].*/, "").lastIndexOf("/") + 1) : k = "", C || (E = (F) => {
            var V = new XMLHttpRequest();
            return V.open("GET", F, false), V.send(null), V.responseText;
          }, b && (D = (F) => {
            var V = new XMLHttpRequest();
            return V.open("GET", F, false), V.responseType = "arraybuffer", V.send(null), new Uint8Array(V.response);
          }), R = (F, V, ue) => {
            var Ee = new XMLHttpRequest();
            Ee.open("GET", F, true), Ee.responseType = "arraybuffer", Ee.onload = () => {
              if (Ee.status == 200 || Ee.status == 0 && Ee.response) {
                V(Ee.response);
                return;
              }
              ue();
            }, Ee.onerror = ue, Ee.send(null);
          }), (F) => document.title = F);
        C && typeof performance == "undefined" && (_global.performance = vB().performance);
        var B = console.log.bind(console), z = console.warn.bind(console);
        C && (B = (F) => M.writeSync(1, F + `
`), z = (F) => M.writeSync(2, F + `
`));
        var U = u.print || B, j = u.printErr || z;
        Object.assign(u, d), d = null, u.arguments && u.arguments, u.thisProgram && u.thisProgram, u.quit && (g = u.quit);
        var ne;
        u.wasmBinary && (ne = u.wasmBinary);
        var ee = u.noExitRuntime || true;
        typeof WebAssembly != "object" && Nu("no native wasm support detected");
        var oe, ie, le = false, be;
        function _e(F, V) {
          F || Nu(V);
        }
        var ve = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
        function Fe(F, V, ue) {
          V >>>= 0;
          for (var Ee = V + ue, Be = V; F[Be] && !(Be >= Ee); )
            ++Be;
          if (Be - V > 16 && F.buffer && ve)
            return ve.decode(F.buffer instanceof SharedArrayBuffer ? F.slice(V, Be) : F.subarray(V, Be));
          for (var Le = ""; V < Be; ) {
            var ge = F[V++];
            if (!(ge & 128)) {
              Le += String.fromCharCode(ge);
              continue;
            }
            var Ne = F[V++] & 63;
            if ((ge & 224) == 192) {
              Le += String.fromCharCode((ge & 31) << 6 | Ne);
              continue;
            }
            var Ft = F[V++] & 63;
            if ((ge & 240) == 224 ? ge = (ge & 15) << 12 | Ne << 6 | Ft : ge = (ge & 7) << 18 | Ne << 12 | Ft << 6 | F[V++] & 63, ge < 65536)
              Le += String.fromCharCode(ge);
            else {
              var no = ge - 65536;
              Le += String.fromCharCode(55296 | no >> 10, 56320 | no & 1023);
            }
          }
          return Le;
        }
        function Pe(F, V) {
          return F >>>= 0, F ? Fe(o8(), F, V) : "";
        }
        function st(F, V, ue, Ee) {
          if (ue >>>= 0, !(Ee > 0))
            return 0;
          for (var Be = ue, Le = ue + Ee - 1, ge = 0; ge < F.length; ++ge) {
            var Ne = F.charCodeAt(ge);
            if (Ne >= 55296 && Ne <= 57343) {
              var Ft = F.charCodeAt(++ge);
              Ne = 65536 + ((Ne & 1023) << 10) | Ft & 1023;
            }
            if (Ne <= 127) {
              if (ue >= Le)
                break;
              V[ue++ >>> 0] = Ne;
            } else if (Ne <= 2047) {
              if (ue + 1 >= Le)
                break;
              V[ue++ >>> 0] = 192 | Ne >> 6, V[ue++ >>> 0] = 128 | Ne & 63;
            } else if (Ne <= 65535) {
              if (ue + 2 >= Le)
                break;
              V[ue++ >>> 0] = 224 | Ne >> 12, V[ue++ >>> 0] = 128 | Ne >> 6 & 63, V[ue++ >>> 0] = 128 | Ne & 63;
            } else {
              if (ue + 3 >= Le)
                break;
              V[ue++ >>> 0] = 240 | Ne >> 18, V[ue++ >>> 0] = 128 | Ne >> 12 & 63, V[ue++ >>> 0] = 128 | Ne >> 6 & 63, V[ue++ >>> 0] = 128 | Ne & 63;
            }
          }
          return V[ue >>> 0] = 0, ue - Be;
        }
        function lt(F, V, ue) {
          return st(F, o8(), V, ue);
        }
        var Ue, mt, it, Lr, Mt, or;
        S && (Ue = u.buffer);
        function Tt(F) {
          Ue = F, u.HEAP8 = mt = new Int8Array(F), u.HEAP16 = new Int16Array(F), u.HEAP32 = Lr = new Int32Array(F), u.HEAPU8 = it = new Uint8Array(F), u.HEAPU16 = new Uint16Array(F), u.HEAPU32 = Mt = new Uint32Array(F), u.HEAPF32 = new Float32Array(F), u.HEAPF64 = or = new Float64Array(F);
        }
        var nr = u.INITIAL_MEMORY || 16777216;
        if (S)
          oe = u.wasmMemory, Ue = u.buffer;
        else if (u.wasmMemory)
          oe = u.wasmMemory;
        else if (oe = new WebAssembly.Memory({ initial: nr / 65536, maximum: 65536, shared: true }), !(oe.buffer instanceof SharedArrayBuffer))
          throw j("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), C && j("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
        oe && (Ue = oe.buffer), nr = Ue.byteLength, Tt(Ue);
        var sr, to = [], ro = [], fr = [];
        function Lo() {
          return ee;
        }
        function Hs() {
          if (u.preRun)
            for (typeof u.preRun == "function" && (u.preRun = [u.preRun]); u.preRun.length; )
              tl(u.preRun.shift());
          nl(to);
        }
        function Yt() {
          !S && nl(ro);
        }
        function za() {
          if (!S) {
            if (u.postRun)
              for (typeof u.postRun == "function" && (u.postRun = [u.postRun]); u.postRun.length; )
                o0(u.postRun.shift());
            nl(fr);
          }
        }
        function tl(F) {
          to.unshift(F);
        }
        function rl(F) {
          ro.unshift(F);
        }
        function o0(F) {
          fr.unshift(F);
        }
        var vi = 0, Va = null;
        function dy(F) {
          vi++, u.monitorRunDependencies && u.monitorRunDependencies(vi);
        }
        function ym(F) {
          if (vi--, u.monitorRunDependencies && u.monitorRunDependencies(vi), vi == 0 && Va) {
            var V = Va;
            Va = null, V();
          }
        }
        function Nu(F) {
          u.onAbort && u.onAbort(F), F = "Aborted(" + F + ")", j(F), le = true, be = 1, F += ". Build with -sASSERTIONS for more info.";
          var V = new WebAssembly.RuntimeError(F);
          throw l(V), V;
        }
        var fy = "data:application/octet-stream;base64,";
        function bm(F) {
          return F.startsWith(fy);
        }
        function Mp(F) {
          return F.startsWith("file://");
        }
        var hr;
        hr = "tfjs-backend-wasm-threaded-simd.wasm", bm(hr) || (hr = _(hr));
        function Cm(F) {
          try {
            if (F == hr && ne)
              return new Uint8Array(ne);
            if (D)
              return D(F);
            throw "both async and sync fetching of the wasm failed";
          } catch (V) {
            Nu(V);
          }
        }
        function hy() {
          if (!ne && (x || b)) {
            if (typeof fetch == "function" && !Mp(hr))
              return fetch(hr, { credentials: "same-origin" }).then(function(F) {
                if (!F.ok)
                  throw "failed to load wasm binary file at '" + hr + "'";
                return F.arrayBuffer();
              }).catch(function() {
                return Cm(hr);
              });
            if (R)
              return new Promise(function(F, V) {
                R(hr, function(ue) {
                  F(new Uint8Array(ue));
                }, V);
              });
          }
          return Promise.resolve().then(function() {
            return Cm(hr);
          });
        }
        function gy() {
          var F = { env: Am, wasi_snapshot_preview1: Am };
          function V(ge, Ne) {
            var Ft = ge.exports;
            if (u.asm = Ft, ky(u.asm._emscripten_tls_init), sr = u.asm.__indirect_function_table, rl(u.asm.__wasm_call_ctors), ie = Ne, !S) {
              var no = Me.unusedWorkers.length;
              Me.unusedWorkers.forEach(function(Ua) {
                Me.loadWasmModuleToWorker(Ua, function() {
                  --no || ym();
                });
              });
            }
          }
          S || dy();
          function ue(ge) {
            V(ge.instance, ge.module);
          }
          function Ee(ge) {
            return hy().then(function(Ne) {
              return WebAssembly.instantiate(Ne, F);
            }).then(function(Ne) {
              return Ne;
            }).then(ge, function(Ne) {
              j("failed to asynchronously prepare wasm: " + Ne), Nu(Ne);
            });
          }
          function Be() {
            return !ne && typeof WebAssembly.instantiateStreaming == "function" && !bm(hr) && !Mp(hr) && !C && typeof fetch == "function" ? fetch(hr, { credentials: "same-origin" }).then(function(ge) {
              var Ne = WebAssembly.instantiateStreaming(ge, F);
              return Ne.then(ue, function(Ft) {
                return j("wasm streaming compile failed: " + Ft), j("falling back to ArrayBuffer instantiation"), Ee(ue);
              });
            }) : Ee(ue);
          }
          if (u.instantiateWasm)
            try {
              var Le = u.instantiateWasm(F, V);
              return Le;
            } catch (ge) {
              j("Module.instantiateWasm callback failed with error: " + ge), l(ge);
            }
          return Be().catch(l), {};
        }
        var wm = {};
        function Tu(F) {
          this.name = "ExitStatus", this.message = "Program terminated with exit(" + F + ")", this.status = F;
        }
        function xy(F) {
          var V = Me.pthreads[F];
          delete Me.pthreads[F], V.terminate(), VC(F), Me.runningWorkers.splice(Me.runningWorkers.indexOf(V), 1), V.pthread_ptr = 0;
        }
        function yy(F) {
          var V = Me.pthreads[F];
          V.postMessage({ cmd: "cancel" });
        }
        function ol(F) {
          var V = Me.pthreads[F];
          _e(V), Me.returnWorkerToPool(V);
        }
        function by(F) {
          var V = Me.getNewWorker();
          if (!V)
            return 6;
          Me.runningWorkers.push(V), Me.pthreads[F.pthread_ptr] = V, V.pthread_ptr = F.pthread_ptr;
          var ue = { cmd: "run", start_routine: F.startRoutine, arg: F.arg, pthread_ptr: F.pthread_ptr };
          return V.runPthread = () => {
            C && V.ref(), V.postMessage(ue, F.transferList), delete V.runPthread;
          }, V.loaded && V.runPthread(), 0;
        }
        function Im(F) {
          if (S)
            return ki(1, 1, F);
          be = F, Lo() || (Me.terminateAllThreads(), u.onExit && u.onExit(F), le = true), g(F, new Tu(F));
        }
        function Cy(F, V) {
          if (be = F, !V && S)
            throw km(F), "unwind";
          Im(F);
        }
        var vm = Cy;
        function wy(F) {
          if (F instanceof Tu || F == "unwind")
            return be;
          g(1, F);
        }
        var Me = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], pthreads: {}, init: function() {
          S ? Me.initWorker() : Me.initMainThread();
        }, initMainThread: function() {
          for (var F = 8; F--; )
            Me.allocateUnusedWorker();
        }, initWorker: function() {
          ee = false;
        }, setExitStatus: function(F) {
          be = F;
        }, terminateAllThreads: function() {
          for (var F of Object.values(Me.pthreads))
            Me.returnWorkerToPool(F);
          for (var F of Me.unusedWorkers)
            F.terminate();
          Me.unusedWorkers = [];
        }, returnWorkerToPool: function(F) {
          var V = F.pthread_ptr;
          delete Me.pthreads[V], Me.unusedWorkers.push(F), Me.runningWorkers.splice(Me.runningWorkers.indexOf(F), 1), F.pthread_ptr = 0, C && F.unref(), VC(V);
        }, receiveObjectTransfer: function(F) {
        }, threadInitTLS: function() {
          Me.tlsInitFunctions.forEach((F) => F());
        }, loadWasmModuleToWorker: function(F, V) {
          F.onmessage = (Le) => {
            var ge = Le.data, Ne = ge.cmd;
            if (F.pthread_ptr && (Me.currentProxiedOperationCallerThread = F.pthread_ptr), ge.targetThread && ge.targetThread != Bm()) {
              var Ft = Me.pthreads[ge.targetThread];
              Ft ? Ft.postMessage(ge, ge.transferList) : j('Internal error! Worker sent a message "' + Ne + '" to target pthread ' + ge.targetThread + ", but that thread no longer exists!"), Me.currentProxiedOperationCallerThread = void 0;
              return;
            }
            Ne === "processProxyingQueue" ? sl(ge.queue) : Ne === "spawnThread" ? by(ge) : Ne === "cleanupThread" ? ol(ge.thread) : Ne === "killThread" ? xy(ge.thread) : Ne === "cancelThread" ? yy(ge.thread) : Ne === "loaded" ? (F.loaded = true, C && F.unref(), V && V(F), F.runPthread && F.runPthread()) : Ne === "print" ? U("Thread " + ge.threadId + ": " + ge.text) : Ne === "printErr" ? j("Thread " + ge.threadId + ": " + ge.text) : Ne === "alert" ? alert("Thread " + ge.threadId + ": " + ge.text) : ge.target === "setimmediate" ? F.postMessage(ge) : Ne === "callHandler" ? u[ge.handler](...ge.args) : Ne && j("worker sent an unknown command " + Ne), Me.currentProxiedOperationCallerThread = void 0;
          }, F.onerror = (Le) => {
            var ge = "worker sent an error!";
            throw j(ge + " " + Le.filename + ":" + Le.lineno + ": " + Le.message), Le;
          }, C && (F.on("message", function(Le) {
            F.onmessage({ data: Le });
          }), F.on("error", function(Le) {
            F.onerror(Le);
          }), F.on("detachedExit", function() {
          }));
          var ue = [], Ee = ["onExit", "onAbort", "print", "printErr"];
          for (var Be of Ee)
            u.hasOwnProperty(Be) && ue.push(Be);
          F.postMessage({ cmd: "load", handlers: ue, urlOrBlob: u.mainScriptUrlOrBlob || r8, wasmMemory: oe, wasmModule: ie });
        }, allocateUnusedWorker: function() {
          var F, V = _("tfjs-backend-wasm-threaded-simd.worker.js");
          F = new Worker(V), Me.unusedWorkers.push(F);
        }, getNewWorker: function() {
          return Me.unusedWorkers.length == 0 && (Me.allocateUnusedWorker(), Me.loadWasmModuleToWorker(Me.unusedWorkers[0])), Me.unusedWorkers.pop();
        } };
        u.PThread = Me;
        function nl(F) {
          for (; F.length > 0; )
            F.shift()(u);
        }
        function Sy() {
          var F = Bm(), V = s()[F + 52 >>> 2], ue = s()[F + 56 >>> 2], Ee = V - ue;
          l0(V, Ee), zm(V);
        }
        u.establishStackSpace = Sy;
        function km(F) {
          if (S)
            return ki(2, 0, F);
          try {
            vm(F);
          } catch (V) {
            wy(V);
          }
        }
        var Lp = [];
        function Iy(F) {
          var V = Lp[F];
          return V || (F >= Lp.length && (Lp.length = F + 1), Lp[F] = V = sr.get(F)), V;
        }
        function vy(F, V) {
          var ue = Iy(F)(V);
          Lo() ? Me.setExitStatus(ue) : c0(ue);
        }
        u.invokeEntryPoint = vy;
        function ky(F) {
          Me.tlsInitFunctions.push(F);
        }
        function Ny(F) {
          i0(F, !b, 1, !x), Me.threadInitTLS();
        }
        function Ty(F) {
          S ? postMessage({ cmd: "cleanupThread", thread: F }) : ol(F);
        }
        function Nm(F, V, ue, Ee) {
          return S ? ki(3, 1, F, V, ue, Ee) : Tm(F, V, ue, Ee);
        }
        function Tm(F, V, ue, Ee) {
          if (typeof SharedArrayBuffer == "undefined")
            return j("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
          var Be = [], Le = 0;
          if (S && (Be.length === 0 || Le))
            return Nm(F, V, ue, Ee);
          var ge = { startRoutine: ue, pthread_ptr: F, arg: Ee, transferList: Be };
          return S ? (ge.cmd = "spawnThread", postMessage(ge, Be), 0) : by(ge);
        }
        function _y() {
          return 65536;
        }
        var $y = true;
        function Ey() {
          return $y;
        }
        function sl(F) {
          Atomics.store(s(), F >> 2, 1), Bm() && p0(F), Atomics.compareExchange(s(), F >> 2, 1, 0);
        }
        u.executeNotifiedProxyingQueue = sl;
        function Ry(F, V, ue, Ee) {
          if (F == V)
            setTimeout(() => sl(Ee));
          else if (S)
            postMessage({ targetThread: F, cmd: "processProxyingQueue", queue: Ee });
          else {
            var Be = Me.pthreads[F];
            if (!Be)
              return;
            Be.postMessage({ cmd: "processProxyingQueue", queue: Ee });
          }
          return 1;
        }
        function Dy(F, V, ue) {
          return -1;
        }
        function Ay() {
          Nu("");
        }
        function _u(F) {
          _u.shown || (_u.shown = {}), _u.shown[F] || (_u.shown[F] = 1, C && (F = "warning: " + F), j(F));
        }
        function Fy() {
          C || b || _u("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
        }
        function Py() {
          return Date.now();
        }
        function _m() {
          return 4294901760;
        }
        function Oy() {
          return _m();
        }
        var al;
        C ? al = () => {
          var F = process$1.hrtime();
          return F[0] * 1e3 + F[1] / 1e6;
        } : al = () => performance.timeOrigin + performance.now();
        function My(F, V, ue) {
          o8().copyWithin(F >>> 0, V >>> 0, V + ue >>> 0);
        }
        function Ly() {
          return C ? kB().cpus().length : navigator.hardwareConcurrency;
        }
        function By(F) {
          var V = WC(), ue = F();
          return zm(V), ue;
        }
        function ki(F, V) {
          var ue = arguments.length - 2, Ee = arguments;
          return By(() => {
            for (var Be = ue, Le = Vm(Be * 8), ge = Le >> 3, Ne = 0; Ne < ue; Ne++) {
              var Ft = Ee[2 + Ne];
              p()[ge + Ne >>> 0] = Ft;
            }
            return u0(F, Be, Le, V);
          });
        }
        var il = [];
        function zy(F, V, ue) {
          il.length = V;
          for (var Ee = ue >> 3, Be = 0; Be < V; Be++)
            il[Be] = p()[Ee + Be >>> 0];
          var Le = F < 0, ge = Le ? wm[-F - 1] : Xy[F];
          return ge.apply(null, il);
        }
        function Vy(F) {
          try {
            return oe.grow(F - Ue.byteLength + 65535 >>> 16), Tt(oe.buffer), 1;
          } catch (V) {
          }
        }
        function Wy(F) {
          var V = o8().length;
          if (F = F >>> 0, F <= V)
            return false;
          var ue = _m();
          if (F > ue)
            return false;
          let Ee = (Ft, no) => Ft + (no - Ft % no) % no;
          for (var Be = 1; Be <= 4; Be *= 2) {
            var Le = V * (1 + 0.2 / Be);
            Le = Math.min(Le, F + 100663296);
            var ge = Math.min(ue, Ee(Math.max(F, Le), 65536)), Ne = Vy(ge);
            if (Ne)
              return true;
          }
          return false;
        }
        function Uy() {
          throw "unwind";
        }
        function $m(F) {
          return S ? ki(4, 1, F) : 52;
        }
        function Em(F, V, ue, Ee, Be) {
          return S ? ki(5, 1, F, V, ue, Ee, Be) : 70;
        }
        var Gy = [null, [], []];
        function Hy(F, V) {
          var ue = Gy[F];
          V === 0 || V === 10 ? ((F === 1 ? U : j)(Fe(ue, 0)), ue.length = 0) : ue.push(V);
        }
        function Rm(F, V, ue, Ee) {
          if (S)
            return ki(6, 1, F, V, ue, Ee);
          for (var Be = 0, Le = 0; Le < ue; Le++) {
            var ge = a()[V >>> 2], Ne = a()[V + 4 >>> 2];
            V += 8;
            for (var Ft = 0; Ft < Ne; Ft++)
              Hy(F, o8()[ge + Ft >>> 0]);
            Be += Ne;
          }
          return a()[Ee >>> 2] = Be, 0;
        }
        function Dm(F) {
          var V = u["_" + F];
          return V;
        }
        function Ky(F, V) {
          t8().set(F, V >>> 0);
        }
        function qy(F, V, ue, Ee, Be) {
          var Le = { string: (Br) => {
            var Wp = 0;
            if (Br != null && Br !== 0) {
              var f0 = (Br.length << 2) + 1;
              Wp = Vm(f0), lt(Br, Wp, f0);
            }
            return Wp;
          }, array: (Br) => {
            var Wp = Vm(Br.length);
            return Ky(Br, Wp), Wp;
          } };
          function ge(Br) {
            return V === "string" ? Pe(Br) : V === "boolean" ? !!Br : Br;
          }
          var Ne = Dm(F), Ft = [], no = 0;
          if (Ee)
            for (var Ua = 0; Ua < Ee.length; Ua++) {
              var d0 = Le[ue[Ua]];
              d0 ? (no === 0 && (no = WC()), Ft[Ua] = d0(Ee[Ua])) : Ft[Ua] = Ee[Ua];
            }
          var UC = Ne.apply(null, Ft);
          function pG(Br) {
            return no !== 0 && zm(no), ge(Br);
          }
          return UC = pG(UC), UC;
        }
        function jy(F, V, ue, Ee) {
          ue = ue || [];
          var Be = ue.every((ge) => ge === "number" || ge === "boolean"), Le = V !== "string";
          return Le && Be && !Ee ? Dm(F) : function() {
            return qy(F, V, ue, arguments);
          };
        }
        Me.init();
        var Xy = [null, Im, km, Nm, $m, Em, Rm], Am = { __emscripten_init_main_thread_js: Ny, __emscripten_thread_cleanup: Ty, __pthread_create_js: Tm, _emscripten_default_pthread_stack_size: _y, _emscripten_get_now_is_monotonic: Ey, _emscripten_notify_task_queue: Ry, _emscripten_set_offscreencanvas_size: Dy, abort: Ay, emscripten_check_blocking_allowed: Fy, emscripten_date_now: Py, emscripten_get_heap_max: Oy, emscripten_get_now: al, emscripten_memcpy_big: My, emscripten_num_logical_cores: Ly, emscripten_receive_on_main_thread_js: zy, emscripten_resize_heap: Wy, emscripten_unwind_to_js_event_loop: Uy, exit: vm, fd_close: $m, fd_seek: Em, fd_write: Rm, memory: oe || u.wasmMemory };
        gy();
        u.___wasm_call_ctors = function() {
          return (u.___wasm_call_ctors = u.asm.__wasm_call_ctors).apply(null, arguments);
        };
        u._init = function() {
          return (u._init = u.asm.init).apply(null, arguments);
        };
        u._init_with_threads_count = function() {
          return (u._init_with_threads_count = u.asm.init_with_threads_count).apply(null, arguments);
        };
        u._get_threads_count = function() {
          return (u._get_threads_count = u.asm.get_threads_count).apply(null, arguments);
        };
        u._register_tensor = function() {
          return (u._register_tensor = u.asm.register_tensor).apply(null, arguments);
        };
        u._dispose_data = function() {
          return (u._dispose_data = u.asm.dispose_data).apply(null, arguments);
        };
        u._dispose = function() {
          return (u._dispose = u.asm.dispose).apply(null, arguments);
        };
        u._Abs = function() {
          return (u._Abs = u.asm.Abs).apply(null, arguments);
        };
        u._Acos = function() {
          return (u._Acos = u.asm.Acos).apply(null, arguments);
        };
        u._Acosh = function() {
          return (u._Acosh = u.asm.Acosh).apply(null, arguments);
        };
        u._Add = function() {
          return (u._Add = u.asm.Add).apply(null, arguments);
        };
        u._AddN = function() {
          return (u._AddN = u.asm.AddN).apply(null, arguments);
        };
        u._All = function() {
          return (u._All = u.asm.All).apply(null, arguments);
        };
        u._Any = function() {
          return (u._Any = u.asm.Any).apply(null, arguments);
        };
        u._ArgMax = function() {
          return (u._ArgMax = u.asm.ArgMax).apply(null, arguments);
        };
        u._ArgMin = function() {
          return (u._ArgMin = u.asm.ArgMin).apply(null, arguments);
        };
        u._Asin = function() {
          return (u._Asin = u.asm.Asin).apply(null, arguments);
        };
        u._Asinh = function() {
          return (u._Asinh = u.asm.Asinh).apply(null, arguments);
        };
        u._Atan = function() {
          return (u._Atan = u.asm.Atan).apply(null, arguments);
        };
        u._Atan2 = function() {
          return (u._Atan2 = u.asm.Atan2).apply(null, arguments);
        };
        u._Atanh = function() {
          return (u._Atanh = u.asm.Atanh).apply(null, arguments);
        };
        u._AvgPool = function() {
          return (u._AvgPool = u.asm.AvgPool).apply(null, arguments);
        };
        u._AvgPool3D = function() {
          return (u._AvgPool3D = u.asm.AvgPool3D).apply(null, arguments);
        };
        u._AvgPool3DGrad = function() {
          return (u._AvgPool3DGrad = u.asm.AvgPool3DGrad).apply(null, arguments);
        };
        u._AvgPoolGrad = function() {
          return (u._AvgPoolGrad = u.asm.AvgPoolGrad).apply(null, arguments);
        };
        u._BatchMatMul = function() {
          return (u._BatchMatMul = u.asm.BatchMatMul).apply(null, arguments);
        };
        u._Bincount = function() {
          return (u._Bincount = u.asm.Bincount).apply(null, arguments);
        };
        u._BitwiseAnd = function() {
          return (u._BitwiseAnd = u.asm.BitwiseAnd).apply(null, arguments);
        };
        u._Ceil = function() {
          return (u._Ceil = u.asm.Ceil).apply(null, arguments);
        };
        u._ClipByValue = function() {
          return (u._ClipByValue = u.asm.ClipByValue).apply(null, arguments);
        };
        u._Conv2D = function() {
          return (u._Conv2D = u.asm.Conv2D).apply(null, arguments);
        };
        u._Conv2DBackpropInput = function() {
          return (u._Conv2DBackpropInput = u.asm.Conv2DBackpropInput).apply(null, arguments);
        };
        u._Conv3D = function() {
          return (u._Conv3D = u.asm.Conv3D).apply(null, arguments);
        };
        u._Conv3DBackpropFilterV2 = function() {
          return (u._Conv3DBackpropFilterV2 = u.asm.Conv3DBackpropFilterV2).apply(null, arguments);
        };
        u._Conv3DBackpropInputV2 = function() {
          return (u._Conv3DBackpropInputV2 = u.asm.Conv3DBackpropInputV2).apply(null, arguments);
        };
        u._Cos = function() {
          return (u._Cos = u.asm.Cos).apply(null, arguments);
        };
        u._Cosh = function() {
          return (u._Cosh = u.asm.Cosh).apply(null, arguments);
        };
        u._CropAndResize = function() {
          return (u._CropAndResize = u.asm.CropAndResize).apply(null, arguments);
        };
        u._Cumprod = function() {
          return (u._Cumprod = u.asm.Cumprod).apply(null, arguments);
        };
        u._Cumsum = function() {
          return (u._Cumsum = u.asm.Cumsum).apply(null, arguments);
        };
        u._DenseBincount = function() {
          return (u._DenseBincount = u.asm.DenseBincount).apply(null, arguments);
        };
        u._DepthToSpace = function() {
          return (u._DepthToSpace = u.asm.DepthToSpace).apply(null, arguments);
        };
        u._DepthwiseConv2dNative = function() {
          return (u._DepthwiseConv2dNative = u.asm.DepthwiseConv2dNative).apply(null, arguments);
        };
        u._Diag = function() {
          return (u._Diag = u.asm.Diag).apply(null, arguments);
        };
        u._Dilation2D = function() {
          return (u._Dilation2D = u.asm.Dilation2D).apply(null, arguments);
        };
        u._Dilation2DBackpropFilter = function() {
          return (u._Dilation2DBackpropFilter = u.asm.Dilation2DBackpropFilter).apply(null, arguments);
        };
        u._Dilation2DBackpropInput = function() {
          return (u._Dilation2DBackpropInput = u.asm.Dilation2DBackpropInput).apply(null, arguments);
        };
        u._Elu = function() {
          return (u._Elu = u.asm.Elu).apply(null, arguments);
        };
        u._EluGrad = function() {
          return (u._EluGrad = u.asm.EluGrad).apply(null, arguments);
        };
        u._Equal = function() {
          return (u._Equal = u.asm.Equal).apply(null, arguments);
        };
        u._Erf = function() {
          return (u._Erf = u.asm.Erf).apply(null, arguments);
        };
        u._Exp = function() {
          return (u._Exp = u.asm.Exp).apply(null, arguments);
        };
        u._Expm1 = function() {
          return (u._Expm1 = u.asm.Expm1).apply(null, arguments);
        };
        u._FlipLeftRight = function() {
          return (u._FlipLeftRight = u.asm.FlipLeftRight).apply(null, arguments);
        };
        u._Floor = function() {
          return (u._Floor = u.asm.Floor).apply(null, arguments);
        };
        u._FloorDiv = function() {
          return (u._FloorDiv = u.asm.FloorDiv).apply(null, arguments);
        };
        u._FusedBatchNorm = function() {
          return (u._FusedBatchNorm = u.asm.FusedBatchNorm).apply(null, arguments);
        };
        u._FusedConv2D = function() {
          return (u._FusedConv2D = u.asm.FusedConv2D).apply(null, arguments);
        };
        u._FusedDepthwiseConv2D = function() {
          return (u._FusedDepthwiseConv2D = u.asm.FusedDepthwiseConv2D).apply(null, arguments);
        };
        u._Gather = function() {
          return (u._Gather = u.asm.Gather).apply(null, arguments);
        };
        u._GatherNd = function() {
          return (u._GatherNd = u.asm.GatherNd).apply(null, arguments);
        };
        u._Greater = function() {
          return (u._Greater = u.asm.Greater).apply(null, arguments);
        };
        u._GreaterEqual = function() {
          return (u._GreaterEqual = u.asm.GreaterEqual).apply(null, arguments);
        };
        u._IsFinite = function() {
          return (u._IsFinite = u.asm.IsFinite).apply(null, arguments);
        };
        u._IsInf = function() {
          return (u._IsInf = u.asm.IsInf).apply(null, arguments);
        };
        u._IsNan = function() {
          return (u._IsNan = u.asm.IsNan).apply(null, arguments);
        };
        u._LRN = function() {
          return (u._LRN = u.asm.LRN).apply(null, arguments);
        };
        u._LRNGrad = function() {
          return (u._LRNGrad = u.asm.LRNGrad).apply(null, arguments);
        };
        u._LeakyRelu = function() {
          return (u._LeakyRelu = u.asm.LeakyRelu).apply(null, arguments);
        };
        u._Less = function() {
          return (u._Less = u.asm.Less).apply(null, arguments);
        };
        u._LessEqual = function() {
          return (u._LessEqual = u.asm.LessEqual).apply(null, arguments);
        };
        u._LinSpace = function() {
          return (u._LinSpace = u.asm.LinSpace).apply(null, arguments);
        };
        u._Log = function() {
          return (u._Log = u.asm.Log).apply(null, arguments);
        };
        u._Log1p = function() {
          return (u._Log1p = u.asm.Log1p).apply(null, arguments);
        };
        u._LogicalAnd = function() {
          return (u._LogicalAnd = u.asm.LogicalAnd).apply(null, arguments);
        };
        u._LogicalNot = function() {
          return (u._LogicalNot = u.asm.LogicalNot).apply(null, arguments);
        };
        u._LogicalOr = function() {
          return (u._LogicalOr = u.asm.LogicalOr).apply(null, arguments);
        };
        u._LogicalXor = function() {
          return (u._LogicalXor = u.asm.LogicalXor).apply(null, arguments);
        };
        u._Max = function() {
          return (u._Max = u.asm.Max).apply(null, arguments);
        };
        u._MaxPool = function() {
          return (u._MaxPool = u.asm.MaxPool).apply(null, arguments);
        };
        u._MaxPool3D = function() {
          return (u._MaxPool3D = u.asm.MaxPool3D).apply(null, arguments);
        };
        u._MaxPool3DGrad = function() {
          return (u._MaxPool3DGrad = u.asm.MaxPool3DGrad).apply(null, arguments);
        };
        u._MaxPoolGrad = function() {
          return (u._MaxPoolGrad = u.asm.MaxPoolGrad).apply(null, arguments);
        };
        u._MaxPoolWithArgmax = function() {
          return (u._MaxPoolWithArgmax = u.asm.MaxPoolWithArgmax).apply(null, arguments);
        };
        u._Maximum = function() {
          return (u._Maximum = u.asm.Maximum).apply(null, arguments);
        };
        u._Mean = function() {
          return (u._Mean = u.asm.Mean).apply(null, arguments);
        };
        u._Min = function() {
          return (u._Min = u.asm.Min).apply(null, arguments);
        };
        u._Minimum = function() {
          return (u._Minimum = u.asm.Minimum).apply(null, arguments);
        };
        u._MirrorPad = function() {
          return (u._MirrorPad = u.asm.MirrorPad).apply(null, arguments);
        };
        u._Mod = function() {
          return (u._Mod = u.asm.Mod).apply(null, arguments);
        };
        u._Multinomial = function() {
          return (u._Multinomial = u.asm.Multinomial).apply(null, arguments);
        };
        u._Multiply = function() {
          return (u._Multiply = u.asm.Multiply).apply(null, arguments);
        };
        u._Neg = function() {
          return (u._Neg = u.asm.Neg).apply(null, arguments);
        };
        u._NonMaxSuppressionV3 = function() {
          return (u._NonMaxSuppressionV3 = u.asm.NonMaxSuppressionV3).apply(null, arguments);
        };
        u._NonMaxSuppressionV4 = function() {
          return (u._NonMaxSuppressionV4 = u.asm.NonMaxSuppressionV4).apply(null, arguments);
        };
        u._NonMaxSuppressionV5 = function() {
          return (u._NonMaxSuppressionV5 = u.asm.NonMaxSuppressionV5).apply(null, arguments);
        };
        u._NotEqual = function() {
          return (u._NotEqual = u.asm.NotEqual).apply(null, arguments);
        };
        u._OneHot = function() {
          return (u._OneHot = u.asm.OneHot).apply(null, arguments);
        };
        u._PadV2 = function() {
          return (u._PadV2 = u.asm.PadV2).apply(null, arguments);
        };
        u._Pow = function() {
          return (u._Pow = u.asm.Pow).apply(null, arguments);
        };
        u._Prelu = function() {
          return (u._Prelu = u.asm.Prelu).apply(null, arguments);
        };
        u._Prod = function() {
          return (u._Prod = u.asm.Prod).apply(null, arguments);
        };
        u._RealDiv = function() {
          return (u._RealDiv = u.asm.RealDiv).apply(null, arguments);
        };
        u._Reciprocal = function() {
          return (u._Reciprocal = u.asm.Reciprocal).apply(null, arguments);
        };
        u._Relu = function() {
          return (u._Relu = u.asm.Relu).apply(null, arguments);
        };
        u._Relu6 = function() {
          return (u._Relu6 = u.asm.Relu6).apply(null, arguments);
        };
        u._ResizeBilinear = function() {
          return (u._ResizeBilinear = u.asm.ResizeBilinear).apply(null, arguments);
        };
        u._ResizeBilinearGrad = function() {
          return (u._ResizeBilinearGrad = u.asm.ResizeBilinearGrad).apply(null, arguments);
        };
        u._ResizeNearestNeighbor = function() {
          return (u._ResizeNearestNeighbor = u.asm.ResizeNearestNeighbor).apply(null, arguments);
        };
        u._ResizeNearestNeighborGrad = function() {
          return (u._ResizeNearestNeighborGrad = u.asm.ResizeNearestNeighborGrad).apply(null, arguments);
        };
        u._Reverse = function() {
          return (u._Reverse = u.asm.Reverse).apply(null, arguments);
        };
        u._RotateWithOffset = function() {
          return (u._RotateWithOffset = u.asm.RotateWithOffset).apply(null, arguments);
        };
        u._Round = function() {
          return (u._Round = u.asm.Round).apply(null, arguments);
        };
        u._Rsqrt = function() {
          return (u._Rsqrt = u.asm.Rsqrt).apply(null, arguments);
        };
        u._ScatterNd = function() {
          return (u._ScatterNd = u.asm.ScatterNd).apply(null, arguments);
        };
        u._SearchSorted = function() {
          return (u._SearchSorted = u.asm.SearchSorted).apply(null, arguments);
        };
        u._SelectV2 = function() {
          return (u._SelectV2 = u.asm.SelectV2).apply(null, arguments);
        };
        u._Selu = function() {
          return (u._Selu = u.asm.Selu).apply(null, arguments);
        };
        u._Sigmoid = function() {
          return (u._Sigmoid = u.asm.Sigmoid).apply(null, arguments);
        };
        u._Sign = function() {
          return (u._Sign = u.asm.Sign).apply(null, arguments);
        };
        u._Sin = function() {
          return (u._Sin = u.asm.Sin).apply(null, arguments);
        };
        u._Sinh = function() {
          return (u._Sinh = u.asm.Sinh).apply(null, arguments);
        };
        u._Softmax = function() {
          return (u._Softmax = u.asm.Softmax).apply(null, arguments);
        };
        u._Softplus = function() {
          return (u._Softplus = u.asm.Softplus).apply(null, arguments);
        };
        u._SparseFillEmptyRows = function() {
          return (u._SparseFillEmptyRows = u.asm.SparseFillEmptyRows).apply(null, arguments);
        };
        u._SparseReshape = function() {
          return (u._SparseReshape = u.asm.SparseReshape).apply(null, arguments);
        };
        u._SparseSegmentReduction = function() {
          return (u._SparseSegmentReduction = u.asm.SparseSegmentReduction).apply(null, arguments);
        };
        u._SparseToDense = function() {
          return (u._SparseToDense = u.asm.SparseToDense).apply(null, arguments);
        };
        u._Sqrt = function() {
          return (u._Sqrt = u.asm.Sqrt).apply(null, arguments);
        };
        u._Square = function() {
          return (u._Square = u.asm.Square).apply(null, arguments);
        };
        u._SquaredDifference = function() {
          return (u._SquaredDifference = u.asm.SquaredDifference).apply(null, arguments);
        };
        u._Step = function() {
          return (u._Step = u.asm.Step).apply(null, arguments);
        };
        u._StridedSlice = function() {
          return (u._StridedSlice = u.asm.StridedSlice).apply(null, arguments);
        };
        u._Sub = function() {
          return (u._Sub = u.asm.Sub).apply(null, arguments);
        };
        u._Sum = function() {
          return (u._Sum = u.asm.Sum).apply(null, arguments);
        };
        u._Tan = function() {
          return (u._Tan = u.asm.Tan).apply(null, arguments);
        };
        u._Tanh = function() {
          return (u._Tanh = u.asm.Tanh).apply(null, arguments);
        };
        u._TensorScatterUpdate = function() {
          return (u._TensorScatterUpdate = u.asm.TensorScatterUpdate).apply(null, arguments);
        };
        u._Tile = function() {
          return (u._Tile = u.asm.Tile).apply(null, arguments);
        };
        u._TopK = function() {
          return (u._TopK = u.asm.TopK).apply(null, arguments);
        };
        u._Transform = function() {
          return (u._Transform = u.asm.Transform).apply(null, arguments);
        };
        u._Transpose = function() {
          return (u._Transpose = u.asm.Transpose).apply(null, arguments);
        };
        u.__FusedMatMul = function() {
          return (u.__FusedMatMul = u.asm._FusedMatMul).apply(null, arguments);
        };
        u._malloc = function() {
          return (u._malloc = u.asm.malloc).apply(null, arguments);
        };
        u._free = function() {
          return (u._free = u.asm.free).apply(null, arguments);
        };
        u.__emscripten_tls_init = function() {
          return (u.__emscripten_tls_init = u.asm._emscripten_tls_init).apply(null, arguments);
        };
        var Bm = u._pthread_self = function() {
          return (Bm = u._pthread_self = u.asm.pthread_self).apply(null, arguments);
        };
        u.___errno_location = function() {
          return (u.___errno_location = u.asm.__errno_location).apply(null, arguments);
        };
        var i0 = u.__emscripten_thread_init = function() {
          return (i0 = u.__emscripten_thread_init = u.asm._emscripten_thread_init).apply(null, arguments);
        };
        u.__emscripten_thread_crashed = function() {
          return (u.__emscripten_thread_crashed = u.asm._emscripten_thread_crashed).apply(null, arguments);
        };
        u._emscripten_main_thread_process_queued_calls = function() {
          return (u._emscripten_main_thread_process_queued_calls = u.asm.emscripten_main_thread_process_queued_calls).apply(null, arguments);
        };
        u._emscripten_main_browser_thread_id = function() {
          return (u._emscripten_main_browser_thread_id = u.asm.emscripten_main_browser_thread_id).apply(null, arguments);
        };
        var u0 = u._emscripten_run_in_main_runtime_thread_js = function() {
          return (u0 = u._emscripten_run_in_main_runtime_thread_js = u.asm.emscripten_run_in_main_runtime_thread_js).apply(null, arguments);
        };
        u._emscripten_dispatch_to_thread_ = function() {
          return (u._emscripten_dispatch_to_thread_ = u.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
        };
        var p0 = u.__emscripten_proxy_execute_task_queue = function() {
          return (p0 = u.__emscripten_proxy_execute_task_queue = u.asm._emscripten_proxy_execute_task_queue).apply(null, arguments);
        }, VC = u.__emscripten_thread_free_data = function() {
          return (VC = u.__emscripten_thread_free_data = u.asm._emscripten_thread_free_data).apply(null, arguments);
        }, c0 = u.__emscripten_thread_exit = function() {
          return (c0 = u.__emscripten_thread_exit = u.asm._emscripten_thread_exit).apply(null, arguments);
        }, l0 = u._emscripten_stack_set_limits = function() {
          return (l0 = u._emscripten_stack_set_limits = u.asm.emscripten_stack_set_limits).apply(null, arguments);
        }, WC = u.stackSave = function() {
          return (WC = u.stackSave = u.asm.stackSave).apply(null, arguments);
        }, zm = u.stackRestore = function() {
          return (zm = u.stackRestore = u.asm.stackRestore).apply(null, arguments);
        }, Vm = u.stackAlloc = function() {
          return (Vm = u.stackAlloc = u.asm.stackAlloc).apply(null, arguments);
        };
        u.dynCall_iijjiiii = function() {
          return (u.dynCall_iijjiiii = u.asm.dynCall_iijjiiii).apply(null, arguments);
        };
        u.dynCall_jiji = function() {
          return (u.dynCall_jiji = u.asm.dynCall_jiji).apply(null, arguments);
        };
        u.keepRuntimeAlive = Lo, u.wasmMemory = oe, u.cwrap = jy, u.ExitStatus = Tu, u.PThread = Me;
        var Wm;
        Va = function F() {
          Wm || m0(), Wm || (Va = F);
        };
        function m0(F) {
          if (vi > 0)
            return;
          if (S) {
            c(u), Yt(), startWorker(u);
            return;
          }
          if (Hs(), vi > 0)
            return;
          function V() {
            Wm || (Wm = true, u.calledRun = true, !le && (Yt(), c(u), u.onRuntimeInitialized && u.onRuntimeInitialized(), za()));
          }
          u.setStatus ? (u.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              u.setStatus("");
            }, 1), V();
          }, 1)) : V();
        }
        if (u.preInit)
          for (typeof u.preInit == "function" && (u.preInit = [u.preInit]); u.preInit.length > 0; )
            u.preInit.pop()();
        m0();
        var Um;
        m && (Um = { uncaughtException: process$1.listeners("uncaughtException").filter(function(F) {
          return !m.uncaughtException.indexOf(F) > -1;
        }), unhandledRejection: process$1.listeners("unhandledRejection").filter(function(F) {
          return !m.unhandledRejection.indexOf(F) > -1;
        }) });
        var Gm;
        if (typeof WasmBackendModule != "undefined")
          Gm = WasmBackendModule;
        else if (typeof e8 != "undefined")
          Gm = e8;
        else
          throw new Error("Could not find wasm module in post.js");
        if (Um) {
          var uG = Gm._dispose;
          Gm._dispose = function() {
            uG(), Um.uncaughtException.forEach(function(F) {
              process$1.removeListener("uncaughtException", F);
            }), Um.unhandledRejection.forEach(function(F) {
              process$1.removeListener("unhandledRejection", F);
            });
          };
        }
        return e8.ready;
      };
    })();
    typeof zg == "object" && typeof Fv == "object" ? Fv.exports = Av : typeof define == "function" && define.amd ? define([], function() {
      return Av;
    }) : typeof zg == "object" && (zg.WasmBackendModuleThreadedSimd = Av);
  });
  var _B = qt((vFt, TB) => {
    TB.exports.wasmWorkerContents = `"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`;
  });
  var $B = qt((Vg, Ov) => {
    var Pv = (() => {
      var r8 = typeof document != "undefined" && document.currentScript ? document.currentScript.src : void 0;
      return typeof __filename != "undefined" && (r8 = r8 || __filename), function(e8) {
        e8 = e8 || {};
        var t8 = typeof e8 != "undefined" ? e8 : {}, o8, n8;
        t8.ready = new Promise(function(G, ae) {
          o8 = G, n8 = ae;
        });
        var s;
        typeof process$1 != "undefined" && process$1.listeners && (s = { uncaughtException: process$1.listeners("uncaughtException"), unhandledRejection: process$1.listeners("unhandledRejection") });
        var a = Object.assign({}, t8), c = typeof window == "object", l = typeof importScripts == "function", m = typeof process$1 == "object" && typeof process$1.versions == "object" && typeof process$1.versions.node == "string", d = "";
        function f(G) {
          return t8.locateFile ? t8.locateFile(G, d) : d + G;
        }
        var h, g, x;
        if (m) {
          var S = Rv(), k = Dv();
          l ? d = k.dirname(d) + "/" : d = __dirname + "/", h = (G, ae) => (G = Hs(G) ? new URL(G) : k.normalize(G), S.readFileSync(G, ae ? void 0 : "utf8")), x = (G) => {
            var ae = h(G, true);
            return ae.buffer || (ae = new Uint8Array(ae)), ae;
          }, g = (G, ae, $e) => {
            G = Hs(G) ? new URL(G) : k.normalize(G), S.readFile(G, function(at, _t) {
              at ? $e(at) : ae(_t.buffer);
            });
          }, process$1.argv.length > 1 && process$1.argv[1].replace(/\\/g, "/"), process$1.argv.slice(2), process$1.on("uncaughtException", function(G) {
            if (!(G instanceof Op))
              throw G;
          }), process$1.on("unhandledRejection", function(G) {
            throw G;
          }), t8.inspect = function() {
            return "[Emscripten Module object]";
          };
        } else
          (c || l) && (l ? d = self.location.href : typeof document != "undefined" && document.currentScript && (d = document.currentScript.src), r8 && (d = r8), d.indexOf("blob:") !== 0 ? d = d.substr(0, d.replace(/[?#].*/, "").lastIndexOf("/") + 1) : d = "", h = (G) => {
            var ae = new XMLHttpRequest();
            return ae.open("GET", G, false), ae.send(null), ae.responseText;
          }, l && (x = (G) => {
            var ae = new XMLHttpRequest();
            return ae.open("GET", G, false), ae.responseType = "arraybuffer", ae.send(null), new Uint8Array(ae.response);
          }), g = (G, ae, $e) => {
            var at = new XMLHttpRequest();
            at.open("GET", G, true), at.responseType = "arraybuffer", at.onload = () => {
              if (at.status == 200 || at.status == 0 && at.response) {
                ae(at.response);
                return;
              }
              $e();
            }, at.onerror = $e, at.send(null);
          }, (G) => document.title = G);
        var _ = t8.print || console.log.bind(console), E = t8.printErr || console.warn.bind(console);
        Object.assign(t8, a), a = null, t8.arguments && t8.arguments, t8.thisProgram && t8.thisProgram, t8.quit && t8.quit;
        var D;
        t8.wasmBinary && (D = t8.wasmBinary);
        t8.noExitRuntime || true;
        typeof WebAssembly != "object" && fr("no native wasm support detected");
        var O, M = false;
        var z = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
        function U(G, ae, $e) {
          ae >>>= 0;
          for (var at = ae + $e, _t = ae; G[_t] && !(_t >= at); )
            ++_t;
          if (_t - ae > 16 && G.buffer && z)
            return z.decode(G.subarray(ae, _t));
          for (var $t = ""; ae < _t; ) {
            var Qe = G[ae++];
            if (!(Qe & 128)) {
              $t += String.fromCharCode(Qe);
              continue;
            }
            var He = G[ae++] & 63;
            if ((Qe & 224) == 192) {
              $t += String.fromCharCode((Qe & 31) << 6 | He);
              continue;
            }
            var Gt = G[ae++] & 63;
            if ((Qe & 240) == 224 ? Qe = (Qe & 15) << 12 | He << 6 | Gt : Qe = (Qe & 7) << 18 | He << 12 | Gt << 6 | G[ae++] & 63, Qe < 65536)
              $t += String.fromCharCode(Qe);
            else {
              var oo = Qe - 65536;
              $t += String.fromCharCode(55296 | oo >> 10, 56320 | oo & 1023);
            }
          }
          return $t;
        }
        function j(G, ae) {
          return G >>>= 0, G ? U(ne, G, ae) : "";
        }
        function q(G, ae, $e, at) {
          if ($e >>>= 0, !(at > 0))
            return 0;
          for (var _t = $e, $t = $e + at - 1, Qe = 0; Qe < G.length; ++Qe) {
            var He = G.charCodeAt(Qe);
            if (He >= 55296 && He <= 57343) {
              var Gt = G.charCodeAt(++Qe);
              He = 65536 + ((He & 1023) << 10) | Gt & 1023;
            }
            if (He <= 127) {
              if ($e >= $t)
                break;
              ae[$e++ >>> 0] = He;
            } else if (He <= 2047) {
              if ($e + 1 >= $t)
                break;
              ae[$e++ >>> 0] = 192 | He >> 6, ae[$e++ >>> 0] = 128 | He & 63;
            } else if (He <= 65535) {
              if ($e + 2 >= $t)
                break;
              ae[$e++ >>> 0] = 224 | He >> 12, ae[$e++ >>> 0] = 128 | He >> 6 & 63, ae[$e++ >>> 0] = 128 | He & 63;
            } else {
              if ($e + 3 >= $t)
                break;
              ae[$e++ >>> 0] = 240 | He >> 18, ae[$e++ >>> 0] = 128 | He >> 12 & 63, ae[$e++ >>> 0] = 128 | He >> 6 & 63, ae[$e++ >>> 0] = 128 | He & 63;
            }
          }
          return ae[$e >>> 0] = 0, $e - _t;
        }
        function Y(G, ae, $e) {
          return q(G, ne, ae, $e);
        }
        var J, re, ne, le;
        function ve(G) {
          J = G, t8.HEAP8 = re = new Int8Array(G), t8.HEAP16 = new Int16Array(G), t8.HEAP32 = new Int32Array(G), t8.HEAPU8 = ne = new Uint8Array(G), t8.HEAPU16 = new Uint16Array(G), t8.HEAPU32 = le = new Uint32Array(G), t8.HEAPF32 = new Float32Array(G), t8.HEAPF64 = new Float64Array(G);
        }
        t8.INITIAL_MEMORY || 16777216;
        var st = [], lt = [], Ue = [];
        function gt() {
          if (t8.preRun)
            for (typeof t8.preRun == "function" && (t8.preRun = [t8.preRun]); t8.preRun.length; )
              Mt(t8.preRun.shift());
          Va(st);
        }
        function xt() {
          Va(lt);
        }
        function Lr() {
          if (t8.postRun)
            for (typeof t8.postRun == "function" && (t8.postRun = [t8.postRun]); t8.postRun.length; )
              or(t8.postRun.shift());
          Va(Ue);
        }
        function Mt(G) {
          st.unshift(G);
        }
        function eo(G) {
          lt.unshift(G);
        }
        function or(G) {
          Ue.unshift(G);
        }
        var Tt = 0, sr = null;
        function to(G) {
          Tt++, t8.monitorRunDependencies && t8.monitorRunDependencies(Tt);
        }
        function ro(G) {
          if (Tt--, t8.monitorRunDependencies && t8.monitorRunDependencies(Tt), Tt == 0 && sr) {
            var ae = sr;
            sr = null, ae();
          }
        }
        function fr(G) {
          t8.onAbort && t8.onAbort(G), G = "Aborted(" + G + ")", E(G), M = true, G += ". Build with -sASSERTIONS for more info.";
          var ae = new WebAssembly.RuntimeError(G);
          throw n8(ae), ae;
        }
        var Ba = "data:application/octet-stream;base64,";
        function Lo(G) {
          return G.startsWith(Ba);
        }
        function Hs(G) {
          return G.startsWith("file://");
        }
        var Yt;
        Yt = "tfjs-backend-wasm.wasm", Lo(Yt) || (Yt = f(Yt));
        function za(G) {
          try {
            if (G == Yt && D)
              return new Uint8Array(D);
            if (x)
              return x(G);
            throw "both async and sync fetching of the wasm failed";
          } catch (ae) {
            fr(ae);
          }
        }
        function tl() {
          if (!D && (c || l)) {
            if (typeof fetch == "function" && !Hs(Yt))
              return fetch(Yt, { credentials: "same-origin" }).then(function(G) {
                if (!G.ok)
                  throw "failed to load wasm binary file at '" + Yt + "'";
                return G.arrayBuffer();
              }).catch(function() {
                return za(Yt);
              });
            if (g)
              return new Promise(function(G, ae) {
                g(Yt, function($e) {
                  G(new Uint8Array($e));
                }, ae);
              });
          }
          return Promise.resolve().then(function() {
            return za(Yt);
          });
        }
        function rl() {
          var G = { env: ol, wasi_snapshot_preview1: ol };
          function ae(Qe, He) {
            var Gt = Qe.exports;
            t8.asm = Gt, O = t8.asm.memory, ve(O.buffer), t8.asm.__indirect_function_table, eo(t8.asm.__wasm_call_ctors), ro();
          }
          to();
          function $e(Qe) {
            ae(Qe.instance);
          }
          function at(Qe) {
            return tl().then(function(He) {
              return WebAssembly.instantiate(He, G);
            }).then(function(He) {
              return He;
            }).then(Qe, function(He) {
              E("failed to asynchronously prepare wasm: " + He), fr(He);
            });
          }
          function _t() {
            return !D && typeof WebAssembly.instantiateStreaming == "function" && !Lo(Yt) && !Hs(Yt) && !m && typeof fetch == "function" ? fetch(Yt, { credentials: "same-origin" }).then(function(Qe) {
              var He = WebAssembly.instantiateStreaming(Qe, G);
              return He.then($e, function(Gt) {
                return E("wasm streaming compile failed: " + Gt), E("falling back to ArrayBuffer instantiation"), at($e);
              });
            }) : at($e);
          }
          if (t8.instantiateWasm)
            try {
              var $t = t8.instantiateWasm(G, ae);
              return $t;
            } catch (Qe) {
              E("Module.instantiateWasm callback failed with error: " + Qe), n8(Qe);
            }
          return _t().catch(n8), {};
        }
        function Op(G) {
          this.name = "ExitStatus", this.message = "Program terminated with exit(" + G + ")", this.status = G;
        }
        function Va(G) {
          for (; G.length > 0; )
            G.shift()(t8);
        }
        function dy() {
          fr("");
        }
        function ym() {
          return 4294901760;
        }
        function Nu() {
          return ym();
        }
        function fy(G, ae, $e) {
          ne.copyWithin(G >>> 0, ae >>> 0, ae + $e >>> 0);
        }
        function bm(G) {
          try {
            return O.grow(G - J.byteLength + 65535 >>> 16), ve(O.buffer), 1;
          } catch (ae) {
          }
        }
        function Mp(G) {
          var ae = ne.length;
          G = G >>> 0;
          var $e = ym();
          if (G > $e)
            return false;
          let at = (Gt, oo) => Gt + (oo - Gt % oo) % oo;
          for (var _t = 1; _t <= 4; _t *= 2) {
            var $t = ae * (1 + 0.2 / _t);
            $t = Math.min($t, G + 100663296);
            var Qe = Math.min($e, at(Math.max(G, $t), 65536)), He = bm(Qe);
            if (He)
              return true;
          }
          return false;
        }
        function Cm(G) {
          return 52;
        }
        function hy(G, ae, $e, at, _t) {
          return 70;
        }
        var gy = [null, [], []];
        function n0(G, ae) {
          var $e = gy[G];
          ae === 0 || ae === 10 ? ((G === 1 ? _ : E)(U($e, 0)), $e.length = 0) : $e.push(ae);
        }
        function s0(G, ae, $e, at) {
          for (var _t = 0, $t = 0; $t < $e; $t++) {
            var Qe = le[ae >>> 2], He = le[ae + 4 >>> 2];
            ae += 8;
            for (var Gt = 0; Gt < He; Gt++)
              n0(G, ne[Qe + Gt >>> 0]);
            _t += He;
          }
          return le[at >>> 2] = _t, 0;
        }
        function wm(G) {
          var ae = t8["_" + G];
          return ae;
        }
        function Tu(G, ae) {
          re.set(G, ae >>> 0);
        }
        function xy(G, ae, $e, at, _t) {
          var $t = { string: (br) => {
            var Ni = 0;
            if (br != null && br !== 0) {
              var Lm = (br.length << 2) + 1;
              Ni = ul(Lm), Y(br, Ni, Lm);
            }
            return Ni;
          }, array: (br) => {
            var Ni = ul(br.length);
            return Tu(br, Ni), Ni;
          } };
          function Qe(br) {
            return ae === "string" ? j(br) : ae === "boolean" ? !!br : br;
          }
          var He = wm(G), Gt = [], oo = 0;
          if (at)
            for (var Wa = 0; Wa < at.length; Wa++) {
              var Mm = $t[$e[Wa]];
              Mm ? (oo === 0 && (oo = Fm()), Gt[Wa] = Mm(at[Wa])) : Gt[Wa] = at[Wa];
            }
          var pl = He.apply(null, Gt);
          function zC(br) {
            return oo !== 0 && Pm(oo), Qe(br);
          }
          return pl = zC(pl), pl;
        }
        function yy(G, ae, $e, at) {
          $e = $e || [];
          var _t = $e.every((Qe) => Qe === "number" || Qe === "boolean"), $t = ae !== "string";
          return $t && _t && !at ? wm(G) : function() {
            return xy(G, ae, $e, arguments);
          };
        }
        var ol = { abort: dy, emscripten_get_heap_max: Nu, emscripten_memcpy_big: fy, emscripten_resize_heap: Mp, fd_close: Cm, fd_seek: hy, fd_write: s0 };
        rl();
        t8.___wasm_call_ctors = function() {
          return (t8.___wasm_call_ctors = t8.asm.__wasm_call_ctors).apply(null, arguments);
        };
        t8._init = function() {
          return (t8._init = t8.asm.init).apply(null, arguments);
        };
        t8._init_with_threads_count = function() {
          return (t8._init_with_threads_count = t8.asm.init_with_threads_count).apply(null, arguments);
        };
        t8._get_threads_count = function() {
          return (t8._get_threads_count = t8.asm.get_threads_count).apply(null, arguments);
        };
        t8._register_tensor = function() {
          return (t8._register_tensor = t8.asm.register_tensor).apply(null, arguments);
        };
        t8._dispose_data = function() {
          return (t8._dispose_data = t8.asm.dispose_data).apply(null, arguments);
        };
        t8._dispose = function() {
          return (t8._dispose = t8.asm.dispose).apply(null, arguments);
        };
        t8._Abs = function() {
          return (t8._Abs = t8.asm.Abs).apply(null, arguments);
        };
        t8._Acos = function() {
          return (t8._Acos = t8.asm.Acos).apply(null, arguments);
        };
        t8._Acosh = function() {
          return (t8._Acosh = t8.asm.Acosh).apply(null, arguments);
        };
        t8._Add = function() {
          return (t8._Add = t8.asm.Add).apply(null, arguments);
        };
        t8._AddN = function() {
          return (t8._AddN = t8.asm.AddN).apply(null, arguments);
        };
        t8._All = function() {
          return (t8._All = t8.asm.All).apply(null, arguments);
        };
        t8._Any = function() {
          return (t8._Any = t8.asm.Any).apply(null, arguments);
        };
        t8._ArgMax = function() {
          return (t8._ArgMax = t8.asm.ArgMax).apply(null, arguments);
        };
        t8._ArgMin = function() {
          return (t8._ArgMin = t8.asm.ArgMin).apply(null, arguments);
        };
        t8._Asin = function() {
          return (t8._Asin = t8.asm.Asin).apply(null, arguments);
        };
        t8._Asinh = function() {
          return (t8._Asinh = t8.asm.Asinh).apply(null, arguments);
        };
        t8._Atan = function() {
          return (t8._Atan = t8.asm.Atan).apply(null, arguments);
        };
        t8._Atan2 = function() {
          return (t8._Atan2 = t8.asm.Atan2).apply(null, arguments);
        };
        t8._Atanh = function() {
          return (t8._Atanh = t8.asm.Atanh).apply(null, arguments);
        };
        t8._AvgPool = function() {
          return (t8._AvgPool = t8.asm.AvgPool).apply(null, arguments);
        };
        t8._AvgPool3D = function() {
          return (t8._AvgPool3D = t8.asm.AvgPool3D).apply(null, arguments);
        };
        t8._AvgPool3DGrad = function() {
          return (t8._AvgPool3DGrad = t8.asm.AvgPool3DGrad).apply(null, arguments);
        };
        t8._AvgPoolGrad = function() {
          return (t8._AvgPoolGrad = t8.asm.AvgPoolGrad).apply(null, arguments);
        };
        t8._BatchMatMul = function() {
          return (t8._BatchMatMul = t8.asm.BatchMatMul).apply(null, arguments);
        };
        t8._Bincount = function() {
          return (t8._Bincount = t8.asm.Bincount).apply(null, arguments);
        };
        t8._BitwiseAnd = function() {
          return (t8._BitwiseAnd = t8.asm.BitwiseAnd).apply(null, arguments);
        };
        t8._Ceil = function() {
          return (t8._Ceil = t8.asm.Ceil).apply(null, arguments);
        };
        t8._ClipByValue = function() {
          return (t8._ClipByValue = t8.asm.ClipByValue).apply(null, arguments);
        };
        t8._Conv2D = function() {
          return (t8._Conv2D = t8.asm.Conv2D).apply(null, arguments);
        };
        t8._Conv2DBackpropInput = function() {
          return (t8._Conv2DBackpropInput = t8.asm.Conv2DBackpropInput).apply(null, arguments);
        };
        t8._Conv3D = function() {
          return (t8._Conv3D = t8.asm.Conv3D).apply(null, arguments);
        };
        t8._Conv3DBackpropFilterV2 = function() {
          return (t8._Conv3DBackpropFilterV2 = t8.asm.Conv3DBackpropFilterV2).apply(null, arguments);
        };
        t8._Conv3DBackpropInputV2 = function() {
          return (t8._Conv3DBackpropInputV2 = t8.asm.Conv3DBackpropInputV2).apply(null, arguments);
        };
        t8._Cos = function() {
          return (t8._Cos = t8.asm.Cos).apply(null, arguments);
        };
        t8._Cosh = function() {
          return (t8._Cosh = t8.asm.Cosh).apply(null, arguments);
        };
        t8._CropAndResize = function() {
          return (t8._CropAndResize = t8.asm.CropAndResize).apply(null, arguments);
        };
        t8._Cumprod = function() {
          return (t8._Cumprod = t8.asm.Cumprod).apply(null, arguments);
        };
        t8._Cumsum = function() {
          return (t8._Cumsum = t8.asm.Cumsum).apply(null, arguments);
        };
        t8._DenseBincount = function() {
          return (t8._DenseBincount = t8.asm.DenseBincount).apply(null, arguments);
        };
        t8._DepthToSpace = function() {
          return (t8._DepthToSpace = t8.asm.DepthToSpace).apply(null, arguments);
        };
        t8._DepthwiseConv2dNative = function() {
          return (t8._DepthwiseConv2dNative = t8.asm.DepthwiseConv2dNative).apply(null, arguments);
        };
        t8._Diag = function() {
          return (t8._Diag = t8.asm.Diag).apply(null, arguments);
        };
        t8._Dilation2D = function() {
          return (t8._Dilation2D = t8.asm.Dilation2D).apply(null, arguments);
        };
        t8._Dilation2DBackpropFilter = function() {
          return (t8._Dilation2DBackpropFilter = t8.asm.Dilation2DBackpropFilter).apply(null, arguments);
        };
        t8._Dilation2DBackpropInput = function() {
          return (t8._Dilation2DBackpropInput = t8.asm.Dilation2DBackpropInput).apply(null, arguments);
        };
        t8._Elu = function() {
          return (t8._Elu = t8.asm.Elu).apply(null, arguments);
        };
        t8._EluGrad = function() {
          return (t8._EluGrad = t8.asm.EluGrad).apply(null, arguments);
        };
        t8._Equal = function() {
          return (t8._Equal = t8.asm.Equal).apply(null, arguments);
        };
        t8._Erf = function() {
          return (t8._Erf = t8.asm.Erf).apply(null, arguments);
        };
        t8._Exp = function() {
          return (t8._Exp = t8.asm.Exp).apply(null, arguments);
        };
        t8._Expm1 = function() {
          return (t8._Expm1 = t8.asm.Expm1).apply(null, arguments);
        };
        t8._FlipLeftRight = function() {
          return (t8._FlipLeftRight = t8.asm.FlipLeftRight).apply(null, arguments);
        };
        t8._Floor = function() {
          return (t8._Floor = t8.asm.Floor).apply(null, arguments);
        };
        t8._FloorDiv = function() {
          return (t8._FloorDiv = t8.asm.FloorDiv).apply(null, arguments);
        };
        t8._FusedBatchNorm = function() {
          return (t8._FusedBatchNorm = t8.asm.FusedBatchNorm).apply(null, arguments);
        };
        t8._FusedConv2D = function() {
          return (t8._FusedConv2D = t8.asm.FusedConv2D).apply(null, arguments);
        };
        t8._FusedDepthwiseConv2D = function() {
          return (t8._FusedDepthwiseConv2D = t8.asm.FusedDepthwiseConv2D).apply(null, arguments);
        };
        t8._Gather = function() {
          return (t8._Gather = t8.asm.Gather).apply(null, arguments);
        };
        t8._GatherNd = function() {
          return (t8._GatherNd = t8.asm.GatherNd).apply(null, arguments);
        };
        t8._Greater = function() {
          return (t8._Greater = t8.asm.Greater).apply(null, arguments);
        };
        t8._GreaterEqual = function() {
          return (t8._GreaterEqual = t8.asm.GreaterEqual).apply(null, arguments);
        };
        t8._IsFinite = function() {
          return (t8._IsFinite = t8.asm.IsFinite).apply(null, arguments);
        };
        t8._IsInf = function() {
          return (t8._IsInf = t8.asm.IsInf).apply(null, arguments);
        };
        t8._IsNan = function() {
          return (t8._IsNan = t8.asm.IsNan).apply(null, arguments);
        };
        t8._LRN = function() {
          return (t8._LRN = t8.asm.LRN).apply(null, arguments);
        };
        t8._LRNGrad = function() {
          return (t8._LRNGrad = t8.asm.LRNGrad).apply(null, arguments);
        };
        t8._LeakyRelu = function() {
          return (t8._LeakyRelu = t8.asm.LeakyRelu).apply(null, arguments);
        };
        t8._Less = function() {
          return (t8._Less = t8.asm.Less).apply(null, arguments);
        };
        t8._LessEqual = function() {
          return (t8._LessEqual = t8.asm.LessEqual).apply(null, arguments);
        };
        t8._LinSpace = function() {
          return (t8._LinSpace = t8.asm.LinSpace).apply(null, arguments);
        };
        t8._Log = function() {
          return (t8._Log = t8.asm.Log).apply(null, arguments);
        };
        t8._Log1p = function() {
          return (t8._Log1p = t8.asm.Log1p).apply(null, arguments);
        };
        t8._LogicalAnd = function() {
          return (t8._LogicalAnd = t8.asm.LogicalAnd).apply(null, arguments);
        };
        t8._LogicalNot = function() {
          return (t8._LogicalNot = t8.asm.LogicalNot).apply(null, arguments);
        };
        t8._LogicalOr = function() {
          return (t8._LogicalOr = t8.asm.LogicalOr).apply(null, arguments);
        };
        t8._LogicalXor = function() {
          return (t8._LogicalXor = t8.asm.LogicalXor).apply(null, arguments);
        };
        t8._Max = function() {
          return (t8._Max = t8.asm.Max).apply(null, arguments);
        };
        t8._MaxPool = function() {
          return (t8._MaxPool = t8.asm.MaxPool).apply(null, arguments);
        };
        t8._MaxPool3D = function() {
          return (t8._MaxPool3D = t8.asm.MaxPool3D).apply(null, arguments);
        };
        t8._MaxPool3DGrad = function() {
          return (t8._MaxPool3DGrad = t8.asm.MaxPool3DGrad).apply(null, arguments);
        };
        t8._MaxPoolGrad = function() {
          return (t8._MaxPoolGrad = t8.asm.MaxPoolGrad).apply(null, arguments);
        };
        t8._MaxPoolWithArgmax = function() {
          return (t8._MaxPoolWithArgmax = t8.asm.MaxPoolWithArgmax).apply(null, arguments);
        };
        t8._Maximum = function() {
          return (t8._Maximum = t8.asm.Maximum).apply(null, arguments);
        };
        t8._Mean = function() {
          return (t8._Mean = t8.asm.Mean).apply(null, arguments);
        };
        t8._Min = function() {
          return (t8._Min = t8.asm.Min).apply(null, arguments);
        };
        t8._Minimum = function() {
          return (t8._Minimum = t8.asm.Minimum).apply(null, arguments);
        };
        t8._MirrorPad = function() {
          return (t8._MirrorPad = t8.asm.MirrorPad).apply(null, arguments);
        };
        t8._Mod = function() {
          return (t8._Mod = t8.asm.Mod).apply(null, arguments);
        };
        t8._Multinomial = function() {
          return (t8._Multinomial = t8.asm.Multinomial).apply(null, arguments);
        };
        t8._Multiply = function() {
          return (t8._Multiply = t8.asm.Multiply).apply(null, arguments);
        };
        t8._Neg = function() {
          return (t8._Neg = t8.asm.Neg).apply(null, arguments);
        };
        t8._NonMaxSuppressionV3 = function() {
          return (t8._NonMaxSuppressionV3 = t8.asm.NonMaxSuppressionV3).apply(null, arguments);
        };
        t8._NonMaxSuppressionV4 = function() {
          return (t8._NonMaxSuppressionV4 = t8.asm.NonMaxSuppressionV4).apply(null, arguments);
        };
        t8._NonMaxSuppressionV5 = function() {
          return (t8._NonMaxSuppressionV5 = t8.asm.NonMaxSuppressionV5).apply(null, arguments);
        };
        t8._NotEqual = function() {
          return (t8._NotEqual = t8.asm.NotEqual).apply(null, arguments);
        };
        t8._OneHot = function() {
          return (t8._OneHot = t8.asm.OneHot).apply(null, arguments);
        };
        t8._PadV2 = function() {
          return (t8._PadV2 = t8.asm.PadV2).apply(null, arguments);
        };
        t8._Pow = function() {
          return (t8._Pow = t8.asm.Pow).apply(null, arguments);
        };
        t8._Prelu = function() {
          return (t8._Prelu = t8.asm.Prelu).apply(null, arguments);
        };
        t8._Prod = function() {
          return (t8._Prod = t8.asm.Prod).apply(null, arguments);
        };
        t8._RealDiv = function() {
          return (t8._RealDiv = t8.asm.RealDiv).apply(null, arguments);
        };
        t8._Reciprocal = function() {
          return (t8._Reciprocal = t8.asm.Reciprocal).apply(null, arguments);
        };
        t8._Relu = function() {
          return (t8._Relu = t8.asm.Relu).apply(null, arguments);
        };
        t8._Relu6 = function() {
          return (t8._Relu6 = t8.asm.Relu6).apply(null, arguments);
        };
        t8._ResizeBilinear = function() {
          return (t8._ResizeBilinear = t8.asm.ResizeBilinear).apply(null, arguments);
        };
        t8._ResizeBilinearGrad = function() {
          return (t8._ResizeBilinearGrad = t8.asm.ResizeBilinearGrad).apply(null, arguments);
        };
        t8._ResizeNearestNeighbor = function() {
          return (t8._ResizeNearestNeighbor = t8.asm.ResizeNearestNeighbor).apply(null, arguments);
        };
        t8._ResizeNearestNeighborGrad = function() {
          return (t8._ResizeNearestNeighborGrad = t8.asm.ResizeNearestNeighborGrad).apply(null, arguments);
        };
        t8._Reverse = function() {
          return (t8._Reverse = t8.asm.Reverse).apply(null, arguments);
        };
        t8._RotateWithOffset = function() {
          return (t8._RotateWithOffset = t8.asm.RotateWithOffset).apply(null, arguments);
        };
        t8._Round = function() {
          return (t8._Round = t8.asm.Round).apply(null, arguments);
        };
        t8._Rsqrt = function() {
          return (t8._Rsqrt = t8.asm.Rsqrt).apply(null, arguments);
        };
        t8._ScatterNd = function() {
          return (t8._ScatterNd = t8.asm.ScatterNd).apply(null, arguments);
        };
        t8._SearchSorted = function() {
          return (t8._SearchSorted = t8.asm.SearchSorted).apply(null, arguments);
        };
        t8._SelectV2 = function() {
          return (t8._SelectV2 = t8.asm.SelectV2).apply(null, arguments);
        };
        t8._Selu = function() {
          return (t8._Selu = t8.asm.Selu).apply(null, arguments);
        };
        t8._Sigmoid = function() {
          return (t8._Sigmoid = t8.asm.Sigmoid).apply(null, arguments);
        };
        t8._Sign = function() {
          return (t8._Sign = t8.asm.Sign).apply(null, arguments);
        };
        t8._Sin = function() {
          return (t8._Sin = t8.asm.Sin).apply(null, arguments);
        };
        t8._Sinh = function() {
          return (t8._Sinh = t8.asm.Sinh).apply(null, arguments);
        };
        t8._Softmax = function() {
          return (t8._Softmax = t8.asm.Softmax).apply(null, arguments);
        };
        t8._Softplus = function() {
          return (t8._Softplus = t8.asm.Softplus).apply(null, arguments);
        };
        t8._SparseFillEmptyRows = function() {
          return (t8._SparseFillEmptyRows = t8.asm.SparseFillEmptyRows).apply(null, arguments);
        };
        t8._SparseReshape = function() {
          return (t8._SparseReshape = t8.asm.SparseReshape).apply(null, arguments);
        };
        t8._SparseSegmentReduction = function() {
          return (t8._SparseSegmentReduction = t8.asm.SparseSegmentReduction).apply(null, arguments);
        };
        t8._SparseToDense = function() {
          return (t8._SparseToDense = t8.asm.SparseToDense).apply(null, arguments);
        };
        t8._Sqrt = function() {
          return (t8._Sqrt = t8.asm.Sqrt).apply(null, arguments);
        };
        t8._Square = function() {
          return (t8._Square = t8.asm.Square).apply(null, arguments);
        };
        t8._SquaredDifference = function() {
          return (t8._SquaredDifference = t8.asm.SquaredDifference).apply(null, arguments);
        };
        t8._Step = function() {
          return (t8._Step = t8.asm.Step).apply(null, arguments);
        };
        t8._StridedSlice = function() {
          return (t8._StridedSlice = t8.asm.StridedSlice).apply(null, arguments);
        };
        t8._Sub = function() {
          return (t8._Sub = t8.asm.Sub).apply(null, arguments);
        };
        t8._Sum = function() {
          return (t8._Sum = t8.asm.Sum).apply(null, arguments);
        };
        t8._Tan = function() {
          return (t8._Tan = t8.asm.Tan).apply(null, arguments);
        };
        t8._Tanh = function() {
          return (t8._Tanh = t8.asm.Tanh).apply(null, arguments);
        };
        t8._TensorScatterUpdate = function() {
          return (t8._TensorScatterUpdate = t8.asm.TensorScatterUpdate).apply(null, arguments);
        };
        t8._Tile = function() {
          return (t8._Tile = t8.asm.Tile).apply(null, arguments);
        };
        t8._TopK = function() {
          return (t8._TopK = t8.asm.TopK).apply(null, arguments);
        };
        t8._Transform = function() {
          return (t8._Transform = t8.asm.Transform).apply(null, arguments);
        };
        t8._Transpose = function() {
          return (t8._Transpose = t8.asm.Transpose).apply(null, arguments);
        };
        t8.__FusedMatMul = function() {
          return (t8.__FusedMatMul = t8.asm._FusedMatMul).apply(null, arguments);
        };
        t8._malloc = function() {
          return (t8._malloc = t8.asm.malloc).apply(null, arguments);
        };
        t8._free = function() {
          return (t8._free = t8.asm.free).apply(null, arguments);
        };
        t8.___errno_location = function() {
          return (t8.___errno_location = t8.asm.__errno_location).apply(null, arguments);
        };
        var Fm = t8.stackSave = function() {
          return (Fm = t8.stackSave = t8.asm.stackSave).apply(null, arguments);
        }, Pm = t8.stackRestore = function() {
          return (Pm = t8.stackRestore = t8.asm.stackRestore).apply(null, arguments);
        }, ul = t8.stackAlloc = function() {
          return (ul = t8.stackAlloc = t8.asm.stackAlloc).apply(null, arguments);
        };
        t8.dynCall_iijjiiii = function() {
          return (t8.dynCall_iijjiiii = t8.asm.dynCall_iijjiiii).apply(null, arguments);
        };
        t8.dynCall_jiji = function() {
          return (t8.dynCall_jiji = t8.asm.dynCall_jiji).apply(null, arguments);
        };
        t8.cwrap = yy;
        var Bp;
        sr = function G() {
          Bp || Om(), Bp || (sr = G);
        };
        function Om(G) {
          if (Tt > 0 || (gt(), Tt > 0))
            return;
          function ae() {
            Bp || (Bp = true, t8.calledRun = true, !M && (xt(), o8(t8), t8.onRuntimeInitialized && t8.onRuntimeInitialized(), Lr()));
          }
          t8.setStatus ? (t8.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              t8.setStatus("");
            }, 1), ae();
          }, 1)) : ae();
        }
        if (t8.preInit)
          for (typeof t8.preInit == "function" && (t8.preInit = [t8.preInit]); t8.preInit.length > 0; )
            t8.preInit.pop()();
        Om();
        var zp;
        s && (zp = { uncaughtException: process$1.listeners("uncaughtException").filter(function(G) {
          return !s.uncaughtException.indexOf(G) > -1;
        }), unhandledRejection: process$1.listeners("unhandledRejection").filter(function(G) {
          return !s.unhandledRejection.indexOf(G) > -1;
        }) });
        var Vp;
        if (typeof e8 != "undefined")
          Vp = e8;
        else if (typeof WasmBackendModuleThreadedSimd != "undefined")
          Vp = WasmBackendModuleThreadedSimd;
        else
          throw new Error("Could not find wasm module in post.js");
        if (zp) {
          var BC = Vp._dispose;
          Vp._dispose = function() {
            BC(), zp.uncaughtException.forEach(function(G) {
              process$1.removeListener("uncaughtException", G);
            }), zp.unhandledRejection.forEach(function(G) {
              process$1.removeListener("unhandledRejection", G);
            });
          };
        }
        return e8.ready;
      };
    })();
    typeof Vg == "object" && typeof Ov == "object" ? Ov.exports = Pv : typeof define == "function" && define.amd ? define([], function() {
      return Pv;
    }) : typeof Vg == "object" && (Vg.WasmBackendModule = Pv);
  });
  var Bo = class {
    constructor(e8, t8) {
      this.backend = e8, this.dataMover = t8, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
    }
    get(e8) {
      return this.data.has(e8) || this.dataMover.moveData(this.backend, e8), this.data.get(e8);
    }
    set(e8, t8) {
      this.dataIdsCount++, this.data.set(e8, t8);
    }
    has(e8) {
      return this.data.has(e8);
    }
    delete(e8) {
      return this.dataIdsCount--, this.data.delete(e8);
    }
    numDataIds() {
      return this.dataIdsCount;
    }
  };
  var so = class {
    refCount(e8) {
      return zr("refCount");
    }
    incRef(e8) {
      return zr("incRef");
    }
    timerAvailable() {
      return true;
    }
    time(e8) {
      return zr("time");
    }
    read(e8) {
      return zr("read");
    }
    readSync(e8) {
      return zr("readSync");
    }
    readToGPU(e8, t8) {
      return zr("readToGPU");
    }
    numDataIds() {
      return zr("numDataIds");
    }
    disposeData(e8, t8) {
      return zr("disposeData");
    }
    write(e8, t8, o8) {
      return zr("write");
    }
    move(e8, t8, o8, n8, s) {
      return zr("move");
    }
    createTensorFromGPUData(e8, t8, o8) {
      return zr("createTensorFromGPUData");
    }
    memory() {
      return zr("memory");
    }
    floatPrecision() {
      return zr("floatPrecision");
    }
    epsilon() {
      return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
    }
    dispose() {
      return zr("dispose");
    }
  };
  function zr(r8) {
    throw new Error(`'${r8}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }
  function h0(r8) {
    let e8 = r8.length, t8 = 0;
    for (; e8 > 0; )
      t8 = Math.random() * e8 | 0, e8--, Hm(r8, e8, t8);
  }
  function gG(r8, e8) {
    if (r8.length !== e8.length)
      throw new Error(`Array sizes must match to be shuffled together First array length was ${r8.length}Second array length was ${e8.length}`);
    let t8 = r8.length, o8 = 0;
    for (; t8 > 0; )
      o8 = Math.random() * t8 | 0, t8--, Hm(r8, t8, o8), Hm(e8, t8, o8);
  }
  function Gp(r8, e8, t8) {
    return Math.max(r8, Math.min(e8, t8));
  }
  function xG(r8) {
    return r8 % 2 === 0 ? r8 : r8 + 1;
  }
  function Hm(r8, e8, t8) {
    let o8 = r8[e8];
    r8[e8] = r8[t8], r8[t8] = o8;
  }
  function yG(r8) {
    let e8 = 0;
    for (let t8 = 0; t8 < r8.length; t8++)
      e8 += r8[t8];
    return e8;
  }
  function bG(r8, e8) {
    let t8 = Math.random();
    return e8 * t8 + (1 - t8) * r8;
  }
  function CG(r8, e8) {
    let t8 = 0;
    for (let o8 = 0; o8 < r8.length; o8++) {
      let n8 = Number(r8[o8]) - Number(e8[o8]);
      t8 += n8 * n8;
    }
    return t8;
  }
  function $(r8, e8) {
    if (!r8)
      throw new Error(typeof e8 == "string" ? e8 : e8());
  }
  function yt(r8, e8, t8 = "") {
    $(Cr(r8, e8), () => t8 + ` Shapes ${r8} and ${e8} must match`);
  }
  function ao(r8) {
    $(r8 != null, () => "The input to the tensor constructor must be a non-null value.");
  }
  function Ge(r8) {
    if (r8.length === 0)
      return 1;
    let e8 = r8[0];
    for (let t8 = 1; t8 < r8.length; t8++)
      e8 *= r8[t8];
    return e8;
  }
  function wG(r8) {
    return r8.length === 0;
  }
  function HC(r8, e8) {
    if (r8 === e8)
      return true;
    if (r8 == null || e8 == null || r8.length !== e8.length)
      return false;
    for (let t8 = 0; t8 < r8.length; t8++)
      if (r8[t8] !== null && e8[t8] !== null && r8[t8] !== e8[t8])
        return false;
    return true;
  }
  function Cr(r8, e8) {
    if (r8 === e8)
      return true;
    if (r8 == null || e8 == null || r8.length !== e8.length)
      return false;
    for (let t8 = 0; t8 < r8.length; t8++)
      if (r8[t8] !== e8[t8])
        return false;
    return true;
  }
  function Ga(r8) {
    return r8 % 1 === 0;
  }
  function SG(r8) {
    if (Math.tanh != null)
      return Math.tanh(r8);
    if (r8 === 1 / 0)
      return 1;
    if (r8 === -1 / 0)
      return -1;
    {
      let e8 = Math.exp(2 * r8);
      return (e8 - 1) / (e8 + 1);
    }
  }
  function IG(r8) {
    let e8 = Math.ceil(Math.sqrt(r8));
    return [e8, Math.ceil(r8 / e8)];
  }
  function vG(r8) {
    let e8 = new Uint32Array(r8);
    for (let t8 = 0; t8 < r8; ++t8)
      e8[t8] = t8;
    return h0(e8), e8;
  }
  function Eu(r8, e8) {
    return e8 <= r8.length ? r8 : r8 + " ".repeat(e8 - r8.length);
  }
  function kG(r8, e8 = (n8) => 0, t8, o8) {
    return new Promise((n8, s) => {
      let a = 0, i10 = () => {
        if (r8()) {
          n8();
          return;
        }
        a++;
        let p = e8(a);
        if (t8 != null && a >= t8) {
          s();
          return;
        }
        o8 != null ? o8(i10, p) : setTimeout(i10, p);
      };
      i10();
    });
  }
  function NG(r8, e8) {
    let t8 = 1, o8 = -1;
    for (let s = 0; s < r8.length; ++s)
      if (r8[s] >= 0)
        t8 *= r8[s];
      else if (r8[s] === -1) {
        if (o8 !== -1)
          throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${o8} and dim ${s}`);
        o8 = s;
      } else if (r8[s] < 0)
        throw Error(`Shapes can not be < 0. Found ${r8[s]} at dim ${s}`);
    if (o8 === -1) {
      if (e8 > 0 && e8 !== t8)
        throw Error(`Size(${e8}) must match the product of shape ${r8}`);
      return r8;
    }
    if (t8 === 0)
      throw Error(`Cannot infer the missing size in [${r8}] when there are 0 elements`);
    if (e8 % t8 !== 0)
      throw Error(`The implicit shape can't be a fractional number. Got ${e8} / ${t8}`);
    let n8 = r8.slice();
    return n8[o8] = e8 / t8, n8;
  }
  function Ti(r8, e8) {
    let t8 = e8.length;
    return r8 = r8 == null ? e8.map((o8, n8) => n8) : [].concat(r8), $(r8.every((o8) => o8 >= -t8 && o8 < t8), () => `All values in axis param must be in range [-${t8}, ${t8}) but got axis ${r8}`), $(r8.every((o8) => Ga(o8)), () => `All values in axis param must be integers but got axis ${r8}`), r8.map((o8) => o8 < 0 ? t8 + o8 : o8);
  }
  function KC(r8, e8) {
    let t8 = [], o8 = [], n8 = e8 != null && Array.isArray(e8) && e8.length === 0, s = e8 == null || n8 ? null : Ti(e8, r8).sort(), a = 0;
    for (let i10 = 0; i10 < r8.length; ++i10) {
      if (s != null) {
        if (s[a] === i10 && r8[i10] !== 1)
          throw new Error(`Can't squeeze axis ${i10} since its dim '${r8[i10]}' is not 1`);
        (s[a] == null || s[a] > i10) && r8[i10] === 1 && (t8.push(r8[i10]), o8.push(i10)), s[a] <= i10 && a++;
      }
      r8[i10] !== 1 && (t8.push(r8[i10]), o8.push(i10));
    }
    return { newShape: t8, keptDims: o8 };
  }
  function qC(r8, e8) {
    return Km(r8, e8);
  }
  function Km(r8, e8) {
    let t8 = null;
    if (r8 == null || r8 === "float32")
      t8 = new Float32Array(e8);
    else if (r8 === "int32")
      t8 = new Int32Array(e8);
    else if (r8 === "bool")
      t8 = new Uint8Array(e8);
    else if (r8 === "string")
      t8 = new Array(e8);
    else
      throw new Error(`Unknown data type ${r8}`);
    return t8;
  }
  function jC(r8, e8) {
    for (let t8 = 0; t8 < r8.length; t8++) {
      let o8 = r8[t8];
      if (isNaN(o8) || !isFinite(o8))
        throw Error(`A tensor of type ${e8} being uploaded contains ${o8}.`);
    }
  }
  function XC(r8) {
    return r8 === "bool" || r8 === "complex64" || r8 === "float32" || r8 === "int32" || r8 === "string";
  }
  function TG(r8, e8) {
    return !(e8 === "complex64" || e8 === "float32" && r8 !== "complex64" || e8 === "int32" && r8 !== "float32" && r8 !== "complex64" || e8 === "bool" && r8 === "bool");
  }
  function Hp(r8) {
    if (r8 === "float32" || r8 === "int32")
      return 4;
    if (r8 === "complex64")
      return 8;
    if (r8 === "bool")
      return 1;
    throw new Error(`Unknown dtype ${r8}`);
  }
  function YC(r8) {
    if (r8 == null)
      return 0;
    let e8 = 0;
    return r8.forEach((t8) => e8 += t8.length), e8;
  }
  function zo(r8) {
    return typeof r8 == "string" || r8 instanceof String;
  }
  function g0(r8) {
    return typeof r8 == "boolean";
  }
  function x0(r8) {
    return typeof r8 == "number";
  }
  function _i(r8) {
    return Array.isArray(r8) ? _i(r8[0]) : r8 instanceof Float32Array ? "float32" : r8 instanceof Int32Array || r8 instanceof Uint8Array || r8 instanceof Uint8ClampedArray ? "int32" : x0(r8) ? "float32" : zo(r8) ? "string" : g0(r8) ? "bool" : "float32";
  }
  function Ks(r8) {
    return !!(r8 && r8.constructor && r8.call && r8.apply);
  }
  function Kp(r8, e8) {
    for (let t8 = e8; t8 < r8; ++t8)
      if (r8 % t8 === 0)
        return t8;
    return r8;
  }
  function qs(r8) {
    let e8 = r8.length;
    if (e8 < 2)
      return [];
    let t8 = new Array(e8 - 1);
    t8[e8 - 2] = r8[e8 - 1];
    for (let o8 = e8 - 3; o8 >= 0; --o8)
      t8[o8] = t8[o8 + 1] * r8[o8 + 1];
    return t8;
  }
  function y0(r8, e8, t8, o8 = false) {
    let n8 = new Array();
    if (e8.length === 1) {
      let s = e8[0] * (o8 ? 2 : 1);
      for (let a = 0; a < s; a++)
        n8[a] = t8[r8 + a];
    } else {
      let s = e8[0], a = e8.slice(1), i10 = a.reduce((p, u) => p * u) * (o8 ? 2 : 1);
      for (let p = 0; p < s; p++)
        n8[p] = y0(r8 + p * i10, a, t8, o8);
    }
    return n8;
  }
  function $u(r8, e8, t8 = false) {
    if (r8.length === 0)
      return e8[0];
    let o8 = r8.reduce((n8, s) => n8 * s) * (t8 ? 2 : 1);
    if (o8 === 0)
      return [];
    if (o8 !== e8.length)
      throw new Error(`[${r8}] does not match the input size ${e8.length}${t8 ? " for a complex tensor" : ""}.`);
    return y0(0, r8, e8, t8);
  }
  function _G(r8, e8) {
    if (Array.isArray(r8))
      return r8;
    if (e8 === "float32")
      return r8 instanceof Float32Array ? r8 : new Float32Array(r8);
    if (e8 === "int32")
      return r8 instanceof Int32Array ? r8 : new Int32Array(r8);
    if (e8 === "bool" || e8 === "string")
      return Uint8Array.from(new Int32Array(r8));
    throw new Error(`Unknown dtype ${e8}`);
  }
  function cl(r8, e8) {
    let t8 = qp(r8, e8);
    for (let o8 = 0; o8 < t8.length; o8++)
      t8[o8] = 1;
    return t8;
  }
  function qp(r8, e8) {
    if (e8 == null || e8 === "float32" || e8 === "complex64")
      return new Float32Array(r8);
    if (e8 === "int32")
      return new Int32Array(r8);
    if (e8 === "bool")
      return new Uint8Array(r8);
    throw new Error(`Unknown data type ${e8}`);
  }
  function $G(r8, e8) {
    let t8 = r8.reduce((o8, n8) => o8 * n8, 1);
    if (e8 == null || e8 === "float32")
      return $u(r8, new Float32Array(t8));
    if (e8 === "int32")
      return $u(r8, new Int32Array(t8));
    if (e8 === "bool")
      return $u(r8, new Uint8Array(t8));
    throw new Error(`Unknown data type ${e8}`);
  }
  function wt(r8) {
    r8.forEach((e8) => {
      $(Number.isInteger(e8) && e8 >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${r8}].`);
    });
  }
  function EG(r8, e8, t8) {
    if (e8 === 0)
      return 0;
    if (e8 === 1)
      return r8[0];
    let o8 = r8[r8.length - 1];
    for (let n8 = 0; n8 < r8.length - 1; ++n8)
      o8 += t8[n8] * r8[n8];
    return o8;
  }
  function RG(r8, e8, t8) {
    if (e8 === 0)
      return [];
    if (e8 === 1)
      return [r8];
    let o8 = new Array(e8);
    for (let n8 = 0; n8 < o8.length - 1; ++n8)
      o8[n8] = Math.floor(r8 / t8[n8]), r8 -= o8[n8] * t8[n8];
    return o8[o8.length - 1] = r8, o8;
  }
  function Ru(r8) {
    return r8 && r8.then && typeof r8.then == "function";
  }
  var b0 = "tfjsflags";
  var ll = class {
    constructor(e8) {
      this.global = e8, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = AG, this.populateURLFlags();
    }
    setPlatform(e8, t8) {
      this.platform != null && (A().getBool("IS_TEST") || A().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e8}.`)), this.platformName = e8, this.platform = t8;
    }
    registerFlag(e8, t8, o8) {
      if (this.flagRegistry[e8] = { evaluationFn: t8, setHook: o8 }, this.urlFlags[e8] != null) {
        let n8 = this.urlFlags[e8];
        A().getBool("IS_TEST") || A().getBool("PROD") || console.warn(`Setting feature override from URL ${e8}: ${n8}.`), this.set(e8, n8);
      }
    }
    async getAsync(e8) {
      return e8 in this.flags ? this.flags[e8] : (this.flags[e8] = await this.evaluateFlag(e8), this.flags[e8]);
    }
    get(e8) {
      if (e8 in this.flags)
        return this.flags[e8];
      let t8 = this.evaluateFlag(e8);
      if (Ru(t8))
        throw new Error(`Flag ${e8} cannot be synchronously evaluated. Please use getAsync() instead.`);
      return this.flags[e8] = t8, this.flags[e8];
    }
    getNumber(e8) {
      return this.get(e8);
    }
    getBool(e8) {
      return this.get(e8);
    }
    getString(e8) {
      return this.get(e8);
    }
    getFlags() {
      return this.flags;
    }
    get features() {
      return this.flags;
    }
    set(e8, t8) {
      if (this.flagRegistry[e8] == null)
        throw new Error(`Cannot set flag ${e8} as it has not been registered.`);
      this.flags[e8] = t8, this.flagRegistry[e8].setHook != null && this.flagRegistry[e8].setHook(t8);
    }
    evaluateFlag(e8) {
      if (this.flagRegistry[e8] == null)
        throw new Error(`Cannot evaluate flag '${e8}': no evaluation function found.`);
      return this.flagRegistry[e8].evaluationFn();
    }
    setFlags(e8) {
      this.flags = Object.assign({}, e8);
    }
    reset() {
      this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
    }
    populateURLFlags() {
      if (typeof this.global == "undefined" || typeof this.global.location == "undefined" || typeof this.global.location.search == "undefined")
        return;
      let e8 = this.getQueryParams(this.global.location.search);
      b0 in e8 && e8[b0].split(",").forEach((o8) => {
        let [n8, s] = o8.split(":");
        this.urlFlags[n8] = PG(n8, s);
      });
    }
  };
  function AG(r8) {
    let e8 = {};
    return r8.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (t8, ...o8) => (FG(e8, o8[0], o8[1]), o8.join("="))), e8;
  }
  function FG(r8, e8, t8) {
    r8[decodeURIComponent(e8)] = decodeURIComponent(t8 || "");
  }
  function PG(r8, e8) {
    let t8 = e8.toLowerCase();
    return t8 === "true" || t8 === "false" ? t8 === "true" : `${+t8}` === t8 ? +t8 : e8;
  }
  function A() {
    return QC;
  }
  var QC = null;
  function C0(r8) {
    QC = r8;
  }
  var ZC;
  function JC() {
    if (ZC == null) {
      let r8;
      if (typeof window != "undefined")
        r8 = window;
      else if (typeof _global != "undefined")
        r8 = _global;
      else if (typeof process$1 != "undefined")
        r8 = process$1;
      else if (typeof self != "undefined")
        r8 = self;
      else
        throw new Error("Could not find a global object");
      ZC = r8;
    }
    return ZC;
  }
  function OG() {
    let r8 = JC();
    return r8._tfGlobals == null && (r8._tfGlobals = /* @__PURE__ */ new Map()), r8._tfGlobals;
  }
  function ml(r8, e8) {
    let t8 = OG();
    if (t8.has(r8))
      return t8.get(r8);
    {
      let o8 = e8();
      return t8.set(r8, o8), t8.get(r8);
    }
  }
  var js = "Abs";
  var Vo = "Acos";
  var Wo = "Acosh";
  var io = "Add";
  var Uo = "AddN";
  var Go = "All";
  var Ho = "Any";
  var Xs = "ArgMax";
  var Ys = "ArgMin";
  var Ko = "Asin";
  var qo = "Asinh";
  var jo = "Atan";
  var Xo = "Atanh";
  var Yo = "Atan2";
  var Qo = "AvgPool";
  var $i = "AvgPoolGrad";
  var Qs = "AvgPool3D";
  var Ei = "AvgPool3DGrad";
  var Zo = "BatchMatMul";
  var Zs = "BatchToSpaceND";
  var Jo = "Bincount";
  var Ha = "BitwiseAnd";
  var _ce = "BroadcastTo";
  var Js = "BroadcastArgs";
  var yo = "Cast";
  var en = "Ceil";
  var bo = "ClipByValue";
  var Ri = "Complex";
  var Di = "ComplexAbs";
  var ea = "Concat";
  var tn = "Conv2D";
  var Ai = "Conv2DBackpropFilter";
  var rn = "Conv2DBackpropInput";
  var on = "Conv3D";
  var Ka = "Conv3DBackpropFilterV2";
  var nn = "Conv3DBackpropInputV2";
  var sn = "Cos";
  var an = "Cosh";
  var un = "Cumprod";
  var pn = "Cumsum";
  var cn = "CropAndResize";
  var ta = "DenseBincount";
  var ln = "DepthToSpace";
  var mn = "DepthwiseConv2dNative";
  var Fi = "DepthwiseConv2dNativeBackpropFilter";
  var Pi = "DepthwiseConv2dNativeBackpropInput";
  var ra = "Diag";
  var dn = "Dilation2D";
  var Oi = "Dilation2DBackpropInput";
  var Mi = "Dilation2DBackpropFilter";
  var qm = "Draw";
  var fn = "RealDiv";
  var Li = "Einsum";
  var hn = "Elu";
  var qa = "EluGrad";
  var gn = "Erf";
  var xn = "Equal";
  var yn = "Exp";
  var oa = "ExpandDims";
  var bn = "Expm1";
  var Bi = "FFT";
  var na = "Fill";
  var Cn = "FlipLeftRight";
  var wn = "Floor";
  var Sn = "FloorDiv";
  var In = "FusedBatchNorm";
  var sa = "GatherV2";
  var vn = "GatherNd";
  var kn = "Greater";
  var Nn = "GreaterEqual";
  var Co = "Identity";
  var zi = "IFFT";
  var Vi = "Imag";
  var Tn = "IsFinite";
  var _n = "IsInf";
  var $n = "IsNan";
  var En = "LeakyRelu";
  var Rn = "Less";
  var Dn = "LessEqual";
  var An = "LinSpace";
  var Fn = "Log";
  var Pn = "Log1p";
  var On = "LogicalAnd";
  var Mn = "LogicalNot";
  var Ln = "LogicalOr";
  var w0 = "LogicalXor";
  var $ce = "LogSoftmax";
  var Ece = "LowerBound";
  var Bn = "LRN";
  var ja = "LRNGrad";
  var Rce = "MatrixBandPart";
  var zn = "Max";
  var Vn = "Maximum";
  var Wn = "MaxPool";
  var Wi = "MaxPoolGrad";
  var aa = "MaxPool3D";
  var Ui = "MaxPool3DGrad";
  var ia = "MaxPoolWithArgmax";
  var Un = "Mean";
  var Gn = "Min";
  var Hn = "Minimum";
  var Kn = "MirrorPad";
  var qn = "Mod";
  var jn = "Multinomial";
  var Xn = "Multiply";
  var ua = "Neg";
  var Yn = "NotEqual";
  var Qn = "NonMaxSuppressionV3";
  var Xa = "NonMaxSuppressionV4";
  var Zn = "NonMaxSuppressionV5";
  var pa = "OnesLike";
  var Jn = "OneHot";
  var ca = "Pack";
  var es = "PadV2";
  var Dce = "Pool";
  var ts = "Pow";
  var rs = "Prelu";
  var os = "Prod";
  var jp = "RaggedGather";
  var Xp = "RaggedRange";
  var Yp = "RaggedTensorToTensor";
  var la = "Range";
  var Gi = "Real";
  var ns = "Reciprocal";
  var ss = "Relu";
  var ma = "Reshape";
  var as = "ResizeNearestNeighbor";
  var Ya = "ResizeNearestNeighborGrad";
  var is = "ResizeBilinear";
  var Qa = "ResizeBilinearGrad";
  var us = "Relu6";
  var ps = "Reverse";
  var cs = "Round";
  var ls = "Rsqrt";
  var ms = "ScatterNd";
  var ds = "TensorScatterUpdate";
  var fs = "SearchSorted";
  var da = "Select";
  var hs = "Selu";
  var fa = "Slice";
  var gs = "Sin";
  var xs = "Sinh";
  var ys = "Sign";
  var bs = "Sigmoid";
  var Cs = "Softplus";
  var ws = "Sqrt";
  var Ss = "Sum";
  var ha = "SpaceToBatchND";
  var ga = "SplitV";
  var Is = "Softmax";
  var Hi = "SparseFillEmptyRows";
  var Za = "SparseReshape";
  var Ki = "SparseSegmentMean";
  var qi = "SparseSegmentSum";
  var vs = "SparseToDense";
  var ks = "SquaredDifference";
  var ji = "Square";
  var Du = "StaticRegexReplace";
  var Ns = "StridedSlice";
  var xa = "StringNGrams";
  var Xi = "StringSplit";
  var Yi = "StringToHashBucketFast";
  var Ts = "Sub";
  var _s = "Tan";
  var $s = "Tanh";
  var uo = "Tile";
  var Es = "TopK";
  var Rs = "Transform";
  var po = "Transpose";
  var Qi = "Unique";
  var ya = "Unpack";
  var Zi = "UnsortedSegmentSum";
  var Ace = "UpperBound";
  var ba = "ZerosLike";
  var wo = "Step";
  var Au = "FromPixels";
  var Ds = "RotateWithOffset";
  var So = "_FusedMatMul";
  var Io = "FusedConv2D";
  var vo = "FusedDepthwiseConv2D";
  function Ca(...r8) {
    A().getBool("IS_TEST") || A().getBool("PROD") || console.warn(...r8);
  }
  function MG(...r8) {
    A().getBool("IS_TEST") || A().getBool("PROD") || console.log(...r8);
  }
  var Qp = ml("kernelRegistry", () => /* @__PURE__ */ new Map());
  var dl = ml("gradRegistry", () => /* @__PURE__ */ new Map());
  function fl(r8, e8) {
    let t8 = tw(r8, e8);
    return Qp.get(t8);
  }
  function ew(r8) {
    return dl.get(r8);
  }
  function jm(r8) {
    let e8 = Qp.entries(), t8 = [];
    for (; ; ) {
      let { done: o8, value: n8 } = e8.next();
      if (o8)
        break;
      let [s, a] = n8, [i10] = s.split("_");
      i10 === r8 && t8.push(a);
    }
    return t8;
  }
  function Ja(r8) {
    let { kernelName: e8, backendName: t8 } = r8, o8 = tw(e8, t8);
    Qp.has(o8) && Ca(`The kernel '${e8}' for backend '${t8}' is already registered`), Qp.set(o8, r8);
  }
  function Lce(r8) {
    let { kernelName: e8 } = r8;
    dl.has(e8) && A().getBool("DEBUG") && Ca(`Overriding the gradient for '${e8}'`), dl.set(e8, r8);
  }
  function Bce(r8, e8) {
    let t8 = tw(r8, e8);
    if (!Qp.has(t8))
      throw new Error(`The kernel '${r8}' for backend '${e8}' is not registered`);
    Qp.delete(t8);
  }
  function zce(r8) {
    if (!dl.has(r8))
      throw new Error(`The gradient '${r8}' for backend is not registered`);
    dl.delete(r8);
  }
  function Vce(r8, e8) {
    jm(r8).forEach((o8) => {
      let n8 = Object.assign({}, o8, { backendName: e8 });
      Ja(n8);
    });
  }
  function tw(r8, e8) {
    return `${e8}_${r8}`;
  }
  var y = {};
  Ke(y, { arraysEqual: () => Cr, arraysEqualWithNull: () => HC, assert: () => $, assertNonNegativeIntegerDimensions: () => wt, assertNonNull: () => ao, assertShapesMatch: () => yt, bytesFromStringArray: () => YC, bytesPerElement: () => Hp, checkConversionForErrors: () => jC, clamp: () => Gp, computeStrides: () => qs, convertBackendValuesAndArrayBuffer: () => _G, createScalarValue: () => GG, createShuffledIndices: () => vG, decodeString: () => tc, distSquared: () => CG, encodeString: () => eu, fetch: () => KG, fingerPrint64: () => UG, flatten: () => Fs, getArrayFromDType: () => Km, getTypedArrayFromDType: () => qC, hasEncodingLoss: () => TG, hexToLong: () => hl, indexToLoc: () => RG, inferDtype: () => _i, inferFromImplicitShape: () => NG, isBoolean: () => g0, isFunction: () => Ks, isInt: () => Ga, isNumber: () => x0, isPromise: () => Ru, isScalarShape: () => wG, isString: () => zo, isTypedArray: () => Pt, isValidDtype: () => XC, locToIndex: () => EG, makeOnesTypedArray: () => cl, makeZerosNestedTypedArray: () => $G, makeZerosTypedArray: () => qp, nearestDivisor: () => Kp, nearestLargerEven: () => xG, now: () => Lu, parseAxisParam: () => Ti, randUniform: () => bG, repeatedTry: () => kG, rightPad: () => Eu, shuffle: () => h0, shuffleCombo: () => gG, sizeFromShape: () => Ge, sizeToSquarishShape: () => IG, squeezeShape: () => KC, sum: () => yG, swap: () => Hm, tanh: () => SG, toNestedArray: () => $u, toTypedArray: () => ec });
  function Xm(r8) {
    return r8 instanceof Float32Array || r8 instanceof Int32Array || r8 instanceof Uint8Array || r8 instanceof Uint8ClampedArray;
  }
  var sw = Up(A0());
  var Mu = sw.default || sw;
  function hl(r8) {
    return Mu.fromString(r8, true, 16);
  }
  var P0 = hl("c3a5c85c97cb3127");
  var Ou = hl("b492b66fbe98f273");
  var wr = hl("9ae16a3b2f90404f");
  function nw(r8) {
    return r8.xor(r8.shru(47));
  }
  function O0(r8, e8, t8) {
    let o8 = r8.slice(e8, e8 + t8);
    return Mu.fromBytes(Array.from(o8), true, true);
  }
  function St(r8, e8) {
    return O0(r8, e8, 8);
  }
  function F0(r8, e8) {
    return O0(r8, e8, 4);
  }
  function Qt(r8, e8) {
    return e8 === 0 ? r8 : r8.shru(e8).or(r8.shl(64 - e8));
  }
  function Ji(r8, e8, t8 = hl("9ddfea08eb382d69")) {
    let o8 = r8.xor(e8).mul(t8);
    o8 = o8.xor(o8.shru(47));
    let n8 = e8.xor(o8).mul(t8);
    return n8 = n8.xor(n8.shru(47)), n8 = n8.mul(t8), n8;
  }
  function BG(r8, e8, t8, o8, n8, s) {
    n8 = n8.add(r8), s = Qt(s.add(n8).add(o8), 21);
    let a = n8;
    return n8 = n8.add(e8), n8 = n8.add(t8), s = s.add(Qt(n8, 44)), [n8.add(o8), s.add(a)];
  }
  function Qm(r8, e8, t8, o8) {
    return BG(St(r8, e8), St(r8, e8 + 8), St(r8, e8 + 16), St(r8, e8 + 24), t8, o8);
  }
  function zG(r8, e8 = r8.length) {
    if (e8 >= 8) {
      let t8 = wr.add(e8 * 2), o8 = St(r8, 0).add(wr), n8 = St(r8, e8 - 8), s = Qt(n8, 37).mul(t8).add(o8), a = Qt(o8, 25).add(n8).mul(t8);
      return Ji(s, a, t8);
    }
    if (e8 >= 4) {
      let t8 = wr.add(e8 * 2), o8 = F0(r8, 0);
      return Ji(o8.shl(3).add(e8), F0(r8, e8 - 4), t8);
    }
    if (e8 > 0) {
      let t8 = r8[0], o8 = r8[e8 >> 1], n8 = r8[e8 - 1], s = t8 + (o8 << 8), a = e8 + (n8 << 2);
      return nw(wr.mul(s).xor(P0.mul(a))).mul(wr);
    }
    return wr;
  }
  function VG(r8, e8 = r8.length) {
    let t8 = wr.add(e8 * 2), o8 = St(r8, 0).mul(Ou), n8 = St(r8, 8), s = St(r8, e8 - 8).mul(t8), a = St(r8, e8 - 16).mul(wr);
    return Ji(Qt(o8.add(n8), 43).add(Qt(s, 30)).add(a), o8.add(Qt(n8.add(wr), 18)).add(s), t8);
  }
  function WG(r8, e8 = r8.length) {
    let t8 = wr.add(e8 * 2), o8 = St(r8, 0).mul(wr), n8 = St(r8, 8), s = St(r8, e8 - 8).mul(t8), a = St(r8, e8 - 16).mul(wr), i10 = Qt(o8.add(n8), 43).add(Qt(s, 30)).add(a), p = Ji(i10, o8.add(Qt(n8.add(wr), 18)).add(s), t8), u = St(r8, 16).mul(t8), c = St(r8, 24), l = i10.add(St(r8, e8 - 32)).mul(t8), m = p.add(St(r8, e8 - 24)).mul(t8);
    return Ji(Qt(u.add(c), 43).add(Qt(l, 30)).add(m), u.add(Qt(c.add(o8), 18)).add(l), t8);
  }
  function UG(r8, e8 = r8.length) {
    let t8 = Mu.fromNumber(81, true);
    if (e8 <= 32)
      return e8 <= 16 ? zG(r8, e8) : VG(r8, e8);
    if (e8 <= 64)
      return WG(r8, e8);
    let o8 = t8, n8 = t8.mul(Ou).add(113), s = nw(n8.mul(wr).add(113)).mul(wr), a = [Mu.UZERO, Mu.UZERO], i10 = [Mu.UZERO, Mu.UZERO];
    o8 = o8.mul(wr).add(St(r8, 0));
    let p = 0, u = (e8 - 1 >> 6) * 64, c = u + (e8 - 1 & 63) - 63;
    do
      o8 = Qt(o8.add(n8).add(a[0]).add(St(r8, p + 8)), 37).mul(Ou), n8 = Qt(n8.add(a[1]).add(St(r8, p + 48)), 42).mul(Ou), o8 = o8.xor(i10[1]), n8 = n8.add(a[0]).add(St(r8, p + 40)), s = Qt(s.add(i10[0]), 33).mul(Ou), a = Qm(r8, p, a[1].mul(Ou), o8.add(i10[0])), i10 = Qm(r8, p + 32, s.add(i10[1]), n8.add(St(r8, p + 16))), [s, o8] = [o8, s], p += 64;
    while (p !== u);
    let l = Ou.add(s.and(255).shl(1));
    return p = c, i10[0] = i10[0].add(e8 - 1 & 63), a[0] = a[0].add(i10[0]), i10[0] = i10[0].add(a[0]), o8 = Qt(o8.add(n8).add(a[0]).add(St(r8, p + 8)), 37).mul(l), n8 = Qt(n8.add(a[1]).add(St(r8, p + 48)), 42).mul(l), o8 = o8.xor(i10[1].mul(9)), n8 = n8.add(a[0].mul(9).add(St(r8, p + 40))), s = Qt(s.add(i10[0]), 33).mul(l), a = Qm(r8, p, a[1].mul(l), o8.add(i10[0])), i10 = Qm(r8, p + 32, s.add(i10[1]), n8.add(St(r8, p + 16))), [s, o8] = [o8, s], Ji(Ji(a[0], i10[0], l).add(nw(n8).mul(P0)).add(s), Ji(a[1], i10[1], l).add(o8), l);
  }
  function GG(r8, e8) {
    return e8 === "string" ? eu(r8) : ec([r8], e8);
  }
  function HG(r8, e8) {
    return r8 instanceof Float32Array && e8 === "float32" || r8 instanceof Int32Array && e8 === "int32" || r8 instanceof Uint8Array && e8 === "bool";
  }
  function ec(r8, e8) {
    if (e8 === "string")
      throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(r8) && (r8 = Fs(r8)), A().getBool("DEBUG") && jC(r8, e8), HG(r8, e8))
      return r8;
    if (e8 == null || e8 === "float32" || e8 === "complex64")
      return new Float32Array(r8);
    if (e8 === "int32")
      return new Int32Array(r8);
    if (e8 === "bool") {
      let t8 = new Uint8Array(r8.length);
      for (let o8 = 0; o8 < t8.length; ++o8)
        Math.round(r8[o8]) !== 0 && (t8[o8] = 1);
      return t8;
    } else
      throw new Error(`Unknown data type ${e8}`);
  }
  function Lu() {
    return A().platform.now();
  }
  function KG(r8, e8) {
    return A().platform.fetch(r8, e8);
  }
  function eu(r8, e8 = "utf-8") {
    return e8 = e8 || "utf-8", A().platform.encode(r8, e8);
  }
  function tc(r8, e8 = "utf-8") {
    return e8 = e8 || "utf-8", A().platform.decode(r8, e8);
  }
  function Pt(r8) {
    return A().platform.isTypedArray != null ? A().platform.isTypedArray(r8) : Xm(r8);
  }
  function Fs(r8, e8 = [], t8 = false) {
    if (e8 == null && (e8 = []), typeof r8 == "boolean" || typeof r8 == "number" || typeof r8 == "string" || Ru(r8) || r8 == null || Pt(r8) && t8)
      e8.push(r8);
    else if (Array.isArray(r8) || Pt(r8))
      for (let o8 = 0; o8 < r8.length; ++o8)
        Fs(r8[o8], e8, t8);
    else {
      let o8 = -1;
      for (let n8 of Object.keys(r8))
        /^([1-9]+[0-9]*|0)$/.test(n8) && (o8 = Math.max(o8, Number(n8)));
      for (let n8 = 0; n8 <= o8; n8++)
        Fs(r8[n8], e8, t8);
    }
    return e8;
  }
  var Zm = class {
    constructor(e8, t8) {
      this.backendTimer = e8, this.logger = t8, t8 == null && (this.logger = new aw());
    }
    profileKernel(e8, t8, o8) {
      let n8, s = () => {
        n8 = o8();
      }, a, i10 = Lu();
      if (this.backendTimer.timerAvailable())
        a = this.backendTimer.time(s);
      else {
        s();
        for (let u of n8)
          u.dataSync();
        a = Promise.resolve({ kernelMs: Lu() - i10 });
      }
      if (A().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
        for (let u = 0; u < n8.length; u++) {
          let c = n8[u];
          c.data().then((l) => {
            qG(l, c.dtype, e8);
          });
        }
      return { kernelName: e8, outputs: n8, inputs: t8, timeMs: a.then((u) => u.kernelMs), extraInfo: a.then((u) => u.getExtraProfileInfo != null ? u.getExtraProfileInfo() : "") };
    }
    logKernelProfile(e8) {
      let { kernelName: t8, outputs: o8, timeMs: n8, inputs: s, extraInfo: a } = e8;
      o8.forEach((i10) => {
        Promise.all([i10.data(), n8, a]).then((p) => {
          this.logger.logKernelProfile(t8, i10, p[0], p[1], s, p[2]);
        });
      });
    }
  };
  function qG(r8, e8, t8) {
    if (e8 !== "float32")
      return false;
    for (let o8 = 0; o8 < r8.length; o8++) {
      let n8 = r8[o8];
      if (isNaN(n8) || !isFinite(n8))
        return console.warn(`Found ${n8} in the result of '${t8}'`), true;
    }
    return false;
  }
  var aw = class {
    logKernelProfile(e8, t8, o8, n8, s, a) {
      let i10 = typeof n8 == "number" ? Eu(`${n8}ms`, 9) : n8.error, p = Eu(e8, 25), u = t8.rank, c = t8.size, l = Eu(t8.shape.toString(), 14), m = "";
      for (let d in s) {
        let f = s[d];
        if (f != null) {
          let h = f.shape || t8.shape, g = h.length;
          m += `${d}: ${g}D ${g > 0 ? h : ""} `;
        }
      }
      console.log(`%c${p}	%c${i10}	%c${u}D ${l}	%c${c}	%c${m}	%c${a}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  };
  function M0(r8, e8, t8) {
    let o8 = {}, n8 = {};
    for (let p = 0; p < e8.length; p++)
      o8[e8[p].id] = true;
    for (let p = 0; p < r8.length; p++) {
      let u = r8[p], c = u.inputs;
      for (let l in c) {
        let m = c[l], d = false;
        for (let f = 0; f < e8.length; f++)
          if (o8[m.id]) {
            u.outputs.forEach((h) => o8[h.id] = true), d = true, n8[u.id] = true;
            break;
          }
        if (d)
          break;
      }
    }
    let s = {};
    s[t8.id] = true;
    let a = {};
    for (let p = r8.length - 1; p >= 0; p--) {
      let u = r8[p], c = u.inputs;
      for (let l = 0; l < u.outputs.length; l++)
        if (s[u.outputs[l].id]) {
          for (let m in c)
            s[c[m].id] = true, a[u.id] = true;
          break;
        }
    }
    let i10 = [];
    for (let p = 0; p < r8.length; p++) {
      let u = r8[p];
      if (n8[u.id] && a[u.id]) {
        let c = {};
        for (let m in u.inputs) {
          let d = u.inputs[m];
          o8[d.id] && (c[m] = d);
        }
        let l = Object.assign({}, u);
        l.inputs = c, l.outputs = u.outputs, i10.push(l);
      }
    }
    return i10;
  }
  function L0(r8, e8, t8, o8) {
    for (let n8 = e8.length - 1; n8 >= 0; n8--) {
      let s = e8[n8], a = [];
      if (s.outputs.forEach((p) => {
        let u = r8[p.id];
        u != null ? a.push(u) : a.push(null);
      }), s.gradient == null)
        throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);
      let i10 = s.gradient(a);
      for (let p in s.inputs) {
        if (!(p in i10))
          throw new Error(`Cannot backprop through input ${p}. Available gradients found: ${Object.keys(i10)}.`);
        let u = t8(() => i10[p]());
        if (u.dtype !== "float32")
          throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${p} must have 'float32' dtype, but has '${u.dtype}'`);
        let c = s.inputs[p];
        if (!Cr(u.shape, c.shape))
          throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${p}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);
        if (r8[c.id] == null)
          r8[c.id] = u;
        else {
          let l = r8[c.id];
          r8[c.id] = o8(l, u), l.dispose();
        }
      }
    }
  }
  var B0 = 20;
  var gl = 3;
  var iw = 7;
  function z0(r8, e8, t8, o8) {
    let n8 = qs(e8), s = jG(r8, e8, t8, n8), a = e8.length, i10 = Jm(r8, e8, t8, n8, s), p = ["Tensor"];
    return o8 && (p.push(`  dtype: ${t8}`), p.push(`  rank: ${a}`), p.push(`  shape: [${e8}]`), p.push("  values:")), p.push(i10.map((u) => "    " + u).join(`
`)), p.join(`
`);
  }
  function jG(r8, e8, t8, o8) {
    let n8 = Ge(e8), s = o8[o8.length - 1], a = new Array(s).fill(0), i10 = e8.length, p = t8 === "complex64" ? yl(r8) : r8;
    if (i10 > 1)
      for (let u = 0; u < n8 / s; u++) {
        let c = u * s;
        for (let l = 0; l < s; l++)
          a[l] = Math.max(a[l], xl(p[c + l], 0, t8).length);
      }
    return a;
  }
  function xl(r8, e8, t8) {
    let o8;
    return Array.isArray(r8) ? o8 = `${parseFloat(r8[0].toFixed(iw))} + ${parseFloat(r8[1].toFixed(iw))}j` : zo(r8) ? o8 = `'${r8}'` : t8 === "bool" ? o8 = V0(r8) : o8 = parseFloat(r8.toFixed(iw)).toString(), Eu(o8, e8);
  }
  function V0(r8) {
    return r8 === 0 ? "false" : "true";
  }
  function Jm(r8, e8, t8, o8, n8, s = true) {
    let a = t8 === "complex64" ? 2 : 1, i10 = e8[0], p = e8.length;
    if (p === 0) {
      if (t8 === "complex64") {
        let h = yl(r8);
        return [xl(h[0], 0, t8)];
      }
      return t8 === "bool" ? [V0(r8[0])] : [r8[0].toString()];
    }
    if (p === 1) {
      if (i10 > B0) {
        let g = gl * a, x = Array.from(r8.slice(0, g)), b = Array.from(r8.slice((i10 - gl) * a, i10 * a));
        return t8 === "complex64" && (x = yl(x), b = yl(b)), ["[" + x.map((C, S) => xl(C, n8[S], t8)).join(", ") + ", ..., " + b.map((C, S) => xl(C, n8[i10 - gl + S], t8)).join(", ") + "]"];
      }
      return ["[" + (t8 === "complex64" ? yl(r8) : Array.from(r8)).map((g, x) => xl(g, n8[x], t8)).join(", ") + "]"];
    }
    let u = e8.slice(1), c = o8.slice(1), l = o8[0] * a, m = [];
    if (i10 > B0) {
      for (let h = 0; h < gl; h++) {
        let g = h * l, x = g + l;
        m.push(...Jm(r8.slice(g, x), u, t8, c, n8, false));
      }
      m.push("...");
      for (let h = i10 - gl; h < i10; h++) {
        let g = h * l, x = g + l;
        m.push(...Jm(r8.slice(g, x), u, t8, c, n8, h === i10 - 1));
      }
    } else
      for (let h = 0; h < i10; h++) {
        let g = h * l, x = g + l;
        m.push(...Jm(r8.slice(g, x), u, t8, c, n8, h === i10 - 1));
      }
    let d = p === 2 ? "," : "";
    m[0] = "[" + (i10 > 0 ? m[0] + d : "");
    for (let h = 1; h < m.length - 1; h++)
      m[h] = " " + m[h] + d;
    let f = `,
`;
    for (let h = 2; h < p; h++)
      f += `
`;
    return m[m.length - 1] = " " + m[m.length - 1] + "]" + (s ? "" : f), m;
  }
  function yl(r8) {
    let e8 = [];
    for (let t8 = 0; t8 < r8.length; t8 += 2)
      e8.push([r8[t8], r8[t8 + 1]]);
    return e8;
  }
  var tt = class {
    constructor(e8, t8, o8) {
      if (this.dtype = t8, this.shape = e8.slice(), this.size = Ge(e8), o8 != null) {
        let n8 = o8.length;
        $(n8 === this.size, () => `Length of values '${n8}' does not match the size inferred by the shape '${this.size}'.`);
      }
      if (t8 === "complex64")
        throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
      this.values = o8 || Km(t8, this.size), this.strides = qs(e8);
    }
    set(e8, ...t8) {
      t8.length === 0 && (t8 = [0]), $(t8.length === this.rank, () => `The number of provided coordinates (${t8.length}) must match the rank (${this.rank})`);
      let o8 = this.locToIndex(t8);
      this.values[o8] = e8;
    }
    get(...e8) {
      e8.length === 0 && (e8 = [0]);
      let t8 = 0;
      for (let n8 of e8) {
        if (n8 < 0 || n8 >= this.shape[t8]) {
          let s = `Requested out of range element at ${e8}.   Buffer shape=${this.shape}`;
          throw new Error(s);
        }
        t8++;
      }
      let o8 = e8[e8.length - 1];
      for (let n8 = 0; n8 < e8.length - 1; ++n8)
        o8 += this.strides[n8] * e8[n8];
      return this.values[o8];
    }
    locToIndex(e8) {
      if (this.rank === 0)
        return 0;
      if (this.rank === 1)
        return e8[0];
      let t8 = e8[e8.length - 1];
      for (let o8 = 0; o8 < e8.length - 1; ++o8)
        t8 += this.strides[o8] * e8[o8];
      return t8;
    }
    indexToLoc(e8) {
      if (this.rank === 0)
        return [];
      if (this.rank === 1)
        return [e8];
      let t8 = new Array(this.shape.length);
      for (let o8 = 0; o8 < t8.length - 1; ++o8)
        t8[o8] = Math.floor(e8 / this.strides[o8]), e8 -= t8[o8] * this.strides[o8];
      return t8[t8.length - 1] = e8, t8;
    }
    get rank() {
      return this.shape.length;
    }
    toTensor() {
      return Ps().makeTensor(this.values, this.shape, this.dtype);
    }
  };
  var Ps = null;
  var rc = null;
  function W0(r8) {
    Ps = r8;
  }
  function U0(r8) {
    rc = r8;
  }
  var ut = class {
    constructor(e8, t8, o8, n8) {
      this.kept = false, this.isDisposedInternal = false, this.shape = e8.slice(), this.dtype = t8 || "float32", this.size = Ge(e8), this.strides = qs(e8), this.dataId = o8, this.id = n8, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
      return this.shape.length;
    }
    async buffer() {
      let e8 = await this.data();
      return rc.buffer(this.shape, this.dtype, e8);
    }
    bufferSync() {
      return rc.buffer(this.shape, this.dtype, this.dataSync());
    }
    async array() {
      let e8 = await this.data();
      return $u(this.shape, e8, this.dtype === "complex64");
    }
    arraySync() {
      return $u(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    async data() {
      this.throwIfDisposed();
      let e8 = Ps().read(this.dataId);
      if (this.dtype === "string") {
        let t8 = await e8;
        try {
          return t8.map((o8) => tc(o8));
        } catch (o8) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return e8;
    }
    dataToGPU(e8) {
      return this.throwIfDisposed(), Ps().readToGPU(this.dataId, e8);
    }
    dataSync() {
      this.throwIfDisposed();
      let e8 = Ps().readSync(this.dataId);
      if (this.dtype === "string")
        try {
          return e8.map((t8) => tc(t8));
        } catch (t8) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      return e8;
    }
    async bytes() {
      this.throwIfDisposed();
      let e8 = await Ps().read(this.dataId);
      return this.dtype === "string" ? e8 : new Uint8Array(e8.buffer);
    }
    dispose() {
      this.isDisposed || (Ps().disposeTensor(this), this.isDisposedInternal = true);
    }
    get isDisposed() {
      return this.isDisposedInternal;
    }
    throwIfDisposed() {
      if (this.isDisposed)
        throw new Error("Tensor is disposed.");
    }
    print(e8 = false) {
      return rc.print(this, e8);
    }
    clone() {
      return this.throwIfDisposed(), rc.clone(this);
    }
    toString(e8 = false) {
      let t8 = this.dataSync();
      return z0(t8, this.shape, this.dtype, e8);
    }
    cast(e8) {
      return this.throwIfDisposed(), rc.cast(this, e8);
    }
    variable(e8 = true, t8, o8) {
      return this.throwIfDisposed(), Ps().makeVariable(this, e8, t8, o8);
    }
  };
  Object.defineProperty(ut, Symbol.hasInstance, { value: (r8) => !!r8 && r8.data != null && r8.dataSync != null && r8.throwIfDisposed != null });
  function YG() {
    return ml("Tensor", () => ut);
  }
  YG();
  var ei = class extends ut {
    constructor(e8, t8, o8, n8) {
      super(e8.shape, e8.dtype, e8.dataId, n8), this.trainable = t8, this.name = o8;
    }
    assign(e8) {
      if (e8.dtype !== this.dtype)
        throw new Error(`dtype of the new value (${e8.dtype}) and previous value (${this.dtype}) must match`);
      if (!Cr(e8.shape, this.shape))
        throw new Error(`shape of the new value (${e8.shape}) and previous value (${this.shape}) must match`);
      Ps().disposeTensor(this), this.dataId = e8.dataId, Ps().incRef(this, null);
    }
    dispose() {
      Ps().disposeVariable(this), this.isDisposedInternal = true;
    }
  };
  Object.defineProperty(ei, Symbol.hasInstance, { value: (r8) => r8 instanceof ut && r8.assign != null && r8.assign instanceof Function });
  var K0 = {};
  Ke(K0, { assertTypesMatch: () => dw, getTensorsInContainer: () => bl, isTensorInList: () => ZG, makeTypesMatch: () => Oe });
  var uw;
  (function(r8) {
    r8.R0 = "R0", r8.R1 = "R1", r8.R2 = "R2", r8.R3 = "R3", r8.R4 = "R4", r8.R5 = "R5", r8.R6 = "R6";
  })(uw || (uw = {}));
  var pw;
  (function(r8) {
    r8.float32 = "float32", r8.int32 = "int32", r8.bool = "int32", r8.complex64 = "complex64";
  })(pw || (pw = {}));
  var cw;
  (function(r8) {
    r8.float32 = "float32", r8.int32 = "int32", r8.bool = "bool", r8.complex64 = "complex64";
  })(cw || (cw = {}));
  var lw;
  (function(r8) {
    r8.float32 = "float32", r8.int32 = "float32", r8.bool = "float32", r8.complex64 = "complex64";
  })(lw || (lw = {}));
  var mw;
  (function(r8) {
    r8.float32 = "complex64", r8.int32 = "complex64", r8.bool = "complex64", r8.complex64 = "complex64";
  })(mw || (mw = {}));
  var QG = { float32: lw, int32: pw, bool: cw, complex64: mw };
  function dt(r8, e8) {
    if (r8 === "string" || e8 === "string") {
      if (r8 === "string" && e8 === "string")
        return "string";
      throw new Error(`Can not upcast ${r8} with ${e8}`);
    }
    return QG[r8][e8];
  }
  function ti(r8) {
    return dt(r8, "int32");
  }
  function ed(r8) {
    return r8 != null && typeof r8 == "object" && "texture" in r8 && r8.texture instanceof WebGLTexture;
  }
  function td(r8) {
    return typeof GPUBuffer != "undefined" && r8 != null && typeof r8 == "object" && "buffer" in r8 && r8.buffer instanceof GPUBuffer;
  }
  function Oe(r8, e8) {
    if (r8.dtype === e8.dtype)
      return [r8, e8];
    let t8 = dt(r8.dtype, e8.dtype);
    return [r8.cast(t8), e8.cast(t8)];
  }
  function dw(r8, e8) {
    $(r8.dtype === e8.dtype, () => `The dtypes of the first(${r8.dtype}) and second(${e8.dtype}) input must match`);
  }
  function ZG(r8, e8) {
    return e8.some((t8) => t8.id === r8.id);
  }
  function bl(r8) {
    let e8 = [];
    return H0(r8, e8, /* @__PURE__ */ new Set()), e8;
  }
  function H0(r8, e8, t8) {
    if (r8 == null)
      return;
    if (r8 instanceof ut) {
      e8.push(r8);
      return;
    }
    if (!JG(r8))
      return;
    let o8 = r8;
    for (let n8 in o8) {
      let s = o8[n8];
      t8.has(s) || (t8.add(s), H0(s, e8, t8));
    }
  }
  function JG(r8) {
    return Array.isArray(r8) || typeof r8 == "object";
  }
  function fw(r8) {
    return r8.kernelName != null;
  }
  var rd = class {
    constructor() {
      this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null, get kernelNames() {
        return Array.from(new Set(this.kernels.map((e8) => e8.name)));
      } };
    }
    dispose() {
      for (let e8 in this.registeredVariables)
        this.registeredVariables[e8].dispose();
    }
  };
  var tu = class {
    constructor(e8) {
      this.ENV = e8, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new rd();
    }
    async ready() {
      if (this.pendingBackendInit != null)
        return this.pendingBackendInit.then(() => {
        });
      if (this.backendInstance != null)
        return;
      let e8 = this.getSortedBackends();
      for (let t8 = 0; t8 < e8.length; t8++) {
        let o8 = e8[t8];
        if (await this.initializeBackend(o8).success) {
          await this.setBackend(o8);
          return;
        }
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    get backend() {
      if (this.pendingBackendInit != null)
        throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      if (this.backendInstance == null) {
        let { name: e8, asyncInit: t8 } = this.initializeBackendsAndReturnBest();
        if (t8)
          throw new Error(`The highest priority backend '${e8}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        this.setBackend(e8);
      }
      return this.backendInstance;
    }
    backendNames() {
      return Object.keys(this.registryFactory);
    }
    findBackend(e8) {
      if (!(e8 in this.registry))
        if (e8 in this.registryFactory) {
          let { asyncInit: t8 } = this.initializeBackend(e8);
          if (t8)
            return null;
        } else
          return null;
      return this.registry[e8];
    }
    findBackendFactory(e8) {
      return e8 in this.registryFactory ? this.registryFactory[e8].factory : null;
    }
    registerBackend(e8, t8, o8 = 1) {
      return e8 in this.registryFactory ? (Ca(`${e8} backend was already registered. Reusing existing backend factory.`), false) : (this.registryFactory[e8] = { factory: t8, priority: o8 }, true);
    }
    async setBackend(e8) {
      if (this.registryFactory[e8] == null)
        throw new Error(`Backend name '${e8}' not found in registry`);
      if (this.backendName = e8, this.registry[e8] == null) {
        this.backendInstance = null;
        let { success: t8, asyncInit: o8 } = this.initializeBackend(e8);
        if (!(o8 ? await t8 : t8))
          return false;
      }
      return this.backendInstance = this.registry[e8], this.setupRegisteredKernels(), this.profiler = new Zm(this.backendInstance), true;
    }
    setupRegisteredKernels() {
      jm(this.backendName).forEach((t8) => {
        t8.setupFunc != null && t8.setupFunc(this.backendInstance);
      });
    }
    disposeRegisteredKernels(e8) {
      jm(e8).forEach((o8) => {
        o8.disposeFunc != null && o8.disposeFunc(this.registry[e8]);
      });
    }
    initializeBackend(e8) {
      let t8 = this.registryFactory[e8];
      if (t8 == null)
        throw new Error(`Cannot initialize backend ${e8}, no registration found.`);
      try {
        let o8 = t8.factory();
        if (o8 && !(o8 instanceof so) && typeof o8.then == "function") {
          let n8 = ++this.pendingBackendInitId, s = o8.then((a) => n8 < this.pendingBackendInitId ? false : (this.registry[e8] = a, this.pendingBackendInit = null, true)).catch((a) => (n8 < this.pendingBackendInitId || (this.pendingBackendInit = null, Ca(`Initialization of backend ${e8} failed`), Ca(a.stack || a.message)), false));
          return this.pendingBackendInit = s, { success: s, asyncInit: true };
        } else
          return this.registry[e8] = o8, { success: true, asyncInit: false };
      } catch (o8) {
        return Ca(`Initialization of backend ${e8} failed`), Ca(o8.stack || o8.message), { success: false, asyncInit: false };
      }
    }
    removeBackend(e8) {
      if (!(e8 in this.registryFactory))
        throw new Error(`${e8} backend not found in registry`);
      this.backendName === e8 && this.pendingBackendInit != null && this.pendingBackendInitId++, e8 in this.registry && (this.disposeRegisteredKernels(e8), this.registry[e8].dispose(), delete this.registry[e8]), delete this.registryFactory[e8], this.backendName === e8 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }
    getSortedBackends() {
      if (Object.keys(this.registryFactory).length === 0)
        throw new Error("No backend found in registry.");
      return Object.keys(this.registryFactory).sort((e8, t8) => this.registryFactory[t8].priority - this.registryFactory[e8].priority);
    }
    initializeBackendsAndReturnBest() {
      let e8 = this.getSortedBackends();
      for (let t8 = 0; t8 < e8.length; t8++) {
        let o8 = e8[t8], { success: n8, asyncInit: s } = this.initializeBackend(o8);
        if (s || n8)
          return { name: o8, asyncInit: s };
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    moveData(e8, t8) {
      let o8 = this.state.tensorInfo.get(t8), n8 = o8.backend, s = this.readSync(t8), a = n8.refCount(t8);
      n8.disposeData(t8, true), o8.backend = e8, e8.move(t8, s, o8.shape, o8.dtype, a), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
    tidy(e8, t8) {
      let o8 = null;
      if (t8 == null) {
        if (typeof e8 != "function")
          throw new Error("Please provide a function to tidy()");
        t8 = e8;
      } else {
        if (typeof e8 != "string" && !(e8 instanceof String))
          throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        if (typeof t8 != "function")
          throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        o8 = e8;
      }
      let n8;
      return this.scopedRun(() => this.startScope(o8), () => this.endScope(n8), () => (n8 = t8(), n8 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n8));
    }
    scopedRun(e8, t8, o8) {
      e8();
      try {
        let n8 = o8();
        return t8(), n8;
      } catch (n8) {
        throw t8(), n8;
      }
    }
    nextTensorId() {
      return tu.nextTensorId++;
    }
    nextVariableId() {
      return tu.nextVariableId++;
    }
    clone(e8) {
      let t8 = T.runKernel(Co, { x: e8 }), o8 = { x: e8 }, n8 = (a) => ({ x: () => {
        let i10 = "float32", p = { x: a }, u = { dtype: i10 };
        return T.runKernel(yo, p, u);
      } }), s = [];
      return this.addTapeNode(this.state.activeScope.name, o8, [t8], n8, s, {}), t8;
    }
    runKernel(e8, t8, o8) {
      if (this.backendName == null && this.backend, !(fl(e8, this.backendName) != null))
        throw new Error(`Kernel '${e8}' not registered for backend '${this.backendName}'`);
      return this.runKernelFunc({ kernelName: e8, inputs: t8, attrs: o8 });
    }
    shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(e8, t8, o8) {
      let n8 = this.backend.numDataIds(), s = 0;
      o8.forEach((p) => {
        s += p.dtype === "complex64" ? 3 : 1;
      });
      let a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i10 = n8 - t8 - s - a;
      if (i10 > 0)
        throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i10} data ids) after running '${e8}'`);
    }
    runKernelFunc(e8) {
      let t8, o8 = [], n8 = this.isTapeOn(), s = this.state.numBytes, a = this.state.numTensors;
      this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
      let i10;
      this.backendName == null && this.backend;
      let p, u = fw(e8) ? e8.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
      if (fw(e8)) {
        let { kernelName: f, inputs: h, attrs: g } = e8;
        this.backendName == null && this.backend;
        let x = fl(f, this.backendName);
        $(x != null, () => `Cannot find registered kernel '${f}' for backend '${this.backendName}'`), i10 = () => {
          let b = this.backend.numDataIds();
          p = x.kernelFunc({ inputs: h, attrs: g, backend: this.backend });
          let C = Array.isArray(p) ? p : [p];
          this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(f, b, C);
          let S = C.map((k) => k.rank != null ? k : this.makeTensorFromTensorInfo(k));
          if (n8) {
            let k = this.getTensorsForGradient(f, h, S);
            o8 = this.saveTensorsForBackwardMode(k);
          }
          return S;
        };
      } else {
        let { forwardFunc: f } = e8, h = (g) => {
          n8 && (o8 = g.map((x) => this.keep(this.clone(x))));
        };
        i10 = () => {
          let g = this.backend.numDataIds();
          p = this.tidy(() => f(this.backend, h));
          let x = Array.isArray(p) ? p : [p];
          return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(u, g, x), x;
        };
      }
      let { inputs: c, attrs: l } = e8, m = fw(e8) ? null : e8.backwardsFunc, d;
      return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
        !this.ENV.getBool("DEBUG") && !this.state.profiling ? t8 = i10() : (d = this.profiler.profileKernel(u, c, () => i10()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(d), t8 = d.outputs);
      }), n8 && this.addTapeNode(u, c, t8, m, o8, l), this.state.profiling && this.state.activeProfile.kernels.push({ name: u, bytesAdded: this.state.numBytes - s, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - a, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(c).map((f) => c[f] != null ? c[f].shape : null), outputShapes: t8.map((f) => f.shape), kernelTimeMs: d.timeMs, extraInfo: d.extraInfo }), Array.isArray(p) ? t8 : t8[0];
    }
    saveTensorsForBackwardMode(e8) {
      return e8.map((o8) => this.keep(this.clone(o8)));
    }
    getTensorsForGradient(e8, t8, o8) {
      let n8 = ew(e8);
      if (n8 != null) {
        let s = n8.inputsToSave || [], a = n8.outputsToSave || [], i10;
        n8.saveAllInputs ? ($(Array.isArray(t8), () => "saveAllInputs is true, expected inputs to be an array."), i10 = Object.keys(t8).map((u) => t8[u])) : i10 = s.map((u) => t8[u]);
        let p = o8.filter((u, c) => a[c]);
        return i10.concat(p);
      }
      return [];
    }
    makeTensor(e8, t8, o8, n8) {
      if (e8 == null)
        throw new Error("Values passed to engine.makeTensor() are null");
      o8 = o8 || "float32", n8 = n8 || this.backend;
      let s = e8;
      o8 === "string" && zo(e8[0]) && (s = e8.map((p) => eu(p)));
      let a = n8.write(s, t8, o8), i10 = new ut(t8, o8, a, this.nextTensorId());
      if (this.trackTensor(i10, n8), o8 === "string") {
        let p = this.state.tensorInfo.get(a), u = YC(s);
        this.state.numBytes += u - p.bytes, p.bytes = u;
      }
      return i10;
    }
    makeTensorFromDataId(e8, t8, o8, n8) {
      o8 = o8 || "float32";
      let s = { dataId: e8, shape: t8, dtype: o8 };
      return this.makeTensorFromTensorInfo(s, n8);
    }
    makeTensorFromTensorInfo(e8, t8) {
      let { dataId: o8, shape: n8, dtype: s } = e8, a = new ut(n8, s, o8, this.nextTensorId());
      return this.trackTensor(a, t8), a;
    }
    makeVariable(e8, t8 = true, o8, n8) {
      o8 = o8 || this.nextVariableId().toString(), n8 != null && n8 !== e8.dtype && (e8 = e8.cast(n8));
      let s = new ei(e8, t8, o8, this.nextTensorId());
      if (this.state.registeredVariables[s.name] != null)
        throw new Error(`Variable with name ${s.name} was already registered`);
      return this.state.registeredVariables[s.name] = s, this.incRef(s, this.backend), s;
    }
    trackTensor(e8, t8) {
      this.state.numTensors++, e8.dtype === "string" && this.state.numStringTensors++;
      let o8 = 0;
      e8.dtype !== "complex64" && e8.dtype !== "string" && (o8 = e8.size * Hp(e8.dtype)), this.state.numBytes += o8, this.state.tensorInfo.has(e8.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e8.dataId, { backend: t8 || this.backend, dtype: e8.dtype, shape: e8.shape, bytes: o8 })), e8 instanceof ei || this.track(e8);
    }
    incRef(e8, t8) {
      this.trackTensor(e8, t8), this.backend.incRef(e8.dataId);
    }
    removeDataId(e8, t8) {
      this.state.tensorInfo.has(e8) && this.state.tensorInfo.get(e8).backend === t8 && (this.state.tensorInfo.delete(e8), this.state.numDataBuffers--);
    }
    disposeTensor(e8) {
      if (!this.state.tensorInfo.has(e8.dataId))
        return;
      let t8 = this.state.tensorInfo.get(e8.dataId);
      if (this.state.numTensors--, e8.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= t8.bytes), e8.dtype !== "complex64" && e8.dtype !== "string") {
        let o8 = e8.size * Hp(e8.dtype);
        this.state.numBytes -= o8;
      }
      t8.backend.disposeData(e8.dataId) && this.removeDataId(e8.dataId, t8.backend);
    }
    disposeVariables() {
      for (let e8 in this.state.registeredVariables) {
        let t8 = this.state.registeredVariables[e8];
        this.disposeVariable(t8);
      }
    }
    disposeVariable(e8) {
      this.disposeTensor(e8), this.state.registeredVariables[e8.name] != null && delete this.state.registeredVariables[e8.name];
    }
    memory() {
      let e8 = this.backend.memory();
      return e8.numTensors = this.state.numTensors, e8.numDataBuffers = this.state.numDataBuffers, e8.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e8.unreliable = true, e8.reasons == null && (e8.reasons = []), e8.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e8;
    }
    async profile(e8) {
      this.state.profiling = true;
      let t8 = this.state.numBytes, o8 = this.state.numTensors;
      this.state.activeProfile.kernels = [], this.state.activeProfile.result = await e8(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((n8) => n8.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - t8, this.state.activeProfile.newTensors = this.state.numTensors - o8;
      for (let n8 of this.state.activeProfile.kernels)
        n8.kernelTimeMs = await n8.kernelTimeMs, n8.extraInfo = await n8.extraInfo;
      return this.state.activeProfile;
    }
    isTapeOn() {
      return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(e8, t8, o8, n8, s, a) {
      let i10 = { id: this.state.nextTapeNodeId++, kernelName: e8, inputs: t8, outputs: o8, saved: s }, p = ew(e8);
      p != null && (n8 = p.gradFunc), n8 != null && (i10.gradient = (u) => (u = u.map((c, l) => {
        if (c == null) {
          let m = o8[l], d = qp(m.size, m.dtype);
          return this.makeTensor(d, m.shape, m.dtype);
        }
        return c;
      }), n8(u.length > 1 ? u : u[0], s, a))), this.state.activeTape.push(i10);
    }
    keep(e8) {
      return e8.kept = true, e8;
    }
    startTape() {
      this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
    }
    endTape() {
      this.state.gradientDepth--;
    }
    startScope(e8) {
      let t8 = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
      e8 && (t8.name = e8), this.state.scopeStack.push(t8), this.state.activeScope = t8;
    }
    endScope(e8) {
      let t8 = bl(e8), o8 = new Set(t8.map((s) => s.id));
      for (let s = 0; s < this.state.activeScope.track.length; s++) {
        let a = this.state.activeScope.track[s];
        !a.kept && !o8.has(a.id) && a.dispose();
      }
      let n8 = this.state.scopeStack.pop();
      this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t8.forEach((s) => {
        !s.kept && s.scopeId === n8.id && this.track(s);
      });
    }
    gradients(e8, t8, o8, n8 = false) {
      if ($(t8.length > 0, () => "gradients() received an empty list of xs."), o8 != null && o8.dtype !== "float32")
        throw new Error(`dy must have 'float32' dtype, but has '${o8.dtype}'`);
      let s = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e8));
      $(s instanceof ut, () => "The result y returned by f() must be a tensor.");
      let a = M0(this.state.activeTape, t8, s);
      if (!n8 && a.length === 0 && t8.length > 0)
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      return this.tidy("backward", () => {
        let i10 = {};
        i10[s.id] = o8 == null ? e4(s.shape) : o8, L0(i10, a, (u) => this.tidy(u), t4);
        let p = t8.map((u) => i10[u.id]);
        return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((u) => {
          for (let c of u.saved)
            c.dispose();
        }), this.state.activeTape = null), { value: s, grads: p };
      });
    }
    customGrad(e8) {
      return $(Ks(e8), () => "The f passed in customGrad(f) must be a function."), (...t8) => {
        $(t8.every((i10) => i10 instanceof ut), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
        let o8, n8 = {};
        t8.forEach((i10, p) => {
          n8[p] = i10;
        });
        let s = (i10, p) => (o8 = e8(...t8, p), $(o8.value instanceof ut, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), $(Ks(o8.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), o8.value), a = (i10, p) => {
          let u = o8.gradFunc(i10, p), c = Array.isArray(u) ? u : [u];
          $(c.length === t8.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), $(c.every((m) => m instanceof ut), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          let l = {};
          return c.forEach((m, d) => {
            l[d] = () => m;
          }), l;
        };
        return this.runKernelFunc({ forwardFunc: s, backwardsFunc: a, inputs: n8 });
      };
    }
    readSync(e8) {
      return this.state.tensorInfo.get(e8).backend.readSync(e8);
    }
    read(e8) {
      return this.state.tensorInfo.get(e8).backend.read(e8);
    }
    readToGPU(e8, t8) {
      return this.state.tensorInfo.get(e8).backend.readToGPU(e8, t8);
    }
    async time(e8) {
      let t8 = Lu(), o8 = await this.backend.time(e8);
      return o8.wallMs = Lu() - t8, o8;
    }
    track(e8) {
      return this.state.activeScope != null && (e8.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e8)), e8;
    }
    get registeredVariables() {
      return this.state.registeredVariables;
    }
    reset() {
      this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new rd();
      for (let e8 in this.registry)
        this.disposeRegisteredKernels(e8), this.registry[e8].dispose(), delete this.registry[e8];
      this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }
  };
  tu.nextTensorId = 0;
  tu.nextVariableId = 0;
  function e4(r8) {
    let e8 = cl(Ge(r8), "float32");
    return T.makeTensor(e8, r8, "float32");
  }
  function hw() {
    let r8 = JC();
    if (r8._tfengine == null) {
      let e8 = new ll(r8);
      r8._tfengine = new tu(e8);
    }
    return C0(r8._tfengine.ENV), W0(() => r8._tfengine), r8._tfengine;
  }
  var T = hw();
  function t4(r8, e8) {
    let t8 = { a: r8, b: e8 };
    return T.runKernel(io, t8);
  }
  var ru = {};
  Ke(ru, { isBrowser: () => xw, isMobile: () => n4, mockIsMobile: () => o4 });
  function r4() {
    return typeof navigator != "undefined" && navigator != null;
  }
  var gw;
  function o4(r8) {
    gw = r8;
  }
  function n4(r8) {
    if (gw !== void 0)
      return gw;
    if (r8 || r4()) {
      if (r8 || (r8 = navigator), r8.product === "ReactNative")
        return true;
      let e8 = r8.userAgent || r8.vendor || (typeof window != "undefined" ? window.opera : "");
      if (!e8) {
        let t8 = r8;
        return t8.userAgentData && t8.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e8) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e8.substr(0, 4));
    }
    return false;
  }
  function xw() {
    return typeof window != "undefined" && window.document != null || typeof WorkerGlobalScope != "undefined";
  }
  var $r = A();
  $r.registerFlag("DEBUG", () => false, (r8) => {
    r8 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
  });
  $r.registerFlag("IS_BROWSER", () => xw());
  $r.registerFlag("IS_NODE", () => typeof process$1 != "undefined" && typeof process$1.versions != "undefined" && typeof process$1.versions.node != "undefined");
  $r.registerFlag("IS_CHROME", () => typeof navigator != "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  $r.registerFlag("IS_SAFARI", () => typeof navigator != "undefined" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
  $r.registerFlag("PROD", () => false);
  $r.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => $r.getBool("DEBUG"));
  $r.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  $r.registerFlag("IS_TEST", () => false);
  $r.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => $r.getBool("DEBUG"));
  $r.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  $r.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
  $r.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
  function ar(r8, e8) {
    let t8 = r8;
    if (Pt(r8))
      return e8 === "string" ? [] : [r8.length];
    if (ed(r8)) {
      let n8 = r8.channels || "RGBA";
      return [r8.height, r8.width * n8.length];
    } else if (td(r8))
      return [r8.buffer.size / (e8 == null ? 4 : Hp(e8))];
    if (!Array.isArray(r8))
      return [];
    let o8 = [];
    for (; Array.isArray(t8) || Pt(t8) && e8 !== "string"; )
      o8.push(t8.length), t8 = t8[0];
    return Array.isArray(r8) && A().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && j0(r8, o8, []), o8;
  }
  function j0(r8, e8, t8) {
    if (t8 = t8 || [], !Array.isArray(r8) && !Pt(r8)) {
      $(e8.length === 0, () => `Element arr[${t8.join("][")}] is a primitive, but should be an array/TypedArray of ${e8[0]} elements`);
      return;
    }
    $(e8.length > 0, () => `Element arr[${t8.join("][")}] should be a primitive, but is an array of ${r8.length} elements`), $(r8.length === e8[0], () => `Element arr[${t8.join("][")}] should have ${e8[0]} elements, but has ${r8.length} elements`);
    let o8 = e8.slice(1);
    for (let n8 = 0; n8 < r8.length; ++n8)
      j0(r8[n8], o8, t8.concat(n8));
  }
  function q0(r8, e8, t8, o8) {
    if (r8 !== "string_or_numeric") {
      if (r8 == null)
        throw new Error("Expected dtype cannot be null.");
      if (r8 !== "numeric" && r8 !== e8 || r8 === "numeric" && e8 === "string")
        throw new Error(`Argument '${t8}' passed to '${o8}' must be ${r8} tensor, but got ${e8} tensor`);
    }
  }
  function v(r8, e8, t8, o8 = "numeric") {
    if (r8 instanceof ut)
      return q0(o8, r8.dtype, e8, t8), r8;
    let n8 = _i(r8);
    if (n8 !== "string" && ["bool", "int32", "float32"].indexOf(o8) >= 0 && (n8 = o8), q0(o8, n8, e8, t8), r8 == null || !Pt(r8) && !Array.isArray(r8) && typeof r8 != "number" && typeof r8 != "boolean" && typeof r8 != "string") {
      let p = r8 == null ? "null" : r8.constructor.name;
      throw new Error(`Argument '${e8}' passed to '${t8}' must be a Tensor or TensorLike, but got '${p}'`);
    }
    let s = ar(r8, n8);
    !Pt(r8) && !Array.isArray(r8) && (r8 = [r8]);
    let i10 = n8 !== "string" ? ec(r8, n8) : Fs(r8, [], true);
    return T.makeTensor(i10, s, n8);
  }
  function ri(r8, e8, t8, o8 = "numeric") {
    if (!Array.isArray(r8))
      throw new Error(`Argument ${e8} passed to ${t8} must be a \`Tensor[]\` or \`TensorLike[]\``);
    return r8.map((s, a) => v(s, `${e8}[${a}]`, t8, o8));
  }
  var yw = "__op";
  function N(r8) {
    let e8 = Object.keys(r8);
    if (e8.length !== 1)
      throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e8.length} keys.`);
    let t8 = e8[0], o8 = r8[t8];
    t8.endsWith("_") && (t8 = t8.substring(0, t8.length - 1)), t8 = t8 + yw;
    let n8 = (...s) => {
      T.startScope(t8);
      try {
        let a = o8(...s);
        return Ru(a) && console.error("Cannot return a Promise inside of tidy."), T.endScope(a), a;
      } catch (a) {
        throw T.endScope(null), a;
      }
    };
    return Object.defineProperty(n8, "name", { value: t8, configurable: true }), n8;
  }
  function s4(r8, e8) {
    let t8 = v(r8, "real", "complex"), o8 = v(e8, "imag", "complex");
    yt(t8.shape, o8.shape, `real and imag shapes, ${t8.shape} and ${o8.shape}, must match in call to tf.complex().`);
    let n8 = { real: t8, imag: o8 };
    return T.runKernel(Ri, n8);
  }
  var Er = N({ complex_: s4 });
  function Sr(r8, e8, t8, o8) {
    if (o8 == null)
      o8 = _i(r8);
    else if (o8 === "complex64")
      throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (td(r8) || ed(r8)) {
      if (o8 !== "float32" && o8 !== "int32")
        throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${o8}.`);
      return T.backend.createTensorFromGPUData(r8, e8 || t8, o8);
    }
    if (!Pt(r8) && !Array.isArray(r8) && typeof r8 != "number" && typeof r8 != "boolean" && typeof r8 != "string")
      throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (e8 != null) {
      wt(e8);
      let n8 = Ge(e8), s = Ge(t8);
      $(n8 === s, () => `Based on the provided shape, [${e8}], the tensor should have ${n8} values but has ${s}`);
      for (let a = 0; a < t8.length; ++a) {
        let i10 = t8[a], p = a === t8.length - 1 ? i10 !== Ge(e8.slice(a)) : true;
        $(t8[a] === e8[a] || !p, () => `Error creating a new Tensor. Inferred shape (${t8}) does not match the provided shape (${e8}). `);
      }
    }
    return !Pt(r8) && !Array.isArray(r8) && (r8 = [r8]), e8 = e8 || t8, r8 = o8 !== "string" ? ec(r8, o8) : Fs(r8, [], true), T.makeTensor(r8, e8, o8);
  }
  function ir(r8, e8, t8) {
    let o8 = ar(r8, t8);
    return Sr(r8, e8, o8, t8);
  }
  var Cl = { float32: 4, float16: 2, int32: 4, uint16: 2, uint8: 1, bool: 1, complex64: 8 };
  var jt = class {
    static join(e8) {
      return new jt(e8).slice();
    }
    constructor(e8) {
      if (this.shards = [], this.previousShardIndex = 0, e8 == null || (e8 instanceof Array || (e8 = [e8]), e8 = e8.map((o8) => Pt(o8) ? o8.buffer : o8), e8.length === 0))
        return;
      this.bufferUniformSize = e8[0].byteLength;
      let t8 = 0;
      for (let o8 = 0; o8 < e8.length; o8++) {
        let n8 = e8[o8];
        o8 !== e8.length - 1 && n8.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
        let s = t8 + n8.byteLength;
        this.shards.push({ buffer: n8, start: t8, end: s }), t8 = s;
      }
      this.shards.length === 0 && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
    }
    slice(e8 = 0, t8 = this.byteLength) {
      if (this.shards.length === 0)
        return new ArrayBuffer(0);
      if (e8 = isNaN(Number(e8)) ? 0 : e8, t8 = isNaN(Number(t8)) ? 0 : t8, e8 = Math.max(0, e8), t8 = Math.min(this.byteLength, t8), t8 <= e8)
        return new ArrayBuffer(0);
      let o8 = this.findShardForByte(e8);
      if (o8 === -1)
        throw new Error(`Could not find start shard for byte ${e8}`);
      let n8 = t8 - e8, s = new ArrayBuffer(n8), a = new Uint8Array(s), i10 = 0;
      for (let p = o8; p < this.shards.length; p++) {
        let u = this.shards[p], l = e8 + i10 - u.start, m = i10, f = Math.min(t8, u.end) - u.start, h = new Uint8Array(u.buffer, l, f - l);
        if (a.set(h, m), i10 += h.length, t8 < u.end)
          break;
      }
      return s;
    }
    findShardForByte(e8) {
      if (this.shards.length === 0 || e8 < 0 || e8 >= this.byteLength)
        return -1;
      if (this.bufferUniformSize != null)
        return this.previousShardIndex = Math.floor(e8 / this.bufferUniformSize), this.previousShardIndex;
      function t8(n8) {
        return e8 < n8.start ? -1 : e8 >= n8.end ? 1 : 0;
      }
      if (t8(this.shards[this.previousShardIndex]) === 0)
        return this.previousShardIndex;
      let o8 = a4(this.shards, t8);
      return o8 === -1 ? -1 : (this.previousShardIndex = o8, this.previousShardIndex);
    }
  };
  function a4(r8, e8) {
    let t8 = 0, o8 = r8.length;
    for (; t8 <= o8; ) {
      let n8 = Math.floor((o8 - t8) / 2) + t8, s = e8(r8[n8]);
      if (s === 0)
        return n8;
      s < 0 ? o8 = n8 : t8 = n8 + 1;
    }
    return -1;
  }
  var od = 4;
  async function Y0(r8, e8) {
    let t8 = [], o8 = [], n8 = Array.isArray(r8) ? r8.map((a) => a.name) : Object.keys(r8);
    for (let a = 0; a < n8.length; ++a) {
      let i10 = n8[a], p = Array.isArray(r8) ? r8[a].tensor : r8[i10];
      if (p.dtype !== "float32" && p.dtype !== "int32" && p.dtype !== "bool" && p.dtype !== "string" && p.dtype !== "complex64")
        throw new Error(`Unsupported dtype in weight '${i10}': ${p.dtype}`);
      let u = { name: i10, shape: p.shape, dtype: p.dtype };
      if (p.dtype === "string") {
        let c = new Promise(async (l) => {
          let m = await p.bytes(), d = m.reduce((g, x) => g + x.length, 0) + od * m.length, f = new Uint8Array(d), h = 0;
          for (let g = 0; g < m.length; g++) {
            let x = m[g], b = new Uint8Array(new Uint32Array([x.length]).buffer);
            f.set(b, h), h += od, f.set(x, h), h += x.length;
          }
          l(f);
        });
        o8.push(c);
      } else
        o8.push(p.data());
      e8 != null && (u.group = e8), t8.push(u);
    }
    let s = await Promise.all(o8);
    return { data: i4(s), specs: t8 };
  }
  function nd(r8, e8) {
    let t8 = new jt(r8), o8 = {}, n8, s = 0;
    for (let a of e8) {
      let i10 = a.name, p = a.dtype, u = a.shape, c = Ge(u), l;
      if ("quantization" in a) {
        let m = a.quantization;
        if (m.dtype === "uint8" || m.dtype === "uint16") {
          if (!("min" in m && "scale" in m))
            throw new Error(`Weight ${a.name} with quantization ${m.dtype} doesn't have corresponding metadata min and scale.`);
        } else if (m.dtype === "float16") {
          if (p !== "float32")
            throw new Error(`Weight ${a.name} is quantized with ${m.dtype} which only supports weights of type float32 not ${p}.`);
        } else
          throw new Error(`Weight ${a.name} has unknown quantization dtype ${m.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
        let d = Cl[m.dtype], f = t8.slice(s, s + c * d), h = m.dtype === "uint8" ? new Uint8Array(f) : new Uint16Array(f);
        if (p === "float32")
          if (m.dtype === "uint8" || m.dtype === "uint16") {
            l = new Float32Array(h.length);
            for (let g = 0; g < h.length; g++) {
              let x = h[g];
              l[g] = x * m.scale + m.min;
            }
          } else if (m.dtype === "float16")
            n8 === void 0 && (n8 = l4()), l = n8(h);
          else
            throw new Error(`Unsupported quantization type ${m.dtype} for weight type float32.`);
        else if (p === "int32") {
          if (m.dtype !== "uint8" && m.dtype !== "uint16")
            throw new Error(`Unsupported quantization type ${m.dtype} for weight type int32.`);
          l = new Int32Array(h.length);
          for (let g = 0; g < h.length; g++) {
            let x = h[g];
            l[g] = Math.round(x * m.scale + m.min);
          }
        } else
          throw new Error(`Unsupported dtype in weight '${i10}': ${p}`);
        s += c * d;
      } else if (p === "string") {
        let m = Ge(a.shape);
        l = [];
        for (let d = 0; d < m; d++) {
          let f = new Uint32Array(t8.slice(s, s + od))[0];
          s += od;
          let h = new Uint8Array(t8.slice(s, s + f));
          l.push(h), s += f;
        }
      } else {
        let m = Cl[p], d = t8.slice(s, s + c * m);
        if (p === "float32")
          l = new Float32Array(d);
        else if (p === "int32")
          l = new Int32Array(d);
        else if (p === "bool")
          l = new Uint8Array(d);
        else if (p === "complex64") {
          l = new Float32Array(d);
          let f = new Float32Array(l.length / 2), h = new Float32Array(l.length / 2);
          for (let b = 0; b < f.length; b++)
            f[b] = l[b * 2], h[b] = l[b * 2 + 1];
          let g = ir(f, u, "float32"), x = ir(h, u, "float32");
          o8[i10] = Er(g, x), g.dispose(), x.dispose();
        } else
          throw new Error(`Unsupported dtype in weight '${i10}': ${p}`);
        s += c * m;
      }
      p !== "complex64" && (o8[i10] = ir(l, u, p));
    }
    return o8;
  }
  function i4(r8) {
    if (r8 === null)
      throw new Error(`Invalid input value: ${JSON.stringify(r8)}`);
    let e8 = 0, t8 = [];
    r8.forEach((s) => {
      if (e8 += s.byteLength, t8.push(s.byteLength === s.buffer.byteLength ? s : new s.constructor(s)), !(s instanceof Float32Array || s instanceof Int32Array || s instanceof Uint8Array))
        throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`);
    });
    let o8 = new Uint8Array(e8), n8 = 0;
    return t8.forEach((s) => {
      o8.set(new Uint8Array(s.buffer), n8), n8 += s.byteLength;
    }), o8.buffer;
  }
  var bw = typeof buffer$1.Buffer != "undefined" && (typeof Blob == "undefined" || typeof atob == "undefined" || typeof btoa == "undefined");
  function X0(r8) {
    return bw ? buffer$1.Buffer.byteLength(r8, "utf8") : new Blob([r8]).size;
  }
  function Q0(r8) {
    if (bw)
      return buffer$1.Buffer.from(r8).toString("base64");
    let e8 = new Uint8Array(r8), t8 = "";
    for (let o8 = 0, n8 = e8.length; o8 < n8; o8++)
      t8 += String.fromCharCode(e8[o8]);
    return btoa(t8);
  }
  function Z0(r8) {
    if (bw) {
      let o8 = buffer$1.Buffer.from(r8, "base64");
      return o8.buffer.slice(o8.byteOffset, o8.byteOffset + o8.byteLength);
    }
    let e8 = atob(r8), t8 = new Uint8Array(e8.length);
    for (let o8 = 0; o8 < e8.length; ++o8)
      t8.set([e8.charCodeAt(o8)], o8);
    return t8.buffer;
  }
  function J0(r8) {
    return jt.join(r8);
  }
  function Cw(r8) {
    let e8 = "/";
    for (r8 = r8.trim(); r8.endsWith(e8); )
      r8 = r8.slice(0, r8.length - 1);
    let t8 = r8.split(e8);
    return t8[t8.length - 1];
  }
  function sd(r8, e8) {
    let t8 = { modelTopology: r8.modelTopology, format: r8.format, generatedBy: r8.generatedBy, convertedBy: r8.convertedBy, weightsManifest: e8 };
    return r8.signature != null && (t8.signature = r8.signature), r8.userDefinedMetadata != null && (t8.userDefinedMetadata = r8.userDefinedMetadata), r8.modelInitializer != null && (t8.modelInitializer = r8.modelInitializer), r8.initializerSignature != null && (t8.initializerSignature = r8.initializerSignature), r8.trainingConfig != null && (t8.trainingConfig = r8.trainingConfig), t8;
  }
  function ww(r8, e8, t8) {
    let o8 = { modelTopology: r8.modelTopology, format: r8.format, generatedBy: r8.generatedBy, convertedBy: r8.convertedBy };
    if (r8.trainingConfig != null && (o8.trainingConfig = r8.trainingConfig), r8.weightsManifest != null) {
      if (!e8)
        throw new Error("modelJSON has weightsManifest but weightSpecs is null");
      if (!t8)
        throw new Error("modelJSON has weightsManifest but weightData is null");
      o8.weightSpecs = e8, o8.weightData = t8;
    }
    return r8.signature != null && (o8.signature = r8.signature), r8.userDefinedMetadata != null && (o8.userDefinedMetadata = r8.userDefinedMetadata), r8.modelInitializer != null && (o8.modelInitializer = r8.modelInitializer), r8.initializerSignature != null && (o8.initializerSignature = r8.initializerSignature), o8;
  }
  async function oc(r8, e8) {
    let t8, o8;
    return r8.weightsManifest != null && ([t8, o8] = await e8(r8.weightsManifest)), ww(r8, t8, o8);
  }
  function wa(r8) {
    if (r8.modelTopology instanceof ArrayBuffer)
      throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: r8.modelTopology == null ? 0 : X0(JSON.stringify(r8.modelTopology)), weightSpecsBytes: r8.weightSpecs == null ? 0 : X0(JSON.stringify(r8.weightSpecs)), weightDataBytes: r8.weightData == null ? 0 : new jt(r8.weightData).byteLength };
  }
  function ad(r8) {
    let e8 = [];
    for (let t8 of r8)
      e8.push(...t8.weights);
    return e8;
  }
  function u4() {
    let r8 = (t8) => {
      let o8 = t8 << 13, n8 = 0;
      for (; !(o8 & 8388608); )
        n8 -= 8388608, o8 <<= 1;
      return o8 &= -8388609, n8 += 947912704, o8 | n8;
    }, e8 = new Uint32Array(2048);
    e8[0] = 0;
    for (let t8 = 1; t8 < 1024; t8++)
      e8[t8] = r8(t8);
    for (let t8 = 1024; t8 < 2048; t8++)
      e8[t8] = 939524096 + (t8 - 1024 << 13);
    return e8;
  }
  function p4() {
    let r8 = new Uint32Array(64);
    r8[0] = 0, r8[31] = 1199570944, r8[32] = 2147483648, r8[63] = 3347054592;
    for (let e8 = 1; e8 < 31; e8++)
      r8[e8] = e8 << 23;
    for (let e8 = 33; e8 < 63; e8++)
      r8[e8] = 2147483648 + (e8 - 32 << 23);
    return r8;
  }
  function c4() {
    let r8 = new Uint32Array(64);
    for (let e8 = 0; e8 < 64; e8++)
      r8[e8] = 1024;
    return r8[0] = r8[32] = 0, r8;
  }
  function l4() {
    let r8 = u4(), e8 = p4(), t8 = c4();
    return (o8) => {
      let n8 = new ArrayBuffer(4 * o8.length), s = new Uint32Array(n8);
      for (let a = 0; a < o8.length; a++) {
        let i10 = o8[a], p = r8[t8[i10 >> 10] + (i10 & 1023)] + e8[i10 >> 10];
        s[a] = p;
      }
      return new Float32Array(n8);
    };
  }
  var ft = class {
    constructor() {
      this.saveRouters = [], this.loadRouters = [];
    }
    static getInstance() {
      return ft.instance == null && (ft.instance = new ft()), ft.instance;
    }
    static registerSaveRouter(e8) {
      ft.getInstance().saveRouters.push(e8);
    }
    static registerLoadRouter(e8) {
      ft.getInstance().loadRouters.push(e8);
    }
    static getSaveHandlers(e8) {
      return ft.getHandlers(e8, "save");
    }
    static getLoadHandlers(e8, t8) {
      return ft.getHandlers(e8, "load", t8);
    }
    static getHandlers(e8, t8, o8) {
      let n8 = [];
      return (t8 === "load" ? ft.getInstance().loadRouters : ft.getInstance().saveRouters).forEach((a) => {
        let i10 = a(e8, o8);
        i10 !== null && n8.push(i10);
      }), n8;
    }
  };
  var ek = (r8) => ft.registerSaveRouter(r8);
  var tk = (r8) => ft.registerLoadRouter(r8);
  var rk = (r8) => ft.getSaveHandlers(r8);
  var ok = (r8, e8) => ft.getLoadHandlers(r8, e8);
  var Sw = "tensorflowjs";
  var Iw = 1;
  var Bu = "models_store";
  var ou = "model_info_store";
  function nk() {
    if (!A().getBool("IS_BROWSER"))
      throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    let r8 = typeof window == "undefined" ? self : window, e8 = r8.indexedDB || r8.mozIndexedDB || r8.webkitIndexedDB || r8.msIndexedDB || r8.shimIndexedDB;
    if (e8 == null)
      throw new Error("The current browser does not appear to support IndexedDB.");
    return e8;
  }
  function vw(r8) {
    let e8 = r8.result;
    e8.createObjectStore(Bu, { keyPath: "modelPath" }), e8.createObjectStore(ou, { keyPath: "modelPath" });
  }
  var Sa = class {
    constructor(e8) {
      if (this.indexedDB = nk(), e8 == null || !e8)
        throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      this.modelPath = e8;
    }
    async save(e8) {
      if (e8.modelTopology instanceof ArrayBuffer)
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      return this.databaseAction(this.modelPath, e8);
    }
    async load() {
      return this.databaseAction(this.modelPath);
    }
    databaseAction(e8, t8) {
      return new Promise((o8, n8) => {
        let s = this.indexedDB.open(Sw, Iw);
        s.onupgradeneeded = () => vw(s), s.onsuccess = () => {
          let a = s.result;
          if (t8 == null) {
            let i10 = a.transaction(Bu, "readonly"), u = i10.objectStore(Bu).get(this.modelPath);
            u.onsuccess = () => {
              if (u.result == null)
                return a.close(), n8(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
              o8(u.result.modelArtifacts);
            }, u.onerror = (c) => (a.close(), n8(u.error)), i10.oncomplete = () => a.close();
          } else {
            t8.weightData = jt.join(t8.weightData);
            let i10 = wa(t8), p = a.transaction(ou, "readwrite"), u = p.objectStore(ou), c;
            try {
              c = u.put({ modelPath: this.modelPath, modelArtifactsInfo: i10 });
            } catch (m) {
              return n8(m);
            }
            let l;
            c.onsuccess = () => {
              l = a.transaction(Bu, "readwrite");
              let m = l.objectStore(Bu), d;
              try {
                d = m.put({ modelPath: this.modelPath, modelArtifacts: t8, modelArtifactsInfo: i10 });
              } catch (f) {
                return n8(f);
              }
              d.onsuccess = () => o8({ modelArtifactsInfo: i10 }), d.onerror = (f) => {
                u = p.objectStore(ou);
                let h = u.delete(this.modelPath);
                h.onsuccess = () => (a.close(), n8(d.error)), h.onerror = (g) => (a.close(), n8(d.error));
              };
            }, c.onerror = (m) => (a.close(), n8(c.error)), p.oncomplete = () => {
              l == null ? a.close() : l.oncomplete = () => a.close();
            };
          }
        }, s.onerror = (a) => n8(s.error);
      });
    }
  };
  Sa.URL_SCHEME = "indexeddb://";
  var sk = (r8) => A().getBool("IS_BROWSER") && !Array.isArray(r8) && r8.startsWith(Sa.URL_SCHEME) ? m4(r8.slice(Sa.URL_SCHEME.length)) : null;
  ft.registerSaveRouter(sk);
  ft.registerLoadRouter(sk);
  function m4(r8) {
    return new Sa(r8);
  }
  function d4(r8) {
    return r8.startsWith(Sa.URL_SCHEME) ? r8.slice(Sa.URL_SCHEME.length) : r8;
  }
  var id = class {
    constructor() {
      this.indexedDB = nk();
    }
    async listModels() {
      return new Promise((e8, t8) => {
        let o8 = this.indexedDB.open(Sw, Iw);
        o8.onupgradeneeded = () => vw(o8), o8.onsuccess = () => {
          let n8 = o8.result, s = n8.transaction(ou, "readonly"), i10 = s.objectStore(ou).getAll();
          i10.onsuccess = () => {
            let p = {};
            for (let u of i10.result)
              p[u.modelPath] = u.modelArtifactsInfo;
            e8(p);
          }, i10.onerror = (p) => (n8.close(), t8(i10.error)), s.oncomplete = () => n8.close();
        }, o8.onerror = (n8) => t8(o8.error);
      });
    }
    async removeModel(e8) {
      return e8 = d4(e8), new Promise((t8, o8) => {
        let n8 = this.indexedDB.open(Sw, Iw);
        n8.onupgradeneeded = () => vw(n8), n8.onsuccess = () => {
          let s = n8.result, a = s.transaction(ou, "readwrite"), i10 = a.objectStore(ou), p = i10.get(e8), u;
          p.onsuccess = () => {
            if (p.result == null)
              return s.close(), o8(new Error(`Cannot find model with path '${e8}' in IndexedDB.`));
            {
              let c = i10.delete(e8), l = () => {
                u = s.transaction(Bu, "readwrite");
                let d = u.objectStore(Bu).delete(e8);
                d.onsuccess = () => t8(p.result.modelArtifactsInfo), d.onerror = (f) => o8(p.error);
              };
              c.onsuccess = l, c.onerror = (m) => (l(), s.close(), o8(p.error));
            }
          }, p.onerror = (c) => (s.close(), o8(p.error)), a.oncomplete = () => {
            u == null ? s.close() : u.oncomplete = () => s.close();
          };
        }, n8.onerror = (s) => o8(n8.error);
      });
    }
  };
  var oi = "/";
  var nc = "tensorflowjs_models";
  var ak = "info";
  var f4 = "model_topology";
  var h4 = "weight_specs";
  var g4 = "weight_data";
  var x4 = "model_metadata";
  function ik(r8) {
    return { info: [nc, r8, ak].join(oi), topology: [nc, r8, f4].join(oi), weightSpecs: [nc, r8, h4].join(oi), weightData: [nc, r8, g4].join(oi), modelMetadata: [nc, r8, x4].join(oi) };
  }
  function uk(r8) {
    for (let e8 of Object.values(r8))
      window.localStorage.removeItem(e8);
  }
  function y4(r8) {
    let e8 = r8.split(oi);
    if (e8.length < 3)
      throw new Error(`Invalid key format: ${r8}`);
    return e8.slice(1, e8.length - 1).join(oi);
  }
  function b4(r8) {
    return r8.startsWith(Ia.URL_SCHEME) ? r8.slice(Ia.URL_SCHEME.length) : r8;
  }
  var Ia = class {
    constructor(e8) {
      if (!A().getBool("IS_BROWSER") || typeof window == "undefined" || typeof window.localStorage == "undefined")
        throw new Error("The current environment does not support local storage.");
      if (this.LS = window.localStorage, e8 == null || !e8)
        throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      this.modelPath = e8, this.keys = ik(this.modelPath);
    }
    async save(e8) {
      if (e8.modelTopology instanceof ArrayBuffer)
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      {
        let t8 = JSON.stringify(e8.modelTopology), o8 = JSON.stringify(e8.weightSpecs), n8 = wa(e8), s = jt.join(e8.weightData);
        try {
          this.LS.setItem(this.keys.info, JSON.stringify(n8)), this.LS.setItem(this.keys.topology, t8), this.LS.setItem(this.keys.weightSpecs, o8), this.LS.setItem(this.keys.weightData, Q0(s));
          let a = { format: e8.format, generatedBy: e8.generatedBy, convertedBy: e8.convertedBy, signature: e8.signature != null ? e8.signature : void 0, userDefinedMetadata: e8.userDefinedMetadata != null ? e8.userDefinedMetadata : void 0, modelInitializer: e8.modelInitializer != null ? e8.modelInitializer : void 0, initializerSignature: e8.initializerSignature != null ? e8.initializerSignature : void 0, trainingConfig: e8.trainingConfig != null ? e8.trainingConfig : void 0 };
          return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(a)), { modelArtifactsInfo: n8 };
        } catch (a) {
          throw uk(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${n8.modelTopologyBytes}, weightSpecsBytes=${n8.weightSpecsBytes}, weightDataBytes=${n8.weightDataBytes}.`);
        }
      }
    }
    async load() {
      let e8 = JSON.parse(this.LS.getItem(this.keys.info));
      if (e8 == null)
        throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
      if (e8.modelTopologyType !== "JSON")
        throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      let t8 = {}, o8 = JSON.parse(this.LS.getItem(this.keys.topology));
      if (o8 == null)
        throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      t8.modelTopology = o8;
      let n8 = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (n8 == null)
        throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      t8.weightSpecs = n8;
      let s = this.LS.getItem(this.keys.modelMetadata);
      if (s != null) {
        let i10 = JSON.parse(s);
        t8.format = i10.format, t8.generatedBy = i10.generatedBy, t8.convertedBy = i10.convertedBy, i10.signature != null && (t8.signature = i10.signature), i10.userDefinedMetadata != null && (t8.userDefinedMetadata = i10.userDefinedMetadata), i10.modelInitializer != null && (t8.modelInitializer = i10.modelInitializer), i10.initializerSignature != null && (t8.initializerSignature = i10.initializerSignature), i10.trainingConfig != null && (t8.trainingConfig = i10.trainingConfig);
      }
      let a = this.LS.getItem(this.keys.weightData);
      if (a == null)
        throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      return t8.weightData = Z0(a), t8;
    }
  };
  Ia.URL_SCHEME = "localstorage://";
  var pk = (r8) => A().getBool("IS_BROWSER") && !Array.isArray(r8) && r8.startsWith(Ia.URL_SCHEME) ? C4(r8.slice(Ia.URL_SCHEME.length)) : null;
  ft.registerSaveRouter(pk);
  ft.registerLoadRouter(pk);
  function C4(r8) {
    return new Ia(r8);
  }
  var ud = class {
    constructor() {
      $(A().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), $(typeof window == "undefined" || typeof window.localStorage != "undefined", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
    }
    async listModels() {
      let e8 = {}, t8 = nc + oi, o8 = oi + ak;
      for (let n8 = 0; n8 < this.LS.length; ++n8) {
        let s = this.LS.key(n8);
        if (s.startsWith(t8) && s.endsWith(o8)) {
          let a = y4(s);
          e8[a] = JSON.parse(this.LS.getItem(s));
        }
      }
      return e8;
    }
    async removeModel(e8) {
      e8 = b4(e8);
      let t8 = ik(e8);
      if (this.LS.getItem(t8.info) == null)
        throw new Error(`Cannot find model at path '${e8}'`);
      let o8 = JSON.parse(this.LS.getItem(t8.info));
      return uk(t8), o8;
    }
  };
  var sc = "://";
  var Zt = class {
    constructor() {
      this.managers = {};
    }
    static getInstance() {
      return Zt.instance == null && (Zt.instance = new Zt()), Zt.instance;
    }
    static registerManager(e8, t8) {
      $(e8 != null, () => "scheme must not be undefined or null."), e8.endsWith(sc) && (e8 = e8.slice(0, e8.indexOf(sc))), $(e8.length > 0, () => "scheme must not be an empty string.");
      let o8 = Zt.getInstance();
      $(o8.managers[e8] == null, () => `A model store manager is already registered for scheme '${e8}'.`), o8.managers[e8] = t8;
    }
    static getManager(e8) {
      let t8 = Zt.getInstance().managers[e8];
      if (t8 == null)
        throw new Error(`Cannot find model manager for scheme '${e8}'`);
      return t8;
    }
    static getSchemes() {
      return Object.keys(Zt.getInstance().managers);
    }
  };
  function pd(r8) {
    if (r8.indexOf(sc) === -1)
      throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Zt.getSchemes().join(",")}`);
    return { scheme: r8.split(sc)[0], path: r8.split(sc)[1] };
  }
  async function ck(r8, e8, t8 = false) {
    $(r8 !== e8, () => `Old path and new path are the same: '${r8}'`);
    let o8 = ft.getLoadHandlers(r8);
    $(o8.length > 0, () => `Copying failed because no load handler is found for source URL ${r8}.`), $(o8.length < 2, () => `Copying failed because more than one (${o8.length}) load handlers for source URL ${r8}.`);
    let n8 = o8[0], s = ft.getSaveHandlers(e8);
    $(s.length > 0, () => `Copying failed because no save handler is found for destination URL ${e8}.`), $(s.length < 2, () => `Copying failed because more than one (${o8.length}) save handlers for destination URL ${e8}.`);
    let a = s[0], i10 = pd(r8).scheme, p = pd(r8).path, u = i10 === pd(r8).scheme, c = await n8.load();
    t8 && u && await Zt.getManager(i10).removeModel(p);
    let l = await a.save(c);
    return t8 && !u && await Zt.getManager(i10).removeModel(p), l.modelArtifactsInfo;
  }
  async function lk() {
    let r8 = Zt.getSchemes(), e8 = {};
    for (let t8 of r8) {
      let o8 = await Zt.getManager(t8).listModels();
      for (let n8 in o8) {
        let s = t8 + sc + n8;
        e8[s] = o8[n8];
      }
    }
    return e8;
  }
  async function mk(r8) {
    let e8 = pd(r8);
    return Zt.getManager(e8.scheme).removeModel(e8.path);
  }
  async function dk(r8, e8) {
    return ck(r8, e8, false);
  }
  async function fk(r8, e8) {
    return ck(r8, e8, true);
  }
  var kw = class {
    constructor() {
      this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = false;
    }
    fetch(e8, t8) {
      return fetch(e8, t8);
    }
    now() {
      return performance.now();
    }
    encode(e8, t8) {
      if (t8 !== "utf-8" && t8 !== "utf8")
        throw new Error(`Browser's encoder only supports utf-8, but got ${t8}`);
      return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e8);
    }
    decode(e8, t8) {
      return new TextDecoder(t8).decode(e8);
    }
    setTimeoutCustom(e8, t8) {
      if (typeof window == "undefined" || !A().getBool("USE_SETTIMEOUTCUSTOM")) {
        setTimeout(e8, t8);
        return;
      }
      this.functionRefs.push(e8), setTimeout(() => {
        window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
      }, t8), this.hasEventListener || (this.hasEventListener = true, window.addEventListener("message", (o8) => {
        if (o8.source === window && o8.data.name === this.messageName) {
          o8.stopPropagation();
          let n8 = this.functionRefs[o8.data.index];
          n8(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0);
        }
      }, true));
    }
    isTypedArray(e8) {
      return Xm(e8);
    }
  };
  if (A().get("IS_BROWSER")) {
    A().setPlatform("browser", new kw());
    try {
      Zt.registerManager(Ia.URL_SCHEME, new ud());
    } catch (r8) {
    }
    try {
      Zt.registerManager(Sa.URL_SCHEME, new id());
    } catch (r8) {
    }
  }
  var w4 = { importFetch: () => hk() };
  var Nw;
  var Tw = class {
    constructor() {
      this.util = gk(), this.textEncoder = new this.util.TextEncoder();
    }
    fetch(e8, t8) {
      return A().global.fetch != null ? A().global.fetch(e8, t8) : (Nw == null && (Nw = w4.importFetch()), Nw(e8, t8));
    }
    now() {
      let e8 = process$1.hrtime();
      return e8[0] * 1e3 + e8[1] / 1e6;
    }
    encode(e8, t8) {
      if (t8 !== "utf-8" && t8 !== "utf8")
        throw new Error(`Node built-in encoder only supports utf-8, but got ${t8}`);
      return this.textEncoder.encode(e8);
    }
    decode(e8, t8) {
      return e8.length === 0 ? "" : new this.util.TextDecoder(t8).decode(e8);
    }
    isTypedArray(e8) {
      return this.util.types.isFloat32Array(e8) || this.util.types.isInt32Array(e8) || this.util.types.isUint8Array(e8) || this.util.types.isUint8ClampedArray(e8);
    }
  };
  A().get("IS_NODE") && !A().get("IS_BROWSER") && A().setPlatform("node", new Tw());
  function me(r8, e8 = "float32", t8) {
    return e8 = e8 || "float32", wt(r8), new tt(r8, e8, t8);
  }
  function S4(r8, e8) {
    let t8 = v(r8, "x", "cast");
    if (!XC(e8))
      throw new Error(`Failed to cast to unknown dtype ${e8}`);
    if (e8 === "string" && t8.dtype !== "string" || e8 !== "string" && t8.dtype === "string")
      throw new Error("Only strings can be casted to strings");
    let o8 = { x: t8 }, n8 = { dtype: e8 };
    return T.runKernel(yo, o8, n8);
  }
  var qe = N({ cast_: S4 });
  function I4(r8) {
    let t8 = { x: v(r8, "x", "clone", "string_or_numeric") };
    return T.runKernel(Co, t8);
  }
  var Ur = N({ clone_: I4 });
  function cd(r8, e8 = false) {
    console.log(r8.toString(e8));
  }
  hw();
  var v4 = { buffer: me, cast: qe, clone: Ur, print: cd };
  U0(v4);
  function ede() {
    A().set("PROD", true);
  }
  function tde() {
    A().set("DEBUG", true);
  }
  function rde() {
    A().set("DEPRECATION_WARNINGS_ENABLED", false), console.warn("TensorFlow.js deprecation warnings have been disabled.");
  }
  function _w(r8) {
    A().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(r8 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
  }
  function ode() {
    T.disposeVariables();
  }
  function ur() {
    return T;
  }
  function nde() {
    return T.memory();
  }
  function sde(r8) {
    return T.profile(r8);
  }
  function De(r8, e8) {
    return T.tidy(r8, e8);
  }
  function Ot(r8) {
    bl(r8).forEach((t8) => t8.dispose());
  }
  function Rr(r8) {
    return T.keep(r8);
  }
  function ade(r8) {
    return T.time(r8);
  }
  function ide(r8) {
    return T.setBackend(r8);
  }
  function ude() {
    return T.ready();
  }
  function pde() {
    return T.backendName;
  }
  function cde(r8) {
    T.removeBackend(r8);
  }
  function lde(r8) {
    return T.findBackend(r8);
  }
  function mde(r8) {
    return T.findBackendFactory(r8);
  }
  function nu(r8, e8, t8 = 1) {
    return T.registerBackend(r8, e8, t8);
  }
  function dde() {
    return T.backend;
  }
  function fde(r8, e8) {
    A().setPlatform(r8, e8);
  }
  function k4(r8, e8) {
    let t8 = v(r8, "a", "add"), o8 = v(e8, "b", "add");
    [t8, o8] = Oe(t8, o8);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(io, n8);
  }
  var Ce = N({ add_: k4 });
  function N4(r8, e8) {
    let t8 = v(r8, "a", "floorDiv"), o8 = v(e8, "b", "floorDiv");
    [t8, o8] = Oe(t8, o8);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Sn, n8);
  }
  var ld = N({ floorDiv_: N4 });
  function T4(r8, e8) {
    let t8 = v(r8, "a", "div"), o8 = v(e8, "b", "div");
    if ([t8, o8] = Oe(t8, o8), t8.dtype === "int32" && o8.dtype === "int32")
      return ld(t8, o8);
    let n8 = { a: t8, b: o8 }, s = {};
    return T.runKernel(fn, n8, s);
  }
  var je = N({ div_: T4 });
  function _4(r8, e8) {
    let t8 = v(r8, "a", "mul"), o8 = v(e8, "b", "mul");
    [t8, o8] = Oe(t8, o8);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Xn, n8);
  }
  var se = N({ mul_: _4 });
  function $4(r8) {
    let e8 = v(r8, "x", "abs");
    if (e8.dtype === "complex64") {
      let t8 = { x: e8 };
      return T.runKernel(Di, t8);
    } else {
      let t8 = { x: e8 };
      return T.runKernel(js, t8);
    }
  }
  var Jt = N({ abs_: $4 });
  function E4(r8) {
    let t8 = { x: v(r8, "x", "acos") };
    return T.runKernel(Vo, t8);
  }
  var xk = N({ acos_: E4 });
  function R4(r8) {
    let t8 = { x: v(r8, "x", "acosh") };
    return T.runKernel(Wo, t8);
  }
  var yk = N({ acosh_: R4 });
  function D4(r8) {
    $(Array.isArray(r8), () => "The argument passed to tf.addN() must be a list of tensors"), $(r8.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${r8.length}`);
    let e8 = r8.map((n8, s) => v(n8, `tensors${s}`, "addN")), t8 = e8[0];
    e8.forEach((n8) => {
      if (n8.dtype !== t8.dtype)
        throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }), e8.forEach((n8) => {
      if (!Cr(n8.shape, t8.shape))
        throw new Error("All tensors passed to tf.addN() must have the same shape");
    });
    let o8 = e8;
    return T.runKernel(Uo, o8);
  }
  var bk = N({ addN_: D4 });
  function A4(r8, e8 = null, t8 = false) {
    let n8 = { x: v(r8, "x", "all", "bool") }, s = { axis: e8, keepDims: t8 };
    return T.runKernel(Go, n8, s);
  }
  var Ck = N({ all_: A4 });
  function F4(r8, e8 = null, t8 = false) {
    let n8 = { x: v(r8, "x", "any", "bool") }, s = { axis: e8, keepDims: t8 };
    return T.runKernel(Ho, n8, s);
  }
  var wk = N({ any_: F4 });
  function P4(r8, e8 = 0) {
    let o8 = { x: v(r8, "x", "argMax") }, n8 = { axis: e8 };
    return T.runKernel(Xs, o8, n8);
  }
  var Sk = N({ argMax_: P4 });
  function O4(r8, e8 = 0) {
    let o8 = { x: v(r8, "x", "argMin") }, n8 = { axis: e8 };
    return T.runKernel(Ys, o8, n8);
  }
  var Ik = N({ argMin_: O4 });
  function M4(r8) {
    let t8 = { x: v(r8, "x", "asin") };
    return T.runKernel(Ko, t8);
  }
  var vk = N({ asin_: M4 });
  function L4(r8) {
    let t8 = { x: v(r8, "x", "asinh") };
    return T.runKernel(qo, t8);
  }
  var kk = N({ asinh_: L4 });
  function B4(r8) {
    let t8 = { x: v(r8, "x", "atan") };
    return T.runKernel(jo, t8);
  }
  var Nk = N({ atan_: B4 });
  function z4(r8, e8) {
    let t8 = v(r8, "a", "atan2"), o8 = v(e8, "b", "atan2");
    [t8, o8] = Oe(t8, o8);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Yo, n8);
  }
  var Tk = N({ atan2_: z4 });
  function V4(r8) {
    let t8 = { x: v(r8, "x", "atanh") };
    return T.runKernel(Xo, t8);
  }
  var _k = N({ atanh_: V4 });
  function W4(r8, e8, t8, o8, n8 = "NHWC", s) {
    let a = r8[3], i10 = [...e8, a], p = Ek(n8);
    return Vu(r8, i10, t8, s, o8, null, null, p);
  }
  function Ew(r8, e8, t8, o8, n8, s, a = "channelsLast") {
    let [i10, p] = wl(e8), u;
    if (a === "channelsLast")
      u = [i10, p, r8[3], r8[3]];
    else if (a === "channelsFirst")
      u = [i10, p, r8[1], r8[1]];
    else
      throw new Error(`Unknown dataFormat ${a}`);
    return Vu(r8, u, t8, o8, n8, s, false, a);
  }
  function U4(r8, e8, t8, o8, n8, s, a = "NDHWC") {
    let [i10, p, u] = $w(e8), c, l;
    if (a === "NDHWC")
      l = "channelsLast", c = [i10, p, u, r8[4], r8[4]];
    else if (a === "NCDHW")
      l = "channelsFirst", c = [i10, p, u, r8[1], r8[1]];
    else
      throw new Error(`Unknown dataFormat ${a}`);
    return $k(r8, c, t8, o8, n8, false, l, s);
  }
  function Vu(r8, e8, t8, o8, n8, s, a = false, i10 = "channelsLast") {
    let [p, u, c, l] = [-1, -1, -1, -1];
    if (i10 === "channelsLast")
      [p, u, c, l] = r8;
    else if (i10 === "channelsFirst")
      [p, l, u, c] = r8;
    else
      throw new Error(`Unknown dataFormat ${i10}`);
    let [m, d, , f] = e8, [h, g] = wl(t8), [x, b] = wl(o8), C = ac(m, x), S = ac(d, b), { padInfo: k, outHeight: _, outWidth: E } = K4(n8, u, c, h, g, C, S, s, i10), R = a ? f * l : f, D;
    return i10 === "channelsFirst" ? D = [p, R, _, E] : i10 === "channelsLast" && (D = [p, _, E, R]), { batchSize: p, dataFormat: i10, inHeight: u, inWidth: c, inChannels: l, outHeight: _, outWidth: E, outChannels: R, padInfo: k, strideHeight: h, strideWidth: g, filterHeight: m, filterWidth: d, effectiveFilterHeight: C, effectiveFilterWidth: S, dilationHeight: x, dilationWidth: b, inShape: r8, outShape: D, filterShape: e8 };
  }
  function $k(r8, e8, t8, o8, n8, s = false, a = "channelsLast", i10) {
    let [p, u, c, l, m] = [-1, -1, -1, -1, -1];
    if (a === "channelsLast")
      [p, u, c, l, m] = r8;
    else if (a === "channelsFirst")
      [p, m, u, c, l] = r8;
    else
      throw new Error(`Unknown dataFormat ${a}`);
    let [d, f, h, , g] = e8, [x, b, C] = $w(t8), [S, k, _] = $w(o8), E = ac(d, S), R = ac(f, k), D = ac(h, _), { padInfo: P, outDepth: O, outHeight: M, outWidth: L } = q4(n8, u, c, l, x, b, C, E, R, D, i10), B = s ? g * m : g, z;
    return a === "channelsFirst" ? z = [p, B, O, M, L] : a === "channelsLast" && (z = [p, O, M, L, B]), { batchSize: p, dataFormat: a, inDepth: u, inHeight: c, inWidth: l, inChannels: m, outDepth: O, outHeight: M, outWidth: L, outChannels: B, padInfo: P, strideDepth: x, strideHeight: b, strideWidth: C, filterDepth: d, filterHeight: f, filterWidth: h, effectiveFilterDepth: E, effectiveFilterHeight: R, effectiveFilterWidth: D, dilationDepth: S, dilationHeight: k, dilationWidth: _, inShape: r8, outShape: z, filterShape: e8 };
  }
  function G4(r8, e8, t8, o8, n8) {
    o8 == null && (o8 = Rw(r8, e8, t8));
    let s = r8[0], a = r8[1], i10 = Sl((s - e8 + 2 * o8) / t8 + 1, n8), p = Sl((a - e8 + 2 * o8) / t8 + 1, n8);
    return [i10, p];
  }
  function H4(r8, e8, t8, o8, n8, s) {
    n8 == null && (n8 = Rw(r8, e8[0], o8[0]));
    let a = [0, 0, 0, t8];
    for (let i10 = 0; i10 < 3; i10++)
      r8[i10] + 2 * n8 >= e8[i10] && (a[i10] = Sl((r8[i10] - e8[i10] + 2 * n8) / o8[i10] + 1, s));
    return a;
  }
  function Rw(r8, e8, t8, o8 = 1) {
    let n8 = ac(e8, o8);
    return Math.floor((r8[0] * (t8 - 1) - t8 + n8) / 2);
  }
  function wl(r8) {
    return typeof r8 == "number" ? [r8, r8, r8] : r8.length === 2 ? [r8[0], r8[1], 1] : r8;
  }
  function $w(r8) {
    return typeof r8 == "number" ? [r8, r8, r8] : r8;
  }
  function ac(r8, e8) {
    return e8 <= 1 ? r8 : r8 + (r8 - 1) * (e8 - 1);
  }
  function K4(r8, e8, t8, o8, n8, s, a, i10, p) {
    let u, c, l;
    if (typeof r8 == "number") {
      u = { top: r8, bottom: r8, left: r8, right: r8, type: r8 === 0 ? "VALID" : "NUMBER" };
      let d = G4([e8, t8], s, o8, r8, i10);
      c = d[0], l = d[1];
    } else if (r8 === "same") {
      c = Math.ceil(e8 / o8), l = Math.ceil(t8 / n8);
      let m = Math.max(0, (c - 1) * o8 + s - e8), d = Math.max(0, (l - 1) * n8 + a - t8), f = Math.floor(m / 2), h = m - f, g = Math.floor(d / 2), x = d - g;
      u = { top: f, bottom: h, left: g, right: x, type: "SAME" };
    } else if (r8 === "valid")
      u = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, c = Math.ceil((e8 - s + 1) / o8), l = Math.ceil((t8 - a + 1) / n8);
    else if (typeof r8 == "object") {
      let m = p === "channelsLast" ? r8[1][0] : r8[2][0], d = p === "channelsLast" ? r8[1][1] : r8[2][1], f = p === "channelsLast" ? r8[2][0] : r8[3][0], h = p === "channelsLast" ? r8[2][1] : r8[3][1];
      u = { top: m, bottom: d, left: f, right: h, type: m === 0 && d === 0 && f === 0 && h === 0 ? "VALID" : "EXPLICIT" }, c = Sl((e8 - s + m + d) / o8 + 1, i10), l = Sl((t8 - a + f + h) / n8 + 1, i10);
    } else
      throw Error(`Unknown padding parameter: ${r8}`);
    return { padInfo: u, outHeight: c, outWidth: l };
  }
  function q4(r8, e8, t8, o8, n8, s, a, i10, p, u, c) {
    let l, m, d, f;
    if (r8 === "valid" && (r8 = 0), typeof r8 == "number") {
      l = { top: r8, bottom: r8, left: r8, right: r8, front: r8, back: r8, type: r8 === 0 ? "VALID" : "NUMBER" };
      let g = H4([e8, t8, o8, 1], [i10, p, u], 1, [n8, s, a], r8, c);
      m = g[0], d = g[1], f = g[2];
    } else if (r8 === "same") {
      m = Math.ceil(e8 / n8), d = Math.ceil(t8 / s), f = Math.ceil(o8 / a);
      let h = (m - 1) * n8 + i10 - e8, g = (d - 1) * s + p - t8, x = (f - 1) * a + u - o8, b = Math.floor(h / 2), C = h - b, S = Math.floor(g / 2), k = g - S, _ = Math.floor(x / 2), E = x - _;
      l = { top: S, bottom: k, left: _, right: E, front: b, back: C, type: "SAME" };
    } else
      throw Error(`Unknown padding parameter: ${r8}`);
    return { padInfo: l, outDepth: m, outHeight: d, outWidth: f };
  }
  function Sl(r8, e8) {
    if (!e8)
      return Math.trunc(r8);
    switch (e8) {
      case "round":
        return Math.round(r8);
      case "ceil":
        return Math.ceil(r8);
      case "floor":
        return Math.floor(r8);
      default:
        throw new Error(`Unknown roundingMode ${e8}`);
    }
  }
  function zu(r8) {
    let [e8, t8, o8] = wl(r8);
    return e8 === 1 && t8 === 1 && o8 === 1;
  }
  function gr(r8, e8) {
    return zu(r8) || zu(e8);
  }
  function va(r8) {
    return wl(r8).every((e8) => e8 > 0);
  }
  function Ek(r8) {
    if (r8 === "NHWC")
      return "channelsLast";
    if (r8 === "NCHW")
      return "channelsFirst";
    throw new Error(`Unknown dataFormat ${r8}`);
  }
  function Lt(r8, e8, t8) {
    if (t8 != null) {
      if (typeof e8 == "string")
        throw Error(`Error in ${r8}: pad must be an integer when using dimRoundingMode ${t8} but got pad ${e8}.`);
      if (typeof e8 == "number")
        $(Ga(e8), () => `Error in ${r8}: pad must be an integer when using dimRoundingMode ${t8} but got pad ${e8}.`);
      else if (typeof e8 == "object")
        e8.forEach((o8) => {
          o8.forEach((n8) => {
            $(Ga(n8), () => `Error in ${r8}: pad must be an integer when using dimRoundingMode ${t8} but got pad ${n8}.`);
          });
        });
      else
        throw Error(`Error in ${r8}: Unknown padding parameter: ${e8}`);
    }
  }
  function j4(r8, e8) {
    let o8 = { x: v(r8, "x", "reshape", "string_or_numeric") }, n8 = { shape: e8 };
    return T.runKernel(ma, o8, n8);
  }
  var W = N({ reshape_: j4 });
  function X4(r8, e8, t8, o8, n8) {
    let s = v(r8, "x", "avgPool", "float32"), a = 1;
    $(gr(t8, a), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${t8} and dilations '${a}'`);
    let i10 = s, p = false;
    s.rank === 3 && (p = true, i10 = W(s, [1, s.shape[0], s.shape[1], s.shape[2]])), $(i10.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${i10.rank}.`), Lt("avgPool", o8, n8);
    let u = { x: i10 }, c = { filterSize: e8, strides: t8, pad: o8, dimRoundingMode: n8 }, l = T.runKernel(Qo, u, c);
    return l = qe(l, s.dtype), p ? W(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
  }
  var md = N({ avgPool_: X4 });
  function Y4(r8, e8, t8, o8, n8, s = "NDHWC") {
    let a = v(r8, "x", "avgPool3d", "float32"), i10 = a, p = false;
    a.rank === 4 && (p = true, i10 = W(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]])), $(i10.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${i10.rank}.`), $(s === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`), $(typeof t8 == "number" && t8 > 0 || Array.isArray(t8) && t8[0] > 0 && t8[1] > 0 && t8[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${t8}'`), Lt("avgPool3d", o8, n8);
    let u = { x: i10 }, c = { filterSize: e8, strides: t8, pad: o8, dimRoundingMode: n8, dataFormat: s }, l = T.runKernel(Qs, u, c);
    return l = qe(l, i10.dtype), p ? W(l, [l.shape[1], l.shape[2], l.shape[3], l.shape[4]]) : l;
  }
  var Rk = N({ avgPool3d_: Y4 });
  function Q4(r8, e8 = 0) {
    $(r8.length >= 1, () => "Pass at least one tensor to concat");
    let t8 = ri(r8, "tensors", "concat", "string_or_numeric");
    if (t8[0].dtype === "complex64" && t8.forEach((s) => {
      if (s.dtype !== "complex64")
        throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `);
    }), t8.length === 1)
      return Ur(t8[0]);
    let o8 = t8, n8 = { axis: e8 };
    return T.runKernel(ea, o8, n8);
  }
  var bt = N({ concat_: Q4 });
  function Z4(r8, e8, t8 = false, o8 = false) {
    let n8 = v(r8, "a", "matMul"), s = v(e8, "b", "matMul");
    [n8, s] = Oe(n8, s);
    let a = { a: n8, b: s }, i10 = { transposeA: t8, transposeB: o8 };
    return T.runKernel(Zo, a, i10);
  }
  var Ze = N({ matMul_: Z4 });
  function J4(r8) {
    let t8 = { x: v(r8, "x", "sigmoid", "float32") };
    return T.runKernel(bs, t8);
  }
  var Na = N({ sigmoid_: J4 });
  function eH(r8, e8, t8) {
    let o8 = v(r8, "x", "slice", "string_or_numeric");
    if (o8.rank === 0)
      throw new Error("Slicing scalar is not possible");
    let n8 = { x: o8 }, s = { begin: e8, size: t8 };
    return T.runKernel(fa, n8, s);
  }
  var Xe = N({ slice_: eH });
  function tH(r8) {
    let t8 = { x: v(r8, "x", "tanh", "float32") };
    return T.runKernel($s, t8);
  }
  var Il = N({ tanh_: tH });
  function rH(r8, e8, t8, o8, n8, s) {
    let a = v(r8, "forgetBias", "basicLSTMCell"), i10 = v(e8, "lstmKernel", "basicLSTMCell"), p = v(t8, "lstmBias", "basicLSTMCell"), u = v(o8, "data", "basicLSTMCell"), c = v(n8, "c", "basicLSTMCell"), l = v(s, "h", "basicLSTMCell"), m = bt([u, l], 1), d = Ze(m, i10), f = Ce(d, p), h = f.shape[0], g = f.shape[1] / 4, x = [h, g], b = Xe(f, [0, 0], x), C = Xe(f, [0, g], x), S = Xe(f, [0, g * 2], x), k = Xe(f, [0, g * 3], x), _ = Ce(se(Na(b), Il(C)), se(c, Na(Ce(a, S)))), E = se(Il(_), Na(k));
    return [_, E];
  }
  var Dk = N({ basicLSTMCell_: rH });
  function oH(r8, e8, t8) {
    let o8 = v(r8, "x", "batchToSpaceND"), n8 = e8.reduce((i10, p) => i10 * p);
    $(o8.rank >= 1 + e8.length, () => `input rank is ${o8.rank} but should be > than blockShape.length ${e8.length}`), $(t8.length === e8.length, () => `crops.length is ${t8.length} but should be equal to blockShape.length  ${e8.length}`), $(o8.shape[0] % n8 === 0, () => `input tensor batch is ${o8.shape[0]} but is not divisible by the product of the elements of blockShape ${e8.join(" * ")} === ${n8}`);
    let s = { x: o8 }, a = { blockShape: e8, crops: t8 };
    return T.runKernel(Zs, s, a);
  }
  var dd = N({ batchToSpaceND_: oH });
  function Ak(r8) {
    let e8;
    return r8.rank === 0 || r8.rank === 1 ? e8 = W(r8, [1, 1, 1, r8.size]) : r8.rank === 2 ? e8 = W(r8, [1, 1, r8.shape[0], r8.shape[1]]) : r8.rank === 3 ? e8 = W(r8, [1, r8.shape[0], r8.shape[1], r8.shape[2]]) : e8 = r8, e8;
  }
  function nH(r8, e8, t8, o8, n8, s) {
    s == null && (s = 1e-3);
    let a = v(r8, "x", "batchNorm"), i10 = v(e8, "mean", "batchNorm"), p = v(t8, "variance", "batchNorm"), u;
    n8 != null && (u = v(n8, "scale", "batchNorm"));
    let c;
    o8 != null && (c = v(o8, "offset", "batchNorm")), $(i10.rank === p.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), $(c == null || i10.rank === c.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), $(u == null || i10.rank === u.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let m = { x: Ak(a), scale: u, offset: c, mean: i10, variance: p }, d = { varianceEpsilon: s }, f = T.runKernel(In, m, d);
    return W(f, a.shape);
  }
  var su = N({ batchNorm_: nH });
  function sH(r8, e8, t8, o8, n8, s) {
    let a = v(r8, "x", "batchNorm"), i10 = v(e8, "mean", "batchNorm"), p = v(t8, "variance", "batchNorm"), u;
    n8 != null && (u = v(n8, "scale", "batchNorm"));
    let c;
    return o8 != null && (c = v(o8, "offset", "batchNorm")), $(a.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`), $(i10.rank === 2 || i10.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i10.rank}.`), $(p.rank === 2 || p.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${p.rank}.`), u != null && $(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`), c != null && $(c.rank === 2 || c.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`), su(a, i10, p, c, u, s);
  }
  var Fk = N({ batchNorm2d_: sH });
  function aH(r8, e8, t8, o8, n8, s) {
    let a = v(r8, "x", "batchNorm"), i10 = v(e8, "mean", "batchNorm"), p = v(t8, "variance", "batchNorm"), u;
    n8 != null && (u = v(n8, "scale", "batchNorm"));
    let c;
    return o8 != null && (c = v(o8, "offset", "batchNorm")), $(a.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`), $(i10.rank === 3 || i10.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i10.rank}.`), $(p.rank === 3 || p.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${p.rank}.`), u != null && $(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`), c != null && $(c.rank === 3 || c.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`), su(a, i10, p, c, u, s);
  }
  var Pk = N({ batchNorm3d_: aH });
  function iH(r8, e8, t8, o8, n8, s) {
    let a = v(r8, "x", "batchNorm"), i10 = v(e8, "mean", "batchNorm"), p = v(t8, "variance", "batchNorm"), u;
    n8 != null && (u = v(n8, "scale", "batchNorm"));
    let c;
    return o8 != null && (c = v(o8, "offset", "batchNorm")), $(a.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`), $(i10.rank === 4 || i10.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i10.rank}.`), $(p.rank === 4 || p.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${p.rank}.`), u != null && $(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`), c != null && $(c.rank === 4 || c.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`), su(a, i10, p, c, u, s);
  }
  var Ok = N({ batchNorm4d_: iH });
  function uH(r8, e8, t8) {
    let o8 = v(r8, "x", "bincount"), n8 = v(e8, "weights", "bincount");
    $(o8.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${o8.dtype}`), $(t8 >= 0, () => `size must be non-negative, but got ${t8}.`), $(n8.size === o8.size || n8.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${o8.shape}, weights shape: ${n8.shape}.`);
    let s = { x: o8, weights: n8 }, a = { size: t8 };
    return T.runKernel(Jo, s, a);
  }
  var fd = N({ bincount_: uH });
  function pH(r8, e8) {
    let t8 = v(r8, "x", "bitwiseAnd"), o8 = v(e8, "y", "bitwiseAnd");
    if (!Cr(t8.shape, o8.shape))
      throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t8.shape}, y: ${o8.shape}`);
    if (t8.dtype !== "int32" || o8.dtype !== "int32")
      throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t8.dtype} and type of y: ${o8.dtype}`);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Ha, n8);
  }
  var Mk = N({ bitwiseAnd_: pH });
  function cH(r8, e8) {
    let t8 = v(r8, "s0", "broadcastArgs", "int32"), o8 = v(e8, "s1", "broadcastArgs", "int32");
    if (t8.rank !== 1)
      throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t8.rank}`);
    if (o8.rank !== 1)
      throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${o8.rank}`);
    let n8 = { s0: t8, s1: o8 };
    return T.runKernel(Js, n8);
  }
  var Lk = N({ broadcastArgs_: cH });
  function lH(r8, e8) {
    let t8 = v(r8, "broadcastTo", "x"), o8 = t8.shape;
    if (wt(e8), e8.length < t8.rank)
      throw new Error(`broadcastTo(): shape.length=${e8.length} < input.rank=${t8.rank}.`);
    if (e8.length > t8.rank) {
      let u = t8.shape.slice();
      for (; u.length < e8.length; )
        u.unshift(1);
      t8 = W(t8, u);
    }
    let n8 = t8.shape, s = Array.from(e8);
    for (let u = e8.length - 1; u >= 0; u--)
      if (n8[u] === e8[u])
        s[u] = 1;
      else if (t8.shape[u] !== 1)
        throw new Error(`broadcastTo(): [${o8}] cannot be broadcast to [${e8}].`);
    if (s.map((u, c) => u > 1 ? c : -1).filter((u) => u >= 0).length === 0)
      return Ur(t8);
    let i10 = { x: t8 }, p = { reps: s };
    return T.runKernel(uo, i10, p);
  }
  var au = N({ broadcastTo_: lH });
  function mH(r8) {
    let t8 = { x: v(r8, "x", "ceil", "float32") };
    return T.runKernel(en, t8);
  }
  var Bk = N({ ceil_: mH });
  function Ta(r8, e8, t8) {
    wt(r8), t8 = t8 || _i(e8);
    let o8 = { shape: r8, value: e8, dtype: t8 };
    return T.runKernel(na, {}, o8);
  }
  function dH(r8, e8, t8) {
    let o8 = v(r8, "x", "clipByValue");
    if ($(e8 <= t8, () => `Error in clip: min (${e8}) must be less than or equal to max (${t8}).`), e8 === t8)
      return Ta(o8.shape, e8, o8.dtype);
    let n8 = { x: o8 }, s = { clipValueMin: e8, clipValueMax: t8 };
    return T.runKernel(bo, n8, s);
  }
  var zk = N({ clipByValue_: dH });
  function fH(r8) {
    return bt(r8, 0);
  }
  var Vk = N({ concat1d_: fH });
  function hH(r8, e8) {
    return bt(r8, e8);
  }
  var Wk = N({ concat2d_: hH });
  function gH(r8, e8) {
    return bt(r8, e8);
  }
  var Uk = N({ concat3d_: gH });
  function xH(r8, e8) {
    return bt(r8, e8);
  }
  var Gk = N({ concat4d_: xH });
  function yH(r8, e8, t8, o8, n8 = "NHWC", s = [1, 1], a) {
    let i10 = v(r8, "x", "conv2d", "float32"), p = v(e8, "filter", "conv2d", "float32"), u = i10, c = false;
    i10.rank === 3 && (c = true, u = W(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]])), $(u.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${u.rank}.`), $(p.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${p.rank}.`), Lt("conv2d", o8, a);
    let l = n8 === "NHWC" ? u.shape[3] : u.shape[1];
    $(l === p.shape[2], () => `Error in conv2d: depth of input (${l}) must match input depth for filter ${p.shape[2]}.`), $(gr(t8, s), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${t8} and dilations '${s}'`), $(va(s), () => "Error in conv2D: Dilated rates should be larger than 0."), $(va(t8), () => "Error in conv2D: Strides should be larger than 0.");
    let m = { x: u, filter: p }, d = { strides: t8, pad: o8, dataFormat: n8, dilations: s, dimRoundingMode: a }, f = T.runKernel(tn, m, d);
    return c ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
  }
  var iu = N({ conv2d_: yH });
  function bH(r8, e8, t8, o8, n8 = "NWC", s = 1, a) {
    let i10 = v(r8, "x", "conv1d"), p = v(e8, "filter", "conv1d"), u = i10, c = false;
    i10.rank === 2 && (c = true, u = W(i10, [1, i10.shape[0], i10.shape[1]])), $(u.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${u.rank}.`), $(p.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${p.rank}.`), Lt("conv1d", o8, a), $(u.shape[2] === p.shape[1], () => `Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${p.shape[1]}.`), $(gr(t8, s), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${t8} and dilation '${s}'`), $(va(s), () => "Error in conv1D: Dilated rates should be larger than 0."), $(va(t8), () => "Error in conv1D: Stride should be larger than 0."), $(n8 === "NWC", () => `Error in conv1d: got dataFormat of ${n8} but only NWC is currently supported.`);
    let l = W(p, [1, p.shape[0], p.shape[1], p.shape[2]]), m = W(u, [u.shape[0], 1, u.shape[1], u.shape[2]]), g = iu(m, l, [1, t8], o8, "NHWC", [1, s], a);
    return c ? W(g, [g.shape[2], g.shape[3]]) : W(g, [g.shape[0], g.shape[2], g.shape[3]]);
  }
  var Hk = N({ conv1d_: bH });
  function CH(r8, e8, t8, o8, n8, s = "NHWC", a) {
    $(r8.length === e8.rank, () => `Length of inShape (${r8.length}) and rank of dy (${e8.rank}) must match`);
    let i10 = r8, p = e8, u = false;
    e8.rank === 3 && (u = true, p = W(e8, [1, e8.shape[0], e8.shape[1], e8.shape[2]]), i10 = [1, r8[0], r8[1], r8[2]]), $(i10.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${i10.length}.`), $(p.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${p.rank}`), $(t8.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${t8.rank}`);
    let c = s === "NHWC" ? i10[3] : i10[1], l = s === "NHWC" ? p.shape[3] : p.shape[1];
    $(c === t8.shape[2], () => `Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t8.shape[2]}.`), $(l === t8.shape[3], () => `Error in conv2dDerInput: depth of output (${l}) must match output depth for filter ${t8.shape[3]}.`), Lt("conv2dDerInput", n8, a);
    let m = { dy: p, filter: t8 }, d = { strides: o8, pad: n8, dataFormat: s, dimRoundingMode: a, inputShape: i10 }, f = T.runKernel(rn, m, d);
    return u ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
  }
  var hd = N({ conv2DBackpropInput_: CH });
  function wH(r8, e8, t8, o8, n8, s) {
    let a = v(r8, "x", "conv2dTranspose"), i10 = v(e8, "filter", "conv2dTranspose");
    return hd(t8, a, i10, o8, n8, "NHWC", s);
  }
  var Kk = N({ conv2dTranspose_: wH });
  function SH(r8, e8, t8, o8, n8 = "NDHWC", s = [1, 1, 1]) {
    let a = v(r8, "x", "conv3d"), i10 = v(e8, "filter", "conv3d"), p = a, u = false;
    a.rank === 4 && (u = true, p = W(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]])), $(p.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${p.rank}.`), $(i10.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${i10.rank}.`), $(p.shape[4] === i10.shape[3], () => `Error in conv3d: depth of input (${p.shape[4]}) must match input depth for filter ${i10.shape[3]}.`), $(gr(t8, s), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${t8} and dilations '${s}'`), $(n8 === "NDHWC", () => `Error in conv3d: got dataFormat of ${n8} but only NDHWC is currently supported.`), $(va(s), () => "Error in conv3D: Dilated rates should be larger than 0."), $(va(t8), () => "Error in conv3D: Strides should be larger than 0.");
    let c = { x: p, filter: i10 }, l = { strides: t8, pad: o8, dataFormat: n8, dilations: s }, m = T.runKernel(on, c, l);
    return u ? W(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m;
  }
  var qk = N({ conv3d_: SH });
  function IH(r8, e8, t8, o8, n8) {
    $(r8.length === e8.rank, () => `Length of inShape (${r8.length}) and rank of dy (${e8.rank}) must match`);
    let s = r8, a = e8, i10 = false;
    e8.rank === 4 && (i10 = true, a = W(e8, [1, e8.shape[0], e8.shape[1], e8.shape[2], e8.shape[3]]), s = [1, r8[0], r8[1], r8[2], r8[3]]);
    let p = s[4], u = a.shape[4];
    $(s.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`), $(a.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`), $(t8.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${t8.rank}`), $(p === t8.shape[3], () => `Error in conv3dDerInput: depth of input (${p}) must match input depth for filter ${t8.shape[3]}.`), $(u === t8.shape[4], () => `Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t8.shape[4]}.`);
    let c = { dy: a, filter: t8 }, l = { pad: n8, strides: o8, inputShape: s }, m = T.runKernel(nn, c, l);
    return i10 ? W(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m;
  }
  var jk = N({ conv3DBackpropInput_: IH });
  function vH(r8, e8, t8, o8, n8) {
    let s = v(r8, "x", "conv3dTranspose"), a = v(e8, "filter", "conv3dTranspose");
    return jk(t8, s, a, o8, n8);
  }
  var Xk = N({ conv3dTranspose_: vH });
  function kH(r8) {
    let t8 = { x: v(r8, "x", "cos", "float32") };
    return T.runKernel(sn, t8);
  }
  var Yk = N({ cos_: kH });
  function NH(r8) {
    let t8 = { x: v(r8, "x", "cosh", "float32") };
    return T.runKernel(an, t8);
  }
  var Qk = N({ cosh_: NH });
  function TH(r8, e8 = 0, t8 = false, o8 = false) {
    let s = { x: v(r8, "x", "cumprod") }, a = { axis: e8, exclusive: t8, reverse: o8 };
    return T.runKernel(un, s, a);
  }
  var Zk = N({ cumprod_: TH });
  function _H(r8, e8 = 0, t8 = false, o8 = false) {
    let s = { x: v(r8, "x", "cumsum") }, a = { axis: e8, exclusive: t8, reverse: o8 };
    return T.runKernel(pn, s, a);
  }
  var Jk = N({ cumsum_: _H });
  function $H(r8, e8, t8, o8 = false) {
    let n8 = v(r8, "x", "denseBincount"), s = v(e8, "weights", "denseBincount");
    $(n8.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${n8.dtype}`), $(n8.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${n8.rank}.`), $(t8 >= 0, () => `size must be non-negative, but got ${t8}.`), $(s.size === n8.size || s.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${n8.shape}, weights shape: ${s.shape}.`);
    let a = { x: n8, weights: s }, i10 = { size: t8, binaryOutput: o8 };
    return T.runKernel(ta, a, i10);
  }
  var e2 = N({ denseBincount_: $H });
  function EH(r8, e8, t8 = "NHWC") {
    let o8 = v(r8, "x", "depthToSpace", "float32"), n8 = t8 === "NHWC" ? o8.shape[1] : o8.shape[2], s = t8 === "NHWC" ? o8.shape[2] : o8.shape[3], a = t8 === "NHWC" ? o8.shape[3] : o8.shape[1];
    $(e8 > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${e8}`), $(n8 * e8 >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${n8} and ${e8}  for depthToSpace with input shape
    ${o8.shape}`), $(s * e8 >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${s} and ${e8} for depthToSpace with input shape
        ${o8.shape}`), $(a % (e8 * e8) === 0, () => `Dimension size must be evenly divisible by ${e8 * e8} but is ${a} for depthToSpace with input shape ${o8.shape}`);
    let i10 = { x: o8 }, p = { blockSize: e8, dataFormat: t8 };
    return T.runKernel(ln, i10, p);
  }
  var t2 = N({ depthToSpace_: EH });
  function RH(r8, e8, t8, o8, n8 = "NHWC", s = [1, 1], a) {
    let i10 = v(r8, "x", "depthwiseConv2d", "float32"), p = v(e8, "filter", "depthwiseConv2d", "float32"), u = i10, c = false;
    i10.rank === 3 && (c = true, u = W(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]])), $(u.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`), $(p.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`);
    let l = n8 === "NHWC" ? u.shape[3] : u.shape[1];
    $(l === p.shape[2], () => `Error in depthwiseConv2d: number of input channels (${l}) must match the inChannels dimension in filter ${p.shape[2]}.`), Lt("depthwiseConv2d", o8, a);
    let m = { x: u, filter: p }, d = { strides: t8, pad: o8, dataFormat: n8, dilations: s, dimRoundingMode: a }, f = T.runKernel(mn, m, d);
    return c ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
  }
  var ic = N({ depthwiseConv2d_: RH });
  function DH(r8) {
    let t8 = { x: v(r8, "x", "diag") };
    return T.runKernel(ra, t8);
  }
  var r2 = N({ diag_: DH });
  function AH(r8, e8, t8, o8, n8 = [1, 1], s = "NHWC") {
    let a = v(r8, "x", "dilation2d"), i10 = v(e8, "filter", "dilation2d");
    $(a.rank === 3 || a.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`), $(i10.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${i10.rank}.`), $(s === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);
    let p = a, u = false;
    a.rank === 3 && (p = W(a, [1, a.shape[0], a.shape[1], a.shape[2]]), u = true), $(p.shape[3] === i10.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${p.shape[3]} vs ${i10.shape[2]}`);
    let c = { x: p, filter: i10 }, l = { strides: t8, pad: o8, dilations: n8 }, m = T.runKernel(dn, c, l);
    return u ? W(m, [m.shape[1], m.shape[2], m.shape[3]]) : m;
  }
  var o2 = N({ dilation2d_: AH });
  var Ir = {};
  Ke(Ir, { assertAndGetBroadcastShape: () => rt, getBroadcastDims: () => n2, getReductionAxes: () => gd });
  function n2(r8, e8) {
    let t8 = r8.length, o8 = [];
    for (let n8 = 0; n8 < t8; n8++) {
      let s = t8 - 1 - n8, a = r8[s] || 1;
      (e8[e8.length - 1 - n8] || 1) > 1 && a === 1 && o8.unshift(s);
    }
    return o8;
  }
  function gd(r8, e8) {
    let t8 = [];
    for (let o8 = 0; o8 < e8.length; o8++) {
      let n8 = r8[r8.length - o8 - 1], s = e8.length - o8 - 1, a = e8[s];
      (n8 == null || n8 === 1 && a > 1) && t8.unshift(s);
    }
    return t8;
  }
  function rt(r8, e8) {
    let t8 = Math.max(r8.length, e8.length), o8 = new Array(t8);
    for (let n8 = 0; n8 < t8; n8++) {
      let s = r8[r8.length - n8 - 1];
      s == null && (s = 1);
      let a = e8[e8.length - n8 - 1];
      if (a == null && (a = 1), s === 1)
        o8[t8 - n8 - 1] = a;
      else if (a === 1)
        o8[t8 - n8 - 1] = s;
      else if (s !== a) {
        let i10 = `Operands could not be broadcast together with shapes ${r8} and ${e8}.`;
        throw Error(i10);
      } else
        o8[t8 - n8 - 1] = s;
    }
    return o8;
  }
  function FH(r8, e8) {
    let t8 = v(r8, "a", "equal", "string_or_numeric"), o8 = v(e8, "b", "equal", "string_or_numeric");
    [t8, o8] = Oe(t8, o8), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(xn, n8);
  }
  var xd = N({ equal_: FH });
  function PH(r8, e8, t8) {
    let o8 = v(e8, "a", "where"), n8 = v(t8, "b", "where"), s = v(r8, "condition", "where", "bool"), a = rt(rt(s.shape, o8.shape), n8.shape), i10 = au(s, a), p = au(o8, a), u = au(n8, a), c = { condition: i10, t: p, e: u };
    return T.runKernel(da, c);
  }
  var co = N({ where_: PH });
  function OH(r8) {
    let t8 = { x: v(r8, "x", "zerosLike") };
    return T.runKernel(ba, t8);
  }
  var Ht = N({ zerosLike_: OH });
  function MH(r8, e8) {
    let t8 = v(r8, "a", "div"), o8 = v(e8, "b", "div");
    [t8, o8] = Oe(t8, o8);
    let n8 = je(t8, o8), s = Ht(n8), a = xd(o8, s);
    return co(a, s, n8);
  }
  var s2 = N({ divNoNan_: MH });
  function LH(r8, e8) {
    let t8 = v(r8, "t1", "dot"), o8 = v(e8, "t2", "dot");
    $((t8.rank === 1 || t8.rank === 2) && (o8.rank === 1 || o8.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${t8.rank} and ${o8.rank}.`);
    let n8 = t8.rank === 1 ? t8.size : t8.shape[1], s = o8.rank === 1 ? o8.size : o8.shape[0];
    if ($(n8 === s, () => `Error in dot: inner dimensions of inputs must match, but got ${n8} and ${s}.`), t8.rank === 1 && o8.rank === 1) {
      let a = W(t8, [1, -1]), i10 = W(o8, [-1, 1]), p = Ze(a, i10);
      return W(p, []);
    } else if (t8.rank === 1 && o8.rank === 2) {
      let a = W(t8, [1, -1]), i10 = W(o8, [o8.shape[0], o8.shape[1]]), p = Ze(a, i10);
      return W(p, [p.size]);
    } else if (t8.rank === 2 && o8.rank === 1) {
      let a = W(o8, [-1, 1]), i10 = Ze(t8, a);
      return W(i10, [i10.size]);
    } else {
      let a = W(o8, [o8.shape[0], o8.shape[1]]);
      return Ze(t8, a);
    }
  }
  var a2 = N({ dot_: LH });
  function BH(r8, ...e8) {
    let t8 = e8.map((n8, s) => v(n8, `tensors${s}`, "einsum")), o8 = { equation: r8 };
    return T.runKernel(Li, t8, o8);
  }
  var i2 = N({ einsum_: BH });
  function zH(r8) {
    let t8 = { x: v(r8, "x", "elu", "float32") };
    return T.runKernel(hn, t8);
  }
  var yd = N({ elu_: zH });
  function VH(r8, e8) {
    let t8 = v(r8, "x", "ensureShape", "string_or_numeric");
    if (!HC(t8.shape, e8))
      throw new Error(`EnsureShape: Shape of tensor ${t8.shape} is not compatible with expected shape ${e8}`);
    return r8;
  }
  var u2 = N({ ensureShape_: VH });
  function WH(r8) {
    let e8 = v(r8, "x", "erf");
    $(e8.dtype === "int32" || e8.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), e8.dtype === "int32" && (e8 = qe(e8, "float32"));
    let t8 = { x: e8 };
    return T.runKernel(gn, t8);
  }
  var p2 = N({ erf_: WH });
  function Dw(r8, e8) {
    for (let t8 = 0; t8 < r8.length; ++t8)
      if (r8[r8.length - t8 - 1] !== e8 - 1 - t8)
        return false;
    return true;
  }
  function c2(r8, e8, t8) {
    let o8 = r8.length + e8.length, n8 = [], s = 0, a = 0;
    for (let i10 = 0; i10 < o8; i10++)
      t8.indexOf(i10) === -1 ? n8.push(r8[s++]) : n8.push(e8[a++]);
    return n8;
  }
  function UH(r8, e8) {
    let t8 = [], o8 = r8.length;
    for (let s = 0; s < o8; s++)
      e8.indexOf(s) === -1 && t8.push(r8[s]);
    let n8 = e8.map((s) => r8[s]);
    return [t8, n8];
  }
  function ni(r8, e8) {
    let t8 = e8.map((o8) => 1);
    return c2(r8, t8, e8);
  }
  function GH(r8, e8, t8) {
    $(Dw(e8, t8), () => `${r8} supports only inner-most axes for now. Got axes ${e8} and rank-${t8} input.`);
  }
  function HH(r8, e8) {
    if (Dw(r8, e8))
      return null;
    let t8 = [];
    for (let o8 = 0; o8 < e8; ++o8)
      r8.indexOf(o8) === -1 && t8.push(o8);
    return r8.forEach((o8) => t8.push(o8)), t8;
  }
  function KH(r8) {
    return r8.map((e8, t8) => [t8, e8]).sort((e8, t8) => e8[1] - t8[1]).map((e8) => e8[0]);
  }
  function qH(r8, e8) {
    let t8 = [];
    for (let o8 = e8 - r8; o8 < e8; ++o8)
      t8.push(o8);
    return t8;
  }
  function XH(r8, e8 = null, t8 = false) {
    let n8 = { x: v(r8, "x", "max") }, s = { reductionIndices: e8, keepDims: t8 };
    return T.runKernel(zn, n8, s);
  }
  var _a = N({ max_: XH });
  function YH(r8, e8 = null, t8 = false) {
    let n8 = { x: v(r8, "x", "min") }, s = { axis: e8, keepDims: t8 };
    return T.runKernel(Gn, n8, s);
  }
  var vl = N({ min_: YH });
  function QH(r8, e8) {
    let t8 = v(r8, "base", "pow"), o8 = v(e8, "exp", "pow");
    [t8, o8] = Oe(t8, o8);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(ts, n8);
  }
  var si = N({ pow_: QH });
  function ke(r8, e8) {
    if ((Pt(r8) && e8 !== "string" || Array.isArray(r8)) && e8 !== "complex64")
      throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if (e8 === "string" && Pt(r8) && !(r8 instanceof Uint8Array))
      throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return Sr(r8, [], [], e8);
  }
  function ZH(r8) {
    let t8 = { x: v(r8, "x", "sqrt", "float32") };
    return T.runKernel(ws, t8);
  }
  var Dr = N({ sqrt_: ZH });
  function JH(r8) {
    let e8 = v(r8, "x", "square"), t8 = {};
    return T.runKernel("Square", { x: e8 }, t8);
  }
  var er = N({ square_: JH });
  function eK(r8, e8 = null, t8 = false) {
    let o8 = v(r8, "x", "sum");
    o8.dtype === "bool" && (o8 = qe(o8, "int32"));
    let n8 = { x: o8 }, s = { axis: e8, keepDims: t8 };
    return T.runKernel(Ss, n8, s);
  }
  var ot = N({ sum_: eK });
  function tK(r8, e8 = "euclidean", t8 = null, o8 = false) {
    r8 = v(r8, "x", "norm");
    let n8 = l2(r8, e8, t8), s = n8.shape;
    if (o8) {
      let a = Ti(t8, r8.shape);
      s = ni(n8.shape, a);
    }
    return W(n8, s);
  }
  function l2(r8, e8, t8 = null) {
    if (r8.rank === 0)
      return Jt(r8);
    if (r8.rank !== 1 && t8 === null)
      return l2(W(r8, [-1]), e8, t8);
    if (r8.rank === 1 || typeof t8 == "number" || Array.isArray(t8) && t8.length === 1) {
      if (e8 === 1)
        return ot(Jt(r8), t8);
      if (e8 === 1 / 0)
        return _a(Jt(r8), t8);
      if (e8 === -1 / 0)
        return vl(Jt(r8), t8);
      if (e8 === "euclidean" || e8 === 2)
        return Dr(ot(si(Jt(r8), ke(2, "int32")), t8));
      throw new Error(`Error in norm: invalid ord value: ${e8}`);
    }
    if (Array.isArray(t8) && t8.length === 2) {
      if (e8 === 1)
        return _a(ot(Jt(r8), t8[0]), t8[1] - 1);
      if (e8 === 1 / 0)
        return _a(ot(Jt(r8), t8[1]), t8[0]);
      if (e8 === -1 / 0)
        return vl(ot(Jt(r8), t8[1]), t8[0]);
      if (e8 === "fro" || e8 === "euclidean")
        return Dr(ot(er(r8), t8));
      throw new Error(`Error in norm: invalid ord value: ${e8}`);
    }
    throw new Error(`Error in norm: invalid axis: ${t8}`);
  }
  var Wu = N({ norm_: tK });
  function rK(r8, e8 = null, t8 = false) {
    return Wu(r8, "euclidean", e8, t8);
  }
  var m2 = N({ euclideanNorm_: rK });
  function oK(r8) {
    let t8 = { x: v(r8, "x", "exp") };
    return T.runKernel(yn, t8);
  }
  var _o = N({ exp_: oK });
  function nK(r8, e8 = 0) {
    let t8 = v(r8, "x", "expandDims", "string_or_numeric");
    $(e8 <= t8.rank, () => "Axis must be <= rank of the tensor");
    let o8 = { input: t8 }, n8 = { dim: e8 };
    return T.runKernel(oa, o8, n8);
  }
  var ai = N({ expandDims_: nK });
  function sK(r8) {
    let t8 = { x: v(r8, "x", "expm1") };
    return T.runKernel(bn, t8);
  }
  var d2 = N({ expm1_: sK });
  function aK(r8, e8) {
    let t8 = v(r8, "x", "tile", "string_or_numeric");
    $(t8.rank === e8.length, () => `Error in transpose: rank of input ${t8.rank} must match length of reps ${e8}.`);
    let o8 = { x: t8 }, n8 = { reps: e8 };
    return T.runKernel(uo, o8, n8);
  }
  var uu = N({ tile_: aK });
  function iK(r8, e8, t8, o8 = "float32") {
    e8 == null && (e8 = r8);
    let n8 = me([r8, e8], o8), s = r8 <= e8 ? r8 : e8;
    for (let i10 = 0; i10 < s; ++i10)
      n8.set(1, i10, i10);
    let a = W(n8.toTensor(), [r8, e8]);
    if (t8 == null)
      return a;
    if (t8.length === 1)
      return uu(ai(a, 0), [t8[0], 1, 1]);
    if (t8.length === 2)
      return uu(ai(ai(a, 0), 0), [t8[0], t8[1], 1, 1]);
    if (t8.length === 3)
      return uu(ai(ai(ai(a, 0), 0), 0), [t8[0], t8[1], t8[2], 1, 1]);
    throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t8.length}D.`);
  }
  var bd = N({ eye_: iK });
  function uK(r8) {
    let t8 = { x: v(r8, "x", "floor", "float32") };
    return T.runKernel(wn, t8);
  }
  var Cd = N({ floor_: uK });
  function pK(r8, e8, t8 = 0, o8 = 0) {
    let n8 = v(r8, "x", "gather"), s = v(e8, "indices", "gather", "int32"), a = { x: n8, indices: s }, i10 = { axis: t8, batchDims: o8 };
    return T.runKernel(sa, a, i10);
  }
  var wd = N({ gather_: pK });
  function cK(r8, e8) {
    let t8 = v(r8, "a", "greater", "string_or_numeric"), o8 = v(e8, "b", "greater", "string_or_numeric");
    [t8, o8] = Oe(t8, o8), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(kn, n8);
  }
  var Uu = N({ greater_: cK });
  function lK(r8, e8) {
    let t8 = v(r8, "a", "greaterEqual", "string_or_numeric"), o8 = v(e8, "b", "greaterEqual", "string_or_numeric");
    [t8, o8] = Oe(t8, o8), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Nn, n8);
  }
  var Sd = N({ greaterEqual_: lK });
  function mK(r8) {
    let t8 = { input: v(r8, "input", "imag") };
    return T.runKernel(Vi, t8);
  }
  var pu = N({ imag_: mK });
  function dK(r8) {
    let t8 = { x: v(r8, "x", "isFinite") };
    return T.runKernel(Tn, t8);
  }
  var f2 = N({ isFinite_: dK });
  function fK(r8) {
    let t8 = { x: v(r8, "x", "isInf") };
    return T.runKernel(_n, t8);
  }
  var h2 = N({ isInf_: fK });
  function hK(r8) {
    let t8 = { x: v(r8, "x", "isNaN") };
    return T.runKernel($n, t8);
  }
  var g2 = N({ isNaN_: hK });
  function gK(r8, e8 = 0.2) {
    let o8 = { x: v(r8, "x", "leakyRelu") }, n8 = { alpha: e8 };
    return T.runKernel(En, o8, n8);
  }
  var Id = N({ leakyRelu_: gK });
  function xK(r8, e8) {
    let t8 = v(r8, "a", "less", "string_or_numeric"), o8 = v(e8, "b", "less", "string_or_numeric");
    [t8, o8] = Oe(t8, o8), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Rn, n8);
  }
  var kl = N({ less_: xK });
  function yK(r8, e8) {
    let t8 = v(r8, "a", "lessEqual", "string_or_numeric"), o8 = v(e8, "b", "lessEqual", "string_or_numeric");
    [t8, o8] = Oe(t8, o8), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Dn, n8);
  }
  var uc = N({ lessEqual_: yK });
  function x2(r8, e8, t8) {
    if (t8 <= 0)
      throw new Error("The number of values should be positive.");
    let o8 = { start: r8, stop: e8, num: t8 };
    return T.runKernel(An, {}, o8);
  }
  function bK(r8, e8 = 5, t8 = 1, o8 = 1, n8 = 0.5) {
    let s = v(r8, "x", "localResponseNormalization");
    $(s.rank === 4 || s.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`), $(Ga(e8), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e8}.`);
    let a = s, i10 = false;
    s.rank === 3 && (i10 = true, a = W(s, [1, s.shape[0], s.shape[1], s.shape[2]]));
    let p = { x: a }, u = { depthRadius: e8, bias: t8, alpha: o8, beta: n8 }, c = T.runKernel(Bn, p, u);
    return i10 ? W(c, [c.shape[1], c.shape[2], c.shape[3]]) : c;
  }
  var y2 = N({ localResponseNormalization_: bK });
  function CK(r8) {
    let t8 = { x: v(r8, "x", "log", "float32") };
    return T.runKernel(Fn, t8);
  }
  var ii = N({ log_: CK });
  function wK(r8) {
    let t8 = { x: v(r8, "x", "log1p") };
    return T.runKernel(Pn, t8);
  }
  var vd = N({ log1p_: wK });
  function SK(r8) {
    return $(Ks(r8), () => "The f passed in grad(f) must be a function"), (e8, t8) => {
      let o8 = v(e8, "x", "tf.grad", "string_or_numeric"), n8 = t8 != null ? v(t8, "dy", "tf.grad") : null;
      return T.tidy(() => {
        let { value: s, grads: a } = T.gradients(() => r8(o8), [o8], n8);
        return n8 != null && yt(s.shape, n8.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), kd(a), a[0];
      });
    };
  }
  function IK(r8) {
    return $(Ks(r8), () => "The f passed in grads(f) must be a function"), (e8, t8) => {
      $(Array.isArray(e8), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
      let o8 = ri(e8, "args", "tf.grads", "string_or_numeric"), n8 = t8 != null ? v(t8, "dy", "tf.grads") : null;
      return T.tidy(() => {
        let { value: s, grads: a } = T.gradients(() => r8(...o8), o8, n8);
        return n8 != null && yt(s.shape, n8.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), kd(a), a;
      });
    };
  }
  function vK(r8) {
    return $(Ks(r8), () => "The f passed in valueAndGrad(f) must be a function"), (e8, t8) => {
      $(e8 instanceof ut, () => "The x passed in valueAndGrad(f)(x) must be a tensor"), $(t8 == null || t8 instanceof ut, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
      let { grads: o8, value: n8 } = T.gradients(() => r8(e8), [e8], t8);
      return kd(o8), { grad: o8[0], value: n8 };
    };
  }
  function kK(r8) {
    return $(Ks(r8), () => "The f passed in valueAndGrads(f) must be a function"), (e8, t8) => {
      $(Array.isArray(e8) && e8.every((n8) => n8 instanceof ut), () => "The args passed in valueAndGrads(f)(args) must be array of tensors"), $(t8 == null || t8 instanceof ut, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
      let o8 = T.gradients(() => r8(...e8), e8, t8);
      return t8 != null && yt(o8.value.shape, t8.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), kd(o8.grads), o8;
    };
  }
  function Aw(r8, e8) {
    $(Ks(r8), () => "The f passed in variableGrads(f) must be a function"), $(e8 == null || Array.isArray(e8) && e8.every((u) => u instanceof ei), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    let t8 = e8 != null;
    if (!t8) {
      e8 = [];
      for (let u in T.registeredVariables)
        e8.push(T.registeredVariables[u]);
    }
    let o8 = t8 ? e8.filter((u) => !u.trainable) : null, n8 = e8.length;
    e8 = e8.filter((u) => u.trainable), $(e8.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${n8} variables is trainable.`);
    let s = true, { value: a, grads: i10 } = T.gradients(r8, e8, null, s);
    $(i10.some((u) => u != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), $(a.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);
    let p = {};
    return e8.forEach((u, c) => {
      i10[c] != null && (p[u.name] = i10[c]);
    }), o8 != null && o8.forEach((u) => p[u.name] = null), { value: a, grads: p };
  }
  function vr(r8) {
    return T.customGrad(r8);
  }
  function kd(r8) {
    if (r8.filter((t8) => t8 == null).length > 0)
      throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
  }
  function NK(r8) {
    let t8 = { x: v(r8, "x", "neg") };
    return T.runKernel(ua, t8);
  }
  var pr = N({ neg_: NK });
  function TK(r8) {
    let t8 = { x: v(r8, "x", "softplus") };
    return T.runKernel(Cs, t8);
  }
  var Nd = N({ softplus_: TK });
  function _K(r8) {
    let e8 = v(r8, "x", "logSigmoid");
    return vr((o8) => ({ value: pr(Nd(pr(o8))), gradFunc: (a) => se(a, Na(pr(o8))) }))(e8);
  }
  var b2 = N({ logSigmoid_: _K });
  function $K(r8, e8) {
    let t8 = v(r8, "a", "sub"), o8 = v(e8, "b", "sub");
    [t8, o8] = Oe(t8, o8);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Ts, n8);
  }
  var Te = N({ sub_: $K });
  function EK(r8, e8 = -1) {
    let t8 = v(r8, "logits", "logSoftmax");
    if (e8 === -1 && (e8 = t8.rank - 1), e8 !== t8.rank - 1)
      throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t8.rank} and axis was ${e8}`);
    return vr((n8, s) => {
      let i10 = _a(n8, e8, true), p = Te(n8, i10), u = Te(qe(p, "float32"), ii(ot(_o(p), e8, true)));
      return s([u]), { value: u, gradFunc: (l, m) => {
        let [d] = m, f = true, h = _o(d);
        return Te(l, se(ot(l, e8, f), h));
      } };
    })(t8);
  }
  var C2 = N({ logSoftmax_: EK });
  function RK(r8, e8 = null, t8 = false) {
    let o8 = v(r8, "x", "logSumExp"), n8 = Ti(e8, o8.shape), s = _a(o8, n8, true), a = Te(o8, s), i10 = _o(a), p = ot(i10, n8), u = ii(p), c = Ce(W(s, u.shape), u);
    if (t8) {
      let l = ni(c.shape, n8);
      return W(c, l);
    }
    return c;
  }
  var Td = N({ logSumExp_: RK });
  function DK(r8, e8) {
    let t8 = v(r8, "a", "logicalAnd", "bool"), o8 = v(e8, "b", "logicalAnd", "bool");
    rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(On, n8);
  }
  var Gu = N({ logicalAnd_: DK });
  function AK(r8) {
    let t8 = { x: v(r8, "x", "logicalNot", "bool") };
    return T.runKernel(Mn, t8);
  }
  var _d = N({ logicalNot_: AK });
  function FK(r8, e8) {
    let t8 = v(r8, "a", "logicalOr", "bool"), o8 = v(e8, "b", "logicalOr", "bool");
    rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Ln, n8);
  }
  var $d = N({ logicalOr_: FK });
  function PK(r8, e8) {
    let t8 = v(r8, "a", "logicalXor", "bool"), o8 = v(e8, "b", "logicalXor", "bool");
    return rt(t8.shape, o8.shape), Gu($d(r8, e8), _d(Gu(r8, e8)));
  }
  var w2 = N({ logicalXor_: PK });
  var Ed = 2147483648;
  function OK(r8, e8, t8 = "left") {
    let o8 = v(r8, "sortedSequence", "searchSorted"), n8 = v(e8, "values", "searchSorted"), s = o8.shape[o8.shape.length - 1], a = n8.shape[n8.shape.length - 1], i10 = W(o8, [-1, s]), p = W(n8, [-1, a]);
    if (i10.rank < 2)
      throw new Error("Sorted input argument must be at least 2-dimensional");
    if (i10.shape[0] !== p.shape[0])
      throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
    if (Ge(p.shape) >= Ed)
      throw new Error(`values tensor size must less than ${Ed}`);
    if (i10.shape[1] >= Ed)
      throw new Error(`trailing dim_size must less than ${Ed} for int32 output type, was ${i10.shape[1]}`);
    let u = { sortedSequence: i10, values: p }, c = { side: t8 };
    return T.runKernel(fs, u, c);
  }
  var Nl = N({ searchSorted_: OK });
  function S2(r8, e8) {
    return Nl(r8, e8, "left");
  }
  function MK(r8, e8, t8, o8, n8) {
    let s = v(r8, "x", "maxPool"), a = 1, i10 = s, p = false;
    s.rank === 3 && (p = true, i10 = W(s, [1, s.shape[0], s.shape[1], s.shape[2]])), $(i10.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${i10.rank}.`), $(gr(t8, a), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${t8} and dilations '${a}'`), Lt("maxPool", o8, n8);
    let u = { x: i10 }, c = { filterSize: e8, strides: t8, pad: o8, dimRoundingMode: n8 }, l = T.runKernel(Wn, u, c);
    return p ? W(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
  }
  var Rd = N({ maxPool_: MK });
  function LK(r8, e8 = [1, 1, 1], t8, o8, n8, s = "NDHWC") {
    let a = v(r8, "x", "maxPool3d"), i10 = a, p = false;
    a.rank === 4 && (p = true, i10 = W(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]])), $(i10.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${i10.rank}.`), $(s === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`), Lt("maxPool3d", o8, n8);
    let u = { x: i10 }, c = { filterSize: e8, strides: t8, pad: o8, dimRoundingMode: n8, dataFormat: s }, l = T.runKernel(aa, u, c);
    return p ? W(l, [l.shape[1], l.shape[2], l.shape[3], l.shape[4]]) : l;
  }
  var I2 = N({ maxPool3d_: LK });
  function BK(r8, e8, t8, o8, n8 = false) {
    let a = { x: v(r8, "x", "maxPoolWithArgmax") }, i10 = { filterSize: e8, strides: t8, pad: o8, includeBatchInIndex: n8 }, p = T.runKernel(ia, a, i10);
    return { result: p[0], indexes: p[1] };
  }
  var v2 = N({ maxPoolWithArgmax_: BK });
  function zK(r8, e8) {
    let t8 = v(r8, "a", "maximum"), o8 = v(e8, "b", "maximum");
    [t8, o8] = Oe(t8, o8), t8.dtype === "bool" && (t8 = qe(t8, "int32"), o8 = qe(o8, "int32")), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Vn, n8);
  }
  var Dd = N({ maximum_: zK });
  function VK(r8, e8 = null, t8 = false) {
    let n8 = { x: v(r8, "x", "mean") }, s = { axis: e8, keepDims: t8 };
    return T.runKernel(Un, n8, s);
  }
  var Hu = N({ mean_: VK });
  function Gr(r8, e8 = "float32") {
    if (wt(r8), e8 === "complex64") {
      let o8 = Gr(r8, "float32"), n8 = Gr(r8, "float32");
      return Er(o8, n8);
    }
    let t8 = qp(Ge(r8), e8);
    return T.makeTensor(t8, r8, e8);
  }
  function $a(r8, e8 = "float32") {
    if (wt(r8), e8 === "complex64") {
      let o8 = $a(r8, "float32"), n8 = Gr(r8, "float32");
      return Er(o8, n8);
    }
    let t8 = cl(Ge(r8), e8);
    return T.makeTensor(t8, r8, e8);
  }
  function k2(r8, e8, { indexing: t8 = "xy" } = {}) {
    if (t8 !== "xy" && t8 !== "ij")
      throw new TypeError(`${t8} is not a valid third argument to meshgrid`);
    if (r8 === void 0)
      return [];
    let o8 = v(r8, "x", "meshgrid", r8 instanceof ut ? r8.dtype : "float32");
    if (e8 === void 0)
      return [o8];
    let n8 = v(e8, "y", "meshgrid", e8 instanceof ut ? e8.dtype : "float32"), s = Ge(o8.shape), a = Ge(n8.shape);
    return t8 === "xy" ? (o8 = W(o8, [1, -1]), n8 = W(n8, [-1, 1]), [Ze($a([a, 1], o8.dtype), o8), Ze(n8, $a([1, s], n8.dtype))]) : (o8 = W(o8, [-1, 1]), n8 = W(n8, [1, -1]), [Ze(o8, $a([1, a], o8.dtype)), Ze($a([s, 1], n8.dtype), n8)]);
  }
  function WK(r8, e8) {
    let t8 = v(r8, "a", "minimum"), o8 = v(e8, "b", "minimum");
    [t8, o8] = Oe(t8, o8), t8.dtype === "bool" && (t8 = qe(t8, "int32"), o8 = qe(o8, "int32")), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Hn, n8);
  }
  var Ku = N({ minimum_: WK });
  function UK(r8, e8, t8) {
    $(t8 === "reflect" || t8 === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${t8}.`);
    let o8 = v(r8, "x", "mirrorPad");
    if (o8.rank === 0)
      throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    $(e8.length === o8.rank, () => `Padding doesn't match input. Must be ${o8.rank}. Got ${e8.length}.`);
    let n8 = t8 === "reflect" ? 1 : 0;
    for (let i10 = 0; i10 < o8.rank; i10++)
      $(e8[i10].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), $(e8[i10][0] >= 0 && e8[i10][0] <= o8.shape[i10] - n8 && e8[i10][1] >= 0 && e8[i10][1] <= o8.shape[i10] - n8, () => `Padding in dimension ${i10} cannot be greater than or equal to ${o8.shape[i10] - n8} or less than 0 for input of shape ${o8.shape}`);
    let s = { paddings: e8, mode: t8 }, a = { x: o8 };
    return T.runKernel(Kn, a, s);
  }
  var N2 = N({ mirrorPad_: UK });
  function GK(r8, e8) {
    let t8 = v(r8, "a", "mod"), o8 = v(e8, "b", "mod");
    [t8, o8] = Oe(t8, o8);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(qn, n8);
  }
  var T2 = N({ mod_: GK });
  function HK(r8, e8 = null, t8 = false) {
    r8 = v(r8, "x", "moments");
    let o8 = Ti(e8, r8.shape), n8 = Hu(r8, o8, t8), s = n8.shape;
    t8 || (s = ni(n8.shape, o8));
    let a = er(Te(qe(r8, "float32"), W(n8, s))), i10 = Hu(a, o8, t8);
    return { mean: n8, variance: i10 };
  }
  var _2 = N({ moments_: HK });
  function KK(r8, e8, t8, o8) {
    let n8 = v(e8, "data", "multiRNNCell"), s = ri(t8, "c", "multiRNNCell"), a = ri(o8, "h", "multiRNNCell"), i10 = n8, p = [];
    for (let l = 0; l < r8.length; l++) {
      let m = r8[l](i10, s[l], a[l]);
      p.push(m[0]), p.push(m[1]), i10 = m[1];
    }
    let u = [], c = [];
    for (let l = 0; l < p.length; l += 2)
      u.push(p[l]), c.push(p[l + 1]);
    return [u, c];
  }
  var $2 = N({ multiRNNCell_: KK });
  function qK(r8, e8, t8, o8 = false) {
    let n8 = v(r8, "logits", "multinomial"), s = n8.size, a = n8.rank;
    if (s < 2)
      throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);
    if (a > 2)
      throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);
    t8 = t8 || Math.random();
    let p = { logits: a === 1 ? W(n8, [1, -1]) : n8 }, u = { numSamples: e8, seed: t8, normalized: o8 }, c = T.runKernel(jn, p, u);
    return a === 1 ? W(c, [c.size]) : c;
  }
  var E2 = N({ multinomial_: qK });
  function jK(r8, e8) {
    let t8 = v(r8, "a", "notEqual", "string_or_numeric"), o8 = v(e8, "b", "notEqual", "string_or_numeric");
    [t8, o8] = Oe(t8, o8), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 };
    return T.runKernel(Yn, n8);
  }
  var Ad = N({ notEqual_: jK });
  function XK(r8, e8, t8 = 1, o8 = 0, n8 = "int32") {
    if (e8 < 2)
      throw new Error(`Error in oneHot: depth must be >=2, but it is ${e8}`);
    let a = { indices: v(r8, "indices", "oneHot", "int32") }, i10 = { dtype: n8, depth: e8, onValue: t8, offValue: o8 };
    return T.runKernel(Jn, a, i10);
  }
  var Tl = N({ oneHot_: XK });
  function YK(r8) {
    let t8 = { x: v(r8, "x", "onesLike") };
    return T.runKernel(pa, t8);
  }
  var R2 = N({ onesLike_: YK });
  function QK(r8, e8) {
    let t8 = v(r8, "v1", "outerProduct"), o8 = v(e8, "v2", "outerProduct");
    $(t8.rank === 1 && o8.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${t8.rank} and ${o8.rank}.`);
    let n8 = W(t8, [-1, 1]), s = W(o8, [1, -1]);
    return Ze(n8, s);
  }
  var D2 = N({ outerProduct_: QK });
  function ZK(r8, e8, t8 = 0) {
    let o8 = v(r8, "x", "pad");
    if (o8.rank === 0)
      throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    let n8 = { paddings: e8, constantValue: t8 }, s = { x: o8 };
    return T.runKernel(es, s, n8);
  }
  var Ea = N({ pad_: ZK });
  function JK(r8, e8, t8 = 0) {
    return $(e8.length === 2, () => "Invalid number of paddings. Must be length of 2."), Ea(r8, [e8], t8);
  }
  var A2 = N({ pad1d_: JK });
  function eq(r8, e8, t8 = 0) {
    return $(e8.length === 2 && e8[0].length === 2 && e8[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), Ea(r8, e8, t8);
  }
  var F2 = N({ pad2d_: eq });
  function tq(r8, e8, t8 = 0) {
    return $(e8.length === 3 && e8[0].length === 2 && e8[1].length === 2 && e8[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), Ea(r8, e8, t8);
  }
  var P2 = N({ pad3d_: tq });
  function rq(r8, e8, t8 = 0) {
    return $(e8.length === 4 && e8[0].length === 2 && e8[1].length === 2 && e8[2].length === 2 && e8[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), Ea(r8, e8, t8);
  }
  var O2 = N({ pad4d_: rq });
  function oq(r8, e8, t8) {
    let o8 = v(r8, "x", "spaceToBatchND");
    $(o8.rank >= 1 + e8.length, () => `input rank ${o8.rank} should be > than [blockShape] ${e8.length}`), $(t8.length === e8.length, () => `paddings.shape[0] ${t8.length} must be equal to [blockShape] ${e8.length}`), $(o8.shape.reduce((a, i10, p) => p > 0 && p <= e8.length ? a && (i10 + t8[p - 1][0] + t8[p - 1][1]) % e8[p - 1] === 0 : a, true), () => `input spatial dimensions ${o8.shape.slice(1)} with paddings ${t8.toString()} must be divisible by blockShapes ${e8.toString()}`);
    let n8 = { x: o8 }, s = { blockShape: e8, paddings: t8 };
    return T.runKernel(ha, n8, s);
  }
  var Fd = N({ spaceToBatchND_: oq });
  function nq(r8, e8, t8, o8, n8, s, a) {
    n8 == null && (n8 = [1, 1]), s == null && (s = 1), o8 === 0 && (o8 = "valid");
    let i10 = v(r8, "x", "maxPool"), p = i10, u = false;
    i10.rank === 3 && (u = true, p = W(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]])), $(gr(s, n8), () => `Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${n8}'`);
    let c = Ew(p.shape, e8, s, n8, o8), l = [c.dilationHeight, c.dilationWidth], m;
    o8 === "same" ? m = aq([c.filterHeight, c.filterWidth], l) : m = [[0, 0], [0, 0]];
    let d = l[0] === 1 && l[1] === 1, [f, h] = sq([c.inHeight, c.inWidth], l, m), g = d ? o8 : "valid", x = d ? p : Fd(p, l, f), C = (t8 === "avg" ? () => md(x, e8, s, g, a) : () => Rd(x, e8, s, g, a))(), S = d ? C : dd(C, l, h);
    return u ? W(S, [S.shape[1], S.shape[2], S.shape[3]]) : S;
  }
  function sq(r8, e8, t8) {
    let o8 = t8.map((c) => c[0]), n8 = t8.map((c) => c[1]), s = r8.concat(o8, n8), a = e8.map((c, l) => (c - s[l] % c) % c), i10 = n8.map((c, l) => c + a[l]), p = e8.map((c, l) => [o8[l], i10[l]]), u = e8.map((c, l) => [0, a[l]]);
    return [p, u];
  }
  function aq(r8, e8) {
    let o8 = r8.map((a, i10) => a + (a - 1) * (e8[i10] - 1)).map((a) => a - 1), n8 = o8.map((a) => Math.floor(a / 2)), s = o8.map((a, i10) => a - n8[i10]);
    return o8.map((a, i10) => [n8[i10], s[i10]]);
  }
  var M2 = N({ pool_: nq });
  function iq(r8, e8) {
    let t8 = v(r8, "x", "prelu"), o8 = v(e8, "alpha", "prelu"), n8 = { x: t8, alpha: o8 };
    return T.runKernel(rs, n8);
  }
  var Pd = N({ prelu_: iq });
  function uq(r8, e8 = null, t8 = false) {
    let o8 = v(r8, "x", "prod");
    o8.dtype === "bool" && (o8 = qe(o8, "int32"));
    let n8 = { x: o8 }, s = { axis: e8, keepDims: t8 };
    return T.runKernel(os, n8, s);
  }
  var L2 = N({ prod_: uq });
  function pq(r8, e8, t8, o8) {
    let n8 = r8.map((c, l) => v(c, `tensors${l}`, "raggedGather", "int32")), s = v(e8, "paramsDenseValues", "raggedGather"), a = v(t8, "indices", "raggedGather", "int32"), i10 = { paramsNestedSplits: n8, paramsDenseValues: s, indices: a }, p = { outputRaggedRank: o8 }, u = T.runKernel(jp, i10, p);
    return { outputNestedSplits: u.slice(0, u.length - 1), outputDenseValues: u[u.length - 1] };
  }
  var B2 = N({ raggedGather_: pq });
  function cq(r8, e8, t8) {
    let o8 = v(r8, "starts", "raggedRange"), n8 = v(e8, "limits", "raggedRange", o8.dtype), s = v(t8, "deltas", "raggedRange", o8.dtype), a = { starts: o8, limits: n8, deltas: s }, i10 = T.runKernel(Xp, a);
    return { rtNestedSplits: i10[0], rtDenseValues: i10[1] };
  }
  var z2 = N({ raggedRange_: cq });
  function lq(r8, e8, t8, o8, n8) {
    let s = v(r8, "shape", "raggedTensorToTensor", "int32"), a = v(e8, "values", "raggedTensorToTensor"), i10 = v(t8, "defaultValue", "raggedTensorToTensor", a.dtype), p = o8.map((l, m) => v(l, `tensors${m}`, "raggedTensorToTensor", "int32")), u = { shape: s, values: a, defaultValue: i10, rowPartitionTensors: p }, c = { rowPartitionTypes: n8 };
    return T.runKernel(Yp, u, c);
  }
  var V2 = N({ raggedTensorToTensor_: lq });
  function mq(r8, e8, t8) {
    wt(r8);
    let o8 = Ge(r8), n8 = null;
    if (t8 == null || t8 === "float32")
      n8 = new Float32Array(o8);
    else if (t8 === "int32")
      n8 = new Int32Array(o8);
    else if (t8 === "bool")
      n8 = new Uint8Array(o8);
    else
      throw new Error(`Unknown data type ${t8}`);
    for (let s = 0; s < o8; s++)
      n8[s] = e8();
    return T.makeTensor(n8, r8, t8);
  }
  var W2 = N({ rand_: mq });
  var zd = Up(zw());
  var u1 = {};
  Ke(u1, { TEST_EPSILON_FLOAT16: () => s1, createVideoElement: () => kq, encodeStrings: () => i1, expectArrayBuffersEqual: () => vq, expectArraysClose: () => Cq, expectArraysEqual: () => Sq, expectNumbersClose: () => a1, expectPromiseToFail: () => wq, expectValuesInRange: () => Iq, play: () => Nq, testEpsilon: () => Md });
  var bq = 1e-3;
  var s1 = 0.1;
  function Cq(r8, e8, t8) {
    return t8 == null && (t8 = Md()), Vw(r8, e8, (o8, n8) => Ww(o8, n8, t8));
  }
  function Md() {
    return T.backend.floatPrecision() === 32 ? bq : s1;
  }
  function Vw(r8, e8, t8) {
    let o8 = true;
    if ((Pt(r8) || Pt(e8)) && (o8 = false), Pt(r8) && Pt(e8) && (o8 = true), o8) {
      let a = r8.constructor.name, i10 = e8.constructor.name;
      if (a !== i10)
        throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i10}`);
    }
    if (Array.isArray(r8) && Array.isArray(e8)) {
      let a = ar(r8), i10 = ar(e8);
      if (!Cr(a, i10))
        throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i10}]`);
    }
    let n8 = Pt(r8) ? r8 : Fs(r8), s = Pt(e8) ? e8 : Fs(e8);
    if (n8.length !== s.length)
      throw new Error(`Arrays have different lengths actual: ${n8.length} vs expected: ${s.length}.
Actual:   ${n8}.
Expected: ${s}.`);
    for (let a = 0; a < s.length; ++a) {
      let i10 = n8[a], p = s[a];
      if (!t8(i10, p))
        throw new Error(`Arrays differ: actual[${a}] = ${i10}, expected[${a}] = ${p}.
Actual:   ${n8}.
Expected: ${s}.`);
    }
    typeof expect != "undefined" && expect().nothing();
  }
  function wq(r8, e8) {
    r8().then(() => e8.fail(), () => e8()), typeof expect != "undefined" && expect().nothing();
  }
  function Sq(r8, e8) {
    let t8 = typeof e8 == "string" || typeof e8 == "number" || typeof e8 == "boolean" ? [e8] : e8;
    return zo(r8) || zo(r8[0]) || zo(e8) || zo(e8[0]) ? Vw(r8, t8, (o8, n8) => o8 == n8) : Vw(r8, e8, (o8, n8) => Ww(o8, n8, 0));
  }
  function a1(r8, e8, t8) {
    if (t8 == null && (t8 = Md()), !Ww(r8, e8, t8))
      throw new Error(`Numbers differ: actual === ${r8}, expected === ${e8}`);
    typeof expect != "undefined" && expect().nothing();
  }
  function Ww(r8, e8, t8) {
    return !isFinite(r8) && !isFinite(e8) ? true : !(isNaN(r8) || isNaN(e8) || Math.abs(r8 - e8) > t8);
  }
  function Iq(r8, e8, t8) {
    for (let o8 = 0; o8 < r8.length; o8++)
      if (r8[o8] < e8 || r8[o8] > t8)
        throw new Error(`Value out of range:${r8[o8]} low: ${e8}, high: ${t8}`);
  }
  function vq(r8, e8) {
    let t8 = new Float32Array(r8), o8 = new Float32Array(e8);
    if (t8.length !== o8.length)
      throw new Error(`Expected ArrayBuffer to be of length ${o8.length}, but it was ${t8.length}`);
    for (let n8 = 0; n8 < o8.length; n8++)
      if (t8[n8] !== o8[n8])
        throw new Error(`Expected ArrayBuffer value at ${n8} to be ${o8[n8]} but got ${t8[n8]} instead`);
  }
  function i1(r8) {
    for (let e8 = 0; e8 < r8.length; e8++) {
      let t8 = r8[e8];
      Array.isArray(t8) ? i1(t8) : r8[e8] = eu(t8);
    }
    return r8;
  }
  function kq(r8) {
    let e8 = document.createElement("video");
    return "playsInline" in e8 && (e8.playsInline = true), e8.muted = true, e8.loop = true, e8.style.position = "fixed", e8.style.left = "0px", e8.style.top = "0px", e8.preload = "auto", e8.appendChild(r8), new Promise((t8) => {
      e8.addEventListener("loadeddata", (o8) => t8(e8)), e8.load();
    });
  }
  async function Nq(r8) {
    await r8.play(), "requestVideoFrameCallback" in r8 && await new Promise((e8) => {
      r8.requestVideoFrameCallback(e8);
    });
  }
  var ju = class {
    constructor(e8, t8, o8, n8, s) {
      this.mean = e8, this.stdDev = t8, this.dtype = o8, this.nextVal = NaN, this.truncated = n8, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
      let a = s || Math.random();
      this.random = zd.alea(a.toString());
    }
    nextValue() {
      if (!isNaN(this.nextVal)) {
        let n8 = this.nextVal;
        return this.nextVal = NaN, n8;
      }
      let e8, t8, o8 = false;
      for (; !o8; ) {
        let n8, s, a;
        do
          n8 = 2 * this.random() - 1, s = 2 * this.random() - 1, a = n8 * n8 + s * s;
        while (a >= 1 || a === 0);
        let i10 = Math.sqrt(-2 * Math.log(a) / a);
        e8 = this.mean + this.stdDev * n8 * i10, t8 = this.mean + this.stdDev * s * i10, (!this.truncated || this.isValidTruncated(e8)) && (o8 = true);
      }
      return (!this.truncated || this.isValidTruncated(t8)) && (this.nextVal = this.convertValue(t8)), this.convertValue(e8);
    }
    convertValue(e8) {
      return this.dtype == null || this.dtype === "float32" ? e8 : Math.round(e8);
    }
    isValidTruncated(e8) {
      return e8 <= this.upper && e8 >= this.lower;
    }
  };
  var Ld = class {
    constructor(e8, t8, o8, n8) {
      this.alpha = e8, this.beta = 1 / t8, this.dtype = o8;
      let s = n8 || Math.random();
      this.randu = zd.alea(s.toString()), this.randn = new ju(0, 1, o8, false, this.randu()), e8 < 1 ? this.d = e8 + 2 / 3 : this.d = e8 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
    }
    nextValue() {
      let e8, t8, o8, n8, s, a;
      for (; ; ) {
        do
          n8 = this.randn.nextValue(), a = 1 + this.c * n8;
        while (a <= 0);
        if (a *= a * a, e8 = n8 * n8, t8 = 1 - 0.331 * e8 * e8, o8 = 0.5 * e8 + this.d * (1 - a + Math.log(a)), s = this.randu(), s < t8 || Math.log(s) < o8)
          break;
      }
      return a = 1 / this.beta * this.d * a, this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a);
    }
    convertValue(e8) {
      return this.dtype === "float32" ? e8 : Math.round(e8);
    }
  };
  var Bd = class {
    constructor(e8 = 0, t8 = 1, o8, n8) {
      if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = e8, this.range = t8 - e8, this.dtype = o8, n8 == null && (n8 = Math.random()), typeof n8 == "number" && (n8 = n8.toString()), !this.canReturnFloat() && this.range <= 1)
        throw new Error(`The difference between ${e8} - ${t8} <= 1 and dtype is not float`);
      this.random = zd.alea(n8);
    }
    convertValue(e8) {
      return this.canReturnFloat() ? e8 : Math.round(e8);
    }
    nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  };
  function Tq(r8, e8, t8 = 1, o8 = "float32", n8) {
    if (wt(r8), t8 == null && (t8 = 1), o8 == null && (o8 = "float32"), o8 !== "float32" && o8 !== "int32")
      throw new Error(`Unsupported data type ${o8}`);
    let s = new Ld(e8, t8, o8, n8), a = me(r8, o8);
    for (let i10 = 0; i10 < a.values.length; i10++)
      a.values[i10] = s.nextValue();
    return a.toTensor();
  }
  var p1 = N({ randomGamma_: Tq });
  function _q(r8, e8 = 0, t8 = 1, o8, n8) {
    if (wt(r8), o8 != null && o8 === "bool")
      throw new Error(`Unsupported data type ${o8}`);
    let s = new ju(e8, t8, o8, false, n8), a = me(r8, o8);
    for (let i10 = 0; i10 < a.values.length; i10++)
      a.values[i10] = s.nextValue();
    return a.toTensor();
  }
  var Vd = N({ randomNormal_: _q });
  function $q(r8, e8, t8) {
    if (e8 != null && e8 === "bool")
      throw new Error(`Unsupported data type ${e8}`);
    return Vd(r8, 0, 1, e8, t8);
  }
  var c1 = N({ randomStandardNormal_: $q });
  function Eq(r8, e8 = 0, t8 = 1, o8 = "float32", n8) {
    wt(r8);
    let s = me(r8, o8), a = new Bd(e8, t8, null, n8);
    for (let i10 = 0; i10 < s.values.length; i10++)
      s.values[i10] = a.nextValue();
    return s.toTensor();
  }
  var pc = N({ randomUniform_: Eq });
  function Rq(r8, e8, t8, o8) {
    return pc(r8, e8, t8, "int32", o8);
  }
  var l1 = N({ randomUniformInt_: Rq });
  function cu(r8, e8, t8 = 1, o8 = "float32") {
    if (t8 === 0)
      throw new Error("Cannot have a step of zero");
    let n8 = { start: r8, stop: e8, step: t8, dtype: o8 };
    return T.runKernel(la, {}, n8);
  }
  function Dq(r8) {
    let t8 = { input: v(r8, "input", "real") };
    return T.runKernel(Gi, t8);
  }
  var ui = N({ real_: Dq });
  function Aq(r8) {
    let t8 = { x: v(r8, "x", "reciprocal") };
    return T.runKernel(ns, t8);
  }
  var m1 = N({ reciprocal_: Aq });
  function Fq(r8) {
    let t8 = { x: v(r8, "x", "relu") };
    return T.runKernel(ss, t8);
  }
  var lu = N({ relu_: Fq });
  function Pq(r8) {
    let t8 = { x: v(r8, "x", "relu6") };
    return T.runKernel(us, t8);
  }
  var Wd = N({ relu6_: Pq });
  function Oq(r8, e8) {
    let o8 = { x: v(r8, "x", "reverse") }, n8 = { dims: e8 };
    return T.runKernel(ps, o8, n8);
  }
  var lo = N({ reverse_: Oq });
  function Mq(r8) {
    let e8 = v(r8, "x", "reverse");
    return $(e8.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${e8.rank}.`), lo(e8, 0);
  }
  var d1 = N({ reverse1d_: Mq });
  function Lq(r8, e8) {
    let t8 = v(r8, "x", "reverse");
    return $(t8.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${t8.rank}.`), lo(t8, e8);
  }
  var f1 = N({ reverse2d_: Lq });
  function Bq(r8, e8) {
    let t8 = v(r8, "x", "reverse");
    return $(t8.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${t8.rank}.`), lo(t8, e8);
  }
  var h1 = N({ reverse3d_: Bq });
  function zq(r8, e8) {
    let t8 = v(r8, "x", "reverse");
    return $(t8.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${t8.rank}.`), lo(t8, e8);
  }
  var g1 = N({ reverse4d_: zq });
  function Vq(r8) {
    let t8 = { x: v(r8, "x", "round") };
    return T.runKernel(cs, t8);
  }
  var Ud = N({ round_: Vq });
  function Wq(r8) {
    let t8 = { x: v(r8, "x", "rsqrt", "float32") };
    return T.runKernel(ls, t8);
  }
  var x1 = N({ rsqrt_: Wq });
  function Uq(r8) {
    let t8 = { x: v(r8, "x", "selu") };
    return T.runKernel(hs, t8);
  }
  var y1 = N({ selu_: Uq });
  function Gq(r8, e8, t8, o8, n8, s = [1, 1], a = "NHWC") {
    let i10 = v(r8, "x", "separableConv2d"), p = v(e8, "depthwiseFilter", "separableConv2d"), u = v(t8, "pointwiseFilter", "separableConv2d"), c = i10, l = false;
    if (i10.rank === 3 && (l = true, c = W(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]])), a === "NCHW")
      throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    $(c.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`), $(p.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`), $(u.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`), $(u.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`), $(u.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);
    let m = p.shape[2], d = p.shape[3];
    $(u.shape[2] === m * d, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${m * d}, but got ${u.shape[2]}.`);
    let f = ic(c, p, o8, n8, a, s), g = iu(f, u, 1, "valid", a);
    return l ? W(g, [g.shape[1], g.shape[2], g.shape[3]]) : g;
  }
  var b1 = N({ separableConv2d_: Gq });
  async function Hq(r8, e8) {
    let t8 = v(r8, "x", "setdiff1d"), o8 = v(e8, "y", "setdiff1d");
    $(t8.dtype === o8.dtype, () => `x and y should have the same dtype, but got x (${t8.dtype}) and y (${o8.dtype}).`), $(t8.rank === 1, () => `x should be 1D tensor, but got x (${t8.shape}).`), $(o8.rank === 1, () => `y should be 1D tensor, but got y (${o8.shape}).`);
    let n8 = await t8.data(), s = await o8.data(), a = new Set(s), i10 = 0;
    for (let c = 0; c < n8.length; c++)
      a.has(n8[c]) || i10++;
    let p = new tt([i10], t8.dtype), u = new tt([i10], "int32");
    for (let c = 0, l = 0; c < n8.length; c++)
      a.has(n8[c]) || (p.values[l] = n8[c], u.values[l] = c, l++);
    return [p.toTensor(), u.toTensor()];
  }
  var C1 = Hq;
  function Kq(r8) {
    let t8 = { x: v(r8, "x", "sign") };
    return T.runKernel(ys, t8);
  }
  var w1 = N({ sign_: Kq });
  function qq(r8) {
    let t8 = { x: v(r8, "x", "sin", "float32") };
    return T.runKernel(gs, t8);
  }
  var S1 = N({ sin_: qq });
  function jq(r8) {
    let t8 = { x: v(r8, "x", "sinh") };
    return T.runKernel(xs, t8);
  }
  var I1 = N({ sinh_: jq });
  function Xq(r8, e8, t8) {
    let o8 = v(r8, "x", "slice1d");
    return $(o8.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${o8.rank} tensor`), Xe(o8, [e8], [t8]);
  }
  var v1 = N({ slice1d_: Xq });
  function Yq(r8, e8, t8) {
    let o8 = v(r8, "x", "slice2d");
    return $(o8.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${o8.rank} tensor`), Xe(o8, e8, t8);
  }
  var k1 = N({ slice2d_: Yq });
  function Qq(r8, e8, t8) {
    let o8 = v(r8, "x", "slice3d");
    return $(o8.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${o8.rank} tensor`), Xe(o8, e8, t8);
  }
  var N1 = N({ slice3d_: Qq });
  function Zq(r8, e8, t8) {
    let o8 = v(r8, "x", "slice4d");
    return $(o8.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${o8.rank} tensor`), Xe(o8, e8, t8);
  }
  var T1 = N({ slice4d_: Zq });
  function Jq(r8, e8 = -1) {
    let t8 = v(r8, "logits", "softmax", "float32");
    if (e8 === -1 && (e8 = t8.rank - 1), e8 !== t8.rank - 1)
      throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t8.rank} and dim was ${e8}`);
    let o8 = { logits: t8 }, n8 = { dim: e8 };
    return T.runKernel(Is, o8, n8);
  }
  var _1 = N({ softmax_: Jq });
  function e6(r8) {
    $(r8.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${r8.dtype}.`);
    let e8 = { input: r8 };
    return T.runKernel(Bi, e8);
  }
  var cc = N({ fft_: e6 });
  function t6(r8) {
    $(r8.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${r8.dtype}.`);
    let e8 = { input: r8 };
    return T.runKernel(zi, e8);
  }
  var Xu = N({ ifft_: t6 });
  function r6(r8) {
    let e8 = r8.shape[r8.shape.length - 1], t8 = r8.size / e8, o8;
    if (e8 <= 2) {
      let n8 = W(r8, [t8, e8]);
      o8 = Xu(n8);
    } else {
      let n8 = [t8, 2 * (e8 - 1)], s = W(ui(r8), [t8, e8]), a = W(pu(r8), [t8, e8]), i10 = lo(Xe(s, [0, 1], [t8, e8 - 2]), 1), p = se(lo(Xe(a, [0, 1], [t8, e8 - 2]), 1), ke(-1)), u = bt([s, i10], 1), c = bt([a, p], 1), l = W(Er(u, c), [n8[0], n8[1]]);
      o8 = Xu(l);
    }
    if (o8 = ui(o8), r8.rank === 3 && r8.shape[0] !== 0) {
      let n8 = o8, s = r8.shape[0];
      o8 = W(o8, [s, o8.shape[0] / s, o8.shape[1]]), n8.dispose();
    }
    return o8;
  }
  var Gd = N({ irfft_: r6 });
  function o6(r8, e8, t8 = 0) {
    let n8 = { x: v(r8, "x", "split") }, s = { numOrSizeSplits: e8, axis: t8 };
    return T.runKernel(ga, n8, s);
  }
  var pi = N({ split_: o6 });
  function n6(r8, e8) {
    $(r8.dtype === "float32", () => `The dtype for rfft() must be real value but got ${r8.dtype}`);
    let t8 = r8.shape[r8.shape.length - 1], o8 = r8.size / t8, n8;
    if (e8 != null && e8 < t8) {
      let f = r8.shape.map((g) => 0), h = r8.shape.map((g) => g);
      h[r8.shape.length - 1] = e8, n8 = Xe(r8, f, h), t8 = e8;
    } else if (e8 != null && e8 > t8) {
      let f = r8.shape.map((h) => h);
      f[r8.shape.length - 1] = e8 - t8, n8 = bt([r8, Gr(f)], r8.shape.length - 1), t8 = e8;
    } else
      n8 = r8;
    let s = Ht(n8), a = W(Er(n8, s), [o8, t8]), i10 = cc(a), p = Math.floor(t8 / 2) + 1, u = ui(i10), c = pu(i10), l = pi(u, [p, t8 - p], u.shape.length - 1), m = pi(c, [p, t8 - p], c.shape.length - 1), d = n8.shape.slice();
    return d[n8.shape.length - 1] = p, W(Er(l[0], m[0]), d);
  }
  var lc = N({ rfft_: n6 });
  function s6(r8, e8) {
    let t8 = v(r8, "a", "squaredDifference"), o8 = v(e8, "b", "squaredDifference");
    [t8, o8] = Oe(t8, o8), rt(t8.shape, o8.shape);
    let n8 = { a: t8, b: o8 }, s = {};
    return T.runKernel(ks, n8, s);
  }
  var Hd = N({ squaredDifference_: s6 });
  function a6(r8, e8) {
    let t8 = v(r8, "x", "squeeze", "string_or_numeric");
    return W(t8, KC(t8.shape, e8).newShape);
  }
  var mc = N({ squeeze_: a6 });
  function i6(r8, e8 = 0) {
    let t8 = ri(r8, "tensors", "stack", "string_or_numeric");
    $(t8.length >= 1, () => "Pass at least one tensor to tf.stack"), t8.length > 0 && $(e8 <= t8[0].rank, () => "Axis must be <= rank of the tensor");
    let o8 = t8, n8 = { axis: e8 };
    return T.runKernel(ca, o8, n8);
  }
  var kr = N({ stack_: i6 });
  function u6(r8, e8 = 0) {
    let o8 = { x: v(r8, "x", "step") }, n8 = { alpha: e8 };
    return T.runKernel(wo, o8, n8);
  }
  var Kd = N({ step_: u6 });
  function p6(r8, e8, t8, o8, n8 = 0, s = 0, a = 0, i10 = 0, p = 0) {
    let c = { x: v(r8, "x", "stridedSlice", "string_or_numeric") }, l = { begin: e8, end: t8, strides: o8, beginMask: n8, endMask: s, ellipsisMask: a, newAxisMask: i10, shrinkAxisMask: p };
    return T.runKernel(Ns, c, l);
  }
  var $1 = N({ stridedSlice_: p6 });
  function c6(r8) {
    let t8 = { x: v(r8, "x", "tan", "float32") };
    return T.runKernel(_s, t8);
  }
  var E1 = N({ tan_: c6 });
  function xr(r8, e8) {
    ao(r8);
    let t8 = ar(r8, e8);
    if (t8.length !== 1)
      throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return Sr(r8, null, t8, e8);
  }
  function mu(r8, e8, t8) {
    if (ao(r8), e8 != null && e8.length !== 2)
      throw new Error("tensor2d() requires shape to have two numbers");
    let o8 = ar(r8, t8);
    if (o8.length !== 2 && o8.length !== 1)
      throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (o8.length === 1 && e8 == null)
      throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return Sr(r8, e8, o8, t8);
  }
  function qd(r8, e8, t8) {
    if (ao(r8), e8 != null && e8.length !== 3)
      throw new Error("tensor3d() requires shape to have three numbers");
    let o8 = ar(r8, t8);
    if (o8.length !== 3 && o8.length !== 1)
      throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    if (o8.length === 1 && e8 == null)
      throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    return Sr(r8, e8, o8, t8);
  }
  function R1(r8, e8, t8) {
    if (ao(r8), e8 != null && e8.length !== 4)
      throw new Error("tensor4d() requires shape to have four numbers");
    let o8 = ar(r8, t8);
    if (o8.length !== 4 && o8.length !== 1)
      throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    if (o8.length === 1 && e8 == null)
      throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    return Sr(r8, e8, o8, t8);
  }
  function D1(r8, e8, t8) {
    if (ao(r8), e8 != null && e8.length !== 5)
      throw new Error("tensor5d() requires shape to have five numbers");
    let o8 = ar(r8, t8);
    if (o8.length !== 5 && o8.length !== 1)
      throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    if (o8.length === 1 && e8 == null)
      throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    return Sr(r8, e8, o8, t8);
  }
  function A1(r8, e8, t8) {
    if (ao(r8), e8 != null && e8.length !== 6)
      throw new Error("tensor6d() requires shape to have six numbers");
    let o8 = ar(r8, t8);
    if (o8.length !== 6 && o8.length !== 1)
      throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    if (o8.length === 1 && e8 == null)
      throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    return e8 = e8 || o8, Sr(r8, e8, o8, t8);
  }
  var du = {};
  Ke(du, { calculateShapes: () => F1, validateInput: () => dc, validateUpdateShape: () => Uw });
  function Uw(r8, e8, t8) {
    let o8 = e8.rank > 1 ? e8.shape[e8.rank - 1] : 1, n8 = e8.rank > 1 ? e8.rank - 1 : 1, s = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t8.shape}, indices.shape: ${e8.shape}, shape: ${r8}, sliceDim: ${o8}, and batchDim: ${n8}.`;
    if (t8.rank < n8)
      throw new Error(s + ` update.rank < ${n8}. `);
    if (r8.length < o8 + (t8.rank - n8))
      throw new Error(s + ` Output shape length < ${o8 + (t8.rank - n8)}`);
    if (t8.rank !== n8 + r8.length - o8)
      throw new Error(s + ` update.rank != ${n8 + r8.length - o8}`);
    for (let a = 0; a < n8; ++a)
      if (t8.shape[a] !== e8.shape[a])
        throw new Error(s + ` updates.shape[${a}] (${t8.shape[a]}) != indices.shape[${a}] (${e8.shape[a]}).`);
    for (let a = 0; a < t8.rank - n8; ++a)
      if (t8.shape[a + n8] !== r8[a + o8])
        throw new Error(s + ` updates.shape[${a + n8}] (${t8.shape[a + n8]}) != shape[${a + n8}] (${r8[a + n8]})`);
  }
  function dc(r8, e8, t8) {
    if (e8.rank < 1)
      throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e8.rank}.`);
    if (r8.rank < 1)
      throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r8.rank}.`);
    if (e8.dtype !== "int32")
      throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e8.dtype}`);
    if (t8.length < 1)
      throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t8}`);
    if (t8.length === 0) {
      if (e8.size === 0)
        throw new Error(`Indices specified for empty output. indices shape: ${e8.shape}`);
      if (r8.size === 0)
        throw new Error(`Updates specified for empty output. updates shape: ${r8.shape}`);
    }
    Uw(t8, e8, r8);
  }
  function F1(r8, e8, t8) {
    let o8 = e8.shape.length, n8 = o8 > 1 ? e8.shape[o8 - 1] : 1, s = t8.length, a = 1;
    for (let l = n8; l < s; ++l)
      a *= t8[l];
    let i10 = n8 < 1 ? 1 : n8, p = Ge(e8.shape) / i10, u = [...qs(t8.slice(0, n8)), 1], c = Ge(t8);
    return { sliceRank: n8, numUpdates: p, sliceSize: a, strides: u, outputSize: c };
  }
  function l6(r8, e8, t8) {
    let o8 = v(r8, "tensor", "tensorScatterupdate"), n8 = v(e8, "indices", "tensorScatterupdate", "int32"), s = v(t8, "updates", "tensorScatterupdate");
    if (dc(s, n8, o8.shape), o8.dtype !== s.dtype)
      throw new Error(`tensor and updates must have the same dtype, instead they are ${o8.dtype} and ${s.dtype}.`);
    let a = { tensor: o8, indices: n8, updates: s }, i10 = {};
    return T.runKernel(ds, a, i10);
  }
  var P1 = N({ tensorScatterUpdate_: l6 });
  function m6(r8, e8 = 1, t8 = true) {
    let o8 = v(r8, "x", "topk");
    if (o8.rank === 0)
      throw new Error("topk() expects the input to be of rank 1 or higher");
    let n8 = o8.shape[o8.shape.length - 1];
    if (e8 < 0)
      throw new Error(`'k' passed to topk() must be >= 0 but got ${e8}`);
    if (e8 > n8)
      throw new Error(`'k' passed to topk() must be <= the last dimension (${n8}) but got ${e8}`);
    let s = { x: o8 }, a = { k: e8, sorted: t8 }, [i10, p] = T.runKernel(Es, s, a);
    return { values: i10, indices: p };
  }
  var O1 = N({ topk_: m6 });
  function d6(r8, e8 = 0, t8 = 1, o8, n8) {
    if (wt(r8), o8 != null && o8 === "bool")
      throw new Error("Unsupported data type $ { dtype }");
    let s = new ju(e8, t8, o8, true, n8), a = me(r8, o8);
    for (let i10 = 0; i10 < a.values.length; i10++)
      a.values[i10] = s.nextValue();
    return a.toTensor();
  }
  var M1 = N({ truncatedNormal_: d6 });
  function f6(r8, e8 = 0) {
    let t8 = v(r8, "x", "unique", "string_or_numeric");
    $(t8.rank > 0, () => "The input tensor must be at least 1D");
    let o8 = { x: t8 }, n8 = { axis: e8 }, [s, a] = T.runKernel(Qi, o8, n8);
    return { values: s, indices: a };
  }
  var L1 = N({ unique_: f6 });
  function h6(r8, e8, t8) {
    let o8 = v(r8, "x", "unsortedSegmentSum"), n8 = v(e8, "segmentIds", "unsortedSegmentSum", "int32");
    $(Ga(t8), () => "numSegments must be of dtype int");
    let s = { x: o8, segmentIds: n8 }, a = { numSegments: t8 };
    return T.runKernel(Zi, s, a);
  }
  var B1 = N({ unsortedSegmentSum_: h6 });
  function g6(r8, e8 = 0) {
    let t8 = v(r8, "x", "unstack", "string_or_numeric");
    $(e8 >= -t8.shape.length && e8 < t8.shape.length, () => `Axis = ${e8} is not in [-${t8.shape.length}, ${t8.shape.length})`);
    let o8 = { value: t8 }, n8 = { axis: e8 };
    return T.runKernel(ya, o8, n8);
  }
  var mo = N({ unstack_: g6 });
  function z1(r8, e8) {
    return Nl(r8, e8, "right");
  }
  function V1(r8, e8 = true, t8, o8) {
    return T.makeVariable(r8, e8, t8, o8);
  }
  function jd(r8, e8) {
    let t8 = [];
    for (let s = 0; s < e8.length; s++)
      e8[s] && t8.push(s);
    let o8 = me(r8, "int32"), n8 = me([t8.length, r8.length], "int32");
    for (let s = 0; s < t8.length; s++) {
      let a = o8.indexToLoc(t8[s]), i10 = s * r8.length;
      n8.values.set(a, i10);
    }
    return n8.toTensor();
  }
  async function x6(r8) {
    let e8 = v(r8, "condition", "whereAsync", "bool"), t8 = await e8.data(), o8 = jd(e8.shape, t8);
    return r8 !== e8 && e8.dispose(), o8;
  }
  var Xd = x6;
  async function y6(r8, e8, t8) {
    let o8 = v(r8, "tensor", "boolMask"), n8 = v(e8, "mask", "boolMask", "bool"), s = t8 == null ? 0 : t8, a = n8.rank, i10 = o8.shape;
    $(a > 0, () => "mask cannot be scalar"), yt(i10.slice(s, s + a), n8.shape, "mask's shape must match the first K dimensions of tensor's shape,");
    let p = 1;
    for (let h = s; h < s + a; h++)
      p *= i10[h];
    let u = i10.slice(0, s).concat([p], i10.slice(s + a)), c = W(o8, u), l = W(n8, [-1]), m = await Xd(l), d = mc(m, [1]), f = wd(c, d, s);
    return r8 !== o8 && o8.dispose(), e8 !== n8 && n8.dispose(), d.dispose(), c.dispose(), l.dispose(), m.dispose(), f;
  }
  var b6 = y6;
  function C6(r8, e8, t8) {
    let o8 = v(r8, "x", "transpose");
    if (e8 == null && (e8 = o8.shape.map((a, i10) => i10).reverse()), $(o8.rank === e8.length, () => `Error in transpose: rank of input ${o8.rank} must match length of perm ${e8}.`), e8.forEach((a) => {
      $(a >= 0 && a < o8.rank, () => `All entries in 'perm' must be between 0 and ${o8.rank - 1} but got ${e8}`);
    }), o8.rank <= 1)
      return o8.clone();
    let n8 = { x: o8 }, s = { perm: e8 };
    return o8.dtype === "complex64" ? De(() => {
      let a = ui(o8), i10 = pu(o8);
      return a = T.runKernel(po, { x: a }, s), i10 = T.runKernel(po, { x: i10 }, s), t8 && (i10 = pr(i10)), Er(a, i10);
    }) : T.runKernel(po, n8, s);
  }
  var fc = N({ transpose_: C6 });
  function w6(r8, e8, t8, o8, n8 = true) {
    let s = v(r8, "v", "movingAverage"), a = v(e8, "x", "movingAverage"), i10 = v(t8, "decay", "movingAverage");
    dw(s, a), $(Cr(s.shape, a.shape), () => "Shape mismatch in v and x");
    let p = ke(1), u = Te(p, i10), c = se(Te(a, s), u);
    if (n8) {
      $(o8 != null, () => "When using zeroDebias: true, step is required.");
      let l = v(o8, "step", "movingAverage");
      c = je(c, Te(p, si(i10, l)));
    }
    return Ce(s, c);
  }
  var S6 = N({ movingAverage_: w6 });
  function I6(r8, e8, t8) {
    wt(t8);
    let o8 = v(r8, "indices", "scatterND", "int32"), n8 = v(e8, "updates", "scatterND");
    dc(n8, o8, t8);
    let s = { indices: o8, updates: n8 }, a = { shape: t8 };
    return T.runKernel(ms, s, a);
  }
  var v6 = N({ scatterND_: I6 });
  function W1(r8, e8, t8, o8) {
    if (r8.dtype !== "int32")
      throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r8.dtype}.`);
    if (r8.rank > 2)
      throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r8.shape}.`);
    let n8 = r8.rank > 0 ? r8.shape[0] : 1, s = r8.rank > 1 ? r8.shape[1] : 1;
    if (t8.length !== s)
      throw new Error(`outputShape has incorrect number of elements:, ${t8.length}, should be: ${s}.`);
    let a = e8.size;
    if (!(e8.rank === 0 || e8.rank === 1 && a === n8))
      throw new Error(`sparseValues has incorrect shape ${e8.shape}, should be [] or [${n8}]`);
    if (e8.dtype !== o8.dtype)
      throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }
  function N6(r8, e8, t8, o8 = 0) {
    wt(t8);
    let n8 = v(r8, "sparseIndices", "sparseToDense", "int32"), s = v(e8, "sparseValues", "sparseToDense", "string_or_numeric"), a = v(o8, "defaultValue", "sparseToDense", s.dtype);
    W1(n8, s, t8, a);
    let i10 = { sparseIndices: n8, sparseValues: s, defaultValue: a }, p = { outputShape: t8 };
    return T.runKernel(vs, i10, p);
  }
  var T6 = N({ sparseToDense_: N6 });
  function _6(r8, e8) {
    let t8 = v(e8, "indices", "gatherND", "int32"), n8 = { params: v(r8, "x", "gatherND", "string_or_numeric"), indices: t8 };
    return T.runKernel(vn, n8);
  }
  var $6 = N({ gatherND_: _6 });
  function U1(r8, e8) {
    if (e8 == null)
      return r8.shape.slice();
    if (Cr(r8.shape, e8))
      return e8;
    if (r8.shape.length === e8.length) {
      let t8 = [];
      for (let o8 = 0; o8 < r8.shape.length; o8++)
        e8[o8] == null && r8.shape[o8] != null ? t8.push(r8.shape[o8]) : t8.push(e8[o8]);
      return t8;
    }
    return e8;
  }
  function E6(r8, e8, t8, o8) {
    let n8 = v(r8, "x", "dropout");
    if ($(n8.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${n8.dtype} tensor instead.`), $(e8 >= 0 && e8 < 1, () => `rate must be a float in the range [0, 1), but got ${e8}.`), e8 === 0)
      return r8 instanceof ut ? n8.clone() : n8;
    let s = U1(n8, t8), a = 1 - e8, i10 = je(Cd(Ce(pc(s, 0, 1, "float32", o8), a)), a);
    return se(n8, i10);
  }
  var R6 = N({ dropout_: E6 });
  function Gw(r8) {
    return Math.floor(Math.pow(2, Math.ceil(Math.log(r8) / Math.log(2))));
  }
  function _l(r8, e8, t8) {
    let o8 = 1 - r8 % 2, n8 = new Float32Array(r8);
    for (let s = 0; s < r8; ++s) {
      let a = 2 * Math.PI * s / (r8 + o8 - 1);
      n8[s] = e8 - t8 * Math.cos(a);
    }
    return xr(n8, "float32");
  }
  async function D6(r8, e8, t8 = 1) {
    let o8 = v(r8, "predictions", "inTopK"), n8 = v(e8, "targets", "inTopK");
    $(o8.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${o8.rank}`), $(o8.rank - 1 === n8.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${o8.rank} and targets rank ${n8.rank}`), yt(o8.shape.slice(0, o8.shape.length - 1), n8.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
    let s = o8.shape[o8.shape.length - 1];
    $(t8 > 0 && t8 <= s, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t8}`);
    let a = await o8.data(), i10 = await n8.data(), [p, u] = [a.length / s, s], c = qC("bool", p);
    for (let l = 0; l < p; l++) {
      let m = l * u, d = a.subarray(m, m + u), f = [];
      for (let h = 0; h < d.length; h++)
        f.push({ value: d[h], index: h });
      f.sort((h, g) => g.value - h.value), c[l] = 0;
      for (let h = 0; h < t8; h++)
        if (f[h].index === i10[l]) {
          c[l] = 1;
          break;
        }
    }
    return r8 !== o8 && o8.dispose(), e8 !== n8 && n8.dispose(), ir(c, n8.shape, "bool");
  }
  var A6 = D6;
  var Hw = {};
  Ke(Hw, { conv2d: () => H1, depthwiseConv2d: () => j1, matMul: () => X1 });
  function F6(r8, e8, t8, o8, n8, s = "NHWC", a) {
    let i10 = r8;
    r8.rank === 3 && (i10 = W(r8, [1, r8.shape[0], r8.shape[1], r8.shape[2]]));
    let p = e8;
    p.rank === 3 && (p = W(e8, [1, e8.shape[0], e8.shape[1], e8.shape[2]])), $(i10.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${i10.shape}.`), $(p.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${p.shape}.`), $(t8.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${t8}.`);
    let u = s === "NHWC" ? i10.shape[3] : i10.shape[1], c = s === "NHWC" ? p.shape[3] : p.shape[1];
    $(u === t8[2], () => `Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t8[2]}.`), $(c === t8[3], () => `Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t8[3]}).`), Lt("conv2dDerFilter", n8, a);
    let l = { x: i10, dy: p }, m = { strides: o8, pad: n8, dataFormat: s, dimRoundingMode: a, filterShape: t8 };
    return T.runKernel(Ai, l, m);
  }
  var G1 = N({ conv2DBackpropFilter_: F6 });
  function Yu(r8, e8, t8) {
    if (t8 == null || t8 === "linear")
      return r8;
    if (t8 === "relu")
      return se(r8, Kd(e8));
    throw new Error(`Cannot compute gradient for fused activation ${t8}.`);
  }
  function Qu(r8, e8) {
    let t8 = e8, o8 = gd(r8.shape, e8.shape);
    return o8.length > 0 && (t8 = ot(t8, o8)), W(t8, r8.shape);
  }
  function Zu(r8, e8, t8, o8) {
    if (e8 === "linear")
      return r8;
    if (e8 === "relu")
      return lu(r8);
    if (e8 === "elu")
      return yd(r8);
    if (e8 === "relu6")
      return Wd(r8);
    if (e8 === "prelu")
      return Pd(r8, t8);
    if (e8 === "leakyrelu")
      return Id(r8, o8);
    if (e8 === "sigmoid")
      return Na(r8);
    throw new Error(`Unknown fused activation ${e8}.`);
  }
  var Ju = (r8, e8) => !(r8 > 0) || e8 === "linear";
  function P6({ x: r8, filter: e8, strides: t8, pad: o8, dataFormat: n8 = "NHWC", dilations: s = [1, 1], dimRoundingMode: a, bias: i10, activation: p = "linear", preluActivationWeights: u, leakyreluAlpha: c }) {
    if (p = p || "linear", Ju(T.state.gradientDepth, p) === false) {
      $(n8 === "NHWC", () => `Error in fused conv2d: got dataFormat of ${n8} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
      let _ = iu(r8, e8, t8, o8, n8, s, a);
      return i10 != null && (_ = Ce(_, i10)), Zu(_, p, u, c);
    }
    let l = v(r8, "x", "conv2d", "float32"), m = v(e8, "filter", "conv2d", "float32"), d = l, f = false;
    l.rank === 3 && (f = true, d = W(l, [1, l.shape[0], l.shape[1], l.shape[2]])), $(d.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`), $(m.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`), Lt("fused conv2d", o8, a);
    let h = n8 === "NHWC" ? d.shape[3] : d.shape[1];
    $(m.shape[2] === h, () => `Error in conv2d: depth of input (${h}) must match input depth for filter ${m.shape[2]}.`), $(gr(t8, s), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${t8} and dilations '${s}'`);
    let g = Vu(d.shape, m.shape, t8, s, o8, a), x;
    i10 != null && (x = v(i10, "bias", "fused conv2d"), [x] = Oe(x, l), n8 === "NHWC" ? rt(g.outShape, x.shape) : ($(x.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`), $(x.shape.length === 0 || x.shape[0] === g.outChannels || x.shape[0] === 1, () => `Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)));
    let b;
    if (u != null) {
      let _ = u.shape;
      if ($(_.length <= 1 || _.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`), _.length === 1)
        $(_[0] === 1 || _[0] === g.outChannels, () => `Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${g.outChannels}).`);
      else if (_.length === 3)
        try {
          rt(_, g.outShape);
        } catch (E) {
          let R = `Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${g.outShape}).`;
          throw Error(R);
        }
      b = v(u, "prelu weights", "fused conv2d");
    }
    let C = (_, E) => {
      $(n8 === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${n8} but only NHWC is currently supported.`);
      let [R, D, P, O] = E, M = Yu(_, P, p);
      $(zu(s), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);
      let L = hd(D.shape, M, R, t8, o8), B = G1(D, M, R.shape, t8, o8), z = [L, B];
      if (O != null) {
        let U = Qu(O, M);
        z.push(U);
      }
      return z;
    }, S = { x: d, filter: m, bias: x, preluActivationWeights: b }, k = { strides: t8, pad: o8, dataFormat: n8, dilations: s, dimRoundingMode: a, activation: p, leakyreluAlpha: c };
    return i10 == null ? vr((E, R, D) => {
      let P = T.runKernel(Io, S, k);
      return D([R, E, P]), f && (P = W(P, [P.shape[1], P.shape[2], P.shape[3]])), { value: P, gradFunc: C };
    })(d, m) : vr((E, R, D, P) => {
      let O = T.runKernel(Io, S, k);
      return P([R, E, O, D]), f && (O = W(O, [O.shape[1], O.shape[2], O.shape[3]])), { value: O, gradFunc: C };
    })(d, m, x);
  }
  var H1 = N({ fusedConv2d_: P6 });
  function O6(r8, e8, t8, o8, n8, s = [1, 1], a) {
    let i10 = r8;
    r8.rank === 3 && (i10 = W(r8, [1, r8.shape[0], r8.shape[1], r8.shape[2]]));
    let p = e8;
    p.rank === 3 && (p = W(e8, [1, e8.shape[0], e8.shape[1], e8.shape[2]]));
    let u = { x: i10, dy: p }, c = { strides: o8, pad: n8, dimRoundingMode: a, dilations: s, filterShape: t8 };
    return T.runKernel(Fi, u, c);
  }
  var K1 = N({ depthwiseConv2dNativeBackpropFilter_: O6 });
  function M6(r8, e8, t8, o8, n8, s = [1, 1], a) {
    let i10 = e8, p = false;
    e8.rank === 3 && (p = true, i10 = W(e8, [1, e8.shape[0], e8.shape[1], e8.shape[2]]));
    let u = { dy: i10, filter: t8 }, c = { strides: o8, pad: n8, dimRoundingMode: a, dilations: s, inputShape: r8 }, l = T.runKernel(Pi, u, c);
    return p ? W(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
  }
  var q1 = N({ depthwiseConv2dNativeBackpropInput_: M6 });
  function L6({ x: r8, filter: e8, strides: t8, pad: o8, dataFormat: n8 = "NHWC", dilations: s = [1, 1], dimRoundingMode: a, bias: i10, activation: p = "linear", preluActivationWeights: u, leakyreluAlpha: c }) {
    if (Ju(T.state.gradientDepth, p) === false) {
      let k = ic(r8, e8, t8, o8, n8, s, a);
      return i10 != null && (k = Ce(k, i10)), Zu(k, p, u, c);
    }
    let l = v(r8, "x", "depthwiseConv2d", "float32"), m = v(e8, "filter", "depthwiseConv2d", "float32"), d = l, f = false;
    l.rank === 3 && (f = true, d = W(l, [1, l.shape[0], l.shape[1], l.shape[2]])), $(d.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`), $(m.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`), $(d.shape[3] === m.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`), s == null && (s = [1, 1]), $(gr(t8, s), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t8} and dilations '${s}'`), Lt("fused depthwiseConv2d", o8, a);
    let h = Vu(d.shape, m.shape, t8, s, o8, a, true), g;
    i10 != null && (g = v(i10, "bias", "fused conv2d"), [g] = Oe(g, l), rt(h.outShape, g.shape));
    let x;
    u != null && (x = v(u, "prelu weights", "fused depthwiseConv2d"));
    let b = (k, _) => {
      $(zu(s), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);
      let [E, R, D, P] = _, O = Yu(k, D, p), M = q1(R.shape, O, E, t8, o8, s, a), L = K1(R, O, E.shape, t8, o8, s, a);
      if (P != null) {
        let B = Qu(g, O);
        return [M, L, B];
      }
      return [M, L];
    }, C = { x: d, filter: m, bias: g, preluActivationWeights: x }, S = { strides: t8, pad: o8, dataFormat: n8, dilations: s, dimRoundingMode: a, activation: p, leakyreluAlpha: c };
    return i10 == null ? vr((_, E, R) => {
      let D = T.runKernel(vo, C, S);
      return R([E, _, D]), f && (D = W(D, [D.shape[1], D.shape[2], D.shape[3]])), { value: D, gradFunc: b };
    })(d, m) : vr((_, E, R, D) => {
      let P = T.runKernel(vo, C, S);
      return D([E, _, P, R]), f && (P = W(P, [P.shape[1], P.shape[2], P.shape[3]])), { value: P, gradFunc: b };
    })(d, m, g);
  }
  var j1 = N({ fusedDepthwiseConv2d_: L6 });
  function B6({ a: r8, b: e8, transposeA: t8 = false, transposeB: o8 = false, bias: n8, activation: s = "linear", preluActivationWeights: a, leakyreluAlpha: i10 = 0.2 }) {
    if (Ju(T.state.gradientDepth, s) === false) {
      let O = Ze(r8, e8, t8, o8);
      return n8 != null && (O = Ce(O, n8)), Zu(O, s, a, i10);
    }
    let p = v(r8, "a", "fused matMul"), u = v(e8, "b", "fused matMul");
    [p, u] = Oe(p, u);
    let c = t8 ? p.shape[p.rank - 2] : p.shape[p.rank - 1], l = o8 ? u.shape[u.rank - 1] : u.shape[u.rank - 2], m = t8 ? p.shape[p.rank - 1] : p.shape[p.rank - 2], d = o8 ? u.shape[u.rank - 2] : u.shape[u.rank - 1], f = p.shape.slice(0, -2), h = u.shape.slice(0, -2), g = Ge(f), x = Ge(h);
    $(c === l, () => `Error in fused matMul: inner shapes (${c}) and (${l}) of Tensors with shapes ${p.shape} and ${u.shape} and transposeA=${t8} and transposeB=${o8} must match.`);
    let C = rt(p.shape.slice(0, -2), u.shape.slice(0, -2)).concat([m, d]), S = t8 ? W(p, [g, c, m]) : W(p, [g, m, c]), k = o8 ? W(u, [x, d, l]) : W(u, [x, l, d]), _;
    n8 != null && (_ = v(n8, "bias", "fused matMul"), [_] = Oe(_, p), rt(C, _.shape));
    let E;
    a != null && (E = v(a, "prelu weights", "fused matMul"));
    let R = (O, M) => {
      let [L, B, z, U] = M, j = Yu(W(O, z.shape), z, s), q, Y;
      if (!t8 && !o8 ? (q = Ze(j, B, false, true), Y = Ze(L, j, true, false)) : !t8 && o8 ? (q = Ze(j, B, false, false), Y = Ze(j, L, true, false)) : t8 && !o8 ? (q = Ze(B, j, false, true), Y = Ze(L, j, false, false)) : (q = Ze(B, j, true, true), Y = Ze(j, L, true, true)), n8 != null) {
        let J = Qu(U, j);
        return [q, Y, J];
      } else
        return [q, Y];
    }, D = { a: S, b: k, bias: _, preluActivationWeights: E }, P = { transposeA: t8, transposeB: o8, activation: s, leakyreluAlpha: i10 };
    return n8 == null ? vr((M, L, B) => {
      let z = T.runKernel(So, D, P);
      return B([M, L, z]), { value: W(z, C), gradFunc: R };
    })(S, k) : vr((M, L, B, z) => {
      let U = T.runKernel(So, D, P);
      return z([M, L, U, B]), { value: W(U, C), gradFunc: R };
    })(S, k, _);
  }
  var X1 = N({ fusedMatMul_: B6 });
  function z6(r8) {
    return _l(r8, 0.54, 0.46);
  }
  var Y1 = N({ hammingWindow_: z6 });
  function V6(r8) {
    return _l(r8, 0.5, 0.5);
  }
  var Yd = N({ hannWindow_: V6 });
  function W6(r8, e8, t8, o8 = false, n8 = 0) {
    let s = 0, a = [];
    for (; s + e8 <= r8.size; )
      a.push(Xe(r8, s, e8)), s += t8;
    if (o8)
      for (; s < r8.size; ) {
        let i10 = s + e8 - r8.size, p = bt([Xe(r8, s, e8 - i10), Ta([i10], n8)]);
        a.push(p), s += t8;
      }
    return a.length === 0 ? mu([], [0, e8]) : W(bt(a), [a.length, e8]);
  }
  var Qd = N({ frame_: W6 });
  function U6(r8, e8, t8, o8, n8 = Yd) {
    o8 == null && (o8 = Gw(e8));
    let s = Qd(r8, e8, t8), a = se(s, n8(e8));
    return lc(a, o8);
  }
  var Q1 = N({ stft_: U6 });
  function G6(r8, e8, t8, o8, n8 = "bilinear", s = 0) {
    let a = v(r8, "image", "cropAndResize"), i10 = v(e8, "boxes", "cropAndResize", "float32"), p = v(t8, "boxInd", "cropAndResize", "int32"), u = i10.shape[0];
    $(a.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`), $(i10.rank === 2 && i10.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i10.shape}.`), $(p.rank === 1 && p.shape[0] === u, () => `Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i10.shape}.`), $(o8.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${o8.length}.`), $(o8[0] >= 1 && o8[1] >= 1, () => `cropSize must be atleast [1,1], but was ${o8}`), $(n8 === "bilinear" || n8 === "nearest", () => `method must be bilinear or nearest, but was ${n8}`);
    let c = { image: a, boxes: i10, boxInd: p }, l = { method: n8, extrapolationValue: s, cropSize: o8 };
    return T.runKernel(cn, c, l);
  }
  var Z1 = N({ cropAndResize_: G6 });
  function H6(r8) {
    let e8 = v(r8, "image", "flipLeftRight", "float32");
    $(e8.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${e8.rank}.`);
    let t8 = { image: e8 };
    return T.runKernel(Cn, t8, {});
  }
  var J1 = N({ flipLeftRight_: H6 });
  function K6(r8) {
    let e8 = v(r8, "image", "grayscaleToRGB"), t8 = e8.rank - 1, o8 = e8.shape[t8];
    $(e8.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e8.rank}.`), $(o8 === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${o8}.`);
    let n8 = new Array(e8.rank);
    return n8.fill(1, 0, t8), n8[t8] = 3, uu(e8, n8);
  }
  var eN = N({ grayscaleToRGB_: K6 });
  function q6(r8, e8, t8 = 0, o8 = 0.5) {
    let n8 = v(r8, "image", "rotateWithOffset", "float32");
    $(n8.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${n8.rank}.`);
    let s = { image: n8 }, a = { radians: e8, fillValue: t8, center: o8 };
    return T.runKernel(Ds, s, a);
  }
  var tN = N({ rotateWithOffset_: q6 });
  function $o(r8, e8, t8, o8, n8, s) {
    o8 == null && (o8 = 0.5), n8 == null && (n8 = Number.NEGATIVE_INFINITY), s == null && (s = 0);
    let a = r8.shape[0];
    return t8 = Math.min(t8, a), $(0 <= o8 && o8 <= 1, () => `iouThreshold must be in [0, 1], but was '${o8}'`), $(r8.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${r8.rank}'`), $(r8.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${r8.shape[1]}`), $(e8.rank === 1, () => "scores must be a 1D tensor"), $(e8.shape[0] === a, () => `scores has incompatible shape with boxes. Expected ${a}, but was ${e8.shape[0]}`), $(0 <= s && s <= 1, () => `softNmsSigma must be in [0, 1], but was '${s}'`), { maxOutputSize: t8, iouThreshold: o8, scoreThreshold: n8, softNmsSigma: s };
  }
  function j6(r8, e8, t8, o8 = 0.5, n8 = Number.NEGATIVE_INFINITY) {
    let s = v(r8, "boxes", "nonMaxSuppression", "float32"), a = v(e8, "scores", "nonMaxSuppression", "float32"), i10 = $o(s, a, t8, o8, n8);
    t8 = i10.maxOutputSize, o8 = i10.iouThreshold, n8 = i10.scoreThreshold;
    let p = { maxOutputSize: t8, iouThreshold: o8, scoreThreshold: n8 };
    return T.runKernel(Qn, { boxes: s, scores: a }, p);
  }
  var rN = N({ nonMaxSuppression_: j6 });
  function oN(r8, e8, t8) {
    let o8 = X6(r8, e8, t8), n8 = o8 < 0 ? -(o8 + 1) : o8;
    r8.splice(n8, 0, e8);
  }
  function X6(r8, e8, t8) {
    return Q6(r8, e8, t8 || Y6);
  }
  function Y6(r8, e8) {
    return r8 > e8 ? 1 : r8 < e8 ? -1 : 0;
  }
  function Q6(r8, e8, t8) {
    let o8 = 0, n8 = r8.length, s = 0, a = false;
    for (; o8 < n8; ) {
      s = o8 + (n8 - o8 >>> 1);
      let i10 = t8(e8, r8[s]);
      i10 > 0 ? o8 = s + 1 : (n8 = s, a = !i10);
    }
    return a ? o8 : -o8 - 1;
  }
  function Zd(r8, e8, t8, o8, n8) {
    return Kw(r8, e8, t8, o8, n8, 0);
  }
  function Jd(r8, e8, t8, o8, n8, s) {
    return Kw(r8, e8, t8, o8, n8, 0, false, s, true);
  }
  function ef(r8, e8, t8, o8, n8, s) {
    return Kw(r8, e8, t8, o8, n8, s, true);
  }
  function Kw(r8, e8, t8, o8, n8, s, a = false, i10 = false, p = false) {
    let u = [];
    for (let g = 0; g < e8.length; g++)
      e8[g] > n8 && u.push({ score: e8[g], boxIndex: g, suppressBeginIndex: 0 });
    u.sort(nN);
    let c = s > 0 ? -0.5 / s : 0, l = [], m = [];
    for (; l.length < t8 && u.length > 0; ) {
      let g = u.pop(), { score: x, boxIndex: b, suppressBeginIndex: C } = g;
      if (x < n8)
        break;
      let S = false;
      for (let k = l.length - 1; k >= C; --k) {
        let _ = Z6(r8, b, l[k]);
        if (_ >= o8) {
          S = true;
          break;
        }
        if (g.score = g.score * J6(o8, c, _), g.score <= n8)
          break;
      }
      g.suppressBeginIndex = l.length, S || (g.score === x ? (l.push(b), m.push(g.score)) : g.score > n8 && oN(u, g, nN));
    }
    let d = l.length, f = t8 - d;
    i10 && f > 0 && (l.push(...new Array(f).fill(0)), m.push(...new Array(f).fill(0)));
    let h = { selectedIndices: l };
    return a && (h.selectedScores = m), p && (h.validOutputs = d), h;
  }
  function Z6(r8, e8, t8) {
    let o8 = r8.subarray(e8 * 4, e8 * 4 + 4), n8 = r8.subarray(t8 * 4, t8 * 4 + 4), s = Math.min(o8[0], o8[2]), a = Math.min(o8[1], o8[3]), i10 = Math.max(o8[0], o8[2]), p = Math.max(o8[1], o8[3]), u = Math.min(n8[0], n8[2]), c = Math.min(n8[1], n8[3]), l = Math.max(n8[0], n8[2]), m = Math.max(n8[1], n8[3]), d = (i10 - s) * (p - a), f = (l - u) * (m - c);
    if (d <= 0 || f <= 0)
      return 0;
    let h = Math.max(s, u), g = Math.max(a, c), x = Math.min(i10, l), b = Math.min(p, m), C = Math.max(x - h, 0) * Math.max(b - g, 0);
    return C / (d + f - C);
  }
  function J6(r8, e8, t8) {
    let o8 = Math.exp(e8 * t8 * t8);
    return t8 <= r8 ? o8 : 0;
  }
  function nN(r8, e8) {
    return r8.score - e8.score || r8.score === e8.score && e8.boxIndex - r8.boxIndex;
  }
  async function ej(r8, e8, t8, o8 = 0.5, n8 = Number.NEGATIVE_INFINITY) {
    let s = v(r8, "boxes", "nonMaxSuppressionAsync"), a = v(e8, "scores", "nonMaxSuppressionAsync"), i10 = $o(s, a, t8, o8, n8);
    t8 = i10.maxOutputSize, o8 = i10.iouThreshold, n8 = i10.scoreThreshold;
    let p = await Promise.all([s.data(), a.data()]), u = p[0], c = p[1], { selectedIndices: l } = Zd(u, c, t8, o8, n8);
    return s !== r8 && s.dispose(), a !== e8 && a.dispose(), xr(l, "int32");
  }
  var sN = ej;
  function tj(r8, e8, t8, o8 = 0.5, n8 = Number.NEGATIVE_INFINITY, s = 0) {
    let a = v(r8, "boxes", "nonMaxSuppression"), i10 = v(e8, "scores", "nonMaxSuppression"), p = $o(a, i10, t8, o8, n8, s);
    t8 = p.maxOutputSize, o8 = p.iouThreshold, n8 = p.scoreThreshold, s = p.softNmsSigma;
    let u = { boxes: a, scores: i10 }, c = { maxOutputSize: t8, iouThreshold: o8, scoreThreshold: n8, softNmsSigma: s }, l = T.runKernel(Zn, u, c);
    return { selectedIndices: l[0], selectedScores: l[1] };
  }
  var aN = N({ nonMaxSuppressionWithScore_: tj });
  async function rj(r8, e8, t8, o8 = 0.5, n8 = Number.NEGATIVE_INFINITY, s = 0) {
    let a = v(r8, "boxes", "nonMaxSuppressionAsync"), i10 = v(e8, "scores", "nonMaxSuppressionAsync"), p = $o(a, i10, t8, o8, n8, s);
    t8 = p.maxOutputSize, o8 = p.iouThreshold, n8 = p.scoreThreshold, s = p.softNmsSigma;
    let u = await Promise.all([a.data(), i10.data()]), c = u[0], l = u[1], { selectedIndices: m, selectedScores: d } = ef(c, l, t8, o8, n8, s);
    return a !== r8 && a.dispose(), i10 !== e8 && i10.dispose(), { selectedIndices: xr(m, "int32"), selectedScores: xr(d) };
  }
  var iN = rj;
  function oj(r8, e8, t8, o8 = 0.5, n8 = Number.NEGATIVE_INFINITY, s = false) {
    let a = v(r8, "boxes", "nonMaxSuppression"), i10 = v(e8, "scores", "nonMaxSuppression"), p = $o(a, i10, t8, o8, n8, null), u = p.maxOutputSize, c = p.iouThreshold, l = p.scoreThreshold, m = { boxes: a, scores: i10 }, d = { maxOutputSize: u, iouThreshold: c, scoreThreshold: l, padToMaxOutputSize: s }, f = T.runKernel(Xa, m, d);
    return { selectedIndices: f[0], validOutputs: f[1] };
  }
  var uN = N({ nonMaxSuppressionPadded_: oj });
  async function nj(r8, e8, t8, o8 = 0.5, n8 = Number.NEGATIVE_INFINITY, s = false) {
    let a = v(r8, "boxes", "nonMaxSuppressionAsync"), i10 = v(e8, "scores", "nonMaxSuppressionAsync"), p = $o(a, i10, t8, o8, n8, null), u = p.maxOutputSize, c = p.iouThreshold, l = p.scoreThreshold, [m, d] = await Promise.all([a.data(), i10.data()]), { selectedIndices: f, validOutputs: h } = Jd(m, d, u, c, l, s);
    return a !== r8 && a.dispose(), i10 !== e8 && i10.dispose(), { selectedIndices: xr(f, "int32"), validOutputs: ke(h, "int32") };
  }
  var pN = nj;
  function sj(r8, e8, t8 = false, o8 = false) {
    let n8 = v(r8, "images", "resizeBilinear");
    $(n8.rank === 3 || n8.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${n8.rank}.`), $(e8.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${e8}.`), $(o8 === false || t8 === false, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
    let s = n8, a = false;
    n8.rank === 3 && (a = true, s = W(n8, [1, n8.shape[0], n8.shape[1], n8.shape[2]]));
    let i10 = { images: s }, p = { alignCorners: t8, halfPixelCenters: o8, size: e8 }, u = T.runKernel(is, i10, p);
    return a ? W(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
  var cN = N({ resizeBilinear_: sj });
  function aj(r8, e8, t8 = false, o8 = false) {
    let n8 = v(r8, "images", "resizeNearestNeighbor");
    $(n8.rank === 3 || n8.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${n8.rank}.`), $(e8.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e8}.`), $(n8.dtype === "float32" || n8.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), $(o8 === false || t8 === false, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
    let s = n8, a = false;
    n8.rank === 3 && (a = true, s = W(n8, [1, n8.shape[0], n8.shape[1], n8.shape[2]]));
    let i10 = { images: s }, p = { alignCorners: t8, halfPixelCenters: o8, size: e8 }, u = T.runKernel(as, i10, p);
    return a ? W(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
  var lN = N({ resizeNearestNeighbor_: aj });
  function ij(r8, e8 = "binary", t8 = false, o8 = 0.5) {
    let n8 = v(r8, "image", "threshold"), s = 0.2989, a = 0.587, i10 = 0.114, p = n8.shape[0] * n8.shape[1], u = se(xr([o8]), 255), c, l, m, d;
    if ($(n8.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${n8.rank}.`), $(n8.shape[2] === 3 || n8.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${n8.shape[2]}.`), $(n8.dtype === "int32" || n8.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${n8.dtype}.`), $(e8 === "otsu" || e8 === "binary", () => `Method must be binary or otsu, but was ${e8}`), n8.shape[2] === 3) {
      [c, l, m] = pi(n8, [1, 1, 1], -1);
      let g = se(c, s), x = se(l, a), b = se(m, i10);
      d = Ce(Ce(g, x), b);
    } else
      d = r8;
    if (e8 === "otsu") {
      let g = fd(qe(Ud(d), "int32"), ir([]), 256);
      u = uj(g, p);
    }
    let f = t8 ? uc(d, u) : Uu(d, u);
    return qe(se(f, 255), "int32");
  }
  function uj(r8, e8) {
    let t8 = xr([-1]), o8 = xr([0]), n8 = xr([0]), s, a, i10, p, u, c;
    for (let l = 0; l < r8.size - 1; l++) {
      s = Xe(r8, 0, l + 1), a = Xe(r8, l + 1), u = je(ot(s), e8), c = je(ot(a), e8);
      let m = ot(se(s, cu(0, s.size)));
      i10 = je(m, ot(s));
      let d = Ta(a.shape, s.size), f = Ce(cu(0, a.size), d), h = se(a, f);
      p = je(ot(h), ot(a));
      let g = Te(i10, p), x = Te(i10, p), b = se(u, c);
      n8 = se(se(b, g), x);
      let C = Uu(n8, o8);
      o8 = co(C, n8, o8), t8 = co(C, xr([l]), t8);
    }
    return t8;
  }
  var mN = N({ threshold_: ij });
  function pj(r8, e8, t8 = "nearest", o8 = "constant", n8 = 0, s) {
    let a = v(r8, "image", "transform", "float32"), i10 = v(e8, "transforms", "transform", "float32");
    $(a.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${a.rank}.`), $(i10.rank === 2 && (i10.shape[0] === a.shape[0] || i10.shape[0] === 1) && i10.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), $(s == null || s.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${s}.`);
    let p = { image: a, transforms: i10 }, u = { interpolation: t8, fillMode: o8, fillValue: n8, outputShape: s };
    return T.runKernel(Rs, p, u);
  }
  var dN = N({ transform_: pj });
  function cj(r8, e8, t8) {
    let o8 = v(r8, "a", "bandPart");
    $(o8.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${o8.rank}.`);
    let n8 = o8.shape, [s, a] = o8.shape.slice(-2), i10, p;
    typeof e8 == "number" ? ($(e8 % 1 === 0, () => `bandPart(): numLower must be an integer, got ${e8}.`), $(e8 <= s, () => `bandPart(): numLower (${e8}) must not be greater than the number of rows (${s}).`), i10 = v(e8 < 0 ? s : e8, "numLower", "bandPart")) : ($(e8.dtype === "int32", () => "bandPart(): numLower's dtype must be an int32."), i10 = co(kl(e8, 0), s, Ku(e8, s))), typeof t8 == "number" ? ($(t8 % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${t8}.`), $(t8 <= a, () => `bandPart(): numUpper (${t8}) must not be greater than the number of columns (${a}).`), p = v(t8 < 0 ? a : t8, "numUpper", "bandPart")) : ($(t8.dtype === "int32", () => "bandPart(): numUpper's dtype must be an int32."), p = co(kl(t8, 0), a, Ku(t8, a)));
    let u = W(cu(0, s, 1, "int32"), [-1, 1]), c = cu(0, a, 1, "int32"), l = Te(u, c), m = Gu(uc(l, i10), Sd(l, pr(p))), d = Gr([s, a], o8.dtype);
    return W(kr(mo(W(o8, [-1, s, a])).map((f) => co(m, f, d))), n8);
  }
  var fN = N({ bandPart_: cj });
  function lj(r8) {
    let e8;
    if (Array.isArray(r8)) {
      e8 = false, $(r8 != null && r8.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
      let n8 = r8[0].shape[0];
      for (let s = 1; s < r8.length; ++s)
        $(r8[s].shape[0] === n8, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${r8[s].shape[0]} vs. ${n8})`);
    } else
      e8 = true, r8 = pi(r8, r8.shape[0], 0).map((n8) => mc(n8, [0]));
    $(r8.length <= r8[0].shape[0], () => `Gram-Schmidt: Number of vectors (${r8.length}) exceeds number of dimensions (${r8[0].shape[0]}).`);
    let t8 = [], o8 = r8;
    for (let n8 = 0; n8 < r8.length; ++n8)
      t8.push(T.tidy(() => {
        let s = o8[n8];
        if (n8 > 0)
          for (let a = 0; a < n8; ++a) {
            let i10 = se(ot(se(t8[a], s)), t8[a]);
            s = Te(s, i10);
          }
        return je(s, Wu(s, "euclidean"));
      }));
    return e8 ? kr(t8, 0) : t8;
  }
  var hN = N({ gramSchmidt_: lj });
  function mj(r8, e8 = false) {
    if ($(r8.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${r8.rank}`), r8.rank === 2)
      return gN(r8, e8);
    {
      let t8 = r8.shape.slice(0, r8.shape.length - 2).reduce((p, u) => p * u), o8 = mo(W(r8, [t8, r8.shape[r8.shape.length - 2], r8.shape[r8.shape.length - 1]]), 0), n8 = [], s = [];
      o8.forEach((p) => {
        let [u, c] = gN(p, e8);
        n8.push(u), s.push(c);
      });
      let a = W(kr(n8, 0), r8.shape), i10 = W(kr(s, 0), r8.shape);
      return [a, i10];
    }
  }
  function gN(r8, e8 = false) {
    return T.tidy(() => {
      $(r8.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${r8.shape.length}D Tensor.`);
      let t8 = r8.shape[0], o8 = r8.shape[1], n8 = bd(t8), s = Ur(r8), a = mu([[1]], [1, 1]), i10 = Ur(a), p = t8 >= o8 ? o8 : t8;
      for (let u = 0; u < p; ++u) {
        let c = s, l = i10, m = n8;
        [i10, s, n8] = T.tidy(() => {
          let d = Xe(s, [u, u], [t8 - u, 1]), f = Wu(d), h = Xe(s, [u, u], [1, 1]), g = co(Uu(h, 0), mu([[-1]]), mu([[1]])), x = Te(h, se(g, f)), b = je(d, x);
          b.shape[0] === 1 ? i10 = Ur(a) : i10 = bt([a, Xe(b, [1, 0], [b.shape[0] - 1, b.shape[1]])], 0);
          let C = pr(je(Ze(g, x), f)), S = Xe(s, [u, 0], [t8 - u, o8]), k = se(C, i10), _ = fc(i10);
          if (u === 0)
            s = Te(S, Ze(k, Ze(_, S)));
          else {
            let D = Te(S, Ze(k, Ze(_, S)));
            s = bt([Xe(s, [0, 0], [u, o8]), D], 0);
          }
          let E = fc(k), R = Xe(n8, [0, u], [t8, n8.shape[1] - u]);
          if (u === 0)
            n8 = Te(R, Ze(Ze(R, i10), E));
          else {
            let D = Te(R, Ze(Ze(R, i10), E));
            n8 = bt([Xe(n8, [0, 0], [t8, u]), D], 1);
          }
          return [i10, s, n8];
        }), Ot([c, l, m]);
      }
      return !e8 && t8 > o8 && (n8 = Xe(n8, [0, 0], [t8, o8]), s = Xe(s, [0, 0], [o8, o8])), [n8, s];
    });
  }
  var xN = N({ qr_: mj });
  var Et;
  (function(r8) {
    r8[r8.NONE = 0] = "NONE", r8[r8.MEAN = 1] = "MEAN", r8[r8.SUM = 2] = "SUM", r8[r8.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
  })(Et || (Et = {}));
  function dj(r8, e8, t8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let o8 = v(r8, "losses", "computeWeightedLoss"), n8 = null;
    e8 != null && (n8 = v(e8, "weights", "computeWeightedLoss"));
    let s = n8 == null ? o8 : se(o8, n8);
    if (t8 === Et.NONE)
      return s;
    if (t8 === Et.SUM)
      return ot(s);
    if (t8 === Et.MEAN) {
      if (n8 == null)
        return Hu(s);
      {
        let a = o8.size / n8.size, i10 = je(ot(s), ot(n8));
        return a > 1 ? je(i10, ke(a)) : i10;
      }
    }
    if (t8 === Et.SUM_BY_NONZERO_WEIGHTS) {
      if (n8 == null)
        return je(ot(s), ke(o8.size));
      {
        let a = se(n8, $a(o8.shape)), i10 = qe(ot(Ad(a, ke(0))), "float32");
        return je(ot(s), i10);
      }
    }
    throw Error(`Unknown reduction: ${t8}`);
  }
  var cr = N({ computeWeightedLoss_: dj });
  function fj(r8, e8, t8, o8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let n8 = v(r8, "labels", "absoluteDifference"), s = v(e8, "predictions", "absoluteDifference"), a = null;
    t8 != null && (a = v(t8, "weights", "absoluteDifference")), yt(n8.shape, s.shape, "Error in absoluteDifference: ");
    let i10 = Jt(Te(n8, s));
    return cr(i10, a, o8);
  }
  var yN = N({ absoluteDifference_: fj });
  function hj(r8, e8, t8, o8, n8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let s = v(r8, "labels", "cosineDistance"), a = v(e8, "predictions", "cosineDistance"), i10 = null;
    o8 != null && (i10 = v(o8, "weights", "cosineDistance")), yt(s.shape, a.shape, "Error in cosineDistance: ");
    let p = ke(1), u = Te(p, ot(se(s, a), t8, true));
    return cr(u, i10, n8);
  }
  var bN = N({ cosineDistance_: hj });
  function gj(r8, e8, t8, o8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let n8 = v(r8, "labels", "hingeLoss"), s = v(e8, "predictions", "hingeLoss"), a = null;
    t8 != null && (a = v(t8, "weights", "hingeLoss")), yt(n8.shape, s.shape, "Error in hingeLoss: ");
    let i10 = ke(1);
    n8 = Te(se(ke(2), n8), i10);
    let p = lu(Te(i10, se(n8, s)));
    return cr(p, a, o8);
  }
  var CN = N({ hingeLoss_: gj });
  function xj(r8, e8, t8, o8 = 1, n8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let s = v(r8, "labels", "huberLoss"), a = v(e8, "predictions", "huberLoss"), i10 = null;
    t8 != null && (i10 = v(t8, "weights", "huberLoss")), yt(s.shape, a.shape, "Error in huberLoss: ");
    let p = ke(o8), u = Jt(Te(a, s)), c = Ku(u, p), l = Te(u, c), m = Ce(se(ke(0.5), er(c)), se(p, l));
    return cr(m, i10, n8);
  }
  var wN = N({ huberLoss_: xj });
  function yj(r8, e8, t8, o8 = 1e-7, n8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let s = v(r8, "labels", "logLoss"), a = v(e8, "predictions", "logLoss"), i10 = null;
    t8 != null && (i10 = v(t8, "weights", "logLoss")), yt(s.shape, a.shape, "Error in logLoss: ");
    let p = ke(1), u = ke(o8), c = pr(se(s, ii(Ce(a, u)))), l = se(Te(p, s), ii(Ce(Te(p, a), u))), m = Te(c, l);
    return cr(m, i10, n8);
  }
  var SN = N({ logLoss_: yj });
  function bj(r8, e8, t8, o8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let n8 = v(r8, "labels", "meanSquaredError"), s = v(e8, "predictions", "meanSquaredError"), a = null;
    t8 != null && (a = v(t8, "weights", "meanSquaredError")), yt(n8.shape, s.shape, "Error in meanSquaredError: ");
    let i10 = Hd(n8, s);
    return cr(i10, a, o8);
  }
  var IN = N({ meanSquaredError_: bj });
  function Cj(r8, e8) {
    let t8 = v(r8, "labels", "sigmoidCrossEntropyWithLogits"), o8 = v(e8, "logits", "sigmoidCrossEntropyWithLogits");
    yt(t8.shape, o8.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    let n8 = lu(o8), s = se(o8, t8), a = vd(_o(pr(Jt(o8))));
    return Ce(Te(n8, s), a);
  }
  function wj(r8, e8, t8, o8 = 0, n8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let s = v(r8, "multiClassLabels", "sigmoidCrossEntropy"), a = v(e8, "logits", "sigmoidCrossEntropy"), i10 = null;
    if (t8 != null && (i10 = v(t8, "weights", "sigmoidCrossEntropy")), yt(s.shape, a.shape, "Error in sigmoidCrossEntropy: "), o8 > 0) {
      let u = ke(o8), c = ke(1), l = ke(0.5);
      s = Ce(se(s, Te(c, u)), se(l, u));
    }
    let p = Cj(s, a);
    return cr(p, i10, n8);
  }
  var vN = N({ sigmoidCrossEntropy_: wj });
  function Sj(r8, e8, t8 = -1) {
    if (t8 === -1 && (t8 = e8.rank - 1), t8 !== e8.rank - 1)
      throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e8.rank} and dim was ${t8}`);
    return vr((n8, s, a) => {
      let p = Td(s, [t8], true), u = Te(qe(s, "float32"), p);
      a([n8, u]);
      let c = pr(se(u, n8));
      return { value: ot(c, [t8]), gradFunc: (d, f) => {
        let [h, g] = f, x = ni(d.shape, [t8]);
        return [se(W(d, x), Te(qe(h, "float32"), _o(g))), se(W(d, x), Te(_o(g), qe(h, "float32")))];
      } };
    })(r8, e8);
  }
  function Ij(r8, e8, t8, o8 = 0, n8 = Et.SUM_BY_NONZERO_WEIGHTS) {
    let s = v(r8, "onehotLabels", "softmaxCrossEntropy"), a = v(e8, "logits", "softmaxCrossEntropy"), i10 = null;
    if (t8 != null && (i10 = v(t8, "weights", "softmaxCrossEntropy")), yt(s.shape, a.shape, "Error in softmaxCrossEntropy: "), o8 > 0) {
      let u = ke(o8), c = ke(1), l = ke(s.shape[1]);
      s = Ce(se(s, Te(c, u)), je(u, l));
    }
    let p = Sj(s, a);
    return cr(p, i10, n8);
  }
  var kN = N({ softmaxCrossEntropy_: Ij });
  function vj(r8, e8, t8, o8) {
    let n8 = v(r8, "indices", "sparseFillEmptyRows", "int32"), s = v(e8, "values", "sparseFillEmptyRows"), a = v(t8, "denseShape", "sparseFillEmptyRows", "int32"), i10 = v(o8, "defaultValue", "sparseFillEmptyRows", s.dtype);
    if (n8.rank !== 2)
      throw new Error(`Indices should be Tensor2D but received shape
        ${n8.shape}`);
    if (s.rank !== 1)
      throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);
    if (a.rank !== 1)
      throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);
    if (i10.rank !== 0)
      throw new Error(`Default value should be a scalar but received shape ${i10.shape}`);
    let p = { indices: n8, values: s, denseShape: a, defaultValue: i10 }, u = T.runKernel(Hi, p);
    return { outputIndices: u[0], outputValues: u[1], emptyRowIndicator: u[2], reverseIndexMap: u[3] };
  }
  var NN = N({ sparseFillEmptyRows_: vj });
  function kj(r8, e8, t8) {
    let o8 = v(r8, "inputIndices", "sparseReshape", "int32"), n8 = v(e8, "inputShape", "sparseReshape", "int32"), s = v(t8, "newShape", "sparseReshape", "int32");
    if (o8.rank !== 2)
      throw new Error(`Input indices should be Tensor2D but received shape
        ${o8.shape}`);
    if (n8.rank !== 1)
      throw new Error(`Input shape should be Tensor1D but received shape ${n8.shape}`);
    if (s.rank !== 1)
      throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);
    let a = { inputIndices: o8, inputShape: n8, newShape: s }, i10 = T.runKernel(Za, a);
    return { outputIndices: i10[0], outputShape: i10[1] };
  }
  var TN = N({ sparseReshape_: kj });
  function Nj(r8, e8, t8) {
    let o8 = v(r8, "data", "sparseSegmentMean"), n8 = v(e8, "indices", "sparseSegmentMean", "int32"), s = v(t8, "segmentIds", "sparseSegmentMean", "int32");
    if (o8.rank < 1)
      throw new Error("Data should be at least 1 dimensional but received scalar");
    if (n8.rank !== 1)
      throw new Error(`Indices should be Tensor1D but received shape
          ${n8.shape}`);
    if (s.rank !== 1)
      throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);
    let a = { data: o8, indices: n8, segmentIds: s };
    return T.runKernel(Ki, a);
  }
  var _N = N({ sparseSegmentMean_: Nj });
  function Tj(r8, e8, t8) {
    let o8 = v(r8, "data", "sparseSegmentSum"), n8 = v(e8, "indices", "sparseSegmentSum", "int32"), s = v(t8, "segmentIds", "sparseSegmentSum", "int32");
    if (o8.rank < 1)
      throw new Error("Data should be at least 1 dimensional but received scalar");
    if (n8.rank !== 1)
      throw new Error(`Indices should be Tensor1D but received shape
         ${n8.shape}`);
    if (s.rank !== 1)
      throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);
    let a = { data: o8, indices: n8, segmentIds: s };
    return T.runKernel(qi, a);
  }
  var $N = N({ sparseSegmentSum_: Tj });
  function _j(r8, e8, t8, o8, n8, s, a, i10) {
    let p = v(r8, "data", "stringNGrams", "string");
    if (p.dtype !== "string")
      throw new Error("Data must be of datatype string");
    if (p.shape.length !== 1)
      throw new Error(`Data must be a vector, saw: ${p.shape}`);
    let u = v(e8, "dataSplits", "stringNGrams");
    if (u.dtype !== "int32")
      throw new Error("Data splits must be of datatype int32");
    let c = { separator: t8, nGramWidths: o8, leftPad: n8, rightPad: s, padWidth: a, preserveShortSequences: i10 }, l = { data: p, dataSplits: u }, m = T.runKernel(xa, l, c);
    return { nGrams: m[0], nGramsSplits: m[1] };
  }
  var EN = N({ stringNGrams_: _j });
  function $j(r8, e8, t8 = true) {
    let o8 = v(r8, "input", "stringSplit", "string"), n8 = v(e8, "delimiter", "stringSplit", "string");
    if (o8.rank !== 1)
      throw new Error(`Input should be Tensor1D but received shape ${o8.shape}`);
    if (n8.rank !== 0)
      throw new Error(`Delimiter should be a scalar but received shape ${n8.shape}`);
    let s = { skipEmpty: t8 }, a = { input: o8, delimiter: n8 }, i10 = T.runKernel(Xi, a, s);
    return { indices: i10[0], values: i10[1], shape: i10[2] };
  }
  var RN = N({ stringSplit_: $j });
  function Ej(r8, e8) {
    let t8 = v(r8, "input", "stringToHashBucketFast", "string"), o8 = { numBuckets: e8 };
    if (e8 <= 0)
      throw new Error("Number of buckets must be at least 1");
    let n8 = { input: t8 };
    return T.runKernel(Yi, n8, o8);
  }
  var DN = N({ stringToHashBucketFast_: Ej });
  function Rj(r8, e8, t8, o8 = true) {
    let n8 = v(r8, "input", "staticRegexReplace", "string"), s = { pattern: e8, rewrite: t8, replaceGlobal: o8 };
    return T.runKernel(Du, { x: n8 }, s);
  }
  var AN = N({ staticRegexReplace_: Rj });
  var Dj = { fft: cc, ifft: Xu, rfft: lc, irfft: Gd };
  var Aj = { hammingWindow: Y1, hannWindow: Yd, frame: Qd, stft: Q1 };
  var Fj = { flipLeftRight: J1, grayscaleToRGB: eN, resizeNearestNeighbor: lN, resizeBilinear: cN, rotateWithOffset: tN, cropAndResize: Z1, nonMaxSuppression: rN, nonMaxSuppressionAsync: sN, nonMaxSuppressionWithScore: aN, nonMaxSuppressionWithScoreAsync: iN, nonMaxSuppressionPadded: uN, nonMaxSuppressionPaddedAsync: pN, threshold: mN, transform: dN };
  var Pj = { bandPart: fN, gramSchmidt: hN, qr: xN };
  var Oj = { absoluteDifference: yN, computeWeightedLoss: cr, cosineDistance: bN, hingeLoss: CN, huberLoss: wN, logLoss: SN, meanSquaredError: IN, sigmoidCrossEntropy: vN, softmaxCrossEntropy: kN };
  var Mj = { sparseFillEmptyRows: NN, sparseReshape: TN, sparseSegmentMean: _N, sparseSegmentSum: $N };
  var Lj = { stringNGrams: EN, stringSplit: RN, stringToHashBucketFast: DN, staticRegexReplace: AN };
  var FN = {};
  Ke(FN, { Serializable: () => $l, SerializationMap: () => Ra, registerClass: () => qw });
  var $l = class {
    getClassName() {
      return this.constructor.className;
    }
    static fromConfig(e8, t8) {
      return new e8(t8);
    }
  };
  var Ra = class {
    constructor() {
      this.classNameMap = {};
    }
    static getMap() {
      return Ra.instance == null && (Ra.instance = new Ra()), Ra.instance;
    }
    static register(e8) {
      Ra.getMap().classNameMap[e8.className] = [e8, e8.fromConfig];
    }
  };
  function qw(r8) {
    $(r8.className != null, () => "Class being registered does not have the static className property defined."), $(typeof r8.className == "string", () => "className is required to be a string, but got type " + typeof r8.className), $(r8.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), Ra.register(r8);
  }
  var Nr = class extends $l {
    minimize(e8, t8 = false, o8) {
      let { value: n8, grads: s } = this.computeGradients(e8, o8);
      if (o8 != null) {
        let a = o8.map((i10) => ({ name: i10.name, tensor: s[i10.name] }));
        this.applyGradients(a);
      } else
        this.applyGradients(s);
      return Ot(s), t8 ? n8 : (n8.dispose(), null);
    }
    get iterations() {
      return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    computeGradients(e8, t8) {
      return Aw(e8, t8);
    }
    dispose() {
      this.iterations_ != null && Ot(this.iterations_);
    }
    async saveIterations() {
      return this.iterations_ == null && (this.iterations_ = 0), { name: "iter", tensor: ke(this.iterations_, "int32") };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(e8) {
      throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    async extractIterations(e8) {
      return this.iterations_ = (await e8[0].tensor.data())[0], e8.slice(1);
    }
  };
  Object.defineProperty(Nr, Symbol.hasInstance, { value: (r8) => r8.minimize != null && r8.computeGradients != null && r8.applyGradients != null });
  var ep = class extends Nr {
    static get className() {
      return "Adadelta";
    }
    constructor(e8, t8, o8 = null) {
      super(), this.learningRate = e8, this.rho = t8, this.epsilon = o8, this.accumulatedGrads = [], this.accumulatedUpdates = [], o8 == null && (this.epsilon = T.backend.epsilon());
    }
    applyGradients(e8) {
      (Array.isArray(e8) ? e8.map((o8) => o8.name) : Object.keys(e8)).forEach((o8, n8) => {
        let s = T.registeredVariables[o8], a = false;
        this.accumulatedGrads[n8] == null && (this.accumulatedGrads[n8] = { originalName: `${o8}/accum_grad`, variable: De(() => Ht(s).variable(a)) }), this.accumulatedUpdates[n8] == null && (this.accumulatedUpdates[n8] = { originalName: `${o8}/accum_var`, variable: De(() => Ht(s).variable(a)) });
        let i10 = Array.isArray(e8) ? e8[n8].tensor : e8[o8];
        if (i10 == null)
          return;
        let p = this.accumulatedGrads[n8].variable, u = this.accumulatedUpdates[n8].variable;
        De(() => {
          let c = Ce(se(p, this.rho), se(er(i10), 1 - this.rho)), l = se(je(Dr(Ce(u, this.epsilon)), Dr(Ce(p, this.epsilon))), i10), m = Ce(se(u, this.rho), se(er(l), 1 - this.rho));
          p.assign(c), u.assign(m);
          let d = Ce(se(l, -this.learningRate), s);
          s.assign(d);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedUpdates != null && (Ot(this.accumulatedGrads.map((e8) => e8.variable)), Ot(this.accumulatedUpdates.map((e8) => e8.variable)));
    }
    async getWeights() {
      let e8 = [...this.accumulatedGrads, ...this.accumulatedUpdates];
      return [await this.saveIterations()].concat(e8.map((t8) => ({ name: t8.originalName, tensor: t8.variable })));
    }
    async setWeights(e8) {
      e8 = await this.extractIterations(e8);
      let t8 = e8.length / 2, o8 = false;
      this.accumulatedGrads = e8.slice(0, t8).map((n8) => ({ originalName: n8.name, variable: n8.tensor.variable(o8) })), this.accumulatedUpdates = e8.slice(t8, t8 * 2).map((n8) => ({ originalName: n8.name, variable: n8.tensor.variable(o8) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
    }
    static fromConfig(e8, t8) {
      return new e8(t8.learningRate, t8.rho, t8.epsilon);
    }
  };
  var tp = class extends Nr {
    static get className() {
      return "Adagrad";
    }
    constructor(e8, t8 = 0.1) {
      super(), this.learningRate = e8, this.initialAccumulatorValue = t8, this.accumulatedGrads = [];
    }
    applyGradients(e8) {
      (Array.isArray(e8) ? e8.map((o8) => o8.name) : Object.keys(e8)).forEach((o8, n8) => {
        let s = T.registeredVariables[o8];
        this.accumulatedGrads[n8] == null && (this.accumulatedGrads[n8] = { originalName: `${o8}/accumulator`, variable: De(() => Ta(s.shape, this.initialAccumulatorValue).variable(false)) });
        let a = Array.isArray(e8) ? e8[n8].tensor : e8[o8];
        if (a == null)
          return;
        let i10 = this.accumulatedGrads[n8].variable;
        De(() => {
          let p = Ce(i10, er(a));
          i10.assign(p);
          let u = Ce(se(je(a, Dr(Ce(p, T.backend.epsilon()))), -this.learningRate), s);
          s.assign(u);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedGrads != null && Ot(this.accumulatedGrads.map((e8) => e8.variable));
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulatedGrads.map((e8) => ({ name: e8.originalName, tensor: e8.variable })));
    }
    async setWeights(e8) {
      e8 = await this.extractIterations(e8);
      let t8 = false;
      this.accumulatedGrads = e8.map((o8) => ({ originalName: o8.name, variable: o8.tensor.variable(t8) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
    }
    static fromConfig(e8, t8) {
      return new e8(t8.learningRate, t8.initialAccumulatorValue);
    }
  };
  var rp = class extends Nr {
    static get className() {
      return "Adam";
    }
    constructor(e8, t8, o8, n8 = null) {
      super(), this.learningRate = e8, this.beta1 = t8, this.beta2 = o8, this.epsilon = n8, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], De(() => {
        this.accBeta1 = ke(t8).variable(), this.accBeta2 = ke(o8).variable();
      }), n8 == null && (this.epsilon = T.backend.epsilon());
    }
    applyGradients(e8) {
      let t8 = Array.isArray(e8) ? e8.map((o8) => o8.name) : Object.keys(e8);
      De(() => {
        let o8 = Te(1, this.accBeta1), n8 = Te(1, this.accBeta2);
        t8.forEach((s, a) => {
          let i10 = T.registeredVariables[s], p = false;
          this.accumulatedFirstMoment[a] == null && (this.accumulatedFirstMoment[a] = { originalName: `${s}/m`, variable: De(() => Ht(i10).variable(p)) }), this.accumulatedSecondMoment[a] == null && (this.accumulatedSecondMoment[a] = { originalName: `${s}/v`, variable: De(() => Ht(i10).variable(p)) });
          let u = Array.isArray(e8) ? e8[a].tensor : e8[s];
          if (u == null)
            return;
          let c = this.accumulatedFirstMoment[a].variable, l = this.accumulatedSecondMoment[a].variable, m = Ce(se(c, this.beta1), se(u, 1 - this.beta1)), d = Ce(se(l, this.beta2), se(er(u), 1 - this.beta2)), f = je(m, o8), h = je(d, n8);
          c.assign(m), l.assign(d);
          let g = Ce(se(je(f, Ce(Dr(h), this.epsilon)), -this.learningRate), i10);
          i10.assign(g);
        }), this.accBeta1.assign(se(this.accBeta1, this.beta1)), this.accBeta2.assign(se(this.accBeta2, this.beta2));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && Ot(this.accumulatedFirstMoment.map((e8) => e8.variable)), this.accumulatedSecondMoment != null && Ot(this.accumulatedSecondMoment.map((e8) => e8.variable));
    }
    async getWeights() {
      let e8 = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
      return [await this.saveIterations()].concat(e8.map((t8) => ({ name: t8.originalName, tensor: t8.variable })));
    }
    async setWeights(e8) {
      e8 = await this.extractIterations(e8), De(() => {
        this.accBeta1.assign(si(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(si(this.beta2, this.iterations_ + 1));
      });
      let t8 = e8.length / 2, o8 = false;
      this.accumulatedFirstMoment = e8.slice(0, t8).map((n8) => ({ originalName: n8.name, variable: n8.tensor.variable(o8) })), this.accumulatedSecondMoment = e8.slice(t8, t8 * 2).map((n8) => ({ originalName: n8.name, variable: n8.tensor.variable(o8) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
    }
    static fromConfig(e8, t8) {
      return new e8(t8.learningRate, t8.beta1, t8.beta2, t8.epsilon);
    }
  };
  var op = class extends Nr {
    static get className() {
      return "Adamax";
    }
    constructor(e8, t8, o8, n8 = null, s = 0) {
      super(), this.learningRate = e8, this.beta1 = t8, this.beta2 = o8, this.epsilon = n8, this.decay = s, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], De(() => {
        this.iteration = ke(0).variable(), this.accBeta1 = ke(t8).variable();
      }), n8 == null && (this.epsilon = T.backend.epsilon());
    }
    applyGradients(e8) {
      let t8 = Array.isArray(e8) ? e8.map((o8) => o8.name) : Object.keys(e8);
      De(() => {
        let o8 = Te(1, this.accBeta1), n8 = je(-this.learningRate, Ce(se(this.iteration, this.decay), 1));
        t8.forEach((s, a) => {
          let i10 = T.registeredVariables[s], p = false;
          this.accumulatedFirstMoment[a] == null && (this.accumulatedFirstMoment[a] = { originalName: `${s}/m`, variable: Ht(i10).variable(p) }), this.accumulatedWeightedInfNorm[a] == null && (this.accumulatedWeightedInfNorm[a] = { originalName: `${s}/v`, variable: Ht(i10).variable(p) });
          let u = Array.isArray(e8) ? e8[a].tensor : e8[s];
          if (u == null)
            return;
          let c = this.accumulatedFirstMoment[a].variable, l = this.accumulatedWeightedInfNorm[a].variable, m = Ce(se(c, this.beta1), se(u, 1 - this.beta1)), d = se(l, this.beta2), f = Jt(u), h = Dd(d, f);
          c.assign(m), l.assign(h);
          let g = Ce(se(je(n8, o8), je(m, Ce(h, this.epsilon))), i10);
          i10.assign(g);
        }), this.iteration.assign(Ce(this.iteration, 1)), this.accBeta1.assign(se(this.accBeta1, this.beta1));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && Ot(this.accumulatedFirstMoment.map((e8) => e8.variable)), this.accumulatedWeightedInfNorm != null && Ot(this.accumulatedWeightedInfNorm.map((e8) => e8.variable));
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(e8) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
    }
    static fromConfig(e8, t8) {
      return new e8(t8.learningRate, t8.beta1, t8.beta2, t8.epsilon, t8.decay);
    }
  };
  var ci = class extends Nr {
    static get className() {
      return "SGD";
    }
    constructor(e8) {
      super(), this.learningRate = e8, this.setLearningRate(e8);
    }
    applyGradients(e8) {
      (Array.isArray(e8) ? e8.map((o8) => o8.name) : Object.keys(e8)).forEach((o8, n8) => {
        let s = Array.isArray(e8) ? e8[n8].tensor : e8[o8];
        if (s == null)
          return;
        let a = T.registeredVariables[o8];
        De(() => {
          let i10 = Ce(se(this.c, s), a);
          a.assign(i10);
        });
      }), this.incrementIterations();
    }
    setLearningRate(e8) {
      this.learningRate = e8, this.c != null && this.c.dispose(), this.c = Rr(ke(-e8));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [await this.saveIterations()];
    }
    async setWeights(e8) {
      if (e8 = await this.extractIterations(e8), e8.length !== 0)
        throw new Error("SGD optimizer does not have settable weights.");
    }
    getConfig() {
      return { learningRate: this.learningRate };
    }
    static fromConfig(e8, t8) {
      return new e8(t8.learningRate);
    }
  };
  var np = class extends ci {
    static get className() {
      return "Momentum";
    }
    constructor(e8, t8, o8 = false) {
      super(e8), this.learningRate = e8, this.momentum = t8, this.useNesterov = o8, this.accumulations = [], this.m = ke(this.momentum);
    }
    applyGradients(e8) {
      (Array.isArray(e8) ? e8.map((o8) => o8.name) : Object.keys(e8)).forEach((o8, n8) => {
        let s = T.registeredVariables[o8];
        this.accumulations[n8] == null && (this.accumulations[n8] = { originalName: `${o8}/momentum`, variable: De(() => Ht(s).variable(false)) });
        let a = this.accumulations[n8].variable, i10 = Array.isArray(e8) ? e8[n8].tensor : e8[o8];
        i10 != null && De(() => {
          let p, u = Ce(se(this.m, a), i10);
          this.useNesterov ? p = Ce(se(this.c, Ce(i10, se(u, this.m))), s) : p = Ce(se(this.c, u), s), a.assign(u), s.assign(p);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.m.dispose(), this.accumulations != null && Ot(this.accumulations.map((e8) => e8.variable));
    }
    setMomentum(e8) {
      this.momentum = e8;
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulations.map((e8) => ({ name: e8.originalName, tensor: e8.variable })));
    }
    async setWeights(e8) {
      e8 = await this.extractIterations(e8);
      let t8 = false;
      this.accumulations = e8.map((o8) => ({ originalName: o8.name, variable: o8.tensor.variable(t8) }));
    }
    getConfig() {
      return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
    }
    static fromConfig(e8, t8) {
      return new e8(t8.learningRate, t8.momentum, t8.useNesterov);
    }
  };
  var sp = class extends Nr {
    static get className() {
      return "RMSProp";
    }
    constructor(e8, t8 = 0.9, o8 = 0, n8 = null, s = false) {
      if (super(), this.learningRate = e8, this.decay = t8, this.momentum = o8, this.epsilon = n8, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = s, n8 == null && (this.epsilon = T.backend.epsilon()), e8 == null)
        throw new Error("learningRate for RMSPropOptimizer must be defined.");
    }
    applyGradients(e8) {
      (Array.isArray(e8) ? e8.map((o8) => o8.name) : Object.keys(e8)).forEach((o8, n8) => {
        let s = T.registeredVariables[o8], a = false;
        this.accumulatedMeanSquares[n8] == null && (this.accumulatedMeanSquares[n8] = { originalName: `${o8}/rms`, variable: De(() => Ht(s).variable(a)) }), this.accumulatedMoments[n8] == null && (this.accumulatedMoments[n8] = { originalName: `${o8}/momentum`, variable: De(() => Ht(s).variable(a)) }), this.accumulatedMeanGrads[n8] == null && this.centered && (this.accumulatedMeanGrads[n8] = { originalName: `${o8}/mg`, variable: De(() => Ht(s).variable(a)) });
        let i10 = Array.isArray(e8) ? e8[n8].tensor : e8[o8];
        if (i10 == null)
          return;
        let p = this.accumulatedMeanSquares[n8].variable, u = this.accumulatedMoments[n8].variable;
        De(() => {
          let c = Ce(se(p, this.decay), se(er(i10), 1 - this.decay));
          if (this.centered) {
            let l = this.accumulatedMeanGrads[n8].variable, m = Ce(se(l, this.decay), se(i10, 1 - this.decay)), d = je(se(i10, this.learningRate), Dr(Te(c, Ce(er(m), this.epsilon)))), f = Ce(se(u, this.momentum), d);
            p.assign(c), l.assign(m), u.assign(f);
            let h = Te(s, f);
            s.assign(h);
          } else {
            let l = Ce(se(p, this.decay), se(er(i10), 1 - this.decay)), m = Ce(se(u, this.momentum), je(se(i10, this.learningRate), Dr(Ce(l, this.epsilon))));
            p.assign(l), u.assign(m);
            let d = Te(s, m);
            s.assign(d);
          }
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedMeanSquares != null && Ot(this.accumulatedMeanSquares.map((e8) => e8.variable)), this.accumulatedMeanGrads != null && this.centered && Ot(this.accumulatedMeanGrads.map((e8) => e8.variable)), this.accumulatedMoments != null && Ot(this.accumulatedMoments.map((e8) => e8.variable));
    }
    async getWeights() {
      let e8 = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
      return this.centered && e8.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(e8.map((t8) => ({ name: t8.originalName, tensor: t8.variable })));
    }
    async setWeights(e8) {
      e8 = await this.extractIterations(e8);
      let t8 = this.centered ? e8.length / 3 : e8.length / 2, o8 = false;
      this.accumulatedMeanSquares = e8.slice(0, t8).map((n8) => ({ originalName: n8.name, variable: n8.tensor.variable(o8) })), this.accumulatedMoments = e8.slice(t8, t8 * 2).map((n8) => ({ originalName: n8.name, variable: n8.tensor.variable(o8) })), this.centered && (this.accumulatedMeanGrads = e8.slice(t8 * 2, t8 * 3).map((n8) => ({ originalName: n8.name, variable: n8.tensor.variable(o8) })));
    }
    getConfig() {
      return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
    }
    static fromConfig(e8, t8) {
      return new e8(t8.learningRate, t8.decay, t8.momentum, t8.epsilon, t8.centered);
    }
  };
  var Bj = [ep, tp, rp, op, np, sp, ci];
  function PN() {
    for (let r8 of Bj)
      qw(r8);
  }
  var mi = {};
  Ke(mi, { CompositeArrayBuffer: () => jt, browserFiles: () => MN, browserHTTPRequest: () => zN, concatenateArrayBuffers: () => J0, copyModel: () => dk, decodeWeights: () => nd, encodeWeights: () => Y0, fromMemory: () => VN, fromMemorySync: () => Jw, getLoadHandlers: () => ok, getModelArtifactsForJSON: () => oc, getModelArtifactsForJSONSync: () => ww, getModelArtifactsInfoForJSON: () => wa, getSaveHandlers: () => rk, getWeightSpecs: () => ad, http: () => rf, isHTTPScheme: () => tf, listModels: () => lk, loadWeights: () => LN, moveModel: () => fk, registerLoadRouter: () => tk, registerSaveRouter: () => ek, removeModel: () => mk, weightsLoaderFactory: () => Qw, withSaveHandler: () => WN, withSaveHandlerSync: () => UN });
  var zj = "model";
  var Vj = ".json";
  var Wj = ".weights.bin";
  function ON(r8) {
    return new Promise((e8) => setTimeout(e8)).then(r8);
  }
  var li = class {
    constructor(e8) {
      if (!A().getBool("IS_BROWSER"))
        throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
      e8.startsWith(li.URL_SCHEME) && (e8 = e8.slice(li.URL_SCHEME.length)), (e8 == null || e8.length === 0) && (e8 = zj), this.modelJsonFileName = e8 + Vj, this.weightDataFileName = e8 + Wj;
    }
    async save(e8) {
      if (typeof document == "undefined")
        throw new Error("Browser downloads are not supported in this environment since `document` is not present");
      let t8 = jt.join(e8.weightData), o8 = window.URL.createObjectURL(new Blob([t8], { type: "application/octet-stream" }));
      if (e8.modelTopology instanceof ArrayBuffer)
        throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      {
        let n8 = [{ paths: ["./" + this.weightDataFileName], weights: e8.weightSpecs }], s = sd(e8, n8), a = window.URL.createObjectURL(new Blob([JSON.stringify(s)], { type: "application/json" })), i10 = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
        if (i10.download = this.modelJsonFileName, i10.href = a, await ON(() => i10.dispatchEvent(new MouseEvent("click"))), e8.weightData != null) {
          let p = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
          p.download = this.weightDataFileName, p.href = o8, await ON(() => p.dispatchEvent(new MouseEvent("click")));
        }
        return { modelArtifactsInfo: wa(e8) };
      }
    }
  };
  li.URL_SCHEME = "downloads://";
  var jw = class {
    constructor(e8) {
      if (e8 == null || e8.length < 1)
        throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e8}`);
      this.jsonFile = e8[0], this.weightsFiles = e8.slice(1);
    }
    async load() {
      return new Promise((e8, t8) => {
        let o8 = new FileReader();
        o8.onload = (n8) => {
          let s = JSON.parse(n8.target.result), a = s.modelTopology;
          if (a == null) {
            t8(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
            return;
          }
          if (s.weightsManifest == null) {
            t8(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
            return;
          }
          if (this.weightsFiles.length === 0) {
            e8({ modelTopology: a });
            return;
          }
          let p = oc(s, (u) => this.loadWeights(u));
          e8(p);
        }, o8.onerror = (n8) => t8(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), o8.readAsText(this.jsonFile);
      });
    }
    loadWeights(e8) {
      let t8 = [], o8 = [];
      for (let a of e8)
        t8.push(...a.weights), o8.push(...a.paths);
      let n8 = this.checkManifestAndWeightFiles(e8), s = o8.map((a) => this.loadWeightsFile(a, n8[a]));
      return Promise.all(s).then((a) => [t8, a]);
    }
    loadWeightsFile(e8, t8) {
      return new Promise((o8, n8) => {
        let s = new FileReader();
        s.onload = (a) => {
          let i10 = a.target.result;
          o8(i10);
        }, s.onerror = (a) => n8(`Failed to weights data from file of path '${e8}'.`), s.readAsArrayBuffer(t8);
      });
    }
    checkManifestAndWeightFiles(e8) {
      let t8 = [], o8 = this.weightsFiles.map((s) => Cw(s.name)), n8 = {};
      for (let s of e8)
        s.paths.forEach((a) => {
          let i10 = Cw(a);
          if (t8.indexOf(i10) !== -1)
            throw new Error(`Duplicate file basename found in weights manifest: '${i10}'`);
          if (t8.push(i10), o8.indexOf(i10) === -1)
            throw new Error(`Weight file with basename '${i10}' is not provided.`);
          n8[a] = this.weightsFiles[o8.indexOf(i10)];
        });
      if (t8.length !== this.weightsFiles.length)
        throw new Error(`Mismatch in the number of files in weights manifest (${t8.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
      return n8;
    }
  };
  var Uj = (r8) => A().getBool("IS_BROWSER") && !Array.isArray(r8) && r8.startsWith(li.URL_SCHEME) ? Gj(r8.slice(li.URL_SCHEME.length)) : null;
  ft.registerSaveRouter(Uj);
  function Gj(r8 = "model") {
    return new li(r8);
  }
  function MN(r8) {
    return new jw(r8);
  }
  function Xw(r8, e8, t8, o8) {
    a(r8), t8 = t8 == null ? 0 : t8, o8 = o8 == null ? 1 : o8, i10(t8, o8);
    let n8 = 0, s = (p) => (p.then((u) => {
      let c = t8 + ++n8 / r8.length * (o8 - t8);
      return e8(c), u;
    }), p);
    function a(p) {
      $(p != null && Array.isArray(p) && p.length > 0, () => "promises must be a none empty array");
    }
    function i10(p, u) {
      $(p >= 0 && p <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${p}`), $(u >= 0 && u <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${u}`), $(u >= p, () => `startFraction must be no more than endFraction, but got startFraction ${p} and endFraction ${u}`);
    }
    return Promise.all(r8.map(s));
  }
  async function Yw(r8, e8) {
    e8 == null && (e8 = {});
    let t8 = e8.fetchFunc == null ? A().platform.fetch : e8.fetchFunc, o8 = r8.map((l) => t8(l, e8.requestInit, { isBinary: true })), n8 = 0, s = 0.5, i10 = (e8.onProgress == null ? await Promise.all(o8) : await Xw(o8, e8.onProgress, n8, s)).map((l) => l.arrayBuffer()), p = 0.5, u = 1;
    return e8.onProgress == null ? await Promise.all(i10) : await Xw(i10, e8.onProgress, p, u);
  }
  async function LN(r8, e8 = "", t8, o8) {
    return Qw((a) => Yw(a, { requestInit: o8 }))(r8, e8, t8);
  }
  function Qw(r8) {
    return async (e8, t8 = "", o8) => {
      let n8 = e8.map(() => false), s = {}, a = o8 != null ? o8.map(() => false) : [], i10 = [];
      if (e8.forEach((d, f) => {
        let h = 0;
        d.weights.forEach((g) => {
          let x = "quantization" in g ? g.quantization.dtype : g.dtype, b = Cl[x] * Ge(g.shape), C = () => {
            n8[f] = true, s[f] == null && (s[f] = []), s[f].push({ manifestEntry: g, groupOffset: h, sizeBytes: b });
          };
          o8 != null ? o8.forEach((S, k) => {
            S === g.name && (C(), a[k] = true);
          }) : C(), i10.push(g.name), h += b;
        });
      }), !a.every((d) => d)) {
        let d = o8.filter((f, h) => !a[h]);
        throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${i10.join(", ")}.`);
      }
      let p = n8.reduce((d, f, h) => (f && d.push(h), d), []), u = [];
      p.forEach((d) => {
        e8[d].paths.forEach((f) => {
          let h = t8 + (t8.endsWith("/") ? "" : "/") + f;
          u.push(h);
        });
      });
      let c = await r8(u), l = {}, m = 0;
      return p.forEach((d) => {
        let f = e8[d].paths.length, h = new jt(c.slice(m, m + f));
        s[d].forEach((x) => {
          let b = h.slice(x.groupOffset, x.groupOffset + x.sizeBytes), C = nd(b, [x.manifestEntry]);
          for (let S in C)
            l[S] = C[S];
        }), m += f;
      }), l;
    };
  }
  var Hj = "application/octet-stream";
  var Kj = "application/json";
  var El = class {
    constructor(e8, t8) {
      if (this.DEFAULT_METHOD = "POST", t8 == null && (t8 = {}), this.weightPathPrefix = t8.weightPathPrefix, this.onProgress = t8.onProgress, this.weightUrlConverter = t8.weightUrlConverter, t8.fetchFunc != null ? ($(typeof t8.fetchFunc == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = t8.fetchFunc) : this.fetch = A().platform.fetch, $(e8 != null && e8.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(e8) && $(e8.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${e8.length}).`), this.path = e8, t8.requestInit != null && t8.requestInit.body != null)
        throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      this.requestInit = t8.requestInit || {};
    }
    async save(e8) {
      if (e8.modelTopology instanceof ArrayBuffer)
        throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      let t8 = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
      t8.body = new FormData();
      let o8 = [{ paths: ["./model.weights.bin"], weights: e8.weightSpecs }], n8 = sd(e8, o8);
      if (t8.body.append("model.json", new Blob([JSON.stringify(n8)], { type: Kj }), "model.json"), e8.weightData != null) {
        let a = jt.join(e8.weightData);
        t8.body.append("model.weights.bin", new Blob([a], { type: Hj }), "model.weights.bin");
      }
      let s = await this.fetch(this.path, t8);
      if (s.ok)
        return { modelArtifactsInfo: wa(e8), responses: [s] };
      throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`);
    }
    async load() {
      let e8 = await this.fetch(this.path, this.requestInit);
      if (!e8.ok)
        throw new Error(`Request to ${this.path} failed with status code ${e8.status}. Please verify this URL points to the model JSON of the model to load.`);
      let t8;
      try {
        t8 = await e8.json();
      } catch (s) {
        let a = `Failed to parse model JSON of response from ${this.path}.`;
        throw this.path.endsWith(".pb") ? a += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : a += " Please make sure the server is serving valid JSON for this request.", new Error(a);
      }
      let o8 = t8.modelTopology, n8 = t8.weightsManifest;
      if (o8 == null && n8 == null)
        throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
      return oc(t8, (s) => this.loadWeights(s));
    }
    async loadWeights(e8) {
      let t8 = Array.isArray(this.path) ? this.path[1] : this.path, [o8, n8] = qj(t8), s = this.weightPathPrefix || o8, a = ad(e8), i10 = [], p = [];
      for (let c of e8)
        for (let l of c.paths)
          this.weightUrlConverter != null ? p.push(this.weightUrlConverter(l)) : i10.push(s + l + n8);
      this.weightUrlConverter && i10.push(...await Promise.all(p));
      let u = await Yw(i10, { requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress });
      return [a, u];
    }
  };
  El.URL_SCHEME_REGEX = /^https?:\/\//;
  function qj(r8) {
    let e8 = r8.lastIndexOf("/"), t8 = r8.lastIndexOf("?"), o8 = r8.substring(0, e8), n8 = t8 > e8 ? r8.substring(t8) : "";
    return [o8 + "/", n8];
  }
  function tf(r8) {
    return r8.match(El.URL_SCHEME_REGEX) != null;
  }
  var BN = (r8, e8) => {
    if (typeof fetch == "undefined" && (e8 == null || e8.fetchFunc == null))
      return null;
    {
      let t8 = true;
      if (Array.isArray(r8) ? t8 = r8.every((o8) => tf(o8)) : t8 = tf(r8), t8)
        return rf(r8, e8);
    }
    return null;
  };
  ft.registerSaveRouter(BN);
  ft.registerLoadRouter(BN);
  function rf(r8, e8) {
    return new El(r8, e8);
  }
  function zN(r8, e8) {
    return rf(r8, e8);
  }
  var Rl = class {
    constructor(e8) {
      this.modelArtifacts = e8;
    }
    load() {
      return this.modelArtifacts;
    }
  };
  var of = class {
    constructor(e8) {
      this.saveHandler = e8;
    }
    save(e8) {
      return this.saveHandler(e8);
    }
  };
  var Zw = class {
    constructor(e8) {
      e8.load && (this.load = () => Promise.resolve(e8.load())), e8.save && (this.save = (t8) => Promise.resolve(e8.save(t8)));
    }
  };
  function VN(r8, e8, t8, o8) {
    let n8 = arguments;
    return new Zw(Jw(...n8));
  }
  function Jw(r8, e8, t8, o8) {
    return arguments.length === 1 ? r8.modelTopology != null || r8.weightSpecs != null ? new Rl(r8) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Rl({ modelTopology: r8 })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Rl({ modelTopology: r8, weightSpecs: e8, weightData: t8, trainingConfig: o8 }));
  }
  function WN(r8) {
    return new of(r8);
  }
  function UN(r8) {
    return new of(r8);
  }
  var HN = {};
  Ke(HN, { confusionMatrix: () => GN });
  function jj(r8, e8, t8) {
    let o8 = v(r8, "labels", "confusionMatrix"), n8 = v(e8, "predictions", "confusionMatrix");
    $(t8 == null || t8 > 0 && Number.isInteger(t8), () => `If provided, numClasses must be a positive integer, but got ${t8}`), $(o8.rank === 1, () => `Expected the rank of labels to be 1, but got ${o8.rank}`), $(n8.rank === 1, () => `Expected the rank of predictions to be 1, but got ${n8.rank}`), $(o8.shape[0] === n8.shape[0], () => `Mismatch in the number of examples: ${o8.shape[0]} vs. ${n8.shape[0]}. Labels and predictions should have the same number of elements.`), $(t8 > 0 && Number.isInteger(t8), () => `numClasses is required to be a positive integer, but got ${t8}`);
    let s = Tl(qe(o8, "int32"), t8), a = Tl(qe(n8, "int32"), t8), i10 = fc(s), p = Ze(i10, a);
    return qe(p, "int32");
  }
  var GN = N({ confusionMatrix_: jj });
  var XN = {};
  Ke(XN, { draw: () => rX, fromPixels: () => oX, fromPixelsAsync: () => Jj, toPixels: () => tX });
  var ap;
  var KN = false;
  function qN(r8, e8 = 3) {
    if (e8 > 4)
      throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    if (r8 == null)
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    let t8 = false, o8 = false, n8 = false, s = false, a = false, i10 = false;
    if (r8.data instanceof Uint8Array)
      t8 = true;
    else if (typeof ImageData != "undefined" && r8 instanceof ImageData)
      o8 = true;
    else if (typeof HTMLVideoElement != "undefined" && r8 instanceof HTMLVideoElement)
      n8 = true;
    else if (typeof HTMLImageElement != "undefined" && r8 instanceof HTMLImageElement)
      s = true;
    else if (r8.getContext != null)
      a = true;
    else if (typeof ImageBitmap != "undefined" && r8 instanceof ImageBitmap)
      i10 = true;
    else
      throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r8.constructor.name}`);
    if (fl(Au, T.backendName) != null) {
      let f = { pixels: r8 }, h = { numChannels: e8 };
      return T.runKernel(Au, f, h);
    }
    let [u, c] = n8 ? [r8.videoWidth, r8.videoHeight] : [r8.width, r8.height], l;
    if (a)
      l = r8.getContext("2d").getImageData(0, 0, u, c).data;
    else if (o8 || t8)
      l = r8.data;
    else if (s || n8 || i10) {
      if (ap == null)
        if (typeof document == "undefined")
          if (typeof OffscreenCanvas != "undefined" && typeof OffscreenCanvasRenderingContext2D != "undefined")
            ap = new OffscreenCanvas(1, 1).getContext("2d");
          else
            throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
        else
          ap = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
      ap.canvas.width = u, ap.canvas.height = c, ap.drawImage(r8, 0, 0, u, c), l = ap.getImageData(0, 0, u, c).data;
    }
    let m;
    if (e8 === 4)
      m = new Int32Array(l);
    else {
      let f = u * c;
      m = new Int32Array(f * e8);
      for (let h = 0; h < f; h++)
        for (let g = 0; g < e8; ++g)
          m[h * e8 + g] = l[h * 4 + g];
    }
    return qd(m, [c, u, e8], "int32");
  }
  function Xj(r8) {
    return r8 != null && r8.data instanceof Uint8Array;
  }
  function Yj() {
    return typeof window != "undefined" && typeof ImageBitmap != "undefined" && window.hasOwnProperty("createImageBitmap");
  }
  function Qj(r8) {
    return r8 != null && r8.width !== 0 && r8.height !== 0;
  }
  function Zj(r8) {
    return Yj() && !(r8 instanceof ImageBitmap) && Qj(r8) && !Xj(r8);
  }
  async function Jj(r8, e8 = 3) {
    let t8 = null;
    if (A().getBool("WRAP_TO_IMAGEBITMAP") && Zj(r8)) {
      let o8;
      try {
        o8 = await createImageBitmap(r8, { premultiplyAlpha: "none" });
      } catch (n8) {
        o8 = null;
      }
      o8 != null && o8.width === r8.width && o8.height === r8.height ? t8 = o8 : t8 = r8;
    } else
      t8 = r8;
    return qN(t8, e8);
  }
  function jN(r8) {
    if (r8.rank !== 2 && r8.rank !== 3)
      throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${r8.rank}.`);
    let e8 = r8.rank === 2 ? 1 : r8.shape[2];
    if (e8 > 4 || e8 === 2)
      throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e8}`);
    if (r8.dtype !== "float32" && r8.dtype !== "int32")
      throw new Error(`Unsupported type for toPixels: ${r8.dtype}. Please use float32 or int32 tensors.`);
  }
  function eX(r8) {
    let e8 = (r8 == null ? void 0 : r8.alpha) || 1;
    if (e8 > 1 || e8 < 0)
      throw new Error(`Alpha value ${e8} is suppoed to be in range [0 - 1].`);
  }
  async function tX(r8, e8) {
    let t8 = v(r8, "img", "toPixels");
    if (!(r8 instanceof ut)) {
      let u = t8;
      t8 = qe(u, "int32"), u.dispose();
    }
    jN(t8);
    let [o8, n8] = t8.shape.slice(0, 2), s = t8.rank === 2 ? 1 : t8.shape[2], a = await t8.data(), i10 = t8.dtype === "float32" ? 255 : 1, p = new Uint8ClampedArray(n8 * o8 * 4);
    for (let u = 0; u < o8 * n8; ++u) {
      let c = [0, 0, 0, 255];
      for (let m = 0; m < s; m++) {
        let d = a[u * s + m];
        if (t8.dtype === "float32") {
          if (d < 0 || d > 1)
            throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`);
        } else if (t8.dtype === "int32" && (d < 0 || d > 255))
          throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);
        s === 1 ? (c[0] = d * i10, c[1] = d * i10, c[2] = d * i10) : c[m] = d * i10;
      }
      let l = u * 4;
      p[l + 0] = Math.round(c[0]), p[l + 1] = Math.round(c[1]), p[l + 2] = Math.round(c[2]), p[l + 3] = Math.round(c[3]);
    }
    if (e8 != null) {
      KN || (console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."), KN = true), e8.width = n8, e8.height = o8;
      let u = e8.getContext("2d"), c = new ImageData(p, n8, o8);
      u.putImageData(c, 0, 0);
    }
    return t8 !== r8 && t8.dispose(), p;
  }
  function rX(r8, e8, t8) {
    let o8 = v(r8, "img", "draw");
    if (!(r8 instanceof ut)) {
      let a = o8;
      o8 = qe(a, "int32"), a.dispose();
    }
    jN(o8), eX(t8 == null ? void 0 : t8.imageOptions);
    let n8 = { image: o8 }, s = { canvas: e8, options: t8 };
    T.runKernel(qm, n8, s);
  }
  var oX = N({ fromPixels_: qN });
  var nf = {};
  Ke(nf, { prepareAndValidate: () => YN });
  function YN(r8, e8) {
    let t8 = r8.shape.length, o8 = e8.shape.length;
    if (t8 < 1)
      throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t8}.`);
    if (o8 < 1)
      throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${o8}.`);
    if (e8.dtype !== "int32")
      throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e8.dtype}.`);
    if (e8.shape[o8 - 1] > t8)
      throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e8.shape[o8 - 1]} vs. ${t8}`);
    if (Ge(r8.shape) === 0)
      throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r8.shape}.`);
    let n8 = e8.shape, s = n8[n8.length - 1], a = 1;
    for (let l = 0; l < n8.length - 1; ++l)
      a *= n8[l];
    let i10 = r8.shape, p = n8.slice();
    p.pop();
    let u = 1;
    for (let l = s; l < t8; ++l)
      u *= i10[l], p.push(i10[l]);
    let c = [...qs(r8.shape).map((l) => l / u), 1].slice(0, s);
    return [p, a, u, c];
  }
  var ct = {};
  Ke(ct, { assertParamsValid: () => sX, computeFlatOffset: () => cX, computeOutShape: () => iX, getNormalizedAxes: () => uX, isSliceContinous: () => pX, maskToAxes: () => aX, parseSliceParams: () => lX, sliceInfo: () => mX, startForAxis: () => nT, startIndicesWithElidedDims: () => tT, stopForAxis: () => sT, stopIndicesWithElidedDims: () => rT, stridesForAxis: () => oT, stridesWithElidedDims: () => ZN });
  var eS = -2;
  var nX = -1;
  function sX(r8, e8, t8) {
    let o8 = r8.shape.length;
    $(o8 === e8.length, () => `Error in slice${o8}D: Length of begin ${e8} must match the rank of the array (${o8}).`), $(o8 === t8.length, () => `Error in slice${o8}D: Length of size ${t8} must match the rank of the array (${o8}).`);
    for (let n8 = 0; n8 < o8; ++n8)
      $(e8[n8] + t8[n8] <= r8.shape[n8], () => `Error in slice${o8}D: begin[${n8}] + size[${n8}] (${e8[n8] + t8[n8]}) would overflow input.shape[${n8}] (${r8.shape[n8]})`);
  }
  function aX(r8) {
    let e8 = [], t8 = 0;
    for (; r8 > 0; )
      r8 & 1 && e8.push(t8), r8 /= 2, t8++;
    return e8;
  }
  function iX(r8, e8, t8) {
    let o8 = [];
    for (let n8 = 0; n8 < r8.length; n8++)
      o8[n8] = Math.ceil((e8[n8] - r8[n8]) / t8[n8]);
    return o8;
  }
  function ZN(r8, e8, t8, o8) {
    let n8 = [...r8];
    for (let s = n8.length; s < o8.length; s++)
      n8.push(1);
    for (let s = 0; s < t8; s++)
      s === 0 ? n8[e8] = 1 : (n8.splice(e8, 0, 1), n8.pop());
    return n8;
  }
  function JN(r8, e8, t8) {
    return t8 <= r8 ? t8 : t8 - (e8 - 1);
  }
  function eT(r8, e8) {
    let t8 = [];
    for (let o8 = 0; o8 < r8; o8++)
      t8.push(e8 + o8);
    return t8;
  }
  function uX(r8, e8, t8, o8, n8, s, a, i10, p) {
    let u = r8.length, c = new Array(u), l = new Array(u), m = new Array(u);
    if (e8.length && t8 > 0) {
      let d = e8[0], f = t8 + 1;
      c = tT(a, d, f, o8, r8), l = rT(i10, d, f, n8, r8), m = ZN(s, d, f, r8);
    } else
      for (let d = 0; d < u; d++)
        c[d] = nT(a, o8, s, r8, d, p), l[d] = sT(i10, n8, s, r8, d, p), m[d] = oT(s, d, p);
    return { begin: c, end: l, strides: m };
  }
  function tT(r8, e8, t8, o8, n8) {
    let s = [...n8], a = eT(t8, e8);
    for (let i10 = 0; i10 < s.length; i10++)
      if (a.indexOf(i10) > -1)
        s[i10] = 0;
      else {
        let p = JN(e8, t8, i10), u = o8[p];
        r8 & 1 << p && (u = 0), s[i10] = u;
      }
    return s;
  }
  function rT(r8, e8, t8, o8, n8) {
    let s = [...n8], a = eT(t8, e8);
    for (let i10 = 0; i10 < s.length; i10++)
      if (a.indexOf(i10) > -1)
        s[i10] = Number.MAX_SAFE_INTEGER;
      else {
        let p = JN(e8, t8, i10), u = o8[p];
        r8 & 1 << p && (u = Number.MAX_SAFE_INTEGER), s[i10] = u;
      }
    for (let i10 = 0; i10 < s.length; i10++) {
      let p = n8[i10];
      s[i10] < 0 && (s[i10] += p), s[i10] = Gp(0, s[i10], n8[i10]);
    }
    return s;
  }
  function oT(r8, e8, t8) {
    let o8 = r8[e8];
    return (t8 & 1 << e8 || o8 == null) && (o8 = 1), o8;
  }
  function nT(r8, e8, t8, o8, n8, s) {
    let a = e8[n8], i10 = t8[n8] || 1;
    (r8 & 1 << n8 || s & 1 << n8 || a == null) && (i10 > 0 ? a = Number.MIN_SAFE_INTEGER : a = Number.MAX_SAFE_INTEGER);
    let p = o8[n8];
    return a < 0 && (a += p), a = Gp(0, a, p - 1), a;
  }
  function sT(r8, e8, t8, o8, n8, s) {
    let a = e8[n8], i10 = t8[n8] || 1;
    (r8 & 1 << n8 || s & 1 << n8 || a == null) && (i10 > 0 ? a = Number.MAX_SAFE_INTEGER : a = Number.MIN_SAFE_INTEGER);
    let p = o8[n8];
    return a < 0 && (a += p), i10 > 0 ? a = Gp(0, a, p) : a = Gp(-1, a, p - 1), a;
  }
  function pX(r8, e8, t8) {
    let o8 = t8.length;
    for (let n8 = 0; n8 < t8.length; n8++)
      if (t8[n8] > 1) {
        o8 = n8;
        break;
      }
    for (let n8 = o8 + 1; n8 < t8.length; n8++)
      if (e8[n8] > 0 || t8[n8] !== r8[n8])
        return false;
    return true;
  }
  function cX(r8, e8) {
    let t8 = r8.length > 0 ? r8[r8.length - 1] : 1;
    for (let o8 = 0; o8 < r8.length - 1; o8++)
      t8 += r8[o8] * e8[o8];
    return t8;
  }
  function lX(r8, e8, t8) {
    let o8, n8 = r8.shape.length;
    typeof e8 == "number" ? o8 = [e8, ...new Array(n8 - 1).fill(0)] : e8.length < n8 ? o8 = e8.concat(new Array(n8 - e8.length).fill(0)) : o8 = e8.slice(), o8.forEach((a) => {
      $(a !== -1, () => "slice() does not support negative begin indexing.");
    });
    let s;
    return t8 == null ? s = new Array(n8).fill(-1) : typeof t8 == "number" ? s = [t8, ...new Array(n8 - 1).fill(-1)] : t8.length < n8 ? s = t8.concat(new Array(n8 - t8.length).fill(-1)) : s = t8, s = s.map((a, i10) => a >= 0 ? a : ($(a === -1, () => `Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i10}.`), r8.shape[i10] - o8[i10])), [o8, s];
  }
  function mX(r8, e8, t8, o8, n8, s, a, i10, p) {
    let u;
    if (o8 == null ? (u = new Array(e8.length), u.fill(1)) : u = o8, a != null && a & a - 1)
      throw new Error("Multiple ellipses in slice is not allowed.");
    let c = false, l = { dims: u.length, numAddAxisAfterEllipsis: 0, begin: e8.slice(), end: t8.slice(), strides: u.slice(), beginMask: n8, endMask: s, ellipsisMask: a, newAxisMask: i10, shrinkAxisMask: p };
    for (let C = 0; C < l.dims; C++)
      c && 1 << C & i10 && l.numAddAxisAfterEllipsis++, 1 << C & a && (c = true);
    c || (l.ellipsisMask |= 1 << l.dims, l.dims++);
    let m = { dims: r8.length, beginMask: 0, endMask: 0, beginValid: false, endValid: false };
    dX(l, m);
    let d = true, f = true, h = true, g = [], x = [];
    for (let C = 0; C < r8.length; ++C) {
      if (m.strides[C] === 0)
        throw Error(`strides[${C}] must be non-zero`);
      let S = !!(m.shrinkAxisMask & 1 << C), k = r8[C];
      if (k === -1) {
        g.push(S ? 1 : -1);
        continue;
      }
      let _ = [m.beginMask & 1 << C, m.endMask & 1 << C], E = [m.strides[C] > 0 ? 0 : -1, m.strides[C] > 0 ? k : k - 1];
      if (S && m.strides[C] <= 0)
        throw Error("only stride 1 allowed on non-range indexing.");
      h = h && m.strides[C] === 1;
      let R = !!(m.beginMask & 1 << C && m.endMask & 1 << C);
      if (m.beginValid && m.endValid) {
        if (S) {
          let M = m.begin[C] < 0 ? k + m.begin[C] : m.begin[C];
          if (m.begin[C] = M, m.end[C] = m.begin[C] + 1, M < 0 || M >= k)
            throw Error(`slice index ${m.begin[C]} of dimension ${C} out of bounds.`);
        } else
          m.begin[C] = QN(m.begin[C], 0, m.strides[C], k, _, E), m.end[C] = QN(m.end[C], 1, m.strides[C], k, _, E);
        let O = m.strides[C] === 1 && m.begin[C] === 0 && m.end[C] === k;
        d = d && O, f = f && (C === 0 && m.strides[C] === 1 || O);
      } else
        d = d && m.strides[C] === 1 && R, f = f && (C === 0 && m.strides[C] === 1 || R);
      let D, P = false;
      if (m.beginValid && m.endValid ? (D = m.end[C] - m.begin[C], P = true) : S ? (D = 1, P = true) : R && k >= 0 && (m.strides[C] < 0 ? D = -k : D = k, P = true), P) {
        let O;
        D === 0 || D < 0 != m.strides[C] < 0 ? O = 0 : O = Math.trunc(D / m.strides[C]) + (D % m.strides[C] !== 0 ? 1 : 0), g.push(O);
      } else
        g.push(-1);
    }
    for (let C = 0; C < m.finalShapeGatherIndices.length; ++C) {
      let S = m.finalShapeGatherIndices[C];
      S >= 0 ? x.push(g[S]) : S === eS && x.push(1);
    }
    return { finalShapeSparse: x.filter((C, S) => m.finalShapeGatherIndices[S] !== eS), finalShape: x, isIdentity: d, sliceDim0: f, isSimpleSlice: h, begin: m.begin, end: m.end, strides: m.strides };
  }
  function dX(r8, e8) {
    e8.beginMask = 0, e8.endMask = 0, e8.shrinkAxisMask = 0;
    let t8 = 0;
    e8.beginValid = r8.begin != null, e8.endValid = r8.end != null, e8.begin = new Array(e8.dims), e8.end = new Array(e8.dims), e8.strides = new Array(e8.dims), e8.finalShapeGatherIndices = [], e8.finalShapeGatherIndicesSparse = [], e8.inputShapeGatherIndicesSparse = new Array(e8.dims);
    for (let o8 = 0; o8 < r8.dims; o8++)
      if (1 << o8 & r8.ellipsisMask) {
        let n8 = Math.min(e8.dims - (r8.dims - o8) + 1 + r8.numAddAxisAfterEllipsis, e8.dims);
        for (; t8 < n8; t8++)
          e8.begin[t8] = 0, e8.end[t8] = 0, e8.strides[t8] = 1, e8.beginMask |= 1 << t8, e8.endMask |= 1 << t8, e8.finalShapeGatherIndices.push(t8), e8.finalShapeGatherIndicesSparse.push(-1), e8.inputShapeGatherIndicesSparse[t8] = o8;
      } else if (1 << o8 & r8.newAxisMask)
        e8.finalShapeGatherIndices.push(eS), e8.finalShapeGatherIndicesSparse.push(-1);
      else {
        if (t8 === e8.begin.length)
          throw Error(`Index out of range using input dim ${t8}; input has only ${e8.dims} dims, ${e8.begin.length}.`);
        r8.begin != null && (e8.begin[t8] = r8.begin[o8]), r8.end != null && (e8.end[t8] = r8.end[o8]), e8.strides[t8] = r8.strides[o8], r8.beginMask & 1 << o8 && (e8.beginMask |= 1 << t8), r8.endMask & 1 << o8 && (e8.endMask |= 1 << t8), r8.shrinkAxisMask & 1 << o8 ? (e8.finalShapeGatherIndices.push(nX), e8.finalShapeGatherIndicesSparse.push(-1), e8.shrinkAxisMask |= 1 << t8) : (e8.finalShapeGatherIndices.push(t8), e8.finalShapeGatherIndicesSparse.push(o8)), e8.inputShapeGatherIndicesSparse[t8] = o8, t8++;
      }
  }
  function QN(r8, e8, t8, o8, n8, s) {
    if (n8[e8])
      return t8 > 0 ? s[e8] : s[e8 + 1 & 1];
    {
      let a = r8 < 0 ? o8 + r8 : r8;
      return a < s[0] ? s[0] : a > s[1] ? s[1] : a;
    }
  }
  var fX = "4.7.0";
  var Dl = class {
    static sgd(e8) {
      return new ci(e8);
    }
    static momentum(e8, t8, o8 = false) {
      return new np(e8, t8, o8);
    }
    static rmsprop(e8, t8 = 0.9, o8 = 0, n8 = null, s = false) {
      return new sp(e8, t8, o8, n8, s);
    }
    static adam(e8 = 1e-3, t8 = 0.9, o8 = 0.999, n8 = null) {
      return new rp(e8, t8, o8, n8);
    }
    static adadelta(e8 = 1e-3, t8 = 0.95, o8 = null) {
      return new ep(e8, t8, o8);
    }
    static adamax(e8 = 2e-3, t8 = 0.9, o8 = 0.999, n8 = null, s = 0) {
      return new op(e8, t8, o8, n8, s);
    }
    static adagrad(e8, t8 = 0.1) {
      return new tp(e8, t8);
    }
  };
  var uGe = Dl;
  var hX = (() => typeof requestAnimationFrame != "undefined" ? requestAnimationFrame : typeof setImmediate != "undefined" ? setImmediate : (r8) => r8())();
  function tS() {
    return new Promise((r8) => hX(() => r8()));
  }
  var w = {};
  Ke(w, { ERF_A1: () => DX, ERF_A2: () => AX, ERF_A3: () => FX, ERF_A4: () => PX, ERF_A5: () => OX, ERF_P: () => RX, PARALLELIZE_THRESHOLD: () => sf, RowPartitionType: () => Da, SELU_SCALE: () => EX, SELU_SCALEALPHA: () => $X, applyActivation: () => Zu, assertAndGetBroadcastShape: () => rt, assertAxesAreInnerMostDims: () => GH, assertParamsConsistent: () => gX, assignToTypedArray: () => WX, axesAreInnerMostDims: () => Dw, calculateShapes: () => F1, checkEinsumDimSizes: () => jX, checkPadOnDimRoundingMode: () => Lt, combineLocations: () => c2, combineRaggedTensorToTensorShapes: () => yX, complexWithEvenIndex: () => BX, complexWithOddIndex: () => zX, computeConv2DInfo: () => Vu, computeConv3DInfo: () => $k, computeDefaultPad: () => Rw, computeDilation2DInfo: () => W4, computeOptimalWindowSize: () => SX, computeOutAndReduceShapes: () => UH, computeOutShape: () => xX, computePool2DInfo: () => Ew, computePool3DInfo: () => U4, convertConv2DDataFormat: () => Ek, decodeEinsumEquation: () => KX, eitherStridesOrDilationsAreOne: () => gr, expandShapeToKeepDim: () => ni, exponent: () => GX, exponents: () => UX, fromStringArrayToUint8: () => h5, fromUint8ToStringArray: () => f5, getAxesPermutation: () => HH, getBroadcastDims: () => n2, getComplexWithIndex: () => VX, getEinsumComputePath: () => XX, getEinsumPermutation: () => qX, getFusedBiasGradient: () => Qu, getFusedDyActivation: () => Yu, getImageCenter: () => IX, getInnerMostAxes: () => qH, getPermuted: () => kX, getRaggedRank: () => CX, getReductionAxes: () => gd, getReshaped: () => vX, getReshapedPermuted: () => NX, getRowPartitionTypesHelper: () => bX, getSliceBeginCoords: () => TX, getSliceSize: () => _X, getSparseFillEmptyRowsIndicesDenseShapeMismatch: () => JX, getSparseFillEmptyRowsNegativeIndexErrorMessage: () => e5, getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: () => t5, getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: () => n5, getSparseReshapeInputOutputMismatchErrorMessage: () => a5, getSparseReshapeInputOutputMultipleErrorMessage: () => s5, getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: () => r5, getSparseReshapeNegativeOutputDimErrorMessage: () => o5, getSparseSegmentReductionIndicesOutOfRangeErrorMessage: () => c5, getSparseSegmentReductionNegativeSegmentIdsErrorMessage: () => i5, getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: () => u5, getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: () => p5, getUndoAxesPermutation: () => KH, isIdentityPermutation: () => YX, log: () => MG, mergeRealAndImagArrays: () => MX, prepareAndValidate: () => YN, prepareSplitSize: () => ZX, segment_util: () => oS, shouldFuse: () => Ju, slice_util: () => ct, splitRealAndImagArrays: () => LX, stridesOrDilationsArePositive: () => va, tupleValuesAreOne: () => zu, upcastType: () => dt, validateDefaultValueShape: () => wX, validateInput: () => dc, validateUpdateShape: () => Uw, warn: () => Ca });
  function gX(r8, e8) {
    let t8 = r8[0].length;
    r8.forEach((n8, s) => {
      $(n8.length === t8, () => `Error in concat${t8}D: rank of tensors[${s}] must be the same as the rank of the rest (${t8})`);
    }), $(e8 >= 0 && e8 < t8, () => `Error in concat${t8}D: axis must be between 0 and ${t8 - 1}.`);
    let o8 = r8[0];
    r8.forEach((n8, s) => {
      for (let a = 0; a < t8; a++)
        $(a === e8 || n8[a] === o8[a], () => `Error in concat${t8}D: Shape of tensors[${s}] (${n8}) does not match the shape of the rest (${o8}) along the non-concatenated axis ${s}.`);
    });
  }
  function xX(r8, e8) {
    let t8 = r8[0].slice();
    for (let o8 = 1; o8 < r8.length; o8++)
      t8[e8] += r8[o8][e8];
    return t8;
  }
  var Da;
  (function(r8) {
    r8[r8.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", r8[r8.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", r8[r8.ROW_LENGTHS = 2] = "ROW_LENGTHS", r8[r8.ROW_SPLITS = 3] = "ROW_SPLITS", r8[r8.ROW_LIMITS = 4] = "ROW_LIMITS", r8[r8.ROW_STARTS = 5] = "ROW_STARTS";
  })(Da || (Da = {}));
  function yX(r8, e8, t8) {
    let o8 = new Array();
    if (t8 == null && e8 == null)
      return o8;
    if (e8 == null)
      for (; o8.length < r8 + t8.length; )
        o8.push(-1);
    else
      o8 = e8.slice();
    if (t8 == null)
      return o8;
    if (r8 + t8.length !== o8.length)
      throw new Error(`rt input.shape and shape=${e8} are incompatible: rt input.rank = ${r8 + t8.length}, but shape.rank = ${o8.length}`);
    for (let n8 = 1; n8 < t8.length; ++n8) {
      let s = t8[n8], a = o8[o8.length - t8.length + n8], i10 = o8[a];
      if (s >= 0)
        if (i10 >= 0) {
          if (i10 !== s)
            throw new Error(`rt input.shape and shape=${e8} are incompatible: rt input.shape[${n8 + r8}] = ${s} but shape[${n8 + r8}] = ${i10}`);
        } else
          o8[a] = s;
    }
    return o8;
  }
  function bX(r8) {
    let e8 = { FIRST_DIM_SIZE: Da.FIRST_DIM_SIZE, VALUE_ROWIDS: Da.VALUE_ROWIDS, ROW_LENGTHS: Da.ROW_LENGTHS, ROW_SPLITS: Da.ROW_SPLITS, ROW_LIMITS: Da.ROW_LIMITS, ROW_STARTS: Da.ROW_STARTS }, t8 = [];
    for (let o8 of r8)
      if (o8 in e8)
        t8.push(e8[o8]);
      else
        break;
    return t8;
  }
  function CX(r8) {
    return r8.length === 0 ? 0 : r8[0] === Da.FIRST_DIM_SIZE ? r8.length - 1 : r8.length;
  }
  function wX(r8, e8) {
    if (r8 == null || e8 == null)
      return;
    let t8 = r8.length, o8 = e8.length;
    if (t8 >= o8)
      throw new Error(`defaultValue.shape=${r8} and ragged tensor flatValues.shape=${e8}, are incompatible: defaultValue.rank = ${t8} must be less than ragged tensor input flatValues.rank = ${o8})`);
    for (let n8 = 0; n8 < Math.min(t8, o8 - 1); ++n8) {
      let s = r8[n8], a = e8[n8 + 1];
      if (s >= 0 && a >= 0 && s !== 1 && s !== a)
        throw new Error(`defaultValue.shape=${r8}, and ragged tensor input flatValues.shape=${e8} are incompatible: defaultValue.shape[${n8 - r8.length}] = ${s} but ragged tensor input.flatValues.shape[${n8 - r8.length}] = ${a}`);
    }
  }
  var sf = 30;
  function SX(r8) {
    return r8 <= sf ? r8 : Kp(r8, Math.floor(Math.sqrt(r8)));
  }
  function IX(r8, e8, t8) {
    let o8 = t8 * (typeof r8 == "number" ? r8 : r8[0]), n8 = e8 * (typeof r8 == "number" ? r8 : r8[1]);
    return [o8, n8];
  }
  function vX(r8, e8, t8, o8 = true) {
    let n8 = [];
    if (o8)
      n8 = n8.concat(e8.slice(0)), n8.push(r8[0] / t8), n8 = n8.concat(r8.slice(1));
    else {
      n8 = n8.concat(r8[0]);
      let s = e8.length;
      for (let a = 0; a < s; ++a)
        n8 = n8.concat([r8[a + 1] / e8[a], e8[a]]);
      n8 = n8.concat(r8.slice(s + 1));
    }
    return n8;
  }
  function kX(r8, e8, t8 = true) {
    let o8 = [];
    if (t8) {
      o8.push(e8);
      for (let n8 = e8 + 1; n8 < r8; ++n8)
        n8 <= 2 * e8 ? (o8.push(n8), o8.push(n8 - (e8 + 1))) : o8.push(n8);
    } else {
      let n8 = [], s = [];
      for (let a = 1; a < r8; ++a)
        a >= e8 * 2 + 1 || a % 2 === 1 ? s.push(a) : n8.push(a);
      o8.push(...n8), o8.push(0), o8.push(...s);
    }
    return o8;
  }
  function NX(r8, e8, t8, o8 = true) {
    let n8 = [];
    o8 ? n8.push(r8[0] / t8) : n8.push(r8[0] * t8);
    for (let s = 1; s < r8.length; ++s)
      s <= e8.length ? o8 ? n8.push(e8[s - 1] * r8[s]) : n8.push(r8[s] / e8[s - 1]) : n8.push(r8[s]);
    return n8;
  }
  function TX(r8, e8) {
    let t8 = [0];
    for (let o8 = 0; o8 < e8; ++o8)
      t8.push(r8[o8][0]);
    return t8;
  }
  function _X(r8, e8, t8) {
    let o8 = r8.slice(0, 1);
    for (let n8 = 0; n8 < t8; ++n8)
      o8.push(r8[n8 + 1] - e8[n8][0] - e8[n8][1]);
    return o8;
  }
  var $X = 1.7580993408473768;
  var EX = 1.0507009873554805;
  var RX = 0.3275911;
  var DX = 0.254829592;
  var AX = -0.284496736;
  var FX = 1.421413741;
  var PX = -1.453152027;
  var OX = 1.061405429;
  function MX(r8, e8) {
    if (r8.length !== e8.length)
      throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r8.length}, imag: ${e8.length}.`);
    let t8 = new Float32Array(r8.length * 2);
    for (let o8 = 0; o8 < t8.length; o8 += 2)
      t8[o8] = r8[o8 / 2], t8[o8 + 1] = e8[o8 / 2];
    return t8;
  }
  function LX(r8) {
    let e8 = new Float32Array(r8.length / 2), t8 = new Float32Array(r8.length / 2);
    for (let o8 = 0; o8 < r8.length; o8 += 2)
      e8[o8 / 2] = r8[o8], t8[o8 / 2] = r8[o8 + 1];
    return { real: e8, imag: t8 };
  }
  function BX(r8) {
    let e8 = Math.ceil(r8.length / 4), t8 = new Float32Array(e8), o8 = new Float32Array(e8);
    for (let n8 = 0; n8 < r8.length; n8 += 4)
      t8[Math.floor(n8 / 4)] = r8[n8], o8[Math.floor(n8 / 4)] = r8[n8 + 1];
    return { real: t8, imag: o8 };
  }
  function zX(r8) {
    let e8 = Math.floor(r8.length / 4), t8 = new Float32Array(e8), o8 = new Float32Array(e8);
    for (let n8 = 2; n8 < r8.length; n8 += 4)
      t8[Math.floor(n8 / 4)] = r8[n8], o8[Math.floor(n8 / 4)] = r8[n8 + 1];
    return { real: t8, imag: o8 };
  }
  function VX(r8, e8) {
    let t8 = r8[e8 * 2], o8 = r8[e8 * 2 + 1];
    return { real: t8, imag: o8 };
  }
  function WX(r8, e8, t8, o8) {
    r8[o8 * 2] = e8, r8[o8 * 2 + 1] = t8;
  }
  function UX(r8, e8) {
    let t8 = new Float32Array(r8 / 2), o8 = new Float32Array(r8 / 2);
    for (let n8 = 0; n8 < Math.ceil(r8 / 2); n8++) {
      let s = (e8 ? 2 : -2) * Math.PI * (n8 / r8);
      t8[n8] = Math.cos(s), o8[n8] = Math.sin(s);
    }
    return { real: t8, imag: o8 };
  }
  function GX(r8, e8, t8) {
    let o8 = (t8 ? 2 : -2) * Math.PI * (r8 / e8), n8 = Math.cos(o8), s = Math.sin(o8);
    return { real: n8, imag: s };
  }
  var rS = "->";
  var HX = /->/g;
  var aT = ",";
  var iT = "...";
  function KX(r8, e8) {
    r8 = r8.replace(/\s/g, "");
    let t8 = (r8.length - r8.replace(HX, "").length) / rS.length;
    if (t8 < 1)
      throw new Error("Equations without an arrow are not supported.");
    if (t8 > 1)
      throw new Error(`Equation must contain exactly one arrow ("${rS}").`);
    let [o8, n8] = r8.split(rS);
    $(o8.indexOf(iT) === -1, () => `The ellipsis notation ("${iT}") is not supported yet.`);
    let s = o8.split(aT), a = s.length;
    if (e8 !== a)
      throw new Error(`Expected ${a} input tensors, received ${e8}`);
    if (a > 2)
      throw new Error("Support for more than 2 input tensors is not implemented yet.");
    let i10 = [];
    for (let m = 0; m < n8.length; ++m) {
      let d = n8[m];
      if (!s.some((f) => f.indexOf(d) !== -1))
        throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);
      i10.indexOf(d) === -1 && i10.push(d);
    }
    for (let m = 0; m < o8.length; ++m) {
      let d = o8[m];
      i10.indexOf(d) === -1 && d !== aT && i10.push(d);
    }
    let p = new Array(s.length);
    for (let m = 0; m < a; ++m) {
      if (new Set(s[m].split("")).size !== s[m].length)
        throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);
      p[m] = [];
      for (let d = 0; d < s[m].length; ++d)
        p[m].push(i10.indexOf(s[m][d]));
    }
    let u = i10.length, c = n8.length, l = [];
    for (let m = c; m < u; ++m)
      l.push(m);
    return { allDims: i10, summedDims: l, idDims: p };
  }
  function qX(r8, e8) {
    let t8 = new Array(r8);
    t8.fill(-1);
    for (let n8 = 0; n8 < e8.length; ++n8)
      t8[e8[n8]] = n8;
    let o8 = [];
    for (let n8 = 0; n8 < r8; ++n8)
      t8[n8] === -1 && o8.push(n8);
    return t8 = t8.filter((n8) => n8 !== -1), { permutationIndices: t8, expandDims: o8 };
  }
  function jX(r8, e8, t8) {
    let o8 = new Array(r8);
    for (let n8 = 0; n8 < t8.length; ++n8) {
      let s = t8[n8].shape;
      for (let a = 0; a < e8[n8].length; ++a)
        o8[e8[n8][a]] === void 0 ? o8[e8[n8][a]] = s[a] : $(o8[e8[n8][a]] === s[a], () => `Expected dimension ${o8[e8[n8][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`);
    }
  }
  function XX(r8, e8) {
    let t8 = r8, o8 = [], n8 = 0;
    r8.length === 0 && t8.push(-1), n8 = r8.length + 1;
    for (let a = 0; a < n8; ++a)
      o8.push([]);
    let s = [];
    for (let a = 0; a < t8.length; ++a) {
      let i10 = t8[a], p = QX(e8, i10);
      for (let u of p)
        s.indexOf(u) === -1 && (o8[a].push(u), s.push(u));
    }
    return { path: t8, steps: o8 };
  }
  function YX(r8) {
    return r8.every((e8, t8) => e8 === t8);
  }
  function QX(r8, e8) {
    let t8 = [];
    for (let o8 = 0; o8 < r8.length; ++o8)
      (r8[o8].length === 0 || r8[o8].indexOf(e8) !== -1 || e8 === -1) && t8.push(o8);
    return t8;
  }
  function ZX(r8, e8, t8 = 0) {
    let o8 = [];
    if (typeof e8 == "number")
      $(r8.shape[t8] % e8 === 0, () => "Number of splits must evenly divide the axis."), o8 = new Array(e8).fill(r8.shape[t8] / e8);
    else {
      let n8 = e8.reduce((a, i10) => (i10 === -1 && (a += 1), a), 0);
      $(n8 <= 1, () => "There should be only one negative value in split array.");
      let s = e8.indexOf(-1);
      if (s !== -1) {
        let a = e8.reduce((i10, p) => p > 0 ? i10 + p : i10);
        e8[s] = r8.shape[t8] - a;
      }
      $(r8.shape[t8] === e8.reduce((a, i10) => a + i10), () => "The sum of sizes must match the size of the axis dimension."), o8 = e8;
    }
    return o8;
  }
  function JX(r8) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r8}`;
  }
  function e5(r8, e8) {
    return `indices(${r8}, 0) is invalid: ${e8} < 0`;
  }
  function t5(r8, e8, t8) {
    return `indices(${r8}, 0) is invalid: ${e8} >= ${t8}`;
  }
  function r5(r8, e8) {
    return `only one output dimension may be -1, not both ${r8} and ${e8}`;
  }
  function o5(r8, e8) {
    return `size ${r8} must be non-negative, not ${e8}`;
  }
  function n5() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
  }
  function s5(r8, e8) {
    let t8 = Ge(r8), o8 = Ge(e8);
    return `Input to reshape is a SparseTensor with ${t8}
  dense values, but the requested shape requires a multiple of ${o8}. inputShape=${r8} outputShape= ${e8}`;
  }
  function a5(r8, e8) {
    let t8 = Ge(r8), o8 = Ge(e8);
    return `Input to reshape is a tensor with ${t8} dense values, but the requested shape has ${o8}. inputShape=${r8} outputShape=${e8}`;
  }
  function i5() {
    return "segment ids must be >= 0";
  }
  function u5() {
    return "segment ids are not increasing";
  }
  function p5(r8, e8) {
    return `Segment id ${r8} out of range [0, ${e8}), possibly because segmentIds input is not sorted.`;
  }
  function c5(r8, e8, t8) {
    return `Bad: indices[${r8}] == ${e8} out of range [0, ${t8})`;
  }
  var oS = {};
  Ke(oS, { collectGatherOpShapeInfo: () => d5, computeOutShape: () => m5, segOpComputeOptimalWindowSize: () => l5 });
  function l5(r8, e8) {
    let t8 = false, o8;
    for (r8 <= sf ? (o8 = r8, t8 = true) : o8 = Kp(r8, Math.floor(Math.sqrt(r8))); !t8; )
      o8 > e8 || o8 === r8 ? t8 = true : o8 = Kp(r8, o8 + 1);
    return o8;
  }
  function m5(r8, e8, t8) {
    let o8 = [], n8 = r8.length;
    for (let s = 0; s < n8; s++)
      s !== e8 ? o8.push(r8[s]) : o8.push(t8);
    return o8;
  }
  function d5(r8, e8, t8, o8) {
    let n8 = e8.shape.length, s = r8.shape.length;
    if (o8 !== 0 && (o8 < -n8 || o8 > n8))
      throw new Error(`Expect batchDims in the range of [-${n8}, ${n8}], but got ${o8}`);
    if (o8 < 0 && (o8 += n8), o8 > s)
      throw new Error(`batchDims (${o8}) must be less than rank(x) (
    ${s}).`);
    if (t8 < o8)
      throw new Error(`batchDims (${o8}) must be less than or equal to axis (${t8}).`);
    for (let l = 0; l < o8; ++l)
      if (r8.shape[l] !== e8.shape[l])
        throw new Error(`x.shape[${l}]: ${r8.shape[l]} should be equal to indices.shape[${l}]: ${e8.shape[l]}.`);
    let a = r8.shape[t8], i10 = [], p = 1, u = 1, c = 1;
    for (let l = 0; l < o8; ++l)
      i10.push(r8.shape[l]), p *= r8.shape[l];
    for (let l = o8; l < t8; l++)
      i10.push(r8.shape[l]), u *= r8.shape[l];
    for (let l = o8; l < n8; l++)
      i10.push(e8.shape[l]);
    for (let l = t8 + 1; l < s; l++)
      i10.push(r8.shape[l]), c *= r8.shape[l];
    return { batchSize: p, sliceSize: c, outerSize: u, dimSize: a, outputShape: i10 };
  }
  function f5(r8) {
    try {
      return r8.map((e8) => tc(e8));
    } catch (e8) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e8}`);
    }
  }
  function h5(r8) {
    return r8.map((e8) => eu(e8));
  }
  var Wt = {};
  Ke(Wt, { nonMaxSuppressionV3Impl: () => Zd, nonMaxSuppressionV4Impl: () => Jd, nonMaxSuppressionV5Impl: () => ef, whereImpl: () => jd });
  PN();
  var g5 = A();
  g5.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (r8) => {
    r8 && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
  });
  var fo;
  (function(r8) {
    r8[r8.DT_INVALID = 0] = "DT_INVALID", r8[r8.DT_FLOAT = 1] = "DT_FLOAT", r8[r8.DT_DOUBLE = 2] = "DT_DOUBLE", r8[r8.DT_INT32 = 3] = "DT_INT32", r8[r8.DT_UINT8 = 4] = "DT_UINT8", r8[r8.DT_INT16 = 5] = "DT_INT16", r8[r8.DT_INT8 = 6] = "DT_INT8", r8[r8.DT_STRING = 7] = "DT_STRING", r8[r8.DT_COMPLEX64 = 8] = "DT_COMPLEX64", r8[r8.DT_INT64 = 9] = "DT_INT64", r8[r8.DT_BOOL = 10] = "DT_BOOL", r8[r8.DT_QINT8 = 11] = "DT_QINT8", r8[r8.DT_QUINT8 = 12] = "DT_QUINT8", r8[r8.DT_QINT32 = 13] = "DT_QINT32", r8[r8.DT_BFLOAT16 = 14] = "DT_BFLOAT16", r8[r8.DT_QINT16 = 15] = "DT_QINT16", r8[r8.DT_QUINT16 = 16] = "DT_QUINT16", r8[r8.DT_UINT16 = 17] = "DT_UINT16", r8[r8.DT_COMPLEX128 = 18] = "DT_COMPLEX128", r8[r8.DT_HALF = 19] = "DT_HALF", r8[r8.DT_RESOURCE = 20] = "DT_RESOURCE", r8[r8.DT_VARIANT = 21] = "DT_VARIANT", r8[r8.DT_UINT32 = 22] = "DT_UINT32", r8[r8.DT_UINT64 = 23] = "DT_UINT64", r8[r8.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", r8[r8.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", r8[r8.DT_INT32_REF = 103] = "DT_INT32_REF", r8[r8.DT_UINT8_REF = 104] = "DT_UINT8_REF", r8[r8.DT_INT16_REF = 105] = "DT_INT16_REF", r8[r8.DT_INT8_REF = 106] = "DT_INT8_REF", r8[r8.DT_STRING_REF = 107] = "DT_STRING_REF", r8[r8.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", r8[r8.DT_INT64_REF = 109] = "DT_INT64_REF", r8[r8.DT_BOOL_REF = 110] = "DT_BOOL_REF", r8[r8.DT_QINT8_REF = 111] = "DT_QINT8_REF", r8[r8.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", r8[r8.DT_QINT32_REF = 113] = "DT_QINT32_REF", r8[r8.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", r8[r8.DT_QINT16_REF = 115] = "DT_QINT16_REF", r8[r8.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", r8[r8.DT_UINT16_REF = 117] = "DT_UINT16_REF", r8[r8.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", r8[r8.DT_HALF_REF = 119] = "DT_HALF_REF", r8[r8.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", r8[r8.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", r8[r8.DT_UINT32_REF = 122] = "DT_UINT32_REF", r8[r8.DT_UINT64_REF = 123] = "DT_UINT64_REF";
  })(fo || (fo = {}));
  var uT;
  (function(r8) {
    (function(t8) {
      t8[t8.LEGACY = 0] = "LEGACY", t8[t8.V1 = 1] = "V1", t8[t8.V2 = 2] = "V2";
    })(r8.CheckpointFormatVersion || (r8.CheckpointFormatVersion = {}));
  })(uT || (uT = {}));
  var sS = {};
  function y5(r8, e8) {
    let t8 = { tfOpName: r8, category: "custom", inputs: [], attrs: [], customExecutor: e8 };
    sS[r8] = t8;
  }
  function af(r8) {
    return sS[r8];
  }
  function b5(r8) {
    delete sS[r8];
  }
  function I(r8, e8, t8, o8, n8) {
    let s = e8.inputParams[r8];
    if (s && s.inputIndexStart !== void 0) {
      let i10 = s.inputIndexStart, p = s.inputIndexEnd === 0 ? void 0 : s.inputIndexEnd === void 0 ? i10 + 1 : s.inputIndexEnd, u = i10 < 0 ? e8.inputNames.length + i10 : i10;
      if (s.type === "tensor")
        return Bt(e8.inputNames[u], t8, o8, n8);
      if (s.type === "tensors") {
        let m = e8.inputs.slice(i10, p);
        return e8.inputNames.slice(i10, p).filter((f, h) => {
          var g;
          return ((g = m[h]) === null || g === void 0 ? void 0 : g.op) !== "NoOp";
        }).map((f) => Bt(f, t8, o8, n8));
      }
      let c = Bt(e8.inputNames[u], t8, o8, n8), l = c.dataSync();
      return s.type === "number" ? l[0] : y.toNestedArray(c.shape, l);
    }
    let a = e8.attrParams[r8];
    return a && a.value;
  }
  function Bt(r8, e8, t8, o8) {
    let [n8, s] = Tr(r8, t8);
    if (o8 != null) {
      let i10 = o8.getHashTableHandleByName(n8);
      if (i10 != null)
        return i10;
    }
    let a = t8.currentContextIds.find((i10) => !!e8[uf(n8, i10)]);
    return a !== void 0 ? e8[uf(n8, a)][s] : void 0;
  }
  function aS(r8, e8, t8) {
    return e8[uf(r8, t8.currentContextId)];
  }
  function Os(r8, e8) {
    let [t8, o8, n8] = Tr(r8, e8);
    return [uf(t8, e8 && e8.currentContextId), o8, n8];
  }
  function uf(r8, e8) {
    return e8 ? `${r8}-${e8}` : r8;
  }
  function Tr(r8, e8) {
    if (r8 === "")
      return ["", 0, void 0];
    let t8 = e8 != null && e8.parseNodeNameCache != null;
    if (t8) {
      let s = e8.parseNodeNameCache.get(r8);
      if (s != null)
        return s;
    }
    let o8 = r8.split(":"), n8;
    if (o8.length === 1)
      n8 = [r8, 0, void 0];
    else {
      let s = o8[0], a = o8.length === 3 ? o8[1] : void 0, i10 = Number(o8[o8.length - 1]);
      n8 = [s, i10, a];
    }
    return t8 && e8.parseNodeNameCache.set(r8, n8), n8;
  }
  function Al(r8, e8, t8) {
    let o8 = I("pad", r8, e8, t8);
    if (o8 === "explicit") {
      o8 = I("explicitPaddings", r8, e8, t8);
      let n8 = [[0, 0], [0, 0], [0, 0], [0, 0]];
      for (let s = 0; s < 4; s++)
        n8[s][0] = o8[s * 2], n8[s][1] = o8[s * 2 + 1];
      return n8;
    }
    return o8;
  }
  function Ms(r8) {
    return r8.kept ? r8 : Ur(r8);
  }
  var iS = {};
  Ke(iS, { json: () => C5 });
  var C5 = [{ tfOpName: "Add", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddV2", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddN", category: "arithmetic", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "BiasAdd", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "Sub", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "RealDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Div", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "DivNoNan", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mul", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Maximum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Minimum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Pow", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorMod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var uS = {};
  Ke(uS, { json: () => w5 });
  var w5 = [{ tfOpName: "Abs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan2", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Ceil", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ClipByValue", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "clipValueMin", type: "number" }, { start: 2, name: "clipValueMax", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Complex", category: "basic_math", inputs: [{ start: 0, name: "real", type: "tensor" }, { start: 1, name: "imag", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ComplexAbs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Elu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Exp", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Floor", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Imag", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Neg", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Real", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Prelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "alpha", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu6", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Selu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sigmoid", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Rsqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Square", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sign", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Round", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Expm1", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log1p", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Reciprocal", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Softplus", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Erf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LeakyRelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsNan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsFinite", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsInf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var pS = {};
  Ke(pS, { json: () => S5 });
  var S5 = [{ tfOpName: "EmptyTensorList", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "maxNumElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "LoopCond", category: "control", inputs: [{ start: 0, name: "pred", type: "tensor" }] }, { tfOpName: "Switch", category: "control", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "pred", type: "tensor" }] }, { tfOpName: "Merge", category: "control", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "Enter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "frame_name", name: "frameName", type: "string" }, { tfName: "is_constant", name: "isConstant", type: "bool" }] }, { tfOpName: "Exit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NextIteration", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayV3", category: "control", inputs: [{ start: 0, name: "size", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "dynamic_size", name: "dynamicSize", type: "bool" }, { tfName: "clear_after_read", name: "clearAfterRead", type: "bool" }, { tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool" }, { tfName: "tensor_array_name", name: "name", type: "string" }] }, { tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayReadV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }] }, { tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: true }] }, { tfOpName: "TensorArraySplitV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }, { start: 2, name: "lengths", type: "number[]" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArraySizeV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }] }, { tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }] }, { tfOpName: "StatelessIf", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "If", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "StatelessWhile", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "While", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "TensorListScatter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListScatterV2", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }, { start: 3, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGather", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListSetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListReserve", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListFromTensor", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListStack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }, { tfName: "num_elements", name: "numElements", type: "dtype" }] }, { tfOpName: "TensorListSplit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }, { start: 2, name: "lengths", type: "number[]" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListConcat", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }], attrs: [{ tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListConcatV2", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }], attrs: [{ tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPopBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPushBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListLength", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }] }, { tfOpName: "TensorListResize", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "size", type: "number" }] }];
  var cS = {};
  Ke(cS, { json: () => I5 });
  var I5 = [{ tfOpName: "AvgPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [], notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPoolWithArgmax", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "include_batch_in_index", name: "includeBatchInIndex", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AvgPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Conv1D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "stride", name: "stride", type: "number" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "dilation", name: "dilation", type: "number", defaultValue: 1 }] }, { tfOpName: "Conv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "_FusedConv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: true }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number", defaultValue: 0.2 }] }, { tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{ start: 2, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 0, name: "outputShape", type: "number[]" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]", notSupported: true }] }, { tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "FusedDepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }] }, { tfOpName: "Conv3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "Dilation2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "rates", name: "dilations", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }] }];
  var lS = {};
  Ke(lS, { json: () => v5 });
  var v5 = [{ tfOpName: "Fill", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }, { start: 1, name: "value", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "LinSpace", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "num", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "OneHot", category: "creation", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "depth", type: "number" }, { start: 2, name: "onValue", type: "number", defaultValue: 1 }, { start: 3, name: "offValue", type: "number", defaultValue: 0 }], attrs: [{ tfName: "axis", name: "axis", type: "number", notSupported: true }, { tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Ones", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "OnesLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "RandomStandardNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "RandomUniform", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number", defaultValue: 0 }, { tfName: "maxval", name: "maxval", type: "number", defaultValue: 1 }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "RandomUniformInt", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number" }, { tfName: "maxval", name: "maxval", type: "number" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Range", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "step", type: "number", defaultValue: 0 }], attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }] }, { tfOpName: "TruncatedNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "means", name: "mean", type: "number", defaultValue: 0 }, { tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1 }, { tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "Zeros", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "ZerosLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Multinomial", category: "creation", inputs: [{ start: 0, name: "logits", type: "tensor" }, { start: 1, name: "numSamples", type: "number" }], attrs: [{ tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number" }, { tfName: "T", name: "dtype", type: "dtype" }, { tfName: "output_dtype", name: "output_dtype", type: "dtype" }] }];
  var mS = {};
  Ke(mS, { json: () => k5 });
  var k5 = [{ tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV4", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "T_threshold", name: "threshold", type: "dtype", notSupported: true }, { tfName: "pad_to_max_output_size", name: "padToMaxOutputSize", type: "bool" }] }, { tfOpName: "NonMaxSuppressionV5", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }, { start: 5, name: "softNmsSigma", type: "number" }] }, { tfOpName: "Where", category: "dynamic", inputs: [{ start: 0, name: "condition", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ListDiff", category: "dynamic", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
  var dS = {};
  Ke(dS, { json: () => N5 });
  var N5 = [{ tfOpName: "LowerBound", category: "evaluation", inputs: [{ start: 0, name: "sortedSequence", type: "tensor" }, { start: 1, name: "values", type: "tensor" }] }, { tfOpName: "TopKV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "k", type: "number" }], attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }] }, { tfOpName: "UpperBound", category: "evaluation", inputs: [{ start: 0, name: "sortedSequence", type: "tensor" }, { start: 1, name: "values", type: "tensor" }] }, { tfOpName: "Unique", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "UniqueV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }];
  var fS = {};
  Ke(fS, { json: () => T5 });
  var T5 = [{ tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{ start: 0, name: "default", type: "tensor" }], attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Placeholder", category: "graph", attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Const", category: "graph" }, { tfOpName: "Identity", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IdentityN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Snapshot", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Rank", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Size", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Shape", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "ShapeN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Print", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "data", type: "tensors" }], attrs: [{ tfName: "message", name: "message", type: "string" }, { tfName: "first_n", name: "firstN", type: "number", notSupported: true }, { tfName: "summarize", name: "summarize", type: "number", defaultValue: 3 }] }, { tfOpName: "NoOp", category: "graph", inputs: [] }, { tfOpName: "StopGradient", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "min", name: "min", type: "number" }, { tfName: "max", name: "max", type: "number" }] }];
  var hS = {};
  Ke(hS, { json: () => _5 });
  var _5 = [{ tfOpName: "HashTable", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "HashTableV2", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "LookupTableImport", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableImportV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFind", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFindV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableSize", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }, { tfOpName: "LookupTableSizeV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }, { tfOpName: "InitializeTable", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }, { tfOpName: "InitializeTableV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }];
  var gS = {};
  Ke(gS, { json: () => $5 });
  var $5 = [{ tfOpName: "ResizeBilinear", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "CropAndResize", category: "image", inputs: [{ start: 0, name: "image", type: "tensor" }, { start: 1, name: "boxes", type: "tensor" }, { start: 2, name: "boxInd", type: "tensor" }, { start: 3, name: "cropSize", type: "number[]" }], attrs: [{ tfName: "method", name: "method", type: "string" }, { tfName: "extrapolation_value", name: "extrapolationValue", type: "number" }] }, { tfOpName: "ImageProjectiveTransformV3", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "transforms", type: "tensor" }, { start: 2, name: "outputShape", type: "number[]" }, { start: 3, name: "fillValue", type: "number" }], attrs: [{ tfName: "interpolation", name: "interpolation", type: "string" }, { tfName: "fill_mode", name: "fillMode", type: "string" }] }];
  var xS = {};
  Ke(xS, { json: () => E5 });
  var E5 = [{ tfOpName: "Equal", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NotEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Greater", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "GreaterEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Less", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LessEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalAnd", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalNot", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalOr", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Select", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SelectV2", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BitwiseAnd", category: "logical", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }] }];
  var yS = {};
  Ke(yS, { json: () => R5 });
  var R5 = [{ tfOpName: "_FusedMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Transpose", category: "matrices", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "perm", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Einsum", category: "matrices", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "equation", name: "equation", type: "string" }, { tfName: "N", name: "n", type: "number", defaultValue: 2 }, { tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "MatrixBandPart", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "numLower", type: "tensor" }, { start: 1, name: "numUpper", type: "tensor" }] }];
  var bS = {};
  Ke(bS, { json: () => D5 });
  var D5 = [{ tfOpName: "EuclideanNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool", defaultValue: false }] }, { tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "LRN", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5 }, { tfName: "bias", name: "bias", type: "number", defaultValue: 1 }, { tfName: "alpha", name: "alpha", type: "number", defaultValue: 1 }, { tfName: "beta", name: "beta", type: "number", defaultValue: 0.5 }] }, { tfOpName: "Softmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "LogSoftmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }];
  var CS = {};
  Ke(CS, { json: () => A5 });
  var A5 = [{ tfOpName: "Bincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }] }, { tfOpName: "DenseBincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }], attrs: [{ tfName: "binary_output", name: "binaryOutput", type: "bool" }] }, { tfOpName: "Max", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Mean", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Min", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Sum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "All", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Any", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "ArgMax", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "ArgMin", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Prod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cumprod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }], attrs: [{ tfName: "exclusive", name: "exclusive", type: "bool" }, { tfName: "reverse", name: "reverse", type: "bool" }] }, { tfOpName: "Cumsum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }], attrs: [{ tfName: "exclusive", name: "exclusive", type: "bool" }, { tfName: "reverse", name: "reverse", type: "bool" }] }];
  var wS = {};
  Ke(wS, { json: () => F5 });
  var F5 = [{ tfOpName: "ConcatV2", category: "slice_join", inputs: [{ start: 0, end: -1, name: "tensors", type: "tensors" }, { start: -1, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "Concat", category: "slice_join", inputs: [{ start: 1, end: 0, name: "tensors", type: "tensors" }, { start: 0, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "GatherV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }], attrs: [{ tfName: "batch_dims", name: "batchDims", type: "number", defaultValue: 0 }] }, { tfOpName: "Gather", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: true }] }, { tfOpName: "Reverse", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "dims", type: "bool[]" }] }, { tfOpName: "ReverseV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }] }, { tfOpName: "Slice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "size", type: "number[]" }] }, { tfOpName: "StridedSlice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "end", type: "number[]" }, { start: 3, name: "strides", type: "number[]" }], attrs: [{ tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0 }, { tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0 }, { tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0 }, { tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0 }, { tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0 }] }, { tfOpName: "Pack", category: "slice_join", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Unpack", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Tile", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "reps", type: "number[]" }] }, { tfOpName: "Split", category: "slice_join", inputs: [{ start: 0, name: "axis", type: "number", defaultValue: 0 }, { start: 1, name: "x", type: "tensor" }], attrs: [{ tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1 }] }, { tfOpName: "SplitV", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "numOrSizeSplits", type: "number[]" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "ScatterNd", category: "slice_join", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "shape", type: "number[]" }] }, { tfOpName: "GatherNd", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "slice_join", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: false, notSupported: true }] }, { tfOpName: "TensorScatterUpdate", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }];
  var SS = {};
  Ke(SS, { json: () => P5 });
  var P5 = [{ tfOpName: "SparseFillEmptyRows", category: "sparse", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "denseShape", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }] }, { tfOpName: "SparseReshape", category: "sparse", inputs: [{ start: 0, name: "inputIndices", type: "tensor" }, { start: 1, name: "inputShape", type: "tensor" }, { start: 2, name: "newShape", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SparseSegmentMean", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }, { tfOpName: "SparseSegmentSum", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }];
  var IS = {};
  Ke(IS, { json: () => O5 });
  var O5 = [{ tfOpName: "FFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "RFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }, { tfOpName: "IRFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }];
  var vS = {};
  Ke(vS, { json: () => M5 });
  var M5 = [{ tfOpName: "StaticRegexReplace", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }], attrs: [{ tfName: "pattern", name: "pattern", type: "string" }, { tfName: "rewrite", name: "rewrite", type: "string" }, { tfName: "replace_global", name: "replaceGlobal", type: "bool" }] }, { tfOpName: "StringNGrams", category: "string", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "dataSplits", type: "tensor" }], attrs: [{ tfName: "separator", name: "separator", type: "string" }, { tfName: "ngram_widths", name: "nGramWidths", type: "number[]" }, { tfName: "left_pad", name: "leftPad", type: "string" }, { tfName: "right_pad", name: "rightPad", type: "string" }, { tfName: "pad_width", name: "padWidth", type: "number" }, { tfName: "preserve_short_sequences", name: "preserveShortSequences", type: "bool" }], outputs: ["ngrams", "ngrams_splits"] }, { tfOpName: "StringSplit", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "delimiter", type: "tensor" }], attrs: [{ tfName: "skip_empty", name: "skipEmpty", type: "bool" }], outputs: ["indices", "values", "shape"] }, { tfOpName: "StringToHashBucketFast", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }], attrs: [{ tfName: "num_buckets", name: "numBuckets", type: "number" }] }];
  var kS = {};
  Ke(kS, { json: () => L5 });
  var L5 = [{ tfOpName: "Cast", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: true }, { tfName: "DstT", name: "dtype", type: "dtype" }] }, { tfOpName: "ExpandDims", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "MirrorPad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "mode", name: "mode", type: "string" }] }, { tfOpName: "Pad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "PadV2", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }, { start: 2, name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "Reshape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "EnsureShape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "Squeeze", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]" }] }, { tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "paddings", type: "number[]" }] }, { tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "crops", type: "number[]" }] }, { tfOpName: "DepthToSpace", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "block_size", name: "blockSize", type: "number" }, { tfName: "data_format", name: "dataFormat", type: "string" }] }, { tfOpName: "BroadcastTo", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }], attrs: [] }, { tfOpName: "BroadcastArgs", category: "transformation", inputs: [{ start: 0, name: "s0", type: "tensor" }, { start: 1, name: "s1", type: "tensor" }], attrs: [] }];
  var Fl = class {
    static get Instance() {
      return this._instance || (this._instance = new this());
    }
    constructor() {
      let e8 = [iS, uS, pS, cS, lS, mS, dS, fS, hS, gS, xS, yS, bS, CS, wS, SS, IS, vS, kS], t8 = [].concat(...e8.map((o8) => o8.json));
      this.opMappers = t8.reduce((o8, n8) => (o8[n8.tfOpName] = n8, o8), {});
    }
    transformGraph(e8, t8 = {}) {
      let o8 = e8.node, n8 = [], s = [], a = [], i10 = o8.reduce((h, g) => (h[g.name] = this.mapNode(g), g.op.startsWith("Placeholder") ? n8.push(h[g.name]) : g.op === "Const" ? s.push(h[g.name]) : (g.input == null || g.input.length === 0) && a.push(h[g.name]), h), {}), p = [], u = [], c = {}, l = {};
      t8 != null && (c = this.mapSignatureEntries(t8.inputs), l = this.mapSignatureEntries(t8.outputs));
      let m = Object.keys(i10);
      m.forEach((h) => {
        let g = i10[h];
        g.inputNames.forEach((x, b) => {
          let [C, , S] = Os(x), k = i10[C];
          if (k.outputs != null) {
            let _ = k.outputs.indexOf(S);
            if (_ !== -1) {
              let E = `${C}:${_}`;
              g.inputNames[b] = E;
            }
          }
          g.inputs.push(k), k.children.push(g);
        });
      }), Object.keys(l).length === 0 ? m.forEach((h) => {
        let g = i10[h];
        g.children.length === 0 && u.push(g);
      }) : Object.keys(l).forEach((h) => {
        let [g] = Os(h), x = i10[g];
        x != null && (x.signatureKey = l[h], u.push(x));
      }), Object.keys(c).length > 0 ? Object.keys(c).forEach((h) => {
        let [g] = Os(h), x = i10[g];
        x && (x.signatureKey = c[h], p.push(x));
      }) : p = n8;
      let d = {};
      e8.library != null && e8.library.function != null && (d = e8.library.function.reduce((h, g) => (h[g.signature.name] = this.mapFunction(g), h), {}));
      let f = { nodes: i10, inputs: p, outputs: u, weights: s, placeholders: n8, signature: t8, functions: d };
      return a.length > 0 && (f.initNodes = a), f;
    }
    mapSignatureEntries(e8) {
      return Object.keys(e8 || {}).reduce((t8, o8) => (t8[e8[o8].name] = o8, t8), {});
    }
    mapNode(e8) {
      let t8 = af(e8.op) || this.opMappers[e8.op] || {};
      e8.attr == null && (e8.attr = {});
      let o8 = { name: e8.name, op: e8.op, category: t8.category, inputNames: (e8.input || []).map((n8) => n8.startsWith("^") ? n8.slice(1) : n8), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: e8.attr, outputs: t8.outputs };
      return t8.inputs != null && (o8.inputParams = t8.inputs.reduce((n8, s) => (n8[s.name] = { type: s.type, inputIndexStart: s.start, inputIndexEnd: s.end }, n8), {})), t8.attrs != null && (o8.attrParams = t8.attrs.reduce((n8, s) => {
        let a = s.type, i10;
        switch (s.type) {
          case "string":
            i10 = pf(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = pf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "string[]":
            i10 = gf(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = gf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "number":
            i10 = lf(e8.attr, s.tfName, s.defaultValue || 0), i10 === void 0 && s.tfDeprecatedName && (i10 = lf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "number[]":
            i10 = hf(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = hf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "bool":
            i10 = cf(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = cf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "bool[]":
            i10 = yf(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = yf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "shape":
            i10 = ff(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = ff(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "shape[]":
            i10 = xf(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = xf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "dtype":
            i10 = mf(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = mf(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "dtype[]":
            i10 = df(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = df(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "func":
            i10 = pT(e8.attr, s.tfName, s.defaultValue), i10 === void 0 && s.tfDeprecatedName && (i10 = pT(e8.attr, s.tfDeprecatedName, s.defaultValue));
            break;
          case "tensor":
          case "tensors":
            break;
          default:
            throw new Error(`Unsupported param type: ${s.type} for op: ${e8.op}`);
        }
        return n8[s.name] = { value: i10, type: a }, n8;
      }, {})), o8;
    }
    mapFunction(e8) {
      let t8 = e8.nodeDef, o8 = [], n8 = [], s = {};
      t8 != null && (s = t8.reduce((l, m) => (l[m.name] = this.mapNode(m), m.op === "Const" && n8.push(l[m.name]), l), {}));
      let a = [], i10 = [];
      e8.signature.inputArg.forEach((l) => {
        let [m] = Os(l.name), d = { name: m, op: "Placeholder", inputs: [], inputNames: [], category: "graph", inputParams: {}, attrParams: { dtype: { value: NS(l.type), type: "dtype" } }, children: [] };
        d.signatureKey = l.name, a.push(d), s[m] = d;
      }), Object.keys(s).forEach((l) => {
        let m = s[l];
        m.inputNames.forEach((d, f) => {
          let [h, , g] = Os(d), x = s[h];
          if (x.outputs != null) {
            let b = x.outputs.indexOf(g);
            if (b !== -1) {
              let C = `${h}:${b}`;
              m.inputNames[f] = C;
            }
          }
          m.inputs.push(x), x.children.push(m);
        });
      });
      let u = e8.ret;
      e8.signature.outputArg.forEach((l) => {
        let [m, d] = Os(u[l.name]), f = s[m];
        f != null && (f.defaultOutput = d, i10.push(f));
      });
      let c = this.mapArgsToSignature(e8);
      return { nodes: s, inputs: a, outputs: i10, weights: n8, placeholders: o8, signature: c };
    }
    mapArgsToSignature(e8) {
      return { methodName: e8.signature.name, inputs: e8.signature.inputArg.reduce((t8, o8) => (t8[o8.name] = this.mapArgToTensorInfo(o8), t8), {}), outputs: e8.signature.outputArg.reduce((t8, o8) => (t8[o8.name] = this.mapArgToTensorInfo(o8, e8.ret), t8), {}) };
    }
    mapArgToTensorInfo(e8, t8) {
      let o8 = e8.name;
      return t8 != null && (o8 = t8[o8]), { name: o8, dtype: e8.type };
    }
  };
  function B5(r8) {
    let e8 = A().global;
    if (typeof e8.atob != "undefined")
      return e8.atob(r8);
    if (typeof buffer$1.Buffer != "undefined")
      return new buffer$1.Buffer(r8, "base64").toString();
    throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
  }
  function cT(r8, e8) {
    let t8 = Array.isArray(r8) ? String.fromCharCode.apply(null, r8) : B5(r8);
    return e8 ? t8 : t8.toLowerCase();
  }
  function pf(r8, e8, t8, o8 = false) {
    let n8 = r8[e8];
    return n8 != null ? cT(n8.s, o8) : t8;
  }
  function cf(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 ? o8.b : t8;
  }
  function lf(r8, e8, t8) {
    let o8 = r8[e8] || {}, n8 = o8.i != null ? o8.i : o8.f != null ? o8.f : t8;
    return typeof n8 == "number" ? n8 : parseInt(n8, 10);
  }
  function NS(r8) {
    switch (typeof r8 == "string" && (r8 = fo[r8]), r8) {
      case fo.DT_FLOAT:
      case fo.DT_HALF:
        return "float32";
      case fo.DT_INT32:
      case fo.DT_INT64:
      case fo.DT_INT8:
      case fo.DT_UINT8:
        return "int32";
      case fo.DT_BOOL:
        return "bool";
      case fo.DT_DOUBLE:
        return "float32";
      case fo.DT_STRING:
        return "string";
      default:
        return null;
    }
  }
  function pT(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 && o8.func ? o8.func.name : t8;
  }
  function mf(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 && o8.type ? NS(o8.type) : t8;
  }
  function df(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 && o8.list && o8.list.type ? o8.list.type.map((n8) => NS(n8)) : t8;
  }
  function lT(r8) {
    if (!r8.unknownRank)
      return r8.dim != null ? r8.dim.map((e8) => typeof e8.size == "number" ? e8.size : parseInt(e8.size, 10)) : [];
  }
  function ff(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 && o8.shape ? lT(o8.shape) : t8;
  }
  function hf(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 ? ((o8.list.f && o8.list.f.length ? o8.list.f : o8.list.i) || []).map((n8) => typeof n8 == "number" ? n8 : parseInt(n8, 10)) : t8;
  }
  function gf(r8, e8, t8, o8 = false) {
    let n8 = r8[e8];
    return n8 && n8.list && n8.list.s ? n8.list.s.map((s) => cT(s, o8)) : t8;
  }
  function xf(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 && o8.list && o8.list.shape ? o8.list.shape.map((n8) => lT(n8)) : t8;
  }
  function yf(r8, e8, t8) {
    let o8 = r8[e8];
    return o8 && o8.list && o8.list.b ? o8.list.b : t8;
  }
  var bf = class {
    constructor(e8, t8, o8) {
      this.node = e8, this.tensorMap = t8, this.context = o8, this.inputs = [], this.attrs = {}, this.inputs = e8.inputNames.map((n8) => this.getInput(n8)), e8.rawAttrs != null && (this.attrs = Object.keys(e8.rawAttrs).reduce((n8, s) => (n8[s] = this.getAttr(s), n8), {}));
    }
    getInput(e8) {
      return Bt(e8, this.tensorMap, this.context);
    }
    getAttr(e8, t8) {
      let o8 = this.node.rawAttrs[e8];
      if (o8.tensor != null)
        return Bt(e8, this.tensorMap, this.context);
      if (o8.i != null || o8.f != null)
        return lf(this.node.rawAttrs, e8, t8);
      if (o8.s != null)
        return pf(this.node.rawAttrs, e8, t8);
      if (o8.b != null)
        return cf(this.node.rawAttrs, e8, t8);
      if (o8.shape != null)
        return ff(this.node.rawAttrs, e8, t8);
      if (o8.type != null)
        return mf(this.node.rawAttrs, e8, t8);
      if (o8.list != null) {
        if (o8.list.i != null || o8.list.f != null)
          return hf(this.node.rawAttrs, e8, t8);
        if (o8.list.s != null)
          return gf(this.node.rawAttrs, e8, t8);
        if (o8.list.shape != null)
          return xf(this.node.rawAttrs, e8, t8);
        if (o8.list.b != null)
          return yf(this.node.rawAttrs, e8, t8);
        if (o8.list.type != null)
          return df(this.node.rawAttrs, e8, t8);
      }
      return t8;
    }
  };
  var Je = {};
  Ke(Je, { OP_SCOPE_SUFFIX: () => yw, abs: () => Jt, acos: () => xk, acosh: () => yk, add: () => Ce, addN: () => bk, all: () => Ck, any: () => wk, argMax: () => Sk, argMin: () => Ik, asin: () => vk, asinh: () => kk, atan: () => Nk, atan2: () => Tk, atanh: () => _k, avgPool: () => md, avgPool3d: () => Rk, basicLSTMCell: () => Dk, batchNorm: () => su, batchNorm2d: () => Fk, batchNorm3d: () => Pk, batchNorm4d: () => Ok, batchToSpaceND: () => dd, bincount: () => fd, bitwiseAnd: () => Mk, booleanMaskAsync: () => b6, broadcastArgs: () => Lk, broadcastTo: () => au, buffer: () => me, cast: () => qe, ceil: () => Bk, clipByValue: () => zk, clone: () => Ur, complex: () => Er, concat: () => bt, concat1d: () => Vk, concat2d: () => Wk, concat3d: () => Uk, concat4d: () => Gk, conv1d: () => Hk, conv2d: () => iu, conv2dTranspose: () => Kk, conv3d: () => qk, conv3dTranspose: () => Xk, cos: () => Yk, cosh: () => Qk, cosineWindow: () => _l, cumprod: () => Zk, cumsum: () => Jk, denseBincount: () => e2, depthToSpace: () => t2, depthwiseConv2d: () => ic, diag: () => r2, dilation2d: () => o2, div: () => je, divNoNan: () => s2, dot: () => a2, dropout: () => R6, einsum: () => i2, elu: () => yd, enclosingPowerOfTwo: () => Gw, ensureShape: () => u2, equal: () => xd, erf: () => p2, euclideanNorm: () => m2, exp: () => _o, expandDims: () => ai, expm1: () => d2, eye: () => bd, fft: () => cc, fill: () => Ta, floor: () => Cd, floorDiv: () => ld, fused: () => Hw, gather: () => wd, gatherND: () => $6, greater: () => Uu, greaterEqual: () => Sd, ifft: () => Xu, imag: () => pu, image: () => Fj, inTopKAsync: () => A6, irfft: () => Gd, isFinite: () => f2, isInf: () => h2, isNaN: () => g2, leakyRelu: () => Id, less: () => kl, lessEqual: () => uc, linalg: () => Pj, linspace: () => x2, localResponseNormalization: () => y2, log: () => ii, log1p: () => vd, logSigmoid: () => b2, logSoftmax: () => C2, logSumExp: () => Td, logicalAnd: () => Gu, logicalNot: () => _d, logicalOr: () => $d, logicalXor: () => w2, losses: () => Oj, lowerBound: () => S2, matMul: () => Ze, max: () => _a, maxPool: () => Rd, maxPool3d: () => I2, maxPoolWithArgmax: () => v2, maximum: () => Dd, mean: () => Hu, meshgrid: () => k2, min: () => vl, minimum: () => Ku, mirrorPad: () => N2, mod: () => T2, moments: () => _2, movingAverage: () => S6, mul: () => se, multiRNNCell: () => $2, multinomial: () => E2, neg: () => pr, norm: () => Wu, notEqual: () => Ad, oneHot: () => Tl, ones: () => $a, onesLike: () => R2, op: () => N, outerProduct: () => D2, pad: () => Ea, pad1d: () => A2, pad2d: () => F2, pad3d: () => P2, pad4d: () => O2, pool: () => M2, pow: () => si, prelu: () => Pd, print: () => cd, prod: () => L2, raggedGather: () => B2, raggedRange: () => z2, raggedTensorToTensor: () => V2, rand: () => W2, randomGamma: () => p1, randomNormal: () => Vd, randomStandardNormal: () => c1, randomUniform: () => pc, randomUniformInt: () => l1, range: () => cu, real: () => ui, reciprocal: () => m1, relu: () => lu, relu6: () => Wd, reshape: () => W, reverse: () => lo, reverse1d: () => d1, reverse2d: () => f1, reverse3d: () => h1, reverse4d: () => g1, rfft: () => lc, round: () => Ud, rsqrt: () => x1, scalar: () => ke, scatterND: () => v6, searchSorted: () => Nl, selu: () => y1, separableConv2d: () => b1, setdiff1dAsync: () => C1, sigmoid: () => Na, sign: () => w1, signal: () => Aj, sin: () => S1, sinh: () => I1, slice: () => Xe, slice1d: () => v1, slice2d: () => k1, slice3d: () => N1, slice4d: () => T1, softmax: () => _1, softplus: () => Nd, spaceToBatchND: () => Fd, sparse: () => Mj, sparseToDense: () => T6, spectral: () => Dj, split: () => pi, sqrt: () => Dr, square: () => er, squaredDifference: () => Hd, squeeze: () => mc, stack: () => kr, step: () => Kd, stridedSlice: () => $1, string: () => Lj, sub: () => Te, sum: () => ot, tan: () => E1, tanh: () => Il, tensor: () => ir, tensor1d: () => xr, tensor2d: () => mu, tensor3d: () => qd, tensor4d: () => R1, tensor5d: () => D1, tensor6d: () => A1, tensorScatterUpdate: () => P1, tile: () => uu, topk: () => O1, transpose: () => fc, truncatedNormal: () => M1, unique: () => L1, unsortedSegmentSum: () => B1, unstack: () => mo, upperBound: () => z1, variable: () => V1, where: () => co, whereAsync: () => Xd, zeros: () => Gr, zerosLike: () => Ht });
  var mT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "BiasAdd":
      case "AddV2":
      case "Add":
        return [o8.add(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "AddN":
        return [o8.addN(I("tensors", r8, e8, t8))];
      case "FloorMod":
      case "Mod":
        return [o8.mod(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Mul":
        return [o8.mul(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "RealDiv":
      case "Div":
        return [o8.div(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "DivNoNan":
        return [o8.divNoNan(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "FloorDiv":
        return [o8.floorDiv(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Sub":
        return [o8.sub(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Minimum":
        return [o8.minimum(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Maximum":
        return [o8.maximum(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Pow":
        return [o8.pow(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "SquaredDifference":
        return [o8.squaredDifference(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var dT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "Abs":
      case "ComplexAbs":
        return [o8.abs(I("x", r8, e8, t8))];
      case "Acos":
        return [o8.acos(I("x", r8, e8, t8))];
      case "Acosh":
        return [o8.acosh(I("x", r8, e8, t8))];
      case "Asin":
        return [o8.asin(I("x", r8, e8, t8))];
      case "Asinh":
        return [o8.asinh(I("x", r8, e8, t8))];
      case "Atan":
        return [o8.atan(I("x", r8, e8, t8))];
      case "Atan2":
        return [o8.atan2(I("x", r8, e8, t8), I("y", r8, e8, t8))];
      case "Atanh":
        return [o8.atanh(I("x", r8, e8, t8))];
      case "Ceil":
        return [o8.ceil(I("x", r8, e8, t8))];
      case "Complex":
        return [o8.complex(I("real", r8, e8, t8), I("imag", r8, e8, t8))];
      case "Cos":
        return [o8.cos(I("x", r8, e8, t8))];
      case "Cosh":
        return [o8.cosh(I("x", r8, e8, t8))];
      case "Elu":
        return [o8.elu(I("x", r8, e8, t8))];
      case "Erf":
        return [o8.erf(I("x", r8, e8, t8))];
      case "Exp":
        return [o8.exp(I("x", r8, e8, t8))];
      case "Expm1":
        return [o8.expm1(I("x", r8, e8, t8))];
      case "Floor":
        return [o8.floor(I("x", r8, e8, t8))];
      case "Log":
        return [o8.log(I("x", r8, e8, t8))];
      case "Log1p":
        return [o8.log1p(I("x", r8, e8, t8))];
      case "Imag":
        return [o8.imag(I("x", r8, e8, t8))];
      case "Neg":
        return [o8.neg(I("x", r8, e8, t8))];
      case "Reciprocal":
        return [o8.reciprocal(I("x", r8, e8, t8))];
      case "Real":
        return [o8.real(I("x", r8, e8, t8))];
      case "Relu":
        return [o8.relu(I("x", r8, e8, t8))];
      case "Round":
        return [o8.round(I("x", r8, e8, t8))];
      case "Selu":
        return [o8.selu(I("x", r8, e8, t8))];
      case "Sigmoid":
        return [o8.sigmoid(I("x", r8, e8, t8))];
      case "Sin":
        return [o8.sin(I("x", r8, e8, t8))];
      case "Sign":
        return [o8.sign(I("x", r8, e8, t8))];
      case "Sinh":
        return [o8.sinh(I("x", r8, e8, t8))];
      case "Softplus":
        return [o8.softplus(I("x", r8, e8, t8))];
      case "Sqrt":
        return [o8.sqrt(I("x", r8, e8, t8))];
      case "Square":
        return [o8.square(I("x", r8, e8, t8))];
      case "Tanh":
        return [o8.tanh(I("x", r8, e8, t8))];
      case "Tan":
        return [o8.tan(I("x", r8, e8, t8))];
      case "ClipByValue":
        return [o8.clipByValue(I("x", r8, e8, t8), I("clipValueMin", r8, e8, t8), I("clipValueMax", r8, e8, t8))];
      case "Relu6":
        return [o8.relu6(I("x", r8, e8, t8))];
      case "Rsqrt":
        return [o8.rsqrt(Bt(r8.inputNames[0], e8, t8))];
      case "LeakyRelu":
        return [o8.leakyRelu(I("x", r8, e8, t8), I("alpha", r8, e8, t8))];
      case "Prelu":
        return [o8.prelu(I("x", r8, e8, t8), I("alpha", r8, e8, t8))];
      case "IsNan":
        return [o8.isNaN(Bt(r8.inputNames[0], e8, t8))];
      case "IsInf":
        return [o8.isInf(Bt(r8.inputNames[0], e8, t8))];
      case "IsFinite":
        return [o8.isFinite(Bt(r8.inputNames[0], e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  function Hr(r8, e8, t8 = "") {
    if (!(typeof r8 == "number" || typeof e8 == "number")) {
      y.assert(r8.length === e8.length, () => t8 + ` Shapes ${r8} and ${e8} must match`);
      for (let o8 = 0; o8 < r8.length; o8++) {
        let n8 = r8[o8], s = e8[o8];
        y.assert(n8 < 0 || s < 0 || n8 === s, () => t8 + ` Shapes ${r8} and ${e8} must match`);
      }
    }
  }
  function fT(r8) {
    return !(typeof r8 == "number" || r8.some((e8) => e8 < 0));
  }
  function hc(r8, e8, t8) {
    let o8 = Cf(r8, t8), n8 = !fT(o8);
    if (n8 && e8.length === 0)
      throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${o8}`);
    if (n8 && e8.forEach((s) => {
      o8 = Cf(s.shape, o8);
    }), !fT(o8))
      throw new Error(`Non-fully-defined elementShape: ${o8}`);
    return o8;
  }
  function Cf(r8, e8) {
    if (typeof r8 == "number")
      return e8;
    if (typeof e8 == "number")
      return r8;
    if (r8.length !== e8.length)
      throw new Error(`Incompatible ranks during merge: ${r8} vs. ${e8}`);
    let t8 = [];
    for (let o8 = 0; o8 < r8.length; ++o8) {
      let n8 = r8[o8], s = e8[o8];
      if (n8 >= 0 && s >= 0 && n8 !== s)
        throw new Error(`Incompatible shape during merge: ${r8} vs. ${e8}`);
      t8[o8] = n8 >= 0 ? n8 : s;
    }
    return t8;
  }
  var wf = class {
    constructor(e8, t8, o8, n8, s, a, i10) {
      this.name = e8, this.dtype = t8, this.maxSize = o8, this.elementShape = n8, this.identicalElementShapes = s, this.dynamicSize = a, this.clearAfterRead = i10, this.tensors = [], this.closed_ = false, this.idTensor = ke(0), Rr(this.idTensor);
    }
    get id() {
      return this.idTensor.id;
    }
    get closed() {
      return this.closed_;
    }
    clearAndClose(e8) {
      this.tensors.forEach((t8) => {
        (e8 == null || !e8.has(t8.tensor.id)) && t8.tensor.dispose();
      }), this.tensors = [], this.closed_ = true, this.idTensor.dispose();
    }
    size() {
      return this.tensors.length;
    }
    read(e8) {
      if (this.closed_)
        throw new Error(`TensorArray ${this.name} has already been closed.`);
      if (e8 < 0 || e8 >= this.size())
        throw new Error(`Tried to read from index ${e8}, but array size is: ${this.size()}`);
      let t8 = this.tensors[e8];
      if (t8.cleared)
        throw new Error(`TensorArray ${this.name}: Could not read index ${e8} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
      return this.clearAfterRead && (t8.cleared = true), t8.read = true, t8.tensor;
    }
    readMany(e8) {
      return e8.map((t8) => this.read(t8));
    }
    write(e8, t8) {
      if (this.closed_)
        throw new Error(`TensorArray ${this.name} has already been closed.`);
      if (e8 < 0 || !this.dynamicSize && e8 >= this.maxSize)
        throw new Error(`Tried to write to index ${e8}, but array is not resizeable and size is: ${this.maxSize}`);
      let o8 = this.tensors[e8] || {};
      if (t8.dtype !== this.dtype)
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e8},
          because the value dtype is ${t8.dtype}, but TensorArray dtype is ${this.dtype}.`);
      if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0) && (this.elementShape = t8.shape), Hr(this.elementShape, t8.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e8}.`), o8.read)
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e8}, because it has already been read.`);
      if (o8.written)
        throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e8}, because it has already been written.`);
      o8.tensor = t8, Rr(t8), o8.written = true, this.tensors[e8] = o8;
    }
    writeMany(e8, t8) {
      if (e8.length !== t8.length)
        throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e8.length} is not the same as tensors size: ${t8.length}.`);
      e8.forEach((o8, n8) => this.write(o8, t8[n8]));
    }
    gather(e8, t8) {
      if (t8 && t8 !== this.dtype)
        throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t8}`);
      if (e8)
        e8 = e8.slice(0, this.size());
      else {
        e8 = [];
        for (let n8 = 0; n8 < this.size(); n8++)
          e8.push(n8);
      }
      if (e8.length === 0)
        return ir([], [0].concat(this.elementShape));
      let o8 = this.readMany(e8);
      return Hr(this.elementShape, o8[0].shape, "TensorArray shape mismatch: "), kr(o8, 0);
    }
    concat(e8) {
      if (e8 && e8 !== this.dtype)
        throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e8}`);
      if (this.size() === 0)
        return ir([], [0].concat(this.elementShape));
      let t8 = [];
      for (let n8 = 0; n8 < this.size(); n8++)
        t8.push(n8);
      let o8 = this.readMany(t8);
      return Hr(this.elementShape, o8[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${o8[0].shape})`), bt(o8, 0);
    }
    scatter(e8, t8) {
      if (t8.dtype !== this.dtype)
        throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t8.dtype}`);
      if (e8.length !== t8.shape[0])
        throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e8.length} vs. ${t8.shape[0]}`);
      let o8 = Math.max(...e8);
      if (!this.dynamicSize && o8 >= this.maxSize)
        throw new Error(`Max index must be < array size (${o8}  vs. ${this.maxSize})`);
      this.writeMany(e8, mo(t8, 0));
    }
    split(e8, t8) {
      if (t8.dtype !== this.dtype)
        throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t8.dtype}`);
      let o8 = 0, n8 = e8.map((p) => (o8 += p, o8));
      if (o8 !== t8.shape[0])
        throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${o8}, and tensor's shape is: ${t8.shape}`);
      if (!this.dynamicSize && e8.length !== this.maxSize)
        throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e8.length}), and the TensorArray is not marked as dynamically resizeable`);
      let s = o8 === 0 ? 0 : t8.size / o8, a = [];
      De(() => {
        t8 = W(t8, [1, o8, s]);
        for (let p = 0; p < e8.length; ++p) {
          let c = [0, p === 0 ? 0 : n8[p - 1], 0], l = [1, e8[p], s];
          a[p] = W(Xe(t8, c, l), this.elementShape);
        }
        return a;
      });
      let i10 = [];
      for (let p = 0; p < e8.length; p++)
        i10[p] = p;
      this.writeMany(i10, a);
    }
  };
  var di = class {
    get id() {
      return this.idTensor.id;
    }
    constructor(e8, t8, o8, n8 = -1) {
      this.tensors = e8, this.elementShape = t8, this.elementDtype = o8, e8 != null && e8.forEach((s) => {
        if (o8 !== s.dtype)
          throw new Error(`Invalid data types; op elements ${o8}, but list elements ${s.dtype}`);
        Hr(t8, s.shape, "TensorList shape mismatch: "), Rr(s);
      }), this.idTensor = ke(0), this.maxNumElements = n8, Rr(this.idTensor);
    }
    copy() {
      return new di([...this.tensors], this.elementShape, this.elementDtype);
    }
    clearAndClose(e8) {
      this.tensors.forEach((t8) => {
        (e8 == null || !e8.has(t8.id)) && t8.dispose();
      }), this.tensors.length = 0, this.idTensor.dispose();
    }
    size() {
      return this.tensors.length;
    }
    stack(e8, t8, o8 = -1) {
      if (t8 !== this.elementDtype)
        throw new Error(`Invalid data types; op elements ${t8}, but list elements ${this.elementDtype}`);
      if (o8 !== -1 && this.tensors.length !== o8)
        throw new Error(`Operation expected a list with ${o8} elements but got a list with ${this.tensors.length} elements.`);
      Hr(e8, this.elementShape, "TensorList shape mismatch: ");
      let n8 = hc(this.elementShape, this.tensors, e8);
      return De(() => {
        let s = this.tensors.map((a) => W(a, n8));
        return kr(s, 0);
      });
    }
    popBack(e8, t8) {
      if (t8 !== this.elementDtype)
        throw new Error(`Invalid data types; op elements ${t8}, but list elements ${this.elementDtype}`);
      if (this.size() === 0)
        throw new Error("Trying to pop from an empty list.");
      let o8 = hc(this.elementShape, this.tensors, e8), n8 = this.tensors.pop();
      return n8.kept = false, Hr(n8.shape, e8, "TensorList shape mismatch: "), W(n8, o8);
    }
    pushBack(e8) {
      if (e8.dtype !== this.elementDtype)
        throw new Error(`Invalid data types; op elements ${e8.dtype}, but list elements ${this.elementDtype}`);
      if (Hr(e8.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size())
        throw new Error("Trying to push element into a full list.");
      Rr(e8), this.tensors.push(e8);
    }
    resize(e8) {
      if (e8 < 0)
        throw new Error(`TensorListResize expects size to be non-negative. Got: ${e8}`);
      if (this.maxNumElements !== -1 && e8 > this.maxNumElements)
        throw new Error(`TensorListResize input size ${e8} is greater maxNumElement ${this.maxNumElements}.`);
      let t8 = new di([], this.elementShape, this.elementDtype, this.maxNumElements);
      t8.tensors.length = e8;
      for (let o8 = 0; o8 < Math.min(this.tensors.length, e8); ++o8)
        t8.tensors[o8] = this.tensors[o8];
      return t8;
    }
    getItem(e8, t8, o8) {
      if (o8 !== this.elementDtype)
        throw new Error(`Invalid data types; op elements ${o8}, but list elements ${this.elementDtype}`);
      if (e8 < 0 || e8 > this.tensors.length)
        throw new Error(`Trying to access element ${e8} in a list with ${this.tensors.length} elements.`);
      if (this.tensors[e8] == null)
        throw new Error(`element at index ${e8} is null.`);
      Hr(this.tensors[e8].shape, t8, "TensorList shape mismatch: ");
      let n8 = hc(this.elementShape, this.tensors, t8);
      return W(this.tensors[e8], n8);
    }
    setItem(e8, t8) {
      if (t8.dtype !== this.elementDtype)
        throw new Error(`Invalid data types; op elements ${t8.dtype}, but list elements ${this.elementDtype}`);
      if (e8 < 0 || this.maxNumElements !== -1 && e8 >= this.maxNumElements)
        throw new Error(`Trying to set element ${e8} in a list with max ${this.maxNumElements} elements.`);
      Hr(this.elementShape, t8.shape, "TensorList shape mismatch: "), Rr(t8), this.tensors[e8] != null && (this.tensors[e8].kept = false), this.tensors[e8] = t8;
    }
    gather(e8, t8, o8) {
      if (t8 !== this.elementDtype)
        throw new Error(`Invalid data types; op elements ${t8}, but list elements ${this.elementDtype}`);
      Hr(this.elementShape, o8, "TensorList shape mismatch: "), e8 = e8.slice(0, this.size());
      let n8 = hc(this.elementShape, this.tensors, o8);
      return e8.length === 0 ? ir([], [0].concat(n8)) : De(() => {
        let s = e8.map((a) => W(this.tensors[a], n8));
        return kr(s, 0);
      });
    }
    concat(e8, t8) {
      if (e8 && e8 !== this.elementDtype)
        throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e8}`);
      Hr(this.elementShape, t8, "TensorList shape mismatch: ");
      let o8 = hc(this.elementShape, this.tensors, t8);
      return this.size() === 0 ? ir([], [0].concat(o8)) : De(() => {
        let n8 = this.tensors.map((s) => W(s, o8));
        return bt(n8, 0);
      });
    }
  };
  function hT(r8, e8, t8) {
    let o8 = r8.dtype;
    if (r8.shape.length < 1)
      throw new Error(`Tensor must be at least a vector, but saw shape: ${r8.shape}`);
    if (r8.dtype !== t8)
      throw new Error(`Invalid data types; op elements ${r8.dtype}, but list elements ${t8}`);
    let n8 = r8.shape.slice(1);
    Hr(n8, e8, "TensorList shape mismatch: ");
    let s = mo(r8);
    return new di(s, e8, o8);
  }
  function gT(r8, e8, t8, o8) {
    return new di([], r8, e8, o8);
  }
  function xT(r8, e8, t8, o8) {
    if (e8.length !== r8.shape[0])
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e8.length} vs. ${r8.shape[0]}`);
    let n8 = Math.max(...e8);
    if (o8 != null && o8 !== -1 && n8 >= o8)
      throw new Error(`Max index must be < array size (${n8}  vs. ${o8})`);
    let s = new di([], t8, r8.dtype, o8), a = mo(r8, 0);
    return e8.forEach((i10, p) => {
      s.setItem(i10, a[p]);
    }), s;
  }
  function yT(r8, e8, t8) {
    let o8 = 0, n8 = e8.map((c) => (o8 += c, o8));
    if (o8 !== r8.shape[0])
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${o8}, and tensor's shape is: ${r8.shape}`);
    let s = r8.shape.slice(1), a = Cf(s, t8), i10 = o8 === 0 ? 0 : r8.size / o8, p = De(() => {
      let c = [];
      r8 = W(r8, [1, o8, i10]);
      for (let l = 0; l < e8.length; ++l) {
        let d = [0, l === 0 ? 0 : n8[l - 1], 0], f = [1, e8[l], i10];
        c[l] = W(Xe(r8, d, f), a);
      }
      return r8.dispose(), c;
    }), u = new di([], t8, r8.dtype, e8.length);
    for (let c = 0; c < p.length; c++)
      u.setItem(c, p[c]);
    return u;
  }
  var bT = async (r8, e8, t8) => {
    switch (r8.op) {
      case "If":
      case "StatelessIf": {
        let o8 = I("thenBranch", r8, e8, t8), n8 = I("elseBranch", r8, e8, t8), s = I("cond", r8, e8, t8), a = I("args", r8, e8, t8);
        return (await s.data())[0] ? t8.functionMap[o8].executeFunctionAsync(a, t8.tensorArrayMap, t8.tensorListMap) : t8.functionMap[n8].executeFunctionAsync(a, t8.tensorArrayMap, t8.tensorListMap);
      }
      case "While":
      case "StatelessWhile": {
        let o8 = I("body", r8, e8, t8), n8 = I("cond", r8, e8, t8), s = I("args", r8, e8, t8), a = await t8.functionMap[n8].executeFunctionAsync(s, t8.tensorArrayMap, t8.tensorListMap), i10 = s.map((c) => c.id), p = await a[0].data();
        a.forEach((c) => {
          !c.kept && i10.indexOf(c.id) === -1 && c.dispose();
        });
        let u = s;
        for (; p[0]; ) {
          let c = u;
          u = await t8.functionMap[o8].executeFunctionAsync(u, t8.tensorArrayMap, t8.tensorListMap);
          let l = u.map((d) => d.id);
          c.forEach((d) => {
            !d.kept && i10.indexOf(d.id) === -1 && l.indexOf(d.id) === -1 && d.dispose();
          });
          let m = await t8.functionMap[n8].executeFunctionAsync(u, t8.tensorArrayMap, t8.tensorListMap);
          p = await m[0].data(), m.forEach((d) => {
            !d.kept && i10.indexOf(d.id) === -1 && l.indexOf(d.id) === -1 && d.dispose();
          });
        }
        return u;
      }
      case "LoopCond": {
        let o8 = I("pred", r8, e8, t8);
        return [Ms(o8)];
      }
      case "Switch": {
        let o8 = I("pred", r8, e8, t8), n8 = I("data", r8, e8, t8);
        return n8.kept || (n8 = Ms(n8)), (await o8.data())[0] ? [void 0, n8] : [n8, void 0];
      }
      case "Merge": {
        let o8 = r8.inputNames.find((n8) => Bt(n8, e8, t8) !== void 0);
        if (o8) {
          let n8 = Bt(o8, e8, t8);
          return [Ms(n8)];
        }
        return;
      }
      case "Enter": {
        let o8 = I("frameName", r8, e8, t8), n8 = I("tensor", r8, e8, t8);
        return t8.enterFrame(o8), [Ms(n8)];
      }
      case "Exit": {
        let o8 = I("tensor", r8, e8, t8);
        return t8.exitFrame(), [Ms(o8)];
      }
      case "NextIteration": {
        let o8 = I("tensor", r8, e8, t8);
        return t8.nextIteration(), [Ms(o8)];
      }
      case "TensorArrayV3": {
        let o8 = I("size", r8, e8, t8), n8 = I("dtype", r8, e8, t8), s = I("elementShape", r8, e8, t8), a = I("dynamicSize", r8, e8, t8), i10 = I("clearAfterRead", r8, e8, t8), p = I("identicalElementShapes", r8, e8, t8), u = I("name", r8, e8, t8), c = new wf(u, n8, o8, s, p, a, i10);
        return t8.addTensorArray(c), [c.idTensor, ke(1)];
      }
      case "TensorArrayWriteV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = I("index", r8, e8, t8), s = I("tensor", r8, e8, t8), a = t8.getTensorArray(o8.id);
        return a.write(n8, s), [a.idTensor];
      }
      case "TensorArrayReadV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = I("index", r8, e8, t8);
        return [t8.getTensorArray(o8.id).read(n8)];
      }
      case "TensorArrayGatherV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = I("indices", r8, e8, t8), s = I("dtype", r8, e8, t8);
        return [t8.getTensorArray(o8.id).gather(n8, s)];
      }
      case "TensorArrayScatterV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = I("indices", r8, e8, t8), s = I("tensor", r8, e8, t8), a = t8.getTensorArray(o8.id);
        return a.scatter(n8, s), [a.idTensor];
      }
      case "TensorArrayConcatV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = t8.getTensorArray(o8.id), s = I("dtype", r8, e8, t8);
        return [n8.concat(s)];
      }
      case "TensorArraySplitV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = I("tensor", r8, e8, t8), s = I("lengths", r8, e8, t8), a = t8.getTensorArray(o8.id);
        return a.split(s, n8), [a.idTensor];
      }
      case "TensorArraySizeV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = t8.getTensorArray(o8.id);
        return [ke(n8.size(), "int32")];
      }
      case "TensorArrayCloseV3": {
        let o8 = I("tensorArrayId", r8, e8, t8), n8 = t8.getTensorArray(o8.id);
        return n8.clearAndClose(), [n8.idTensor];
      }
      case "TensorListSetItem": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = I("index", r8, e8, t8), s = I("tensor", r8, e8, t8), a = t8.getTensorList(o8.id);
        return a.setItem(n8, s), [a.idTensor];
      }
      case "TensorListGetItem": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = I("index", r8, e8, t8), s = I("elementShape", r8, e8, t8), a = I("elementDType", r8, e8, t8);
        return [t8.getTensorList(o8.id).getItem(n8, s, a)];
      }
      case "TensorListScatterV2":
      case "TensorListScatter": {
        let o8 = I("indices", r8, e8, t8), n8 = I("tensor", r8, e8, t8), s = I("elementShape", r8, e8, t8), a = I("numElements", r8, e8, t8), i10 = xT(n8, o8, s, a);
        return t8.addTensorList(i10), [i10.idTensor];
      }
      case "TensorListReserve":
      case "EmptyTensorList": {
        let o8 = I("elementShape", r8, e8, t8), n8 = I("elementDType", r8, e8, t8), s;
        r8.op === "TensorListReserve" ? s = "numElements" : s = "maxNumElements";
        let a = I(s, r8, e8, t8), i10 = r8.op === "TensorListReserve" ? -1 : a, p = gT(o8, n8, a, i10);
        return t8.addTensorList(p), [p.idTensor];
      }
      case "TensorListGather": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = I("indices", r8, e8, t8), s = I("elementShape", r8, e8, t8), a = I("elementDType", r8, e8, t8);
        return [t8.getTensorList(o8.id).gather(n8, a, s)];
      }
      case "TensorListStack": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = I("elementShape", r8, e8, t8), s = I("elementDType", r8, e8, t8), a = I("numElements", r8, e8, t8);
        return [t8.getTensorList(o8.id).stack(n8, s, a)];
      }
      case "TensorListFromTensor": {
        let o8 = I("tensor", r8, e8, t8), n8 = I("elementShape", r8, e8, t8), s = I("elementDType", r8, e8, t8), a = hT(o8, n8, s);
        return t8.addTensorList(a), [a.idTensor];
      }
      case "TensorListConcat":
      case "TensorListConcatV2": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = t8.getTensorList(o8.id), s = I("dtype", r8, e8, t8), a = I("elementShape", r8, e8, t8);
        return [n8.concat(s, a)];
      }
      case "TensorListPushBack": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = I("tensor", r8, e8, t8), s = t8.getTensorList(o8.id);
        return s.pushBack(n8), [s.idTensor];
      }
      case "TensorListPopBack": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = I("elementShape", r8, e8, t8), s = I("elementDType", r8, e8, t8);
        return [t8.getTensorList(o8.id).popBack(n8, s)];
      }
      case "TensorListSplit": {
        let o8 = I("tensor", r8, e8, t8), n8 = I("elementShape", r8, e8, t8), s = I("lengths", r8, e8, t8), a = yT(o8, s, n8);
        return t8.addTensorList(a), [a.idTensor];
      }
      case "TensorListLength": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = t8.getTensorList(o8.id);
        return [ke(n8.size(), "int32")];
      }
      case "TensorListResize": {
        let o8 = I("tensorListId", r8, e8, t8), n8 = I("size", r8, e8, t8), a = t8.getTensorList(o8.id).resize(n8);
        return t8.addTensorList(a), [a.idTensor];
      }
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  function CT(r8, e8, t8) {
    let [o8, n8] = I("fusedOps", r8, e8, t8), s = o8 === "biasadd", a = !s, i10 = n8 === "prelu", p = o8 === "fusedbatchnorm", u = I("numArgs", r8, e8, t8);
    if (s) {
      if (i10 && u !== 2)
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
      if (!i10 && s && u !== 1)
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
    }
    if (p)
      throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
    let c = I("strides", r8, e8, t8), l = Al(r8, e8, t8), m = I("dataFormat", r8, e8, t8).toUpperCase(), d = I("dilations", r8, e8, t8), [f, h] = I("args", r8, e8, t8);
    a && (h = f, f = void 0);
    let g = I("leakyreluAlpha", r8, e8, t8);
    return { stride: c, pad: l, dataFormat: m, dilations: d, biasArg: f, preluArg: h, activationFunc: n8, leakyreluAlpha: g };
  }
  var wT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "Conv1D": {
        let n8 = I("stride", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("dataFormat", r8, e8, t8).toUpperCase(), i10 = I("dilation", r8, e8, t8);
        return [o8.conv1d(I("x", r8, e8, t8), I("filter", r8, e8, t8), n8, s, a, i10)];
      }
      case "Conv2D": {
        let n8 = I("strides", r8, e8, t8), s = Al(r8, e8, t8), a = I("dataFormat", r8, e8, t8).toUpperCase(), i10 = I("dilations", r8, e8, t8);
        return [o8.conv2d(I("x", r8, e8, t8), I("filter", r8, e8, t8), [n8[1], n8[2]], s, a, [i10[1], i10[2]])];
      }
      case "_FusedConv2D": {
        let { stride: n8, pad: s, dataFormat: a, dilations: i10, biasArg: p, preluArg: u, activationFunc: c, leakyreluAlpha: l } = CT(r8, e8, t8);
        return [o8.fused.conv2d({ x: I("x", r8, e8, t8), filter: I("filter", r8, e8, t8), strides: [n8[1], n8[2]], pad: s, dataFormat: a, dilations: [i10[1], i10[2]], bias: p, activation: c, preluActivationWeights: u, leakyreluAlpha: l })];
      }
      case "FusedDepthwiseConv2dNative": {
        let { stride: n8, pad: s, dataFormat: a, dilations: i10, biasArg: p, preluArg: u, activationFunc: c, leakyreluAlpha: l } = CT(r8, e8, t8);
        return [o8.fused.depthwiseConv2d({ x: I("x", r8, e8, t8), filter: I("filter", r8, e8, t8), strides: [n8[1], n8[2]], pad: s, dataFormat: a, dilations: [i10[1], i10[2]], bias: p, activation: c, preluActivationWeights: u, leakyreluAlpha: l })];
      }
      case "Conv2DBackpropInput":
      case "Conv2dTranspose": {
        let n8 = I("outputShape", r8, e8, t8), s = I("strides", r8, e8, t8), a = Al(r8, e8, t8);
        return [o8.conv2dTranspose(I("x", r8, e8, t8), I("filter", r8, e8, t8), n8, [s[1], s[2]], a)];
      }
      case "DepthwiseConv2dNative":
      case "DepthwiseConv2d": {
        let n8 = I("strides", r8, e8, t8), s = Al(r8, e8, t8), a = I("dilations", r8, e8, t8), i10 = I("dataFormat", r8, e8, t8).toUpperCase();
        return [o8.depthwiseConv2d(I("input", r8, e8, t8), I("filter", r8, e8, t8), [n8[1], n8[2]], s, i10, [a[1], a[2]])];
      }
      case "Conv3D": {
        let n8 = I("strides", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("dataFormat", r8, e8, t8).toUpperCase(), i10 = I("dilations", r8, e8, t8);
        return [o8.conv3d(I("x", r8, e8, t8), I("filter", r8, e8, t8), [n8[1], n8[2], n8[3]], s, a, [i10[1], i10[2], i10[3]])];
      }
      case "AvgPool": {
        let n8 = I("strides", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("kernelSize", r8, e8, t8);
        return [o8.avgPool(I("x", r8, e8, t8), [a[1], a[2]], [n8[1], n8[2]], s)];
      }
      case "MaxPool": {
        let n8 = I("strides", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("kernelSize", r8, e8, t8);
        return [o8.maxPool(I("x", r8, e8, t8), [a[1], a[2]], [n8[1], n8[2]], s)];
      }
      case "MaxPoolWithArgmax": {
        let n8 = I("strides", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("kernelSize", r8, e8, t8), i10 = I("includeBatchInIndex", r8, e8, t8), { result: p, indexes: u } = o8.maxPoolWithArgmax(I("x", r8, e8, t8), [a[1], a[2]], [n8[1], n8[2]], s, i10);
        return [p, u];
      }
      case "AvgPool3D": {
        let n8 = I("strides", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("kernelSize", r8, e8, t8);
        return [o8.avgPool3d(I("x", r8, e8, t8), [a[1], a[2], a[3]], [n8[1], n8[2], n8[3]], s)];
      }
      case "MaxPool3D": {
        let n8 = I("strides", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("kernelSize", r8, e8, t8);
        return [o8.maxPool3d(I("x", r8, e8, t8), [a[1], a[2], a[3]], [n8[1], n8[2], n8[3]], s)];
      }
      case "Dilation2D": {
        let n8 = I("strides", r8, e8, t8), s = I("pad", r8, e8, t8), a = I("dilations", r8, e8, t8), i10 = n8[1], p = n8[2], u = a[1], c = a[2];
        return [o8.dilation2d(I("x", r8, e8, t8), I("filter", r8, e8, t8), [i10, p], s, [u, c], "NHWC")];
      }
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var ST = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "Fill": {
        let n8 = I("shape", r8, e8, t8), s = I("dtype", r8, e8, t8), a = I("value", r8, e8, t8);
        return [o8.fill(n8, a, s)];
      }
      case "LinSpace": {
        let n8 = I("start", r8, e8, t8), s = I("stop", r8, e8, t8), a = I("num", r8, e8, t8);
        return [o8.linspace(n8, s, a)];
      }
      case "Multinomial": {
        let n8 = I("logits", r8, e8, t8), s = I("numSamples", r8, e8, t8), a = I("seed", r8, e8, t8);
        return [o8.multinomial(n8, s, a)];
      }
      case "OneHot": {
        let n8 = I("indices", r8, e8, t8), s = I("depth", r8, e8, t8), a = I("onValue", r8, e8, t8), i10 = I("offValue", r8, e8, t8), p = I("dtype", r8, e8, t8);
        return [o8.oneHot(n8, s, a, i10, p)];
      }
      case "Ones":
        return [o8.ones(I("shape", r8, e8, t8), I("dtype", r8, e8, t8))];
      case "OnesLike":
        return [o8.onesLike(I("x", r8, e8, t8))];
      case "RandomStandardNormal":
        return [o8.randomStandardNormal(I("shape", r8, e8, t8), I("dtype", r8, e8, t8), I("seed", r8, e8, t8))];
      case "RandomUniform":
        return [o8.randomUniform(I("shape", r8, e8, t8), I("minval", r8, e8, t8), I("maxval", r8, e8, t8), I("dtype", r8, e8, t8))];
      case "RandomUniformInt":
        return [o8.randomUniformInt(I("shape", r8, e8, t8), I("minval", r8, e8, t8), I("maxval", r8, e8, t8), I("seed", r8, e8, t8))];
      case "Range": {
        let n8 = I("start", r8, e8, t8), s = I("stop", r8, e8, t8), a = I("step", r8, e8, t8);
        return [o8.range(n8, s, a, I("dtype", r8, e8, t8))];
      }
      case "TruncatedNormal": {
        let n8 = I("shape", r8, e8, t8), s = I("mean", r8, e8, t8), a = I("stdDev", r8, e8, t8), i10 = I("seed", r8, e8, t8);
        return [o8.truncatedNormal(n8, s, a, I("dtype", r8, e8, t8), i10)];
      }
      case "Zeros":
        return [o8.zeros(I("shape", r8, e8, t8), I("dtype", r8, e8, t8))];
      case "ZerosLike":
        return [o8.zerosLike(I("x", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  function TS(r8, e8, t8) {
    let o8 = I("boxes", r8, e8, t8), n8 = I("scores", r8, e8, t8), s = I("maxOutputSize", r8, e8, t8), a = I("iouThreshold", r8, e8, t8), i10 = I("scoreThreshold", r8, e8, t8), p = I("softNmsSigma", r8, e8, t8);
    return { boxes: o8, scores: n8, maxOutputSize: s, iouThreshold: a, scoreThreshold: i10, softNmsSigma: p };
  }
  var IT = async (r8, e8, t8, o8, n8 = Je) => {
    switch (r8.op) {
      case "NonMaxSuppressionV5": {
        let { boxes: s, scores: a, maxOutputSize: i10, iouThreshold: p, scoreThreshold: u, softNmsSigma: c } = TS(r8, e8, t8), l = await n8.image.nonMaxSuppressionWithScoreAsync(s, a, i10, p, u, c);
        return [l.selectedIndices, l.selectedScores];
      }
      case "NonMaxSuppressionV4": {
        let { boxes: s, scores: a, maxOutputSize: i10, iouThreshold: p, scoreThreshold: u } = TS(r8, e8, t8), c = I("padToMaxOutputSize", r8, e8, t8), l = await n8.image.nonMaxSuppressionPaddedAsync(s, a, i10, p, u, c);
        return [l.selectedIndices, l.validOutputs];
      }
      case "NonMaxSuppressionV3":
      case "NonMaxSuppressionV2": {
        let { boxes: s, scores: a, maxOutputSize: i10, iouThreshold: p, scoreThreshold: u } = TS(r8, e8, t8);
        return [await n8.image.nonMaxSuppressionAsync(s, a, i10, p, u)];
      }
      case "Where": {
        let s = n8.cast(I("condition", r8, e8, t8), "bool"), a = [await n8.whereAsync(s)];
        return s.dispose(), a;
      }
      case "ListDiff":
        return n8.setdiff1dAsync(I("x", r8, e8, t8), I("y", r8, e8, t8));
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var vT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "LowerBound": {
        let n8 = I("sortedSequence", r8, e8, t8), s = I("values", r8, e8, t8);
        return [o8.lowerBound(n8, s)];
      }
      case "TopKV2": {
        let n8 = I("x", r8, e8, t8), s = I("k", r8, e8, t8), a = I("sorted", r8, e8, t8), i10 = o8.topk(n8, s, a);
        return [i10.values, i10.indices];
      }
      case "UpperBound": {
        let n8 = I("sortedSequence", r8, e8, t8), s = I("values", r8, e8, t8);
        return [o8.upperBound(n8, s)];
      }
      case "Unique": {
        let n8 = I("x", r8, e8, t8), s = o8.unique(n8);
        return [s.values, s.indices];
      }
      case "UniqueV2": {
        let n8 = I("x", r8, e8, t8), s = I("axis", r8, e8, t8), a = o8.unique(n8, s);
        return [a.values, a.indices];
      }
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var kT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "Const":
        return e8[r8.name];
      case "PlaceholderWithDefault":
        let n8 = I("default", r8, e8, t8);
        return [Bt(r8.name, e8, t8) || n8];
      case "Placeholder":
        return [Bt(r8.name, e8, t8)];
      case "Identity":
      case "StopGradient":
      case "FakeQuantWithMinMaxVars": {
        let c = I("x", r8, e8, t8);
        return [Ms(c)];
      }
      case "IdentityN":
        return I("x", r8, e8, t8).map((c) => Ms(c));
      case "Snapshot":
        let s = I("x", r8, e8, t8);
        return [Ms(s)];
      case "Shape":
        return [o8.tensor1d(I("x", r8, e8, t8).shape, "int32")];
      case "ShapeN":
        return I("x", r8, e8, t8).map((c) => o8.tensor1d(c.shape));
      case "Size":
        return [o8.scalar(I("x", r8, e8, t8).size, "int32")];
      case "Rank":
        return [o8.scalar(I("x", r8, e8, t8).rank, "int32")];
      case "NoOp":
        return [o8.scalar(1)];
      case "Print":
        let a = I("x", r8, e8, t8), i10 = I("data", r8, e8, t8), p = I("message", r8, e8, t8), u = I("summarize", r8, e8, t8);
        console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(p);
        for (let c = 0; c < i10.length; c++)
          console.log(Array.prototype.slice.call(i10[c].dataSync()).slice(0, u));
        return [a];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var Sf = class {
    get id() {
      return this.handle.id;
    }
    constructor(e8, t8) {
      this.keyDType = e8, this.valueDType = t8, this.handle = ke(0), this.tensorMap = /* @__PURE__ */ new Map(), Rr(this.handle);
    }
    clearAndClose() {
      this.tensorMap.forEach((e8) => e8.dispose()), this.tensorMap.clear(), this.handle.dispose();
    }
    size() {
      return this.tensorMap.size;
    }
    tensorSize() {
      return ke(this.size(), "int32");
    }
    async import(e8, t8) {
      this.checkKeyAndValueTensor(e8, t8);
      let o8 = await e8.data();
      return this.tensorMap.forEach((n8) => n8.dispose()), this.tensorMap.clear(), De(() => {
        let n8 = mo(t8), s = o8.length, a = n8.length;
        y.assert(s === a, () => `The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);
        for (let i10 = 0; i10 < s; i10++) {
          let p = o8[i10], u = n8[i10];
          Rr(u), this.tensorMap.set(p, u);
        }
        return this.handle;
      });
    }
    async find(e8, t8) {
      this.checkKeyAndValueTensor(e8, t8);
      let o8 = await e8.data();
      return De(() => {
        let n8 = [];
        for (let s = 0; s < o8.length; s++) {
          let a = o8[s], i10 = this.findWithDefault(a, t8);
          n8.push(i10);
        }
        return kr(n8);
      });
    }
    findWithDefault(e8, t8) {
      let o8 = this.tensorMap.get(e8);
      return o8 != null ? o8 : t8;
    }
    checkKeyAndValueTensor(e8, t8) {
      if (e8.dtype !== this.keyDType)
        throw new Error(`Expect key dtype ${this.keyDType}, but got ${e8.dtype}`);
      if (t8.dtype !== this.valueDType)
        throw new Error(`Expect value dtype ${this.valueDType}, but got ${t8.dtype}`);
    }
  };
  var NT = async (r8, e8, t8, o8) => {
    switch (r8.op) {
      case "HashTable":
      case "HashTableV2": {
        let n8 = o8.getHashTableHandleByName(r8.name);
        if (n8 != null)
          return [n8];
        {
          let s = I("keyDType", r8, e8, t8), a = I("valueDType", r8, e8, t8), i10 = new Sf(s, a);
          return o8.addHashTable(r8.name, i10), [i10.handle];
        }
      }
      case "InitializeTable":
      case "InitializeTableV2":
      case "LookupTableImport":
      case "LookupTableImportV2": {
        let n8 = I("tableHandle", r8, e8, t8, o8), s = I("keys", r8, e8, t8), a = I("values", r8, e8, t8);
        return [await o8.getHashTableById(n8.id).import(s, a)];
      }
      case "LookupTableFind":
      case "LookupTableFindV2": {
        let n8 = I("tableHandle", r8, e8, t8, o8), s = I("keys", r8, e8, t8), a = I("defaultValue", r8, e8, t8);
        return [await o8.getHashTableById(n8.id).find(s, a)];
      }
      case "LookupTableSize":
      case "LookupTableSizeV2": {
        let n8 = I("tableHandle", r8, e8, t8, o8);
        return [o8.getHashTableById(n8.id).tensorSize()];
      }
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var TT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "ResizeBilinear": {
        let n8 = I("images", r8, e8, t8), s = I("size", r8, e8, t8), a = I("alignCorners", r8, e8, t8), i10 = I("halfPixelCenters", r8, e8, t8);
        return [o8.image.resizeBilinear(n8, [s[0], s[1]], a, i10)];
      }
      case "ResizeNearestNeighbor": {
        let n8 = I("images", r8, e8, t8), s = I("size", r8, e8, t8), a = I("alignCorners", r8, e8, t8), i10 = I("halfPixelCenters", r8, e8, t8);
        return [o8.image.resizeNearestNeighbor(n8, [s[0], s[1]], a, i10)];
      }
      case "CropAndResize": {
        let n8 = I("image", r8, e8, t8), s = I("boxes", r8, e8, t8), a = I("boxInd", r8, e8, t8), i10 = I("cropSize", r8, e8, t8), p = I("method", r8, e8, t8), u = I("extrapolationValue", r8, e8, t8);
        return [o8.image.cropAndResize(n8, s, a, i10, p, u)];
      }
      case "ImageProjectiveTransformV3": {
        let n8 = I("images", r8, e8, t8), s = I("transforms", r8, e8, t8), a = I("outputShape", r8, e8, t8), i10 = I("fillValue", r8, e8, t8), p = I("interpolation", r8, e8, t8), u = I("fillMode", r8, e8, t8);
        return [o8.image.transform(n8, s, p.toLowerCase(), u.toLowerCase(), i10, a)];
      }
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var _T = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "Equal":
        return [o8.equal(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "NotEqual":
        return [o8.notEqual(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Greater":
        return [o8.greater(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "GreaterEqual":
        return [o8.greaterEqual(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Less":
        return [o8.less(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "LessEqual":
        return [o8.lessEqual(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "LogicalAnd":
        return [o8.logicalAnd(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "LogicalNot":
        return [o8.logicalNot(I("a", r8, e8, t8))];
      case "LogicalOr":
        return [o8.logicalOr(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "Select":
      case "SelectV2":
        return [o8.where(I("condition", r8, e8, t8), I("a", r8, e8, t8), I("b", r8, e8, t8))];
      case "BitwiseAnd":
        return [o8.bitwiseAnd(I("a", r8, e8, t8), I("b", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var $T = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "BatchMatMul":
      case "BatchMatMulV2":
      case "MatMul":
        return [o8.matMul(I("a", r8, e8, t8), I("b", r8, e8, t8), I("transposeA", r8, e8, t8), I("transposeB", r8, e8, t8))];
      case "Einsum":
        return [o8.einsum(I("equation", r8, e8, t8), ...I("tensors", r8, e8, t8))];
      case "Transpose":
        return [o8.transpose(I("x", r8, e8, t8), I("perm", r8, e8, t8))];
      case "_FusedMatMul":
        let [n8, s] = I("fusedOps", r8, e8, t8), a = n8 === "biasadd", i10 = s === "prelu", p = I("numArgs", r8, e8, t8), u = I("leakyreluAlpha", r8, e8, t8);
        if (a) {
          if (i10 && p !== 2)
            throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          if (!i10 && p !== 1)
            throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
        }
        let [c, l] = I("args", r8, e8, t8);
        return [o8.fused.matMul({ a: I("a", r8, e8, t8), b: I("b", r8, e8, t8), transposeA: I("transposeA", r8, e8, t8), transposeB: I("transposeB", r8, e8, t8), bias: c, activation: s, preluActivationWeights: l, leakyreluAlpha: u })];
      case "MatrixBandPart":
        return [o8.linalg.bandPart(I("a", r8, e8, t8), I("numLower", r8, e8, t8), I("numUpper", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var ET = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "EuclideanNorm":
        return [o8.euclideanNorm(I("x", r8, e8, t8), I("axis", r8, e8, t8), I("keepDims", r8, e8, t8))];
      case "FusedBatchNorm":
      case "FusedBatchNormV2":
        return [o8.batchNorm(I("x", r8, e8, t8), I("mean", r8, e8, t8), I("variance", r8, e8, t8), I("offset", r8, e8, t8), I("scale", r8, e8, t8), I("epsilon", r8, e8, t8))];
      case "FusedBatchNormV3":
        return [o8.batchNorm(I("x", r8, e8, t8), I("mean", r8, e8, t8), I("variance", r8, e8, t8), I("offset", r8, e8, t8), I("scale", r8, e8, t8), I("epsilon", r8, e8, t8))];
      case "LRN":
        return [o8.localResponseNormalization(I("x", r8, e8, t8), I("radius", r8, e8, t8), I("bias", r8, e8, t8), I("alpha", r8, e8, t8), I("beta", r8, e8, t8))];
      case "Softmax":
        return [o8.softmax(I("x", r8, e8, t8))];
      case "LogSoftmax":
        return [o8.logSoftmax(I("x", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var RT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "RaggedGather": {
        let { outputNestedSplits: n8, outputDenseValues: s } = o8.raggedGather(I("paramsNestedSplits", r8, e8, t8), I("paramsDenseValues", r8, e8, t8), I("indices", r8, e8, t8), I("outputRaggedRank", r8, e8, t8));
        return n8.concat(s);
      }
      case "RaggedRange": {
        let { rtNestedSplits: n8, rtDenseValues: s } = o8.raggedRange(I("starts", r8, e8, t8), I("limits", r8, e8, t8), I("splits", r8, e8, t8));
        return [n8, s];
      }
      case "RaggedTensorToTensor":
        return [o8.raggedTensorToTensor(I("shape", r8, e8, t8), I("values", r8, e8, t8), I("defaultValue", r8, e8, t8), I("rowPartitionTensors", r8, e8, t8), I("rowPartitionTypes", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var DT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "Max": {
        let i10 = I("axis", r8, e8, t8), p = I("keepDims", r8, e8, t8);
        return [o8.max(I("x", r8, e8, t8), i10, p)];
      }
      case "Mean": {
        let i10 = I("axis", r8, e8, t8), p = I("keepDims", r8, e8, t8);
        return [o8.mean(I("x", r8, e8, t8), i10, p)];
      }
      case "Min": {
        let i10 = I("axis", r8, e8, t8), p = I("keepDims", r8, e8, t8);
        return [o8.min(I("x", r8, e8, t8), i10, p)];
      }
      case "Sum": {
        let i10 = I("axis", r8, e8, t8), p = I("keepDims", r8, e8, t8);
        return [o8.sum(I("x", r8, e8, t8), i10, p)];
      }
      case "All": {
        let i10 = I("axis", r8, e8, t8), p = I("keepDims", r8, e8, t8);
        return [o8.all(I("x", r8, e8, t8), i10, p)];
      }
      case "Any": {
        let i10 = I("axis", r8, e8, t8), p = I("keepDims", r8, e8, t8);
        return [o8.any(I("x", r8, e8, t8), i10, p)];
      }
      case "ArgMax": {
        let i10 = I("axis", r8, e8, t8);
        return [o8.argMax(I("x", r8, e8, t8), i10)];
      }
      case "ArgMin": {
        let i10 = I("axis", r8, e8, t8);
        return [o8.argMin(I("x", r8, e8, t8), i10)];
      }
      case "Prod": {
        let i10 = I("axis", r8, e8, t8), p = I("keepDims", r8, e8, t8);
        return [o8.prod(I("x", r8, e8, t8), i10, p)];
      }
      case "Cumprod": {
        let i10 = I("axis", r8, e8, t8), p = I("exclusive", r8, e8, t8), u = I("reverse", r8, e8, t8);
        return [o8.cumprod(I("x", r8, e8, t8), i10, p, u)];
      }
      case "Cumsum": {
        let i10 = I("axis", r8, e8, t8), p = I("exclusive", r8, e8, t8), u = I("reverse", r8, e8, t8);
        return [o8.cumsum(I("x", r8, e8, t8), i10, p, u)];
      }
      case "Bincount":
        let n8 = I("x", r8, e8, t8), s = I("weights", r8, e8, t8), a = I("size", r8, e8, t8);
        return [o8.bincount(n8, s, a)];
      case "DenseBincount": {
        let i10 = I("x", r8, e8, t8), p = I("weights", r8, e8, t8), u = I("size", r8, e8, t8), c = I("binaryOutput", r8, e8, t8);
        return [o8.denseBincount(i10, p, u, c)];
      }
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var AT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "ConcatV2":
      case "Concat": {
        let n8 = I("n", r8, e8, t8), s = I("axis", r8, e8, t8), a = I("tensors", r8, e8, t8);
        return a = a.slice(0, n8), [o8.concat(a, s)];
      }
      case "Gather": {
        let n8 = I("x", r8, e8, t8), s = I("indices", r8, e8, t8);
        return [o8.gather(n8, o8.cast(s, "int32"), 0)];
      }
      case "GatherV2": {
        let n8 = I("axis", r8, e8, t8), s = I("batchDims", r8, e8, t8), a = I("x", r8, e8, t8), i10 = I("indices", r8, e8, t8);
        return [o8.gather(a, o8.cast(i10, "int32"), n8, s)];
      }
      case "Reverse": {
        let n8 = I("dims", r8, e8, t8), s = [];
        for (let i10 = 0; i10 < n8.length; i10++)
          n8[i10] && s.push(i10);
        let a = I("x", r8, e8, t8);
        return [o8.reverse(a, s)];
      }
      case "ReverseV2": {
        let n8 = I("axis", r8, e8, t8), s = I("x", r8, e8, t8);
        return [o8.reverse(s, n8)];
      }
      case "Slice": {
        let n8 = I("begin", r8, e8, t8), s = I("size", r8, e8, t8);
        return [o8.slice(I("x", r8, e8, t8), n8, s)];
      }
      case "StridedSlice": {
        let n8 = I("begin", r8, e8, t8), s = I("end", r8, e8, t8), a = I("strides", r8, e8, t8), i10 = I("beginMask", r8, e8, t8), p = I("endMask", r8, e8, t8), u = I("ellipsisMask", r8, e8, t8), c = I("newAxisMask", r8, e8, t8), l = I("shrinkAxisMask", r8, e8, t8), m = I("x", r8, e8, t8);
        return [o8.stridedSlice(m, n8, s, a, i10, p, u, c, l)];
      }
      case "Pack":
        return De(() => {
          let n8 = I("axis", r8, e8, t8), s = I("tensors", r8, e8, t8), a = s[0].shape, i10 = o8.squeeze(s[0]).shape, p = s.map((u) => {
            let c = y.arraysEqual(u.shape, a);
            if (!c && !y.arraysEqual(o8.squeeze(u).shape, i10))
              throw new Error("the input tensors shape does not match");
            return c ? u : o8.reshape(u, a);
          });
          return [o8.stack(p, n8)];
        });
      case "Unpack": {
        let n8 = I("axis", r8, e8, t8), s = I("tensor", r8, e8, t8);
        return o8.unstack(s, n8);
      }
      case "Tile": {
        let n8 = I("reps", r8, e8, t8);
        return [o8.tile(I("x", r8, e8, t8), n8)];
      }
      case "Split":
      case "SplitV": {
        let n8 = I("axis", r8, e8, t8), s = I("numOrSizeSplits", r8, e8, t8), a = I("x", r8, e8, t8);
        return o8.split(a, s, n8);
      }
      case "ScatterNd": {
        let n8 = I("indices", r8, e8, t8), s = I("values", r8, e8, t8), a = I("shape", r8, e8, t8);
        return [o8.scatterND(n8, s, a)];
      }
      case "GatherNd": {
        let n8 = I("x", r8, e8, t8), s = I("indices", r8, e8, t8);
        return [o8.gatherND(n8, s)];
      }
      case "SparseToDense": {
        let n8 = I("sparseIndices", r8, e8, t8), s = I("outputShape", r8, e8, t8), a = I("sparseValues", r8, e8, t8), i10 = I("defaultValue", r8, e8, t8);
        return [o8.sparseToDense(n8, a, s, a.dtype === i10.dtype ? i10 : o8.cast(i10, a.dtype))];
      }
      case "TensorScatterUpdate": {
        let n8 = I("indices", r8, e8, t8), s = I("values", r8, e8, t8), a = I("tensor", r8, e8, t8);
        return [o8.tensorScatterUpdate(a, n8, s)];
      }
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var FT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "SparseFillEmptyRows": {
        let { outputIndices: n8, outputValues: s, emptyRowIndicator: a, reverseIndexMap: i10 } = o8.sparse.sparseFillEmptyRows(I("indices", r8, e8, t8), I("values", r8, e8, t8), I("denseShape", r8, e8, t8), I("defaultValue", r8, e8, t8));
        return [n8, s, a, i10];
      }
      case "SparseReshape": {
        let { outputIndices: n8, outputShape: s } = o8.sparse.sparseReshape(I("inputIndices", r8, e8, t8), I("inputShape", r8, e8, t8), I("newShape", r8, e8, t8));
        return [n8, s];
      }
      case "SparseSegmentMean":
        return [o8.sparse.sparseSegmentMean(I("data", r8, e8, t8), I("indices", r8, e8, t8), I("segmentIds", r8, e8, t8))];
      case "SparseSegmentSum":
        return [o8.sparse.sparseSegmentSum(I("data", r8, e8, t8), I("indices", r8, e8, t8), I("segmentIds", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var PT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "FFT":
        return [o8.fft(I("x", r8, e8, t8))];
      case "IFFT":
        return [o8.ifft(I("x", r8, e8, t8))];
      case "RFFT":
        return [o8.rfft(I("x", r8, e8, t8))];
      case "IRFFT":
        return [o8.irfft(I("x", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var OT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "StaticRegexReplace":
        return [o8.string.staticRegexReplace(I("input", r8, e8, t8), I("pattern", r8, e8, t8), I("rewrite", r8, e8, t8), I("replaceGlobal", r8, e8, t8))];
      case "StringNGrams": {
        let { nGrams: n8, nGramsSplits: s } = o8.string.stringNGrams(I("data", r8, e8, t8), I("dataSplits", r8, e8, t8), I("separator", r8, e8, t8), I("nGramWidths", r8, e8, t8), I("leftPad", r8, e8, t8), I("rightPad", r8, e8, t8), I("padWidth", r8, e8, t8), I("preserveShortSequences", r8, e8, t8));
        return [n8, s];
      }
      case "StringSplit": {
        let { indices: n8, values: s, shape: a } = o8.string.stringSplit(I("input", r8, e8, t8), I("delimiter", r8, e8, t8), I("skipEmpty", r8, e8, t8));
        return [n8, s, a];
      }
      case "StringToHashBucketFast":
        return [o8.string.stringToHashBucketFast(I("input", r8, e8, t8), I("numBuckets", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  var MT = (r8, e8, t8, o8 = Je) => {
    switch (r8.op) {
      case "Cast":
        return [o8.cast(I("x", r8, e8, t8), I("dtype", r8, e8, t8))];
      case "ExpandDims": {
        let n8 = I("axis", r8, e8, t8);
        return [o8.expandDims(I("x", r8, e8, t8), n8)];
      }
      case "Squeeze": {
        let n8 = I("axis", r8, e8, t8);
        return [o8.squeeze(I("x", r8, e8, t8), n8)];
      }
      case "Reshape":
        return [o8.reshape(I("x", r8, e8, t8), I("shape", r8, e8, t8))];
      case "EnsureShape":
        return [o8.ensureShape(I("x", r8, e8, t8), I("shape", r8, e8, t8))];
      case "MirrorPad":
        return [o8.mirrorPad(I("x", r8, e8, t8), I("padding", r8, e8, t8), I("mode", r8, e8, t8))];
      case "PadV2":
      case "Pad":
        return [o8.pad(I("x", r8, e8, t8), I("padding", r8, e8, t8), I("constantValue", r8, e8, t8))];
      case "SpaceToBatchND": {
        let n8 = I("blockShape", r8, e8, t8), s = I("paddings", r8, e8, t8);
        return [o8.spaceToBatchND(I("x", r8, e8, t8), n8, s)];
      }
      case "BatchToSpaceND": {
        let n8 = I("blockShape", r8, e8, t8), s = I("crops", r8, e8, t8);
        return [o8.batchToSpaceND(I("x", r8, e8, t8), n8, s)];
      }
      case "DepthToSpace": {
        let n8 = I("blockSize", r8, e8, t8), s = I("dataFormat", r8, e8, t8).toUpperCase();
        return [o8.depthToSpace(I("x", r8, e8, t8), n8, s)];
      }
      case "BroadcastTo":
        return [o8.broadcastTo(I("x", r8, e8, t8), I("shape", r8, e8, t8))];
      case "BroadcastArgs":
        return [o8.broadcastArgs(I("s0", r8, e8, t8), I("s1", r8, e8, t8))];
      default:
        throw TypeError(`Node type ${r8.op} is not implemented`);
    }
  };
  function _S(r8, e8, t8, o8, n8 = De) {
    let s = ((a, i10, p) => {
      switch (a.category) {
        case "arithmetic":
          return n8(() => mT(a, i10, p));
        case "basic_math":
          return n8(() => dT(a, i10, p));
        case "control":
          return bT(a, i10, p);
        case "convolution":
          return n8(() => wT(a, i10, p));
        case "creation":
          return n8(() => ST(a, i10, p));
        case "dynamic":
          return IT(a, i10, p);
        case "evaluation":
          return n8(() => vT(a, i10, p));
        case "image":
          return n8(() => TT(a, i10, p));
        case "graph":
          return n8(() => kT(a, i10, p));
        case "logical":
          return n8(() => _T(a, i10, p));
        case "matrices":
          return n8(() => $T(a, i10, p));
        case "normalization":
          return n8(() => ET(a, i10, p));
        case "ragged":
          return n8(() => RT(a, i10, p));
        case "reduction":
          return n8(() => DT(a, i10, p));
        case "slice_join":
          return n8(() => AT(a, i10, p));
        case "sparse":
          return n8(() => FT(a, i10, p));
        case "spectral":
          return n8(() => PT(a, i10, p));
        case "string":
          return n8(() => OT(a, i10, p));
        case "transformation":
          return n8(() => MT(a, i10, p));
        case "hash_table":
          return NT(a, i10, p, o8);
        case "custom":
          let u = af(a.op);
          if (u && u.customExecutor)
            return u.customExecutor(new bf(a, i10, p));
          throw TypeError(`Custom op ${a.op} is not registered.`);
        default:
          throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
      }
    })(r8, e8, t8);
    return y.isPromise(s) ? s.then((a) => [].concat(a)) : [].concat(s);
  }
  var Pl = class {
    constructor(e8 = {}, t8 = {}, o8 = {}, n8 = {}, s) {
      this.weightMap = e8, this.tensorArrayMap = t8, this.tensorListMap = o8, this.functionMap = n8, this.parseNodeNameCache = s, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
    }
    newFrame(e8, t8) {
      return { id: e8, frameName: t8, iterationId: 0 };
    }
    set currentContext(e8) {
      this.contexts !== e8 && (this.contexts = e8, this.generateCurrentContextIds());
    }
    get currentContext() {
      return this.contexts;
    }
    get currentContextId() {
      return this._currentContextIds[0];
    }
    get currentContextIds() {
      return this._currentContextIds;
    }
    generateCurrentContextIds() {
      let e8 = [];
      for (let t8 = 0; t8 < this.contexts.length - 1; t8++) {
        let o8 = this.contexts.slice(0, this.contexts.length - t8);
        e8.push(this.contextIdforContexts(o8));
      }
      e8.push(""), this._currentContextIds = e8;
    }
    contextIdforContexts(e8) {
      return e8 ? e8.map((t8) => t8.id === 0 && t8.iterationId === 0 ? "" : `${t8.frameName}-${t8.iterationId}`).join("/") : "";
    }
    enterFrame(e8) {
      this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e8)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
    }
    exitFrame() {
      if (this.contexts && this.contexts.length > 1)
        this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
      else
        throw new Error("Cannot exit frame, the context is empty");
    }
    nextIteration() {
      if (this.contexts && this.contexts.length > 0) {
        this.contexts = this.contexts.slice(), this.lastId++;
        let e8 = Object.assign({}, this.contexts[this.contexts.length - 1]);
        e8.iterationId += 1, e8.id = this.lastId, this.contexts.splice(-1, 1, e8), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
      } else
        throw new Error("Cannot increase frame iteration, the context is empty");
    }
    getWeight(e8) {
      return this.weightMap[e8];
    }
    addTensorArray(e8) {
      this.tensorArrayMap[e8.id] = e8;
    }
    getTensorArray(e8) {
      return this.tensorArrayMap[e8];
    }
    addTensorList(e8) {
      this.tensorListMap[e8.id] = e8;
    }
    getTensorList(e8) {
      return this.tensorListMap[e8];
    }
    dispose(e8) {
      for (let t8 in this.tensorArrayMap)
        this.tensorArrayMap[t8].clearAndClose(e8);
      for (let t8 in this.tensorListMap)
        this.tensorListMap[t8].clearAndClose(e8);
    }
  };
  function $S(r8, e8, t8, o8) {
    let n8 = /* @__PURE__ */ new Set(), s = [], a = null, i10 = null, p = /* @__PURE__ */ new Set(), u = new Set(Object.keys(r8).map((m) => Tr(m)[0]));
    o8 = o8 || [];
    let c = new Set(o8.map((m) => Tr(m.name)[0])), l = [...e8];
    for (; l.length > 0; ) {
      let m = l.pop();
      if ((fu(m) || l8(m) || m8(m)) && a == null && (a = m, i10 = a.children.map((d) => d.name).filter((d) => n8.has(d))), n8.add(m.name), t8[m.name] == null && !u.has(m.name) && !c.has(m.name)) {
        if (m.inputs.length === 0) {
          s.push(m.name);
          continue;
        }
        m.inputs.forEach((d) => {
          p.has(d.name) || (p.add(d.name), l.push(d));
        });
      }
    }
    return { inputs: r8, outputs: e8, usedNodes: n8, missingInputs: s, dynamicNode: a, syncInputs: i10 };
  }
  function LT(r8, e8) {
    let { usedNodes: t8, inputs: o8 } = e8, n8 = Object.keys(o8).map((g) => Tr(g)[0]).map((g) => r8.nodes[g]), s = r8.initNodes || [], a = (g) => t8.has(typeof g == "string" ? g : g.name);
    function i10(g) {
      return [...new Map(g.map((x) => [x.name, x])).values()];
    }
    let p = i10([...n8, ...r8.weights, ...s]).filter(a), u = i10([...p, ...Object.values(r8.nodes)]).filter(a), c = new Map(u.map((g) => [g.name, g])), l = {};
    for (let g of u) {
      l[g.name] = l[g.name] || 0;
      for (let x of g.children)
        a(x) || (l[x.name] = Number.POSITIVE_INFINITY), l[x.name] = (l[x.name] || 0) + 1;
    }
    let m = Object.entries(l).filter(([, g]) => g === 0).map(([g]) => g), d = [...m];
    for (; m.length > 0; ) {
      let g = m.pop(), x = c.get(g);
      for (let b of x.children.filter(a))
        --l[b.name] === 0 && (d.push(b.name), m.push(b.name));
    }
    let f = d.map((g) => c.get(g)), h = a8(f, p);
    return i8(h, p), h;
  }
  function a8(r8, e8) {
    let t8 = new Map(r8.map((a) => [a.name, a])), o8 = e8.map((a) => a.name), n8 = new Set(o8);
    for (; o8.length > 0; ) {
      let a = o8.pop(), i10 = t8.get(a);
      for (let p of i10.children)
        !t8.has(p.name) || n8.has(p.name) || (n8.add(p.name), o8.push(p.name));
    }
    return r8.filter((a) => n8.has(a.name));
  }
  var gc = class extends Error {
    constructor(e8) {
      super(`NodesExecutionOrderError: ${e8}`);
    }
  };
  function i8(r8, e8) {
    let t8 = new Map(r8.map((i10, p) => [i10.name, p])), o8 = new Set(e8.map((i10) => i10.name)), n8 = (i10) => o8.has(typeof i10 == "string" ? i10 : i10.name), s = new Set(r8.map((i10) => i10.name)), a = (i10) => s.has(typeof i10 == "string" ? i10 : i10.name);
    for (let i10 of r8) {
      for (let p of i10.children.filter(a)) {
        if (!t8.has(p.name))
          throw new gc(`Child ${p.name} of node ${i10.name} is unreachable.`);
        if (t8.get(i10.name) > t8.get(p.name))
          throw new gc(`Node ${i10.name} is scheduled to run after its child ${p.name}.`);
      }
      if (!n8(i10))
        for (let p of i10.inputs) {
          if (!t8.has(p.name))
            throw new gc(`Input ${p.name} of node ${i10.name} is unreachable.`);
          if (t8.get(p.name) > t8.get(i10.name))
            throw new gc(`Node ${i10.name} is scheduled to run before its input ${p.name}.`);
        }
    }
  }
  function BT(r8) {
    let e8 = new Map(r8.map((i10, p) => [i10.name, p])), t8 = Number.MAX_SAFE_INTEGER, o8 = r8.map((i10, p) => fu(i10) ? t8 : p), n8 = (i10) => {
      let p = o8[e8.get(i10.name)];
      return p == null ? -1 : p;
    }, s = r8.map((i10, p) => i10.children.map(n8).reduce((u, c) => Math.max(u, c), o8[p])), a = /* @__PURE__ */ new Map();
    for (let i10 = 0; i10 < r8.length; ++i10) {
      let p = s[i10];
      if (p === t8)
        continue;
      let u = r8[i10], c = r8[p];
      a.has(c.name) || a.set(c.name, []), a.get(c.name).push(u);
    }
    return a;
  }
  var u8 = /* @__PURE__ */ new Set(["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"]);
  var p8 = /* @__PURE__ */ new Set(["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"]);
  var c8 = /* @__PURE__ */ new Set(["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"]);
  function fu(r8) {
    return u8.has(r8.op);
  }
  function l8(r8) {
    return p8.has(r8.op);
  }
  function m8(r8) {
    return c8.has(r8.op);
  }
  var ip = class {
    get weightIds() {
      return this.parent ? this.parent.weightIds : this._weightIds;
    }
    get functionExecutorMap() {
      return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
    }
    get weightMap() {
      return this.parent ? this.parent.weightMap : this._weightMap;
    }
    set weightMap(e8) {
      let t8 = Object.keys(e8).map((o8) => e8[o8].map((n8) => n8.id));
      this._weightIds = [].concat(...t8), this._weightMap = e8;
    }
    set resourceManager(e8) {
      this._resourceManager = e8;
    }
    get inputs() {
      return this._inputs.map((e8) => ({ name: e8.name, shape: e8.attrParams.shape ? e8.attrParams.shape.value : void 0, dtype: e8.attrParams.dtype ? e8.attrParams.dtype.value : void 0 }));
    }
    get outputs() {
      return this._outputs.map((e8) => ({ name: e8.name, shape: e8.attrParams.shape ? e8.attrParams.shape.value : void 0, dtype: e8.attrParams.dtype ? e8.attrParams.dtype.value : void 0 }));
    }
    get inputNodes() {
      return this._inputs.map((e8) => e8.signatureKey || e8.name);
    }
    get outputNodes() {
      return this._outputs.map((e8) => {
        let t8 = e8.signatureKey || e8.name;
        return e8.defaultOutput ? `${t8}:${e8.defaultOutput}` : t8;
      });
    }
    get functions() {
      return Object.keys(this._functions).reduce((e8, t8) => (e8[t8] = this._functions[t8].signature, e8), {});
    }
    constructor(e8, t8) {
      this.graph = e8, this.parent = t8, this.compiledMap = /* @__PURE__ */ new Map(), this.parseNodeNameCache = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPARATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.keepIntermediateTensors = false, this._outputs = e8.outputs, this._inputs = e8.inputs, this._initNodes = e8.initNodes, this._signature = e8.signature, this._functions = e8.functions, e8.functions != null && Object.keys(e8.functions).forEach((o8) => {
        this._functionExecutorMap[o8] = new ip(e8.functions[o8], this);
      });
    }
    getCompilationKey(e8, t8) {
      let o8 = e8.map((s) => s.name).sort(), n8 = t8.map((s) => s.name).sort();
      return o8.join(this.SEPARATOR) + "--" + n8.join(this.SEPARATOR);
    }
    compile(e8, t8) {
      let o8 = $S(e8, t8, this.weightMap, this._initNodes), { missingInputs: n8, dynamicNode: s, syncInputs: a } = o8;
      if (s != null)
        throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);
      if (n8.length > 0) {
        let u = t8.map((l) => l.name), c = Object.keys(e8);
        throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${n8}]`);
      }
      let i10 = LT(this.graph, o8), p = BT(i10);
      return { orderedNodes: i10, nodeLiveUntilMap: p };
    }
    cloneAndKeepTensor(e8) {
      if (e8 == null)
        return null;
      let t8 = e8.clone();
      return Rr(t8), t8;
    }
    cloneTensorList(e8) {
      return e8 ? e8.map((o8) => this.cloneAndKeepTensor(o8)) : null;
    }
    cloneTensorMap(e8) {
      return Object.fromEntries(Object.entries(e8).map(([t8, o8]) => [t8, this.cloneTensorList(o8)]));
    }
    execute(e8, t8) {
      this.disposeIntermediateTensors(), e8 = this.mapInputs(e8);
      let o8 = Object.keys(e8).sort();
      this.checkInputs(e8), this.checkInputShapeAndType(e8), t8 = this.mapOutputs(t8), this.checkOutputs(t8);
      let n8 = o8.map((m) => this.graph.nodes[Tr(m)[0]]), s = t8.map((m) => Tr(m)[0]), a = new Set(s), i10 = s.map((m) => this.graph.nodes[m]);
      i10.length === 0 && (i10 = this._outputs);
      let p = this.getCompilationKey(n8, i10), u = this.compiledMap.get(p);
      u == null && (u = this.compile(e8, i10), this.compiledMap.set(p, u));
      try {
        this.keepIntermediateTensors = A().getBool("KEEP_INTERMEDIATE_TENSORS");
      } catch (m) {
        this.keepIntermediateTensors = false, console.warn(m.message);
      }
      let c = {}, l = {};
      return De(() => {
        let m = new Pl(this.weightMap, c, l, this.functionExecutorMap, this.parseNodeNameCache), d = Object.assign({}, this.weightMap);
        this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), Object.keys(e8).forEach((x) => {
          let [b, C] = Tr(x, m), S = [];
          S[C] = e8[x], d[b] = S, this.keepIntermediateTensors && (this.clonedTensorsMap[b] = this.cloneTensorList(S));
        });
        let f = this.getFrozenTensorIds(d), { orderedNodes: h, nodeLiveUntilMap: g } = u;
        for (let x of h) {
          if (d[x.name])
            continue;
          let b = _S(x, d, m, this._resourceManager);
          if (y.isPromise(b))
            throw new Error(`The execution of the op '${x.op}' returned a promise. Please use model.executeAsync() instead.`);
          d[x.name] = b, this.keepIntermediateTensors && (this.clonedTensorsMap[x.name] = this.cloneTensorList(b)), this.checkTensorForDisposalWithNodeLiveUntilInfo(x, d, m, f, a, g.get(x.name));
        }
        return this.parent == null && m.dispose(f), t8.map((x) => Bt(x, d, m));
      });
    }
    getFrozenTensorIds(e8) {
      let t8 = [].concat.apply([], Object.keys(e8).map((o8) => e8[o8]).map((o8) => o8.map((n8) => n8.id)));
      return new Set(t8);
    }
    checkTensorForDisposal(e8, t8, o8, n8, s, a, i10) {
      if (!(fu(t8) || a.has(e8))) {
        for (let p of o8[e8])
          p != null && (i10[p.id] = (i10[p.id] || 0) + t8.children.length);
        for (let p of t8.inputs) {
          if (fu(p))
            continue;
          let u = aS(p.name, o8, n8);
          if (u != null)
            for (let c of u) {
              if (!c || c.kept || s.has(c.id))
                continue;
              let l = i10[c.id];
              l === 1 ? (c.dispose(), delete i10[c.id]) : l != null && i10[c.id]--;
            }
        }
      }
    }
    checkTensorForDisposalWithNodeLiveUntilInfo(e8, t8, o8, n8, s, a) {
      function i10(p) {
        return fu(p) || s.has(p.name);
      }
      if (!(fu(e8) || a == null))
        for (let p of a) {
          if (i10(p))
            continue;
          let u = aS(p.name, t8, o8);
          for (let c of u)
            !c || c.kept || n8.has(c.id) || c.dispose();
        }
    }
    async executeAsync(e8, t8) {
      return this._executeAsync(e8, t8);
    }
    disposeIntermediateTensors() {
      this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach((e8) => {
        for (let t8 of e8)
          t8 && !t8.isDisposed && t8.dispose();
      }), this.clonedTensorsMap = null);
    }
    getIntermediateTensors() {
      return this.clonedTensorsMap;
    }
    async _executeAsync(e8, t8, o8 = false, n8 = {}, s = {}) {
      this.disposeIntermediateTensors(), o8 || (e8 = this.mapInputs(e8), this.checkInputs(e8), this.checkInputShapeAndType(e8), t8 = this.mapOutputs(t8), this.checkOutputs(t8));
      try {
        this.keepIntermediateTensors = A().getBool("KEEP_INTERMEDIATE_TENSORS");
      } catch (m) {
        this.keepIntermediateTensors = false, console.warn(m.message);
      }
      let a = new Pl(this.weightMap, n8, s, this.functionExecutorMap, this.parseNodeNameCache);
      this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap));
      let i10 = await this.executeWithControlFlow(e8, a, t8, o8), p = t8.map((m) => Bt(m, i10, a)), u = p.map((m) => m.id), c = Object.keys(e8).map((m) => e8[m].id), l = /* @__PURE__ */ new Set([...u, ...c, ...this.weightIds]);
      return Object.values(i10).forEach((m) => {
        m.forEach((d) => {
          d && !d.isDisposed && !l.has(d.id) && d.dispose();
        });
      }), this.parent == null && a.dispose(l), p;
    }
    async executeFunctionAsync(e8, t8, o8) {
      let n8 = e8.reduce((s, a, i10) => (s[this.inputs[i10].name] = a, s), {});
      return this._executeAsync(n8, this.outputNodes, true, t8, o8);
    }
    async executeWithControlFlow(e8, t8, o8, n8) {
      let s = Object.keys(e8), a = s.map((S) => this.graph.nodes[Tr(S)[0]]), i10 = o8.map((S) => Tr(S)[0]), p = new Set(i10), u = i10.map((S) => this.graph.nodes[S]);
      u.length === 0 && (u = this._outputs);
      let { usedNodes: c, missingInputs: l, dynamicNode: m, syncInputs: d } = $S(e8, u, this.weightMap, this._initNodes), f = [...a, ...this.graph.weights, ...this._initNodes || []].map((S) => ({ node: S, contexts: t8.currentContext })), h = Object.assign({}, this.weightMap);
      Object.keys(e8).forEach((S) => {
        let [k, _] = Tr(S), E = [];
        E[_] = e8[S], h[k] = E;
      });
      let g = {}, x = this.getFrozenTensorIds(h), b = {};
      for (; f.length > 0; ) {
        let S = this.processStack(a, f, t8, h, b, x, p, g, c);
        await Promise.all(S);
      }
      m == null && !n8 && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
      let C = u.filter((S) => !fu(S) && !Bt(S.name, h, t8)).map((S) => S.name);
      if (C.length > 0) {
        let S = "";
        throw m != null && (S = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`), new Error(`Cannot compute the outputs [${C}] from the provided inputs [${s}]. Consider providing the following inputs: [${l}]. ${S}`);
      }
      return h;
    }
    processStack(e8, t8, o8, n8, s, a, i10, p, u) {
      let c = [];
      for (; t8.length > 0; ) {
        let l = t8.pop();
        o8.currentContext = l.contexts;
        let m = "";
        if (l.node.op === "Enter" && I("isConstant", l.node, n8, o8) && ([m] = Os(l.node.name, o8)), n8[l.node.name] == null) {
          let d = _S(l.node, n8, o8, this._resourceManager);
          m || ([m] = Os(l.node.name, o8));
          let f = o8.currentContext;
          y.isPromise(d) ? c.push(d.then((h) => (n8[m] = h, this.keepIntermediateTensors && (this.clonedTensorsMap[m] = this.cloneTensorList(h)), o8.currentContext = f, this.checkTensorForDisposal(m, l.node, n8, o8, a, i10, p), this.processChildNodes(l.node, t8, o8, n8, s, u), h))) : (n8[m] = d, this.keepIntermediateTensors && (this.clonedTensorsMap[m] = this.cloneTensorList(d)), this.checkTensorForDisposal(m, l.node, n8, o8, a, i10, p), this.processChildNodes(l.node, t8, o8, n8, s, u));
        } else
          this.processChildNodes(l.node, t8, o8, n8, s, u);
      }
      return c;
    }
    processChildNodes(e8, t8, o8, n8, s, a) {
      e8.children.forEach((i10) => {
        let [p] = Os(i10.name, o8);
        s[p] || !a.has(i10.name) || (i10.op === "Merge" ? i10.inputNames.some((u) => !!Bt(u, n8, o8)) && (s[p] = true, t8.push({ contexts: o8.currentContext, node: i10 })) : i10.inputNames.every((u) => !!Bt(u, n8, o8)) && (s[p] = true, t8.push({ contexts: o8.currentContext, node: i10 })));
      });
    }
    dispose() {
      Object.keys(this.weightMap).forEach((e8) => this.weightMap[e8].forEach((t8) => t8.dispose()));
    }
    checkInputShapeAndType(e8) {
      Object.keys(e8).forEach((t8) => {
        let o8 = e8[t8], [n8] = Tr(t8), s = this.graph.nodes[n8];
        if (s.attrParams.shape && s.attrParams.shape.value) {
          let a = s.attrParams.shape.value, i10 = a.length === o8.shape.length && o8.shape.every((p, u) => a[u] === -1 || a[u] === p);
          y.assert(i10, () => `The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${o8.shape}]`);
        }
        s.attrParams.dtype && s.attrParams.dtype.value && y.assert(o8.dtype === s.attrParams.dtype.value, () => `The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${o8.dtype}`);
      });
    }
    mapInputs(e8) {
      var t8, o8;
      let n8 = {};
      for (let s in e8) {
        let a = (o8 = (t8 = this._signature) === null || t8 === void 0 ? void 0 : t8.inputs) === null || o8 === void 0 ? void 0 : o8[s];
        a != null ? n8[a.name] = e8[s] : n8[s] = e8[s];
      }
      return n8;
    }
    checkInputs(e8) {
      let t8 = Object.keys(e8).filter((o8) => {
        let [n8] = Tr(o8);
        return this.graph.nodes[n8] == null;
      });
      if (t8.length > 0)
        throw new Error(`The dict provided in model.execute(dict) has keys: [${t8}] that are not part of graph`);
    }
    mapOutputs(e8) {
      return e8.map((t8) => {
        var o8, n8;
        let s = (n8 = (o8 = this._signature) === null || o8 === void 0 ? void 0 : o8.outputs) === null || n8 === void 0 ? void 0 : n8[t8];
        return s != null ? s.name : t8;
      }, {});
    }
    checkOutputs(e8) {
      e8.forEach((t8) => {
        let [o8] = Tr(t8);
        if (!this.graph.nodes[o8])
          throw new Error(`The output '${t8}' is not found in the graph`);
      });
    }
  };
  var If = class {
    constructor(e8 = {}, t8 = {}) {
      this.hashTableNameToHandle = e8, this.hashTableMap = t8;
    }
    addHashTable(e8, t8) {
      this.hashTableNameToHandle[e8] = t8.handle, this.hashTableMap[t8.id] = t8;
    }
    getHashTableHandleByName(e8) {
      return this.hashTableNameToHandle[e8];
    }
    getHashTableById(e8) {
      return this.hashTableMap[e8];
    }
    dispose() {
      for (let e8 in this.hashTableMap)
        this.hashTableMap[e8].clearAndClose(), delete this.hashTableMap[e8];
      for (let e8 in this.hashTableNameToHandle)
        this.hashTableNameToHandle[e8].dispose(), delete this.hashTableNameToHandle[e8];
    }
  };
  var d8 = "?tfjs-format=file";
  var f8 = "model.json";
  var Ol = class {
    get modelVersion() {
      return this.version;
    }
    get inputNodes() {
      return this.executor.inputNodes;
    }
    get outputNodes() {
      return this.executor.outputNodes;
    }
    get inputs() {
      return this.executor.inputs;
    }
    get outputs() {
      return this.executor.outputs;
    }
    get weights() {
      return this.executor.weightMap;
    }
    get metadata() {
      return this.artifacts.userDefinedMetadata;
    }
    get modelSignature() {
      return this.signature;
    }
    get modelStructuredOutputKeys() {
      return this.structuredOutputKeys;
    }
    constructor(e8, t8 = {}, o8 = mi) {
      this.modelUrl = e8, this.loadOptions = t8, this.version = "n/a", this.io = o8, t8 == null && (this.loadOptions = {}), this.resourceManager = new If();
    }
    findIOHandler() {
      let e8 = this.modelUrl;
      if (e8.load != null)
        this.handler = e8;
      else if (this.loadOptions.requestInit != null)
        this.handler = this.io.browserHTTPRequest(e8, this.loadOptions);
      else {
        let t8 = this.io.getLoadHandlers(e8, this.loadOptions);
        if (t8.length === 0)
          t8.push(this.io.browserHTTPRequest(e8, this.loadOptions));
        else if (t8.length > 1)
          throw new Error(`Found more than one (${t8.length}) load handlers for URL '${[e8]}'`);
        this.handler = t8[0];
      }
    }
    load() {
      if (this.findIOHandler(), this.handler.load == null)
        throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
      let e8 = this.handler.load();
      return y.isPromise(e8) ? e8.then((t8) => this.loadSync(t8)) : this.loadSync(e8);
    }
    loadSync(e8) {
      this.artifacts = e8;
      let t8 = this.artifacts.modelTopology, o8 = this.artifacts.signature;
      if (this.artifacts.userDefinedMetadata != null) {
        let s = this.artifacts.userDefinedMetadata;
        s.signature != null && (o8 = s.signature), s.structuredOutputKeys != null && (this.structuredOutputKeys = s.structuredOutputKeys);
      }
      this.signature = o8, this.version = `${t8.versions.producer}.${t8.versions.minConsumer}`;
      let n8 = this.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
      if (this.executor = new ip(Fl.Instance.transformGraph(t8, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(n8), this.executor.resourceManager = this.resourceManager, e8.modelInitializer != null && e8.modelInitializer.node != null) {
        let s = Fl.Instance.transformGraph(e8.modelInitializer);
        this.initializer = new ip(s), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e8.initializerSignature;
      }
      return true;
    }
    async save(e8, t8) {
      if (typeof e8 == "string") {
        let o8 = this.io.getSaveHandlers(e8);
        if (o8.length === 0)
          throw new Error(`Cannot find any save handlers for URL '${e8}'`);
        if (o8.length > 1)
          throw new Error(`Found more than one (${o8.length}) save handlers for URL '${e8}'`);
        e8 = o8[0];
      }
      if (e8.save == null)
        throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      return e8.save(this.artifacts);
    }
    addStructuredOutputNames(e8) {
      if (this.structuredOutputKeys) {
        let t8 = e8 instanceof ut ? [e8] : e8, o8 = {};
        return t8.forEach((n8, s) => o8[this.structuredOutputKeys[s]] = n8), o8;
      }
      return e8;
    }
    predict(e8, t8) {
      let o8 = this.execute(e8, this.outputNodes);
      return this.addStructuredOutputNames(o8);
    }
    async predictAsync(e8, t8) {
      let o8 = await this.executeAsync(e8, this.outputNodes);
      return this.addStructuredOutputNames(o8);
    }
    normalizeInputs(e8) {
      var t8;
      if (!(e8 instanceof ut) && !Array.isArray(e8)) {
        let s = (t8 = this.signature) === null || t8 === void 0 ? void 0 : t8.inputs;
        if (s != null)
          for (let a in s) {
            let i10 = s[a];
            i10.resourceId != null && (e8[a] = this.resourceIdToCapturedInput[i10.resourceId]);
          }
        return e8;
      }
      e8 = Array.isArray(e8) ? e8 : [e8];
      let o8 = Object.keys(this.resourceIdToCapturedInput).length;
      if (e8.length + o8 !== this.inputNodes.length)
        throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - o8} non-resource placeholders, while there are ${e8.length} input tensors provided.`);
      let n8 = 0;
      return this.inputNodes.reduce((s, a) => {
        var i10, p, u;
        let c = (u = (p = (i10 = this.signature) === null || i10 === void 0 ? void 0 : i10.inputs) === null || p === void 0 ? void 0 : p[a]) === null || u === void 0 ? void 0 : u.resourceId;
        return c != null ? s[a] = this.resourceIdToCapturedInput[c] : s[a] = e8[n8++], s;
      }, {});
    }
    normalizeOutputs(e8) {
      return e8 = e8 || this.outputNodes, Array.isArray(e8) ? e8 : [e8];
    }
    executeInitializerGraph() {
      return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.execute({}, []) : this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
    }
    async executeInitializerGraphAsync() {
      return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.executeAsync({}, []) : this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
    }
    setResourceIdToCapturedInput(e8) {
      if (this.resourceIdToCapturedInput = {}, this.initializerSignature) {
        let t8 = this.initializerSignature.outputs, o8 = Object.keys(t8);
        for (let n8 = 0; n8 < o8.length; n8++) {
          let s = o8[n8], a = t8[s];
          this.resourceIdToCapturedInput[a.resourceId] = e8[n8];
        }
      }
    }
    execute(e8, t8) {
      this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), e8 = this.normalizeInputs(e8), t8 = this.normalizeOutputs(t8);
      let o8 = this.executor.execute(e8, t8);
      return o8.length > 1 ? o8 : o8[0];
    }
    async executeAsync(e8, t8) {
      this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()), e8 = this.normalizeInputs(e8), t8 = this.normalizeOutputs(t8);
      let o8 = await this.executor.executeAsync(e8, t8);
      return o8.length > 1 ? o8 : o8[0];
    }
    getIntermediateTensors() {
      return this.executor.getIntermediateTensors();
    }
    disposeIntermediateTensors() {
      this.executor.disposeIntermediateTensors();
    }
    convertTensorMapToTensorsMap(e8) {
      return Object.keys(e8).reduce((t8, o8) => (t8[o8] = [e8[o8]], t8), {});
    }
    dispose() {
      this.executor.dispose(), this.initializer && (this.initializer.dispose(), this.resourceIdToCapturedInput && Ot(this.resourceIdToCapturedInput)), this.resourceManager.dispose();
    }
  };
  async function h8(r8, e8 = {}, t8 = mi) {
    if (r8 == null)
      throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
    e8 == null && (e8 = {}), e8.fromTFHub && typeof r8 == "string" && (r8 = x8(r8));
    let o8 = new Ol(r8, e8, t8);
    return await o8.load(), o8;
  }
  function g8(r8) {
    if (r8 == null)
      throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");
    let e8;
    if (r8 instanceof Array) {
      let [o8, n8] = r8;
      if (!o8)
        throw new Error("modelJSON must be the first element of the array");
      if (!n8 || !(n8 instanceof ArrayBuffer))
        throw new Error("An ArrayBuffer of weights must be the second element of the array");
      if (!("modelTopology" in o8))
        throw new Error("Model JSON is missing 'modelTopology'");
      if (!("weightsManifest" in o8))
        throw new Error("Model JSON is missing 'weightsManifest'");
      let s = mi.getWeightSpecs(o8.weightsManifest), a = mi.getModelArtifactsForJSONSync(o8, s, n8);
      e8 = mi.fromMemorySync(a);
    } else if ("load" in r8)
      e8 = r8;
    else if ("modelTopology" in r8 && "weightSpecs" in r8 && "weightData" in r8)
      e8 = mi.fromMemorySync(r8);
    else
      throw new Error("Unknown model format");
    let t8 = new Ol(e8);
    return t8.load(), t8;
  }
  function x8(r8) {
    return r8.endsWith("/") || (r8 = r8 + "/"), `${r8}${f8}${d8}`;
  }
  var y8 = "4.7.0";
  function Q(r8, e8) {
    Array.isArray(r8) || (r8 = [r8]), r8.forEach((t8) => {
      t8 != null && y.assert(t8.dtype !== "complex64", () => `${e8} does not support complex64 tensors in the CPU backend.`);
    });
  }
  var b8 = Wt.whereImpl;
  var hu = class extends so {
    nextDataId() {
      return hu.nextDataId++;
    }
    constructor() {
      super(), this.blockSize = 48, this.firstUse = true, this.data = new Bo(this, ur());
    }
    write(e8, t8, o8) {
      this.firstUse && (this.firstUse = false, A().get("IS_NODE") && w.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
      let n8 = { id: this.nextDataId() };
      return this.data.set(n8, { values: e8, dtype: o8, refCount: 1 }), n8;
    }
    makeTensorInfo(e8, t8, o8) {
      let n8;
      if (t8 === "string" && o8 != null && o8.length > 0 && y.isString(o8[0])) {
        let s = o8.map((a) => y.encodeString(a));
        n8 = this.write(s, e8, t8);
      } else
        n8 = this.write(o8, e8, t8);
      return { dataId: n8, shape: e8, dtype: t8 };
    }
    refCount(e8) {
      return this.data.has(e8) ? this.data.get(e8).refCount : 0;
    }
    incRef(e8) {
      let t8 = this.data.get(e8);
      t8.refCount++;
    }
    decRef(e8) {
      if (this.data.has(e8)) {
        let t8 = this.data.get(e8);
        t8.refCount--;
      }
    }
    move(e8, t8, o8, n8, s) {
      this.data.set(e8, { values: t8, dtype: n8, refCount: s });
    }
    numDataIds() {
      return this.data.numDataIds();
    }
    async read(e8) {
      return this.readSync(e8);
    }
    readSync(e8) {
      let { dtype: t8, complexTensorInfos: o8 } = this.data.get(e8);
      if (t8 === "complex64") {
        let n8 = this.readSync(o8.real.dataId), s = this.readSync(o8.imag.dataId);
        return w.mergeRealAndImagArrays(n8, s);
      }
      return y.convertBackendValuesAndArrayBuffer(this.data.get(e8).values, t8);
    }
    bufferSync(e8) {
      let t8 = this.readSync(e8.dataId);
      if (e8.dtype === "string")
        try {
          let o8 = t8.map((n8) => y.decodeString(n8));
          return me(e8.shape, e8.dtype, o8);
        } catch (o8) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      return me(e8.shape, e8.dtype, t8);
    }
    makeOutput(e8, t8, o8) {
      return ur().makeTensorFromTensorInfo(this.makeTensorInfo(t8, o8, e8), this);
    }
    disposeData(e8, t8 = false) {
      if (this.data.has(e8)) {
        if (this.data.get(e8).refCount--, !t8 && this.data.get(e8).refCount > 0)
          return false;
        let { complexTensorInfos: o8 } = this.data.get(e8);
        o8 != null && (this.disposeData(o8.real.dataId, true), this.disposeData(o8.imag.dataId, true)), this.data.delete(e8);
      }
      return true;
    }
    disposeIntermediateTensorInfo(e8) {
      this.disposeData(e8.dataId);
    }
    async time(e8) {
      let t8 = y.now();
      return e8(), { kernelMs: y.now() - t8 };
    }
    memory() {
      return { unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
    }
    where(e8) {
      Q([e8], "where");
      let t8 = this.readSync(e8.dataId);
      return b8(e8.shape, t8);
    }
    dispose() {
    }
    floatPrecision() {
      return 32;
    }
    epsilon() {
      return super.epsilon();
    }
  };
  hu.nextDataId = 0;
  var Ic = {};
  Ke(Ic, { addImpl: () => DS, bincountImpl: () => bc, bincountReduceImpl: () => vf, bitwiseAndImpl: () => AS, castImpl: () => RS, ceilImpl: () => FS, concatImpl: () => up, equalImpl: () => PS, expImpl: () => MS, expm1Impl: () => BS, floorDivImpl: () => VS, floorImpl: () => zS, gatherNdImpl: () => kf, gatherV2Impl: () => Nf, greaterEqualImpl: () => US, greaterImpl: () => WS, lessEqualImpl: () => HS, lessImpl: () => GS, linSpaceImpl: () => Tf, logImpl: () => KS, maxImpl: () => _f, maximumImpl: () => qS, minimumImpl: () => jS, multiplyImpl: () => Ml, negImpl: () => XS, notEqualImpl: () => YS, prodImpl: () => QS, raggedGatherImpl: () => $f, raggedRangeImpl: () => Ef, raggedTensorToTensorImpl: () => Rf, rangeImpl: () => cp, rsqrtImpl: () => ZS, scatterImpl: () => Ls, sigmoidImpl: () => g_, simpleAbsImpl: () => ES, sliceImpl: () => lp, sparseFillEmptyRowsImpl: () => Df, sparseReshapeImpl: () => Af, sparseSegmentReductionImpl: () => Sc, sqrtImpl: () => b_, squaredDifferenceImpl: () => eI, staticRegexReplaceImpl: () => tI, stridedSliceImpl: () => Ff, stringNGramsImpl: () => mp, stringSplitImpl: () => dp, stringToHashBucketFastImpl: () => fp, subImpl: () => oI, tileImpl: () => Pf, topKImpl: () => Of, transposeImpl: () => Cc, uniqueImpl: () => hp });
  function ES(r8) {
    let e8 = new Float32Array(r8.length);
    for (let t8 = 0; t8 < r8.length; ++t8)
      e8[t8] = Math.abs(r8[t8]);
    return e8;
  }
  var C8 = (r8) => {
    let { x: e8 } = r8.inputs, t8 = r8.backend;
    Q(e8, "abs");
    let o8 = new Float32Array(y.sizeFromShape(e8.shape)), n8 = t8.data.get(e8.dataId).values;
    return o8 = ES(n8), t8.makeOutput(o8, e8.shape, e8.dtype);
  };
  var zT = { kernelName: js, backendName: "cpu", kernelFunc: C8 };
  function ze(r8) {
    return (e8, t8, o8, n8, s) => {
      let a = w.assertAndGetBroadcastShape(e8, t8), i10 = a.length, p = y.computeStrides(a), u = y.sizeFromShape(a), c = y.getTypedArrayFromDType(s, u), l = e8.length, m = t8.length, d = y.computeStrides(e8), f = y.computeStrides(t8), h = w.getBroadcastDims(e8, a), g = w.getBroadcastDims(t8, a);
      if (h.length + g.length === 0)
        for (let x = 0; x < c.length; ++x)
          c[x] = r8(o8[x % o8.length], n8[x % n8.length]);
      else
        for (let x = 0; x < c.length; ++x) {
          let b = y.indexToLoc(x, i10, p), C = b.slice(-l);
          h.forEach((E) => C[E] = 0);
          let S = y.locToIndex(C, l, d), k = b.slice(-m);
          g.forEach((E) => k[E] = 0);
          let _ = y.locToIndex(k, m, f);
          c[x] = r8(o8[S], n8[_]);
        }
      return [c, a];
    };
  }
  function Kt(r8) {
    let { inputs: e8, backend: t8 } = r8, { real: o8, imag: n8 } = e8, s = t8.data.get(o8.dataId).values, a = t8.data.get(n8.dataId).values, i10 = t8.makeTensorInfo(o8.shape, "complex64"), p = t8.data.get(i10.dataId);
    return p.complexTensorInfos = { real: t8.makeTensorInfo(o8.shape, "float32", s), imag: t8.makeTensorInfo(n8.shape, "float32", a) }, i10;
  }
  var VT = { kernelName: Ri, backendName: "cpu", kernelFunc: Kt };
  function xc(r8, e8, t8 = "float32") {
    if (t8 === "complex64") {
      let n8 = xc(r8, e8, "float32"), s = xc(r8, e8, "float32");
      return Kt({ inputs: { real: n8, imag: s }, backend: r8 });
    }
    let o8 = y.makeZerosTypedArray(y.sizeFromShape(e8), t8);
    return r8.makeTensorInfo(e8, t8, o8);
  }
  function lr(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    return t8.incRef(o8.dataId), { dataId: o8.dataId, shape: o8.shape, dtype: o8.dtype };
  }
  var WT = { kernelName: Co, backendName: "cpu", kernelFunc: lr };
  function Eo(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = t8.data.get(o8.dataId).complexTensorInfos.real, s = t8.data.get(n8.dataId).values;
    return t8.makeTensorInfo(n8.shape, n8.dtype, s);
  }
  var UT = { kernelName: Gi, backendName: "cpu", kernelFunc: Eo };
  function RS(r8, e8, t8, o8) {
    if (o8 === "int32") {
      let n8 = Int32Array.from(r8);
      return [e8, "int32", n8];
    }
    if (o8 === "bool") {
      let n8 = y.toTypedArray([0], t8), [s, a] = ze((i10, p) => i10 !== p ? 1 : 0)(e8, [], r8, n8, "bool");
      return [a, "bool", s];
    }
    throw new Error(`Error in Cast: failed to cast ${t8} to ${o8}`);
  }
  function Ro(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { dtype: s } = o8;
    if (s === "complex64") {
      if (n8.dtype === "complex64")
        return lr({ inputs: { x: n8 }, backend: t8 });
      let c = xc(t8, n8.shape, n8.dtype), l = Ro({ inputs: { x: n8 }, backend: t8, attrs: { dtype: "float32" } }), m = Kt({ inputs: { real: l, imag: c }, backend: t8 });
      return t8.disposeIntermediateTensorInfo(c), t8.disposeIntermediateTensorInfo(l), m;
    }
    if (n8.dtype === "complex64") {
      let c = Eo({ inputs: { input: n8 }, backend: t8 }), l = Ro({ inputs: { x: c }, backend: t8, attrs: { dtype: s } });
      return t8.disposeIntermediateTensorInfo(c), l;
    }
    if (!y.hasEncodingLoss(n8.dtype, s)) {
      let c = lr({ inputs: { x: n8 }, backend: t8 });
      return { dataId: c.dataId, shape: c.shape, dtype: s };
    }
    let a = t8.data.get(n8.dataId).values, [i10, p, u] = RS(a, n8.shape, n8.dtype, s);
    return t8.makeTensorInfo(i10, p, u);
  }
  var GT = { kernelName: yo, backendName: "cpu", kernelFunc: Ro };
  function Ye(r8, e8, t8, o8) {
    return t8 == null ? ({ inputs: n8, backend: s }) => {
      let { a, b: i10 } = n8, p = s;
      Q([a, i10], r8);
      let u = p.data.get(a.dataId).values, c = p.data.get(i10.dataId).values, l = a.dtype === "string" ? w.fromUint8ToStringArray(u) : u, m = a.dtype === "string" ? w.fromUint8ToStringArray(c) : c, d = o8 || a.dtype, [f, h] = e8(a.shape, i10.shape, l, m, d);
      return p.makeTensorInfo(h, d, f);
    } : ({ inputs: n8, backend: s }) => {
      let { a, b: i10 } = n8, p = s;
      if (a.dtype === "complex64" || i10.dtype === "complex64") {
        let u = Ro({ inputs: { x: a }, backend: p, attrs: { dtype: "complex64" } }), c = p.data.get(u.dataId), l = c.complexTensorInfos.real, m = c.complexTensorInfos.imag, d = p.data.get(l.dataId).values, f = p.data.get(m.dataId).values, h = Ro({ inputs: { x: i10 }, backend: p, attrs: { dtype: "complex64" } }), g = p.data.get(h.dataId), x = g.complexTensorInfos.real, b = g.complexTensorInfos.imag, C = p.data.get(x.dataId).values, S = p.data.get(b.dataId).values, [k, _, E] = t8(a.shape, i10.shape, d, f, C, S), R = p.makeTensorInfo(E, "float32", k), D = p.makeTensorInfo(E, "float32", _), P = Kt({ inputs: { real: R, imag: D }, backend: p });
        return p.disposeIntermediateTensorInfo(u), p.disposeIntermediateTensorInfo(h), p.disposeIntermediateTensorInfo(R), p.disposeIntermediateTensorInfo(D), P;
      } else {
        let u = p.data.get(a.dataId).values, c = p.data.get(i10.dataId).values, l = o8 || a.dtype, [m, d] = e8(a.shape, i10.shape, u, c, l);
        return p.makeTensorInfo(d, l, m);
      }
    };
  }
  function yc(r8) {
    return (e8, t8, o8, n8, s, a) => {
      let i10 = w.assertAndGetBroadcastShape(e8, t8), p = y.sizeFromShape(i10), u = i10.length, c = y.computeStrides(i10), l = y.getTypedArrayFromDType("float32", p), m = y.getTypedArrayFromDType("float32", p), d = w.getBroadcastDims(e8, i10), f = w.getBroadcastDims(t8, i10), h = w.mergeRealAndImagArrays(o8, n8), g = w.mergeRealAndImagArrays(s, a), x = e8.length, b = y.computeStrides(e8), C = t8.length, S = y.computeStrides(t8);
      if (d.length + f.length === 0)
        for (let k = 0; k < l.length; k++) {
          let _ = k % h.length, E = k % g.length, R = r8(h[_ * 2], h[_ * 2 + 1], g[E * 2], g[E * 2 + 1]);
          l[k] = R.real, m[k] = R.imag;
        }
      else
        for (let k = 0; k < l.length; k++) {
          let _ = y.indexToLoc(k, u, c), E = _.slice(-x);
          d.forEach((M) => E[M] = 0);
          let R = y.locToIndex(E, x, b), D = _.slice(-C);
          f.forEach((M) => D[M] = 0);
          let P = y.locToIndex(D, C, S), O = r8(h[R * 2], h[R * 2 + 1], g[P * 2], g[P * 2 + 1]);
          l[k] = O.real, m[k] = O.imag;
        }
      return [l, m, i10];
    };
  }
  var DS = ze((r8, e8) => r8 + e8);
  var w8 = yc((r8, e8, t8, o8) => ({ real: r8 + t8, imag: e8 + o8 }));
  var Aa = Ye(io, DS, w8);
  var HT = { kernelName: io, backendName: "cpu", kernelFunc: Aa };
  function bc(r8, e8, t8, o8, n8) {
    let s = y.sizeFromShape(o8), a = y.makeZerosTypedArray(n8, t8);
    for (let i10 = 0; i10 < r8.length; i10++) {
      let p = r8[i10];
      if (p < 0)
        throw new Error("Input x must be non-negative!");
      p >= n8 || (s > 0 ? a[p] += e8[i10] : a[p] += 1);
    }
    return a;
  }
  function vf(r8, e8, t8, o8 = false) {
    let n8 = r8.shape[0], s = r8.shape[1], a = me([n8, t8], e8.dtype);
    for (let i10 = 0; i10 < n8; i10++)
      for (let p = 0; p < s; p++) {
        let u = r8.get(i10, p);
        if (u < 0)
          throw new Error("Input x must be non-negative!");
        u >= t8 || (o8 ? a.set(1, i10, u) : e8.size > 0 ? a.set(a.get(i10, u) + e8.get(i10, p), i10, u) : a.set(a.get(i10, u) + 1, i10, u));
      }
    return a;
  }
  var AS = ze((r8, e8) => r8 & e8);
  var S8 = Ye(Ha, AS);
  var KT = { kernelName: Ha, backendName: "cpu", kernelFunc: S8 };
  function Xt(r8) {
    return (e8, t8, o8) => {
      let n8 = y.getArrayFromDType(t8, e8.length);
      for (let s = 0; s < e8.length; ++s)
        n8[s] = r8(e8[s], o8);
      return n8;
    };
  }
  function Ie(r8, e8, t8) {
    let o8 = Xt(e8);
    return Ar(r8, o8, t8);
  }
  function Ar(r8, e8, t8) {
    return ({ inputs: o8, attrs: n8, backend: s }) => {
      let { x: a } = o8;
      Q(a, r8);
      let i10 = s, p = i10.data.get(a.dataId).values, u;
      if (a.dtype === "string") {
        if (!Array.isArray(p))
          throw new Error("String tensor's value was not an instance of Array");
        u = w.fromUint8ToStringArray(p);
      } else
        u = p;
      let c = t8 || a.dtype, l = e8(u, c, n8);
      return i10.makeTensorInfo(a.shape, c, l);
    };
  }
  var FS = Xt((r8) => Math.ceil(r8));
  var I8 = Ar(en, FS);
  var qT = { kernelName: en, backendName: "cpu", kernelFunc: I8 };
  function up(r8, e8, t8, o8) {
    let n8 = y.getArrayFromDType(t8, y.sizeFromShape(e8));
    if (o8 && t8 !== "string") {
      let s = 0;
      r8.forEach((a) => {
        let i10 = y.sizeFromShape(a.shape);
        n8.set(a.vals, s), s += i10;
      });
    } else {
      let s = 0;
      r8.forEach((a) => {
        let i10 = t8 === "string" ? w.fromUint8ToStringArray(a.vals) : a.vals, p = 0;
        for (let u = 0; u < a.shape[0]; ++u) {
          let c = u * e8[1] + s;
          for (let l = 0; l < a.shape[1]; ++l)
            n8[c + l] = i10[p++];
        }
        s += a.shape[1];
      });
    }
    return n8;
  }
  var PS = ze((r8, e8) => r8 === e8 ? 1 : 0);
  var OS = Ye(xn, PS, null, "bool");
  var jT = { kernelName: xn, backendName: "cpu", kernelFunc: OS };
  var MS = Xt((r8) => Math.exp(r8));
  var LS = Ar(yn, MS, "float32");
  var XT = { kernelName: yn, backendName: "cpu", kernelFunc: LS };
  var BS = Xt((r8) => Math.expm1(r8));
  var v8 = Ar(bn, BS);
  var YT = { kernelName: bn, backendName: "cpu", kernelFunc: v8 };
  var zS = Xt((r8) => Math.floor(r8));
  var k8 = Ar(wn, zS);
  var QT = { kernelName: wn, backendName: "cpu", kernelFunc: k8 };
  var VS = ze((r8, e8) => Math.floor(r8 / e8));
  var N8 = Ye(Sn, VS, null, "int32");
  var ZT = { kernelName: Sn, backendName: "cpu", kernelFunc: N8 };
  function kf(r8, e8, t8, o8, n8, s, a, i10, p) {
    let u = me([o8, s], t8);
    for (let c = 0; c < o8; c++) {
      let l = [], m = 0;
      for (let d = 0; d < n8; d++) {
        let f = r8[c * n8 + d];
        m += f * a[d], l.push(f);
      }
      if (m < 0 || m >= p / s)
        throw new Error(`Invalid indices: ${l} does not index into ${i10}`);
      for (let d = 0; d < s; d++)
        u.values[c * s + d] = e8.get(...e8.indexToLoc(m * s + d));
    }
    return u;
  }
  function Nf(r8, e8, t8) {
    let o8 = me(t8, r8.dtype);
    for (let n8 = 0; n8 < o8.size; ++n8) {
      let a = o8.indexToLoc(n8).slice(), i10 = a[0], p = a[2], u = e8.locToIndex([i10, p]);
      a[2] = e8.values[u];
      let c = r8.locToIndex(a);
      0 <= c && c < r8.values.length && (o8.values[n8] = r8.values[c]);
    }
    return o8;
  }
  var WS = ze((r8, e8) => r8 > e8 ? 1 : 0);
  var T8 = Ye(kn, WS, null, "bool");
  var JT = { kernelName: kn, backendName: "cpu", kernelFunc: T8 };
  var US = ze((r8, e8) => r8 >= e8 ? 1 : 0);
  var _8 = Ye(Nn, US, null, "bool");
  var e_ = { kernelName: Nn, backendName: "cpu", kernelFunc: _8 };
  var GS = ze((r8, e8) => r8 < e8 ? 1 : 0);
  var $8 = Ye(Rn, GS, null, "bool");
  var t_ = { kernelName: Rn, backendName: "cpu", kernelFunc: $8 };
  var HS = ze((r8, e8) => r8 <= e8 ? 1 : 0);
  var E8 = Ye(Dn, HS, null, "bool");
  var r_ = { kernelName: Dn, backendName: "cpu", kernelFunc: E8 };
  function Tf(r8, e8, t8) {
    let o8 = (e8 - r8) / (t8 - 1), n8 = y.makeZerosTypedArray(t8, "float32");
    n8[0] = r8;
    for (let s = 1; s < n8.length; s++)
      n8[s] = n8[s - 1] + o8;
    return n8;
  }
  var KS = Xt((r8) => Math.log(r8));
  var R8 = Ar(Fn, KS);
  var o_ = { kernelName: Fn, backendName: "cpu", kernelFunc: R8 };
  function _f(r8, e8, t8, o8) {
    let n8 = y.getTypedArrayFromDType(o8, y.sizeFromShape(t8));
    for (let s = 0; s < n8.length; ++s) {
      let a = s * e8, i10 = r8[a];
      for (let p = 0; p < e8; ++p) {
        let u = r8[a + p];
        (Number.isNaN(u) || u > i10) && (i10 = u);
      }
      n8[s] = i10;
    }
    return n8;
  }
  var qS = ze((r8, e8) => Math.max(r8, e8));
  var D8 = Ye(Vn, qS);
  var n_ = { kernelName: Vn, backendName: "cpu", kernelFunc: D8 };
  var jS = ze((r8, e8) => Math.min(r8, e8));
  var A8 = Ye(Hn, jS);
  var s_ = { kernelName: Hn, backendName: "cpu", kernelFunc: A8 };
  var Ml = ze((r8, e8) => r8 * e8);
  var F8 = yc((r8, e8, t8, o8) => ({ real: r8 * t8 - e8 * o8, imag: r8 * o8 + e8 * t8 }));
  var pp = Ye(Xn, Ml, F8);
  var a_ = { kernelName: Xn, backendName: "cpu", kernelFunc: pp };
  function XS(r8, e8, t8) {
    let o8 = y.createScalarValue(-1, t8);
    return Ml([], e8, o8, r8, t8);
  }
  function P8(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    Q(o8, "neg");
    let n8 = t8.data.get(o8.dataId).values, [s, a] = XS(n8, o8.shape, o8.dtype);
    return t8.makeTensorInfo(a, o8.dtype, s);
  }
  var i_ = { kernelName: ua, backendName: "cpu", kernelFunc: P8 };
  var YS = ze((r8, e8) => r8 !== e8 ? 1 : 0);
  var O8 = Ye(Yn, YS, null, "bool");
  var u_ = { kernelName: Yn, backendName: "cpu", kernelFunc: O8 };
  function Cc(r8, e8, t8, o8, n8) {
    let s = e8.length, a = y.sizeFromShape(e8), i10 = y.computeStrides(e8), p = y.computeStrides(n8), u = y.getTypedArrayFromDType(t8, y.sizeFromShape(n8));
    for (let c = 0; c < a; ++c) {
      let l = y.indexToLoc(c, s, i10), m = new Array(l.length);
      for (let f = 0; f < m.length; f++)
        m[f] = l[o8[f]];
      let d = y.locToIndex(m, s, p);
      u[d] = r8[c];
    }
    return u;
  }
  function It(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { x: n8 } = e8, { perm: s } = t8;
    Q(n8, "transpose");
    let a = n8.shape.length, i10 = new Array(a);
    for (let l = 0; l < i10.length; l++)
      i10[l] = n8.shape[s[l]];
    let p = o8.data.get(n8.dataId).values, u = Cc(p, n8.shape, n8.dtype, s, i10);
    return { dataId: o8.write(u, i10, n8.dtype), shape: i10, dtype: n8.dtype };
  }
  var p_ = { kernelName: po, backendName: "cpu", kernelFunc: It };
  function QS(r8, e8, t8, o8) {
    let [n8, s] = w.computeOutAndReduceShapes(r8, o8), a = dt(e8, "int32"), i10 = y.makeZerosTypedArray(y.sizeFromShape(n8), a), p = y.sizeFromShape(s);
    for (let u = 0; u < i10.length; ++u) {
      let c = u * p, l = 1;
      for (let m = 0; m < p; ++m)
        l *= t8[c + m];
      i10[u] = l;
    }
    return { outVals: i10, outShape: n8, outDtype: a };
  }
  function M8(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    Q(n8, "prod");
    let i10 = n8.shape.length, p = y.parseAxisParam(s, n8.shape), u = w.getAxesPermutation(p, i10), c = p, l = n8, m = [];
    u != null && (l = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: u } }), m.push(l), c = w.getInnerMostAxes(c.length, i10));
    let d = t8.data.get(l.dataId).values, { outVals: f, outShape: h, outDtype: g } = QS(l.shape, l.dtype, d, c), x = h;
    return a && (x = w.expandShapeToKeepDim(h, p)), m.forEach((b) => t8.disposeIntermediateTensorInfo(b)), t8.makeTensorInfo(x, g, f);
  }
  var c_ = { kernelName: os, backendName: "cpu", kernelFunc: M8 };
  function L8(r8, e8, t8) {
    r8.forEach((o8, n8) => {
      if (o8 < 0 || o8 >= t8) {
        let s = y.indexToLoc(n8, e8.length, y.computeStrides(e8)).join(",");
        throw new Error(`indices[${s}] = ${o8} is not in [0, ${t8})`);
      }
    });
  }
  function B8(r8, e8) {
    for (let t8 = 0; t8 < r8.length; ++t8) {
      let o8 = r8[t8], n8 = t8 === r8.length - 1 ? e8 : r8[t8 + 1].length;
      if (o8.length === 0)
        throw new Error("Ragged splits may not be empty");
      if (o8[0] < 0)
        throw new Error("Ragged splits must be non-negative");
      if (o8[o8.length - 1] > n8)
        throw new Error("Ragged splits must not point past values");
      for (let s = 1; s < o8.length; ++s)
        if (o8[s - 1] > o8[s])
          throw new Error("Ragged splits must be sorted in ascending order");
    }
  }
  function z8(r8, e8, t8, o8) {
    let n8 = [], s = 0, a = e8.length - 1 + t8.length, i10 = new Array(a).fill(null).map(() => [0]);
    B8(t8, o8);
    let p = 1;
    for (let u = 0; u < e8.length - 1; ++u) {
      p *= e8[u];
      let c = e8[u + 1];
      for (let l = 1; l < p + 1; ++l)
        i10[u].push(l * c);
    }
    for (let u = 0; u < r8.length; ++u) {
      let c = r8[u], l = r8[u] + 1;
      for (let m = 0; m < t8.length; ++m) {
        let d = t8[m], f = m + e8.length - 1;
        if (f >= 0) {
          let h = i10[f], g = h[h.length - 1] - d[c];
          for (let x = c; x < l; ++x)
            i10[f].push(d[x + 1] + g);
        }
        c = d[c], l = d[l];
      }
      l !== c && (n8.push([c, l]), s += l - c);
    }
    return { outSplits: i10, valueSlices: n8, numValues: s };
  }
  function V8(r8) {
    let e8 = [];
    for (let t8 = 0; t8 < r8.length; ++t8) {
      let o8 = r8[t8].length, n8 = y.getArrayFromDType("int32", o8);
      e8.push(n8), r8[t8].forEach((s, a) => n8[a] = s);
    }
    return e8;
  }
  function l_(r8, e8) {
    let t8 = r8.slice(0, e8);
    for (; t8.length < e8; )
      t8.push(1);
    for (let o8 = e8; o8 < r8.length; o8++)
      t8[e8 - 1] *= r8[o8];
    return t8;
  }
  function W8(r8, e8, t8, o8, n8, s) {
    let a = l_(e8, 2)[1], i10 = l_(s, 2)[1], p = 0;
    for (let u of t8)
      for (let c = u[0]; c < u[1]; ++c) {
        for (let l = 0; l < o8; ++l)
          n8[p * i10 + l] = r8[c * a + l];
        ++p;
      }
  }
  function U8(r8, e8, t8, o8, n8) {
    let s = e8.slice();
    s[0] = n8;
    let a = y.getArrayFromDType(t8, y.sizeFromShape(s)), i10 = r8.length, p = i10 === 0 ? 0 : i10 / e8[0];
    return W8(r8, e8, o8, p, a, s), [a, s];
  }
  function $f(r8, e8, t8, o8, n8, s, a, i10) {
    if (r8.length === 0)
      throw new Error("paramsNestedSplits must be non empty");
    if (e8[0].length === 0)
      throw new Error("Split tensors must not be scalars");
    let p = e8[0][0] - 1;
    if (L8(s, a, p), o8.length === 0)
      throw new Error("params.rank must be nonzero");
    let u = o8[0], { outSplits: c, valueSlices: l, numValues: m } = z8(s, a, r8, u), d = V8(c), f = U8(t8, o8, n8, l, m);
    return [d, f[0], f[1]];
  }
  var m_ = 2147483647;
  function Ef(r8, e8, t8, o8, n8, s, a) {
    if (e8.length > 1)
      throw new Error("starts must be a scalar or vector");
    if (n8.length > 1)
      throw new Error("limits must be a scalar or vector");
    if (a.length > 1)
      throw new Error("deltas must be a scalar or vector");
    let i10 = e8.length === 0, p = n8.length === 0, u = a.length === 0, c = [];
    i10 || c.push(e8[0]), p || c.push(n8[0]), u || c.push(a[0]);
    for (let g = 1; g < c.length; ++g)
      if (c[g] !== c[g - 1])
        throw new Error("starts, limits, and deltas must have the same shape");
    let l = c.length === 0 ? 1 : c[0], m = y.getArrayFromDType("int32", l + 1);
    m[0] = 0;
    for (let g = 0; g < l; ++g) {
      let x = i10 ? r8[0] : r8[g], b = p ? o8[0] : o8[g], C = u ? s[0] : s[g];
      if (C === 0)
        throw new Error("Requires delta != 0");
      let S;
      if (C > 0 && b < x || C < 0 && b > x)
        S = 0;
      else if (S = Math.ceil(Math.abs((b - x) / C)), S > m_)
        throw new Error(`Requires ((limit - start) / delta) <= ${m_}`);
      m[g + 1] = m[g] + S;
    }
    let d = m[l], f = y.getArrayFromDType(t8, d), h = 0;
    for (let g = 0; g < l; ++g) {
      let x = m[g + 1] - m[g], b = i10 ? r8[0] : r8[g], C = u ? s[0] : s[g];
      for (let S = 0; S < x; ++S)
        f[h++] = b, b += C;
    }
    return [m, f];
  }
  var Do = w.RowPartitionType;
  var wc = class {
    constructor(e8, t8, o8, n8, s, a, i10, p, u, c) {
      this.shape = e8, this.shapeShape = t8, this.values = o8, this.valuesShape = n8, this.valuesDType = s, this.defaultValue = a, this.defaultValueShape = i10, this.rowPartitionValues = p, this.rowPartitionValuesShapes = u, this.rowPartitionTypes = w.getRowPartitionTypesHelper(c), this.raggedRank = w.getRaggedRank(this.rowPartitionTypes);
    }
    getRowPartitionTypeByDimension(e8) {
      return this.rowPartitionTypes[0] === Do.FIRST_DIM_SIZE ? this.rowPartitionTypes[e8 + 1] : this.rowPartitionTypes[e8];
    }
    getRowPartitionTensor(e8) {
      return this.rowPartitionTypes[0] === Do.FIRST_DIM_SIZE ? this.rowPartitionValues[e8 + 1] : this.rowPartitionValues[e8];
    }
    getMaxWidth(e8) {
      let t8 = this.getRowPartitionTensor(e8 - 1);
      switch (this.getRowPartitionTypeByDimension(e8 - 1)) {
        case Do.VALUE_ROWIDS:
          return wc.getMaxWidthValueRowID(t8);
        case Do.ROW_SPLITS:
          return wc.getMaxWidthRowSplit(t8);
        default:
          throw new Error(`Cannot handle partition type ${Do[this.getRowPartitionTypeByDimension(e8 - 1)]}`);
      }
    }
    static getMaxWidthRowSplit(e8) {
      let t8 = e8.length;
      if (t8 === 0 || t8 === 1)
        return 0;
      let o8 = 0;
      for (let n8 = 0; n8 < t8 - 1; ++n8) {
        let s = e8[n8 + 1] - e8[n8];
        s > o8 && (o8 = s);
      }
      return o8;
    }
    static getMaxWidthValueRowID(e8) {
      let t8 = e8.length;
      if (t8 === 0)
        return 0;
      let o8 = 0, n8 = e8[0], s = 0;
      for (let a = 1; a < t8; ++a) {
        let i10 = e8[a];
        i10 !== n8 && (n8 = i10, s = Math.max(a - o8, s), o8 = a);
      }
      return Math.max(t8 - o8, s);
    }
    tensorShapeFromTensor(e8, t8, o8 = true) {
      if (t8.length === 0) {
        if (e8[0] === -1)
          return [];
        throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
      }
      return f_(e8, o8);
    }
    calculateOutputSize(e8) {
      let t8 = this.valuesShape, o8 = this.defaultValueShape;
      w.validateDefaultValueShape(o8, t8);
      let n8 = this.tensorShapeFromTensor(this.shape, this.shapeShape), a = w.combineRaggedTensorToTensorShapes(this.raggedRank, n8, t8);
      a[0] < 0 && (a[0] = e8);
      for (let i10 = 1; i10 <= this.raggedRank; ++i10)
        a[i10] < 0 && (a[i10] = this.getMaxWidth(i10));
      return a;
    }
    calculateFirstParentOutputIndex(e8, t8, o8) {
      let n8 = Math.min(e8, o8), s = [], a = 0;
      for (let i10 = 0; i10 < n8; ++i10, a += t8)
        s.push(a);
      for (let i10 = n8; i10 < e8; ++i10)
        s.push(-1);
      return y.assert(s.length === e8, () => "Final length of result must be equal to firstDimension."), s;
    }
    calculateOutputIndexRowSplit(e8, t8, o8, n8) {
      let s = e8.length, a = [];
      for (let i10 = 0; i10 < s - 1; ++i10) {
        let p = e8[i10 + 1] - e8[i10], u = Math.min(n8, p), c = t8[i10];
        c === -1 && (u = 0);
        for (let l = 0; l < u; ++l)
          a.push(c), c += o8;
        for (let l = 0; l < p - u; ++l)
          a.push(-1);
      }
      if (s > 0 && a.length !== e8[s - 1])
        throw new Error("Invalid row split size.");
      return a;
    }
    calculateOutputIndexValueRowID(e8, t8, o8, n8) {
      let s = e8.length, a = [];
      if (s === 0)
        return [];
      let i10 = 0, p = e8[0];
      if (p >= t8.length)
        throw new Error(`Got currentValueRowId=${p}, which is not less than ${t8.length}`);
      let u = t8[p];
      a.push(u);
      for (let c = 1; c < s; ++c) {
        let l = e8[c];
        if (l === p)
          u >= 0 && (++i10, i10 < n8 ? u += o8 : u = -1);
        else {
          if (i10 = 0, p = l, l >= t8.length)
            throw new Error(`Got nextValueRowId=${l} which is not less than ${t8.length}`);
          u = t8[l];
        }
        a.push(u);
      }
      if (a.length !== e8.length)
        throw new Error("Invalid row ids.");
      return a;
    }
    calculateOutputIndex(e8, t8, o8, n8) {
      let s = this.getRowPartitionTensor(e8), a = this.getRowPartitionTypeByDimension(e8);
      switch (a) {
        case Do.VALUE_ROWIDS:
          return this.calculateOutputIndexValueRowID(s, t8, o8, n8);
        case Do.ROW_SPLITS:
          if (s.length - 1 > t8.length)
            throw new Error(`Row partition size is greater than output size: ${s.length - 1} > ${t8.length}`);
          return this.calculateOutputIndexRowSplit(s, t8, o8, n8);
        default:
          throw new Error(`Unsupported partition type: ${Do[a]}`);
      }
    }
    getFirstDimensionSize() {
      let e8 = this.rowPartitionValues[0];
      if (this.rowPartitionTypes.length === 0)
        throw new Error("No row_partition_types given.");
      let t8 = this.rowPartitionTypes[0];
      switch (t8) {
        case Do.FIRST_DIM_SIZE:
          return e8[0];
        case Do.VALUE_ROWIDS:
          throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
        case Do.ROW_SPLITS:
          return this.rowPartitionValuesShapes[0][0] - 1;
        default:
          throw new Error(`Cannot handle type ${Do[t8]}`);
      }
    }
    compute() {
      if (this.rowPartitionValues[0].length <= 0)
        throw new Error("Invalid first partition input. Tensor requires at least one element.");
      let t8 = this.getFirstDimensionSize(), o8 = this.calculateOutputSize(t8), n8 = new Array(this.raggedRank + 1);
      n8[n8.length - 1] = 1;
      for (let p = n8.length - 2; p >= 0; --p)
        n8[p] = n8[p + 1] * o8[p + 1];
      let s = f_(o8, false), a = y.getArrayFromDType(this.valuesDType, y.sizeFromShape(s));
      if (n8[0] * o8[0] > 0) {
        let p = this.calculateFirstParentOutputIndex(t8, n8[0], o8[0]);
        for (let u = 1; u <= this.raggedRank; ++u)
          p = this.calculateOutputIndex(u - 1, p, n8[u], o8[u]);
        this.setOutput(this.raggedRank, p, a, s);
      }
      return [s, a];
    }
    setOutput(e8, t8, o8, n8) {
      if (o8.length === 0)
        return;
      let s = this.values, a = o8, i10 = n8.slice();
      i10 = i10.slice(e8 + 1);
      let p = y.sizeFromShape(i10), u = t8.length, c = this.defaultValue;
      if (c.length !== p && c.length !== 1) {
        let f = this.defaultValueShape;
        De(() => {
          let h = W(c, f);
          c = au(h, i10).dataSync();
        });
      }
      let l = 0, m = 0, d = 0;
      for (let f = 0; f <= u; ++f) {
        let h = f < u ? t8[f] : -1;
        if (h === d) {
          ++d;
          continue;
        }
        if (m < d) {
          let g = s.subarray(l * p), x = a.subarray(m * p), b = (d - m) * p;
          d_(x, g, b);
        }
        if (f >= u) {
          let g = o8.length;
          h = Math.floor(g / p);
        }
        if (h > d)
          if (this.defaultValue.length === 1)
            a.subarray(d * p, h * p).fill(this.defaultValue[0]), d = h;
          else
            for (; h > d; ) {
              let g = a.slice(d * p);
              d_(g, c, p), ++d;
            }
        h < 0 ? (l = f + 1, m = d) : (l = f, m = d, d = m + 1);
      }
    }
  };
  function d_(r8, e8, t8) {
    for (let o8 = 0; o8 < t8; o8++)
      r8[o8] = e8[o8];
  }
  function f_(r8, e8) {
    let t8 = [];
    for (let o8 of r8) {
      if (o8 < 0) {
        if (!e8)
          throw new Error(`Dimension ${o8} must be >= 0`);
        if (o8 < -1)
          throw new Error(`Dimension ${o8} must be >= -1`);
        o8 = -1;
      }
      t8.push(o8);
    }
    return t8;
  }
  function Rf(r8, e8, t8, o8, n8, s, a, i10, p, u) {
    return new wc(r8, e8, t8, o8, n8, s, a, i10, p, u).compute();
  }
  function cp(r8, e8, t8, o8) {
    let n8 = r8 === e8, s = r8 < e8 && t8 < 0, a = e8 < r8 && t8 > 1;
    if (n8 || s || a)
      return y.makeZerosTypedArray(0, o8);
    let i10 = Math.abs(Math.ceil((e8 - r8) / t8)), p = y.makeZerosTypedArray(i10, o8);
    e8 < r8 && t8 === 1 && (t8 = -1), p[0] = r8;
    for (let u = 1; u < p.length; u++)
      p[u] = p[u - 1] + t8;
    return p;
  }
  var ZS = Xt((r8) => 1 / Math.sqrt(r8));
  var G8 = Ar(ls, ZS);
  var h_ = { kernelName: ls, backendName: "cpu", kernelFunc: G8 };
  function Ls(r8, e8, t8, o8, n8, s, a, i10, p, u) {
    let c = [o8 / n8, n8], l = r8.values, m = e8.values;
    if (o8 === 0)
      return me(t8, e8.dtype);
    let d = p instanceof tt ? p : me(c, e8.dtype);
    typeof p == "string" || typeof p == "number" ? d.values.fill(p) : typeof p == "boolean" && d.values.fill(+p);
    for (let f = 0; f < s; f++) {
      let h = [], g = 0;
      for (let x = 0; x < a; x++) {
        let b = l[f * a + x];
        h.push(b), g += b * i10[x];
      }
      if (g < 0 || g >= o8 / n8)
        throw new Error(`Invalid indices: ${h} does not index into ${t8}`);
      for (let x = 0; x < n8; x++)
        u ? d.values[g * n8 + x] += m[f * n8 + x] : d.values[g * n8 + x] = e8.rank === 0 ? m[0] : m[f * n8 + x];
    }
    return d;
  }
  var g_ = Xt((r8) => 1 / (1 + Math.exp(-r8)));
  var JS = Ie(bs, (r8) => 1 / (1 + Math.exp(-r8)));
  var x_ = { kernelName: bs, backendName: "cpu", kernelFunc: JS };
  function lp(r8, e8, t8, o8, n8) {
    let s = ct.isSliceContinous(o8, e8, t8), a = y.sizeFromShape(t8), i10 = y.computeStrides(o8);
    if (s) {
      let l = ct.computeFlatOffset(e8, i10);
      return n8 === "string" ? r8.slice(l, l + a) : r8.subarray(l, l + a);
    }
    let p = n8 === "string" ? w.fromUint8ToStringArray(r8) : r8, u = me(o8, n8, p), c = me(t8, n8);
    for (let l = 0; l < c.size; ++l) {
      let m = c.indexToLoc(l), d = m.map((f, h) => f + e8[h]);
      c.set(u.get(...d), ...m);
    }
    return n8 === "string" ? w.fromStringArrayToUint8(c.values) : c.values;
  }
  function Ao(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { begin: s, size: a } = o8;
    Q(n8, "slice");
    let [i10, p] = ct.parseSliceParams(n8, s, a);
    ct.assertParamsValid(n8, i10, p);
    let u = t8.data.get(n8.dataId).values, c = lp(u, i10, p, n8.shape, n8.dtype);
    return t8.makeTensorInfo(p, n8.dtype, c);
  }
  var y_ = { kernelName: fa, backendName: "cpu", kernelFunc: Ao };
  function Df(r8, e8, t8, o8, n8, s, a) {
    let i10 = e8[0], p = s[0], u = new Array(p), c = new Array(i10), l = e8[1];
    if (p === 0) {
      if (i10 !== 0)
        throw new Error(w.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i10));
      let g = y.getArrayFromDType(t8, 0), x = y.getArrayFromDType(n8, 0);
      return [g, [0, l], x, u, c];
    }
    let m = true, d = 0, f = new Array(p).fill(0);
    for (let g = 0; g < i10; ++g) {
      let x = r8[g * l];
      if (x < 0)
        throw new Error(w.getSparseFillEmptyRowsNegativeIndexErrorMessage(g, x));
      if (x >= p)
        throw new Error(w.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g, x, p));
      ++f[x], m = m && x >= d, d = x;
    }
    let h = true;
    for (let g = 0; g < p; ++g) {
      let x = f[g] === 0;
      u[g] = x, h = h && !x, f[g] = Math.max(f[g], 1), g > 0 && (f[g] += f[g - 1]);
    }
    if (h && m) {
      let g = r8, x = o8;
      for (let b = 0; b < i10; ++b)
        c[b] = b;
      return [g, [i10, l], x, u, c];
    } else {
      let g = f[p - 1], x = y.getArrayFromDType(t8, g * l), b = y.getArrayFromDType(n8, g), C = new Array(p).fill(0);
      for (let S = 0; S < i10; ++S) {
        let k = r8[S * l], _ = C[k], E = (k === 0 ? 0 : f[k - 1]) + _;
        C[k]++;
        for (let R = 0; R < l; ++R)
          x[E * l + R] = r8[S * l + R];
        b[E] = o8[S], c[S] = E;
      }
      for (let S = 0; S < p; ++S)
        if (C[S] === 0) {
          let _ = S === 0 ? 0 : f[S - 1];
          x[_ * l + 0] = S;
          for (let E = 1; E < l; ++E)
            x[_ * l + E] = 0;
          b[_] = a;
        }
      return [x, [g, l], b, u, c];
    }
  }
  function Af(r8, e8, t8, o8, n8) {
    let s = y.sizeFromShape(o8), a = e8[0], i10 = n8.length, p = [], u = 1, c = -1;
    for (let g = 0; g < i10; ++g) {
      let x = n8[g];
      if (x === -1) {
        if (c !== -1)
          throw new Error(w.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c, g));
        c = g, p.push(1);
      } else {
        if (x < 0)
          throw new Error(w.getSparseReshapeNegativeOutputDimErrorMessage(g, x));
        u *= x, p.push(x);
      }
    }
    if (c !== -1) {
      if (u <= 0)
        throw new Error(w.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
      let g = Math.trunc(s / u);
      if (u * g !== s)
        throw new Error(w.getSparseReshapeInputOutputMultipleErrorMessage(o8, p));
      p[c] = g;
    }
    if (y.sizeFromShape(p) !== s)
      throw new Error(w.getSparseReshapeInputOutputMismatchErrorMessage(o8, p));
    let m = o8.length, d = [];
    if (m > 0) {
      d[m - 1] = 1;
      for (let g = m - 2; g >= 0; --g)
        d[g] = d[g + 1] * o8[g + 1];
    }
    let f = [];
    if (i10 > 0) {
      f[i10 - 1] = 1;
      for (let g = i10 - 2; g >= 0; --g)
        f[g] = f[g + 1] * p[g + 1];
    }
    let h = y.getArrayFromDType(t8, a * i10);
    for (let g = 0; g < a; ++g) {
      let x = 0;
      for (let b = 0; b < m; ++b)
        x += r8[g * m + b] * d[b];
      for (let b = 0; b < i10; ++b)
        h[g * i10 + b] = Math.trunc(x / f[b]), x %= f[b];
    }
    return [h, [a, i10], p];
  }
  function Sc(r8, e8, t8, o8, n8, s = false, a = 0) {
    let i10 = o8.length, p = [e8[0], r8.length / e8[0]], u = p[1], l = i10 > 0 ? n8[i10 - 1] + 1 : 0;
    if (l < 0)
      throw new Error(w.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let m = e8.slice();
    m[0] = l;
    let d = m.reduce((C, S) => C * S, 1), f = y.getArrayFromDType(t8, d);
    if (i10 === 0)
      return l > 0 && f.fill(a), [f, m];
    if (l <= 0)
      throw new Error(w.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let h = 0, g = 1, x = 0, b = n8[h];
    for (; ; ) {
      let C = 0;
      if (g < i10) {
        if (C = n8[g], b === C) {
          ++g;
          continue;
        }
        if (b >= C)
          throw new Error(w.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
      }
      if (b < 0 || b >= l)
        throw new Error(w.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b, l));
      b > x && f.fill(a, x * u, b * u);
      for (let S = h; S < g; ++S) {
        let k = o8[S];
        if (k < 0 || k >= p[0])
          throw new Error(w.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(S, o8[S], p[0]));
        for (let _ = 0; _ < u; _++)
          f[b * u + _] += r8[k * u + _];
      }
      if (s)
        for (let S = 0; S < u; S++)
          f[b * u + S] /= g - h;
      if (h = g, ++g, x = b + 1, b = C, g > i10)
        break;
    }
    return x < l && f.fill(a, x * u, l * u), [f, m];
  }
  var b_ = Xt((r8) => Math.sqrt(r8));
  var H8 = Ie(ws, (r8) => Math.sqrt(r8));
  var C_ = { kernelName: ws, backendName: "cpu", kernelFunc: H8 };
  var eI = ze((r8, e8) => {
    let t8 = r8 - e8;
    return t8 * t8;
  });
  var K8 = Ye(ks, eI);
  var w_ = { kernelName: ks, backendName: "cpu", kernelFunc: K8 };
  var tI = Xt((r8, e8) => {
    let { pattern: t8, replaceGlobal: o8, rewrite: n8 } = e8;
    return r8.replace(new RegExp(t8, o8 ? "g" : ""), n8);
  });
  var q8 = Ar(Du, tI);
  var S_ = { kernelName: Du, backendName: "cpu", kernelFunc: q8 };
  function Ff(r8, e8, t8, o8) {
    let n8 = me(r8, e8.dtype);
    for (let s = 0; s < n8.size; s++) {
      let a = n8.indexToLoc(s), i10 = new Array(a.length);
      for (let p = 0; p < i10.length; p++)
        i10[p] = a[p] * t8[p] + o8[p];
      n8.set(e8.get(...i10), ...a);
    }
    return n8;
  }
  var rI = class {
    constructor(e8, t8, o8, n8, s, a) {
      this.separator = y.encodeString(e8), this.nGramWidths = t8, this.leftPad = y.encodeString(o8), this.rightPad = y.encodeString(n8), this.padWidth = s, this.preserveShort = a;
    }
    getPadWidth(e8) {
      return Math.min(this.padWidth < 0 ? e8 - 1 : this.padWidth, e8 - 1);
    }
    getNumNGrams(e8, t8) {
      let o8 = this.getPadWidth(t8);
      return Math.max(0, e8 + 2 * o8 - t8 + 1);
    }
    createNGrams(e8, t8, o8, n8, s, a) {
      for (let i10 = 0; i10 < s; ++i10) {
        let p = this.getPadWidth(a), u = Math.max(0, p - i10), c = Math.max(0, p - (s - (i10 + 1))), l = a - (u + c), m = t8 + (u > 0 ? 0 : i10 - p), d = 0;
        d += u * this.leftPad.length;
        for (let b = 0; b < l; ++b)
          d += e8[m + b].length;
        d += c * this.rightPad.length;
        let f = u + c + l - 1;
        d += f * this.separator.length, o8[n8 + i10] = new Uint8Array(d);
        let h = o8[n8 + i10], g = 0, x = (b) => b.forEach((C) => h[g++] = C);
        for (let b = 0; b < u; ++b)
          x(this.leftPad), x(this.separator);
        for (let b = 0; b < l - 1; ++b)
          x(e8[m + b]), x(this.separator);
        if (l > 0) {
          x(e8[m + l - 1]);
          for (let b = 0; b < c; ++b)
            x(this.separator), x(this.rightPad);
        } else {
          for (let b = 0; b < c - 1; ++b)
            x(this.rightPad), x(this.separator);
          x(this.rightPad);
        }
      }
    }
    compute(e8, t8) {
      let o8 = e8.length, n8 = t8.length;
      if (n8 > 0) {
        let p = t8[0];
        if (p !== 0)
          throw new Error(`First split value must be 0, got ${p}`);
        for (let u = 1; u < n8; ++u) {
          let c = t8[u] >= p;
          if (c = c && t8[u] <= o8, !c)
            throw new Error(`Invalid split value ${t8[u]}, must be in [${p}, ${o8}]`);
          p = t8[u];
        }
        if (p !== o8)
          throw new Error(`Last split value must be data size. Expected ${o8}, got ${p}`);
      }
      let s = n8 - 1, a = y.getArrayFromDType("int32", n8);
      if (o8 === 0 || n8 === 0) {
        let p = new Array(o8);
        for (let u = 0; u <= s; ++u)
          a[u] = 0;
        return [p, a];
      }
      a[0] = 0;
      for (let p = 1; p <= s; ++p) {
        let u = t8[p] - t8[p - 1], c = 0;
        this.nGramWidths.forEach((l) => {
          c += this.getNumNGrams(u, l);
        }), this.preserveShort && u > 0 && c === 0 && (c = 1), a[p] = a[p - 1] + c;
      }
      let i10 = new Array(a[s]);
      for (let p = 0; p < s; ++p) {
        let u = t8[p], c = a[p];
        if (this.nGramWidths.forEach((l) => {
          let m = t8[p + 1] - t8[p], d = this.getNumNGrams(m, l);
          this.createNGrams(e8, u, i10, c, d, l), c += d;
        }), this.preserveShort && c === a[p]) {
          let l = t8[p + 1] - t8[p];
          if (l === 0)
            continue;
          let m = l + 2 * this.padWidth, d = 1;
          this.createNGrams(e8, u, i10, c, d, m);
        }
      }
      return [i10, a];
    }
  };
  function mp(r8, e8, t8, o8, n8, s, a, i10) {
    return new rI(t8, o8, n8, s, a, i10).compute(r8, e8);
  }
  function j8(r8, e8, t8, o8) {
    if (!r8.length)
      return;
    if (e8.length === 0) {
      for (let s = 0; s < r8.length; ++s)
        o8.push(r8.subarray(s, s + 1));
      return;
    }
    if (e8.length === 1) {
      let s = e8[0], a = r8.indexOf(s);
      for (; a !== -1; ) {
        let i10 = r8.subarray(0, a);
        (!t8 || i10.length !== 0) && o8.push(i10), r8 = r8.subarray(a + 1), a = r8.indexOf(s);
      }
      (!t8 || r8.length !== 0) && o8.push(r8);
      return;
    }
    let n8 = 0;
    for (let s = 0; s < r8.length + 1; s++)
      if (s === r8.length || e8.indexOf(r8[s]) !== -1) {
        let a = r8.subarray(n8, s);
        (!t8 || a.length !== 0) && o8.push(a), n8 = s + 1;
      }
  }
  function dp(r8, e8, t8) {
    let o8 = r8.length, n8 = [], s = 0, a = 0, i10 = new Array(o8);
    for (let m = 0; m < o8; ++m) {
      let d = n8.length;
      j8(r8[m], e8, t8, n8);
      let f = n8.length - d;
      i10[m] = f, s += f, a = Math.max(a, f);
    }
    let p = y.getArrayFromDType("int32", s * 2), u = new Array(s), c = [o8, a], l = 0;
    for (let m = 0; m < o8; ++m)
      for (let d = 0; d < i10[m]; ++d)
        p[l * 2] = m, p[l * 2 + 1] = d, u[l] = n8[l], ++l;
    return [p, u, c];
  }
  function fp(r8, e8) {
    let t8 = y.getArrayFromDType("int32", r8.length);
    for (let o8 = 0; o8 < r8.length; ++o8)
      t8[o8] = y.fingerPrint64(r8[o8]).modulo(e8).getLowBitsUnsigned();
    return t8;
  }
  var oI = ze((r8, e8) => r8 - e8);
  var X8 = yc((r8, e8, t8, o8) => ({ real: r8 - t8, imag: e8 - o8 }));
  var Ll = Ye(Ts, oI, X8);
  var I_ = { kernelName: Ts, backendName: "cpu", kernelFunc: Ll };
  function Pf(r8, e8) {
    let t8 = new Array(r8.rank);
    for (let n8 = 0; n8 < t8.length; n8++)
      t8[n8] = r8.shape[n8] * e8[n8];
    let o8 = me(t8, r8.dtype);
    for (let n8 = 0; n8 < o8.values.length; ++n8) {
      let s = o8.indexToLoc(n8), a = new Array(r8.rank);
      for (let p = 0; p < a.length; p++)
        a[p] = s[p] % r8.shape[p];
      let i10 = r8.locToIndex(a);
      o8.values[n8] = r8.values[i10];
    }
    return o8;
  }
  var Bl = (r8, e8) => {
    let t8 = e8.value - r8.value;
    return t8 === 0 ? r8.index - e8.index : t8;
  };
  function v_(r8, e8, t8 = 0, o8 = r8.length - 1) {
    for (; o8 > t8; ) {
      if (o8 - t8 > 600) {
        let i10 = o8 - t8 + 1, p = e8 - t8 + 1, u = Math.log(i10), c = 0.5 * Math.exp(2 * u / 3), l = 0.5 * Math.sqrt(u * c * (i10 - c) / i10) * Math.sign(p - i10 / 2), m = Math.max(t8, Math.floor(e8 - p * c / i10 + l)), d = Math.min(o8, Math.floor(e8 + (i10 - p) * c / i10 + l));
        v_(r8, e8, m, d);
      }
      let n8 = r8[e8], s = t8, a = o8;
      for (y.swap(r8, t8, e8), Bl(r8[o8], n8) > 0 && y.swap(r8, t8, o8); s < a; ) {
        for (y.swap(r8, s, a), s++, a--; Bl(r8[s], n8) < 0; )
          s = s + 1;
        for (; Bl(r8[a], n8) > 0; )
          a = a - 1;
      }
      Bl(r8[t8], n8) === 0 ? y.swap(r8, t8, a) : (a = a + 1, y.swap(r8, a, o8)), a <= e8 && (t8 = a + 1), e8 <= a && (o8 = a - 1);
    }
  }
  function Of(r8, e8, t8, o8, n8) {
    let s = e8[e8.length - 1], [a, i10] = [r8.length / s, s], p = y.getTypedArrayFromDType(t8, a * o8), u = y.getTypedArrayFromDType("int32", a * o8);
    for (let l = 0; l < a; l++) {
      let m = l * i10, d = r8.subarray(m, m + i10), f = new Array(d.length);
      d.forEach((b, C) => f[C] = { value: b, index: C }), o8 < f.length && (v_(f, o8), f = f.slice(0, o8)), n8 && f.sort(Bl);
      let h = l * o8, g = p.subarray(h, h + o8), x = u.subarray(h, h + o8);
      for (let b = 0; b < o8; b++)
        g[b] = f[b].value, x[b] = f[b].index;
    }
    let c = e8.slice();
    return c[c.length - 1] = o8, [me(c, t8, p), me(c, "int32", u)];
  }
  function hp(r8, e8, t8, o8) {
    let n8 = y.parseAxisParam(e8, t8)[0], s = [1, t8[0], 1];
    for (let f = 0; f < n8; f++)
      s[0] *= t8[f];
    s[1] = t8[n8];
    for (let f = n8 + 1; f < t8.length; f++)
      s[2] *= t8[f];
    let a = /* @__PURE__ */ new Map(), i10 = new Int32Array(t8[n8]), p = new tt(s, o8, r8), u = [], c = s[0] === 1 && s[2] === 1;
    for (let f = 0; f < t8[n8]; f++) {
      let h;
      if (c)
        h = r8[f].toString();
      else {
        let x = [];
        for (let b = 0; b < s[0]; b++)
          for (let C = 0; C < s[2]; C++)
            x.push(p.get(b, f, C));
        h = x.join(",");
      }
      let g = a.get(h);
      if (g != null)
        i10[f] = g;
      else {
        let x = a.size;
        a.set(h, x), i10[f] = x, u.push(f);
      }
    }
    let l = s.slice();
    l[1] = a.size;
    let m = new tt(l, o8);
    u.forEach((f, h) => {
      for (let g = 0; g < s[0]; g++)
        for (let x = 0; x < s[2]; x++)
          m.set(p.get(g, f, x), g, h, x);
    });
    let d = t8.slice();
    return d[n8] = l[1], { outputValues: m.values, outputShape: d, indices: i10 };
  }
  var Y8 = "4.7.0";
  nu("cpu", () => new hu(), 1);
  var nI = Ie(hn, (r8) => r8 >= 0 ? r8 : Math.exp(r8) - 1);
  var k_ = { kernelName: hn, backendName: "cpu", kernelFunc: nI };
  function sI(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { alpha: s } = o8;
    Q([n8], "leakyRelu");
    let a = y.sizeFromShape(n8.shape), i10 = t8.data.get(n8.dataId).values, p = y.getTypedArrayFromDType("float32", a);
    for (let u = 0; u < i10.length; u++)
      p[u] = i10[u] < 0 ? s * i10[u] : i10[u];
    return t8.makeTensorInfo(n8.shape, "float32", p);
  }
  var N_ = { kernelName: En, backendName: "cpu", kernelFunc: sI };
  var Q8 = ze((r8, e8) => r8 < 0 ? e8 * r8 : r8);
  function aI(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8, alpha: n8 } = e8;
    Q([o8, n8], "prelu");
    let s = t8.data.get(o8.dataId).values, a = t8.data.get(n8.dataId).values, [i10, p] = Q8(o8.shape, n8.shape, s, a, "float32");
    return t8.makeTensorInfo(p, "float32", i10);
  }
  var T_ = { kernelName: rs, backendName: "cpu", kernelFunc: aI };
  var iI = Ie(ss, (r8) => Math.max(0, r8));
  var __ = { kernelName: ss, backendName: "cpu", kernelFunc: iI };
  var uI = Ie(us, (r8) => Math.min(Math.max(0, r8), 6));
  var $_ = { kernelName: us, backendName: "cpu", kernelFunc: uI };
  function gp(r8, e8, t8, o8, n8) {
    if (t8 === "linear")
      return lr({ inputs: { x: e8 }, backend: r8 });
    if (t8 === "relu")
      return iI({ inputs: { x: e8 }, backend: r8 });
    if (t8 === "elu")
      return nI({ inputs: { x: e8 }, backend: r8 });
    if (t8 === "relu6")
      return uI({ inputs: { x: e8 }, backend: r8 });
    if (t8 === "prelu")
      return aI({ inputs: { x: e8, alpha: o8 }, backend: r8 });
    if (t8 === "leakyrelu")
      return sI({ inputs: { x: e8 }, backend: r8, attrs: { alpha: n8 } });
    if (t8 === "sigmoid")
      return JS({ inputs: { x: e8 }, backend: r8 });
    throw new Error(`Activation ${t8} has not been implemented for the CPU backend.`);
  }
  function Ve(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { shape: s } = o8, a = y.sizeFromShape(n8.shape), i10 = y.inferFromImplicitShape(s, a), p = y.sizeFromShape(i10);
    y.assert(a === p, () => `The new shape (${i10}) has ${p} elements and the old shape (${n8.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`), t8.incRef(n8.dataId);
    let u = t8.data.get(n8.dataId);
    if (u.complexTensorInfos != null) {
      let c = u.complexTensorInfos.real, l = u.complexTensorInfos.imag;
      c.shape = i10, l.shape = i10;
    }
    return { dataId: n8.dataId, shape: i10, dtype: n8.dtype };
  }
  var E_ = { kernelName: ma, backendName: "cpu", kernelFunc: Ve };
  function pI(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s } = e8, { transposeA: a, transposeB: i10 } = o8;
    Q([n8, s], "matMul");
    let p = n8.shape.length, u = s.shape.length, c = a ? n8.shape[p - 2] : n8.shape[p - 1], l = i10 ? s.shape[u - 1] : s.shape[u - 2], m = a ? n8.shape[p - 1] : n8.shape[p - 2], d = i10 ? s.shape[u - 2] : s.shape[u - 1], f = n8.shape.slice(0, -2), h = s.shape.slice(0, -2), g = y.sizeFromShape(f), x = y.sizeFromShape(h), C = Ir.assertAndGetBroadcastShape(n8.shape.slice(0, -2), s.shape.slice(0, -2)).concat([m, d]);
    y.assert(c === l, () => `Error in matMul: inner shapes (${c}) and (${l}) of Tensors with shapes ${n8.shape} and ${s.shape} and transposeA=${a} and transposeB=${i10} must match.`);
    let S = a ? [g, c, m] : [g, m, c], k = i10 ? [x, d, l] : [x, l, d], _ = Ve({ inputs: { x: n8 }, backend: t8, attrs: { shape: S } }), E = Ve({ inputs: { x: s }, backend: t8, attrs: { shape: k } }), R = a ? _.shape[1] : _.shape[2], D = a ? _.shape[2] : _.shape[1], P = i10 ? E.shape[1] : E.shape[2], O = Math.max(g, x), M = t8.data.get(_.dataId).values, L = t8.data.get(E.dataId).values, B = y.computeStrides(_.shape), z = y.computeStrides(E.shape), [U, j, q] = a ? [B[0], 1, B[1]] : [B[0], B[1], 1], [Y, J, re] = i10 ? [1, z[1], z[0]] : [z[1], 1, z[0]], ne = D * P, ee = me([O, D, P], _.dtype), oe = ee.values, ie = t8.blockSize;
    for (let le = 0; le < O; le++) {
      let be = le % g, _e = le % x;
      for (let ve = 0; ve < D; ve += ie) {
        let Fe = Math.min(ve + ie, D);
        for (let Pe = 0; Pe < P; Pe += ie) {
          let st = Math.min(Pe + ie, P);
          for (let lt = 0; lt < R; lt += ie) {
            let Ue = Math.min(lt + ie, R);
            for (let mt = ve; mt < Fe; mt++)
              for (let it = Pe; it < st; it++) {
                let gt = 0;
                for (let xt = lt; xt < Ue; xt++) {
                  let Lr = M[be * U + mt * j + xt * q], Mt = L[xt * Y + it * J + _e * re];
                  gt += Lr * Mt;
                }
                oe[le * ne + (mt * P + it)] += gt;
              }
          }
        }
      }
    }
    return t8.disposeIntermediateTensorInfo(_), t8.disposeIntermediateTensorInfo(E), t8.makeTensorInfo(C, ee.dtype, ee.values);
  }
  var R_ = { kernelName: Zo, backendName: "cpu", kernelFunc: pI };
  function Z8(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s, bias: a, preluActivationWeights: i10 } = e8, { transposeA: p, transposeB: u, activation: c, leakyreluAlpha: l } = o8, m, d, f, h = [];
    m = pI({ inputs: { a: n8, b: s }, attrs: { transposeA: p, transposeB: u }, backend: t8 }), a && (d = Aa({ inputs: { a: m, b: a }, backend: t8 }), h.push(m), m = d), c && (f = gp(t8, m, c, i10, l), h.push(m), m = f);
    for (let x of h)
      t8.disposeIntermediateTensorInfo(x);
    return m;
  }
  var D_ = { kernelName: So, backendName: "cpu", kernelFunc: Z8 };
  var J8 = Ie(Vo, (r8) => Math.acos(r8));
  var A_ = { kernelName: Vo, backendName: "cpu", kernelFunc: J8 };
  var eY = Ie(Wo, (r8) => Math.acosh(r8));
  var F_ = { kernelName: Wo, backendName: "cpu", kernelFunc: eY };
  function tY(r8) {
    let { inputs: e8, backend: t8 } = r8, o8 = e8;
    Q(e8, "addN");
    let n8 = o8.map((i10) => t8.data.get(i10.dataId).values), s = me(o8[0].shape, o8[0].dtype), a = s.values;
    for (let i10 = 0; i10 < o8.length; i10++) {
      let p = n8[i10];
      for (let u = 0; u < a.length; u++)
        a[u] += p[u];
    }
    return t8.makeTensorInfo(s.shape, s.dtype, s.values);
  }
  var P_ = { kernelName: Uo, backendName: "cpu", kernelFunc: tY };
  function rY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    Q(n8, "all");
    let i10 = y.parseAxisParam(s, n8.shape), p = i10, u = w.getAxesPermutation(p, n8.shape.length), c = n8;
    u != null && (c = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: u } }), p = w.getInnerMostAxes(p.length, n8.shape.length)), w.assertAxesAreInnerMostDims("all", p, c.shape.length);
    let [l, m] = w.computeOutAndReduceShapes(c.shape, p), d = y.sizeFromShape(m), f = y.makeZerosTypedArray(y.sizeFromShape(l), c.dtype), h = t8.data.get(c.dataId).values;
    for (let x = 0; x < f.length; ++x) {
      let b = x * d, C = h[b];
      for (let S = 0; S < d; ++S) {
        let k = h[b + S];
        C = C && k;
      }
      f[x] = C;
    }
    u != null && t8.disposeIntermediateTensorInfo(c);
    let g = t8.makeTensorInfo(l, c.dtype, f);
    if (a) {
      let x = w.expandShapeToKeepDim(l, i10), b = Ve({ inputs: { x: g }, backend: t8, attrs: { shape: x } });
      return t8.disposeIntermediateTensorInfo(g), b;
    }
    return g;
  }
  var O_ = { kernelName: Go, backendName: "cpu", kernelFunc: rY };
  function oY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    Q(n8, "any");
    let i10 = y.parseAxisParam(s, n8.shape), p = i10, u = w.getAxesPermutation(p, n8.shape.length), c = n8;
    u != null && (c = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: u } }), p = w.getInnerMostAxes(p.length, n8.shape.length)), w.assertAxesAreInnerMostDims("any", p, c.shape.length);
    let [l, m] = w.computeOutAndReduceShapes(c.shape, p), d = y.sizeFromShape(m), f = y.makeZerosTypedArray(y.sizeFromShape(l), c.dtype), h = t8.data.get(c.dataId).values;
    for (let x = 0; x < f.length; ++x) {
      let b = x * d, C = h[b];
      for (let S = 0; S < d; ++S) {
        let k = h[b + S];
        C = C || k;
      }
      f[x] = C;
    }
    u != null && t8.disposeIntermediateTensorInfo(c);
    let g = t8.makeTensorInfo(l, c.dtype, f);
    if (a) {
      let x = w.expandShapeToKeepDim(l, i10), b = Ve({ inputs: { x: g }, backend: t8, attrs: { shape: x } });
      return t8.disposeIntermediateTensorInfo(g), b;
    }
    return g;
  }
  var M_ = { kernelName: Ho, backendName: "cpu", kernelFunc: oY };
  function nY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s } = o8;
    Q(n8, "argMax");
    let a = y.parseAxisParam(s, n8.shape), i10 = w.getAxesPermutation(a, n8.shape.length), p = n8, u = [];
    i10 != null && (p = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: i10 } }), u.push(p), a = w.getInnerMostAxes(a.length, p.shape.length)), a = [a[0]], w.assertAxesAreInnerMostDims("argMax", a, p.shape.length);
    let [c, l] = w.computeOutAndReduceShapes(p.shape, a), m = y.sizeFromShape(c), d = y.makeZerosTypedArray(m, "int32"), f = y.sizeFromShape(l), h = t8.data.get(p.dataId).values;
    for (let g = 0; g < d.length; ++g) {
      let x = g * f, b = h[x], C = 0;
      for (let S = 0; S < f; ++S) {
        let k = h[x + S];
        k > b && (b = k, C = S);
      }
      d[g] = C;
    }
    return u.forEach((g) => t8.disposeIntermediateTensorInfo(g)), t8.makeTensorInfo(c, "int32", d);
  }
  var L_ = { kernelName: Xs, backendName: "cpu", kernelFunc: nY };
  function sY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s } = o8;
    Q(n8, "argMin");
    let a = y.parseAxisParam(s, n8.shape), i10 = w.getAxesPermutation(a, n8.shape.length), p = n8, u = [];
    i10 != null && (p = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: i10 } }), u.push(p), a = w.getInnerMostAxes(a.length, p.shape.length)), a = [a[0]], w.assertAxesAreInnerMostDims("argMin", a, p.shape.length);
    let [c, l] = w.computeOutAndReduceShapes(p.shape, a), m = y.sizeFromShape(c), d = y.makeZerosTypedArray(m, "int32"), f = y.sizeFromShape(l), h = t8.data.get(p.dataId).values;
    for (let g = 0; g < d.length; ++g) {
      let x = g * f, b = h[x], C = 0;
      for (let S = 0; S < f; ++S) {
        let k = h[x + S];
        k < b && (b = k, C = S);
      }
      d[g] = C;
    }
    return u.forEach((g) => t8.disposeIntermediateTensorInfo(g)), t8.makeTensorInfo(c, "int32", d);
  }
  var B_ = { kernelName: Ys, backendName: "cpu", kernelFunc: sY };
  var aY = Ie(Ko, (r8) => Math.asin(r8));
  var z_ = { kernelName: Ko, backendName: "cpu", kernelFunc: aY };
  var iY = Ie(qo, (r8) => Math.asinh(r8));
  var V_ = { kernelName: qo, backendName: "cpu", kernelFunc: iY };
  var uY = Ie(jo, (r8) => Math.atan(r8));
  var W_ = { kernelName: jo, backendName: "cpu", kernelFunc: uY };
  var pY = ze((r8, e8) => Math.atan2(r8, e8));
  var cY = Ye(Yo, pY);
  var U_ = { kernelName: Yo, backendName: "cpu", kernelFunc: cY };
  var lY = Ie(Xo, (r8) => Math.atanh(r8));
  var G_ = { kernelName: Xo, backendName: "cpu", kernelFunc: lY };
  function vc(r8, e8, t8, o8, n8, s) {
    let a = n8.strideHeight, i10 = n8.strideWidth, p = n8.dilationHeight, u = n8.dilationWidth, c = n8.effectiveFilterHeight, l = n8.effectiveFilterWidth, m = n8.padInfo.top, d = n8.padInfo.left, f = s === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, h = me(n8.outShape, t8), g = h.values, x = n8.outShape[1] * n8.outShape[2] * n8.outShape[3], b = n8.outShape[2] * n8.outShape[3], C = n8.outShape[3];
    for (let S = 0; S < n8.batchSize; ++S) {
      let k = S * x, _ = S * o8[0];
      for (let E = 0; E < n8.inChannels; ++E)
        for (let R = 0; R < n8.outHeight; ++R) {
          let D = R * a - m, P = Math.max(0, D), O = Math.min(n8.inHeight, c + D), M = k + R * b;
          for (let L = 0; L < n8.outWidth; ++L) {
            let B = L * i10 - d, z = Math.max(0, B), U = Math.min(n8.inWidth, l + B), j = f, q = 0, Y = 0;
            for (let re = P; re < O; re += p) {
              let ne = _ + re * o8[1];
              for (let ee = z; ee < U; ee += u) {
                let oe = ne + ee * o8[2], ie = r8[oe + E];
                s === "max" && ie > j ? j = ie : s === "avg" && (q += ie, Y++);
              }
              if (isNaN(j))
                break;
            }
            let J = M + L * C + E;
            g[J] = s === "avg" ? q / Y : j;
          }
        }
    }
    return h;
  }
  function Mf(r8, e8, t8, o8, n8 = false, s = false) {
    let a = me(o8.outShape, "int32"), i10 = o8.strideHeight, p = o8.strideWidth, u = o8.dilationHeight, c = o8.dilationWidth, l = o8.effectiveFilterHeight, m = o8.effectiveFilterWidth, d = o8.padInfo.top, f = o8.padInfo.left, h = me(e8, t8, r8);
    for (let g = 0; g < o8.batchSize; ++g)
      for (let x = 0; x < o8.inChannels; ++x)
        for (let b = 0; b < o8.outHeight; ++b) {
          let C = b * i10 - d, S = C;
          for (; S < 0; )
            S += u;
          let k = Math.min(o8.inHeight, l + C);
          for (let _ = 0; _ < o8.outWidth; ++_) {
            let E = _ * p - f, R = E;
            for (; R < 0; )
              R += c;
            let D = Math.min(o8.inWidth, m + E), P = Number.NEGATIVE_INFINITY, O = -1;
            for (let M = S; M < k; M += u) {
              let L = M - C;
              for (let B = R; B < D; B += c) {
                let z = B - E, U = h.get(g, M, B, x);
                U > P && (P = U, n8 ? O = s ? ((g * o8.inHeight + M) * o8.inWidth + B) * o8.inChannels + x : (M * o8.inWidth + B) * o8.inChannels + x : O = L * m + z);
              }
            }
            a.set(O, g, b, _, x);
          }
        }
    return a;
  }
  function Lf(r8, e8, t8, o8, n8, s) {
    let a = n8.strideDepth, i10 = n8.strideHeight, p = n8.strideWidth, u = n8.dilationDepth, c = n8.dilationHeight, l = n8.dilationWidth, m = n8.effectiveFilterDepth, d = n8.effectiveFilterHeight, f = n8.effectiveFilterWidth, h = n8.padInfo.front, g = n8.padInfo.top, x = n8.padInfo.left, b = s === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, C = me(n8.outShape, t8), S = C.values, k = n8.outShape[1] * n8.outShape[2] * n8.outShape[3] * n8.outShape[4], _ = n8.outShape[2] * n8.outShape[3] * n8.outShape[4], E = n8.outShape[3] * n8.outShape[4], R = n8.outShape[4];
    for (let D = 0; D < n8.batchSize; ++D) {
      let P = D * k, O = D * o8[0];
      for (let M = 0; M < n8.inChannels; ++M)
        for (let L = 0; L < n8.outDepth; ++L) {
          let B = L * a - h, z = B;
          for (; z < 0; )
            z += u;
          let U = Math.min(n8.inDepth, m + B), j = P + L * _;
          for (let q = 0; q < n8.outHeight; ++q) {
            let Y = q * i10 - g, J = Y;
            for (; J < 0; )
              J += c;
            let re = Math.min(n8.inHeight, d + Y), ne = j + q * E;
            for (let ee = 0; ee < n8.outWidth; ++ee) {
              let oe = ee * p - x, ie = oe;
              for (; ie < 0; )
                ie += l;
              let le = Math.min(n8.inWidth, f + oe), be = ne + ee * R, _e = b, ve = 0, Fe = 0;
              for (let st = z; st < U; st += u) {
                let lt = O + st * o8[1];
                for (let Ue = J; Ue < re; Ue += c) {
                  let mt = lt + Ue * o8[2];
                  for (let it = ie; it < le; it += l) {
                    let gt = mt + it * o8[3], xt = r8[gt + M];
                    if (s === "max" && xt > _e ? _e = xt : s === "avg" && (ve += xt, Fe++), isNaN(_e))
                      break;
                  }
                  if (isNaN(_e))
                    break;
                }
                if (isNaN(_e))
                  break;
              }
              let Pe = be + M;
              S[Pe] = s === "avg" ? ve / Math.max(Fe, 1) : _e;
            }
          }
        }
    }
    return C;
  }
  function H_(r8, e8) {
    let t8 = me(e8.outShape, "int32"), o8 = e8.strideDepth, n8 = e8.strideHeight, s = e8.strideWidth, a = e8.dilationDepth, i10 = e8.dilationHeight, p = e8.dilationWidth, u = e8.effectiveFilterDepth, c = e8.effectiveFilterHeight, l = e8.effectiveFilterWidth, m = e8.padInfo.front, d = e8.padInfo.top, f = e8.padInfo.left;
    for (let h = 0; h < e8.batchSize; ++h)
      for (let g = 0; g < e8.inChannels; ++g)
        for (let x = 0; x < e8.outDepth; ++x) {
          let b = x * o8 - m, C = b;
          for (; C < 0; )
            C += a;
          let S = Math.min(e8.inDepth, u + b);
          for (let k = 0; k < e8.outHeight; ++k) {
            let _ = k * n8 - d, E = _;
            for (; E < 0; )
              E += i10;
            let R = Math.min(e8.inHeight, c + _);
            for (let D = 0; D < e8.outWidth; ++D) {
              let P = D * s - f, O = P;
              for (; O < 0; )
                O += p;
              let M = Math.min(e8.inWidth, l + P), L = Number.NEGATIVE_INFINITY, B = -1;
              for (let z = C; z < S; z += a) {
                let U = z - b;
                for (let j = E; j < R; j += i10) {
                  let q = j - _;
                  for (let Y = O; Y < M; Y += p) {
                    let J = Y - P, re = r8.get(h, z, j, Y, g);
                    re >= L && (L = re, B = U * c * l + q * c + J);
                  }
                }
              }
              t8.set(B, h, x, k, D, g);
            }
          }
        }
    return t8;
  }
  function mY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8;
    Q(n8, "avgPool");
    let { filterSize: s, strides: a, pad: i10, dimRoundingMode: p } = o8, u = 1;
    y.assert(w.eitherStridesOrDilationsAreOne(a, u), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
    let c = w.computePool2DInfo(n8.shape, s, a, u, i10, p), l;
    if (c.filterWidth === 1 && c.filterHeight === 1 && y.arraysEqual(c.inShape, c.outShape))
      l = lr({ inputs: { x: n8 }, backend: t8 });
    else {
      let m = t8.data.get(n8.dataId).values, d = y.computeStrides(n8.shape), f = vc(m, n8.shape, n8.dtype, d, c, "avg");
      l = t8.makeTensorInfo(c.outShape, n8.dtype, f.values);
    }
    return l;
  }
  var K_ = { kernelName: Qo, backendName: "cpu", kernelFunc: mY };
  function dY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dimRoundingMode: p, dataFormat: u } = o8;
    Q(n8, "avgPool3d");
    let c = w.computePool3DInfo(n8.shape, s, a, 1, i10, p, u), l = t8.data.get(n8.dataId).values, m = Lf(l, n8.shape, n8.dtype, y.computeStrides(n8.shape), c, "avg");
    return t8.makeTensorInfo(m.shape, "float32", m.values);
  }
  var q_ = { kernelName: Qs, backendName: "cpu", kernelFunc: dY };
  function fY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, { filterSize: a, strides: i10, pad: p, dimRoundingMode: u } = o8;
    Q([n8, s], "avgPool3DGrad");
    let c = w.computePool3DInfo(s.shape, a, i10, 1, p, u), l = c.strideDepth, m = c.strideHeight, d = c.strideWidth, f = c.filterDepth, h = c.filterHeight, g = c.filterWidth, x = c.dilationDepth, b = c.dilationHeight, C = c.dilationWidth, S = c.effectiveFilterDepth, k = c.effectiveFilterHeight, _ = c.effectiveFilterWidth, E = S - 1 - c.padInfo.front, R = _ - 1 - c.padInfo.left, D = k - 1 - c.padInfo.top, P = me(s.shape, "float32"), O = 1 / (f * h * g), M = t8.bufferSync(n8);
    for (let L = 0; L < c.batchSize; ++L)
      for (let B = 0; B < c.inChannels; ++B)
        for (let z = 0; z < c.inDepth; ++z)
          for (let U = 0; U < c.inHeight; ++U)
            for (let j = 0; j < c.inWidth; ++j) {
              let q = z - E, Y = U - D, J = j - R, re = 0;
              for (let ne = 0; ne < S; ne += x) {
                let ee = (q + ne) / l;
                if (!(ee < 0 || ee >= c.outDepth || Math.floor(ee) !== ee))
                  for (let oe = 0; oe < k; oe += b) {
                    let ie = (Y + oe) / m;
                    if (!(ie < 0 || ie >= c.outHeight || Math.floor(ie) !== ie))
                      for (let le = 0; le < _; le += C) {
                        let be = (J + le) / d;
                        if (be < 0 || be >= c.outWidth || Math.floor(be) !== be)
                          continue;
                        let _e = M.get(L, ee, ie, be, B);
                        re += _e;
                      }
                  }
              }
              P.set(re * O, L, z, U, j, B);
            }
    return t8.makeTensorInfo(P.shape, P.dtype, P.values);
  }
  var j_ = { kernelName: Ei, backendName: "cpu", kernelFunc: fY };
  function hY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, a = s;
    Q([n8, s], "avgPoolGrad");
    let { filterSize: i10, strides: p, pad: u } = o8, c = w.computePool2DInfo(a.shape, i10, p, 1, u), l = c.strideHeight, m = c.strideWidth, d = c.filterHeight, f = c.filterWidth, h = c.dilationHeight, g = c.dilationWidth, x = c.effectiveFilterHeight, b = c.effectiveFilterWidth, C = b - 1 - c.padInfo.left, S = x - 1 - c.padInfo.top, k = me(a.shape, "float32"), _ = 1 / (d * f), E = t8.data.get(n8.dataId).values, R = me(n8.shape, "float32", E);
    for (let D = 0; D < c.batchSize; ++D)
      for (let P = 0; P < c.inChannels; ++P)
        for (let O = 0; O < c.inHeight; ++O)
          for (let M = 0; M < c.inWidth; ++M) {
            let L = O - S, B = M - C, z = 0;
            for (let U = 0; U < x; U += h) {
              let j = (L + U) / l;
              if (!(j < 0 || j >= c.outHeight || Math.floor(j) !== j))
                for (let q = 0; q < b; q += g) {
                  let Y = (B + q) / m;
                  if (Y < 0 || Y >= c.outWidth || Math.floor(Y) !== Y)
                    continue;
                  let J = R.get(D, j, Y, P);
                  z += J;
                }
            }
            k.set(z * _, D, O, M, P);
          }
    return t8.makeTensorInfo(k.shape, k.dtype, k.values);
  }
  var X_ = { kernelName: $i, backendName: "cpu", kernelFunc: hY };
  function gY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, scale: s, offset: a, mean: i10, variance: p } = e8;
    y.assert(i10.shape.length === p.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), y.assert(a == null || i10.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), y.assert(s == null || i10.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), Q([n8, i10, p, s, a], "batchNorm");
    let { varianceEpsilon: u } = o8;
    u == null && (u = 1e-3);
    let c = t8.data.get(n8.dataId).values, l = t8.data.get(i10.dataId).values, m = t8.data.get(p.dataId).values, d = s ? t8.data.get(s.dataId).values : new Float32Array([1]), f = a ? t8.data.get(a.dataId).values : new Float32Array([0]), h = new Float32Array(c.length), g = f.length, x = d.length, b = m.length, C = l.length, S = 0, k = 0, _ = 0, E = 0;
    for (let R = 0; R < c.length; ++R)
      h[R] = f[S++] + (c[R] - l[k++]) * d[_++] / Math.sqrt(m[E++] + u), S >= g && (S = 0), k >= C && (k = 0), _ >= x && (_ = 0), E >= b && (E = 0);
    return t8.makeTensorInfo(n8.shape, n8.dtype, h);
  }
  var Y_ = { kernelName: In, backendName: "cpu", kernelFunc: gY };
  function xY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, crops: a } = o8;
    Q([n8], "batchToSpaceND");
    let i10 = s.reduce((x, b) => x * b), p = w.getReshaped(n8.shape, s, i10), u = w.getPermuted(p.length, s.length), c = w.getReshapedPermuted(n8.shape, s, i10), l = w.getSliceBeginCoords(a, s.length), m = w.getSliceSize(c, a, s.length), d = Ve({ inputs: { x: n8 }, backend: t8, attrs: { shape: p } }), f = It({ inputs: { x: d }, backend: t8, attrs: { perm: u } }), h = Ve({ inputs: { x: f }, backend: t8, attrs: { shape: c } }), g = Ao({ inputs: { x: h }, backend: t8, attrs: { begin: l, size: m } });
    return t8.disposeIntermediateTensorInfo(d), t8.disposeIntermediateTensorInfo(f), t8.disposeIntermediateTensorInfo(h), g;
  }
  var Q_ = { kernelName: Zs, backendName: "cpu", kernelFunc: xY };
  function yY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, weights: s } = e8, { size: a } = o8, i10 = t8.data.get(n8.dataId).values, p = t8.data.get(s.dataId).values, u = bc(i10, p, s.dtype, s.shape, a);
    return t8.makeTensorInfo([a], s.dtype, u);
  }
  var Z_ = { kernelName: Jo, backendName: "cpu", kernelFunc: yY };
  function bY(r8) {
    let { inputs: e8, backend: t8 } = r8, { s0: o8, s1: n8 } = e8, s = t8.data.get(o8.dataId).values, a = t8.data.get(n8.dataId).values, i10 = w.assertAndGetBroadcastShape(Array.from(s), Array.from(a));
    return t8.makeTensorInfo([i10.length], "int32", Int32Array.from(i10));
  }
  var J_ = { kernelName: Js, backendName: "cpu", kernelFunc: bY };
  var CY = Ie(bo, (r8, e8) => {
    let t8 = e8;
    return r8 > t8.clipValueMax ? t8.clipValueMax : r8 < t8.clipValueMin ? t8.clipValueMin : r8;
  });
  var e$ = { kernelName: bo, backendName: "cpu", kernelFunc: CY };
  var wY = (r8) => {
    let { x: e8 } = r8.inputs, t8 = r8.backend, o8 = new Float32Array(y.sizeFromShape(e8.shape)), n8 = t8.data.get(e8.dataId), s = n8.complexTensorInfos.real, a = n8.complexTensorInfos.imag, i10 = t8.data.get(s.dataId).values, p = t8.data.get(a.dataId).values;
    for (let u = 0; u < i10.length; u++) {
      let c = i10[u], l = p[u];
      o8[u] = Math.hypot(c, l);
    }
    return t8.makeOutput(o8, e8.shape, "float32");
  };
  var t$ = { kernelName: Di, backendName: "cpu", kernelFunc: wY };
  function Fa(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = t8.data.get(o8.dataId).complexTensorInfos.imag, s = t8.data.get(n8.dataId).values;
    return t8.makeTensorInfo(n8.shape, n8.dtype, s);
  }
  var r$ = { kernelName: Vi, backendName: "cpu", kernelFunc: Fa };
  function gu(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { axis: n8 } = o8, s = y.parseAxisParam(n8, e8[0].shape)[0], a = e8.map((h) => h.shape);
    w.assertParamsConsistent(a, s);
    let i10 = w.computeOutShape(e8.map((h) => h.shape), s);
    if (y.sizeFromShape(i10) === 0)
      return t8.makeTensorInfo(i10, e8[0].dtype, []);
    let p = e8.filter((h) => y.sizeFromShape(h.shape) > 0);
    if (p.length === 1)
      return lr({ inputs: { x: p[0] }, backend: t8 });
    if (p[0].dtype === "complex64") {
      let h = p.map((S) => Eo({ inputs: { input: S }, backend: t8 })), g = p.map((S) => Fa({ inputs: { input: S }, backend: t8 })), x = gu({ inputs: h, backend: t8, attrs: { axis: s } }), b = gu({ inputs: g, backend: t8, attrs: { axis: s } }), C = Kt({ inputs: { real: x, imag: b }, backend: t8 });
      return h.forEach((S) => t8.disposeIntermediateTensorInfo(S)), g.forEach((S) => t8.disposeIntermediateTensorInfo(S)), t8.disposeIntermediateTensorInfo(x), t8.disposeIntermediateTensorInfo(b), C;
    }
    let u = p.map((h) => {
      let x = [-1, y.sizeFromShape(h.shape.slice(s))];
      return Ve({ inputs: { x: h }, backend: t8, attrs: { shape: x } });
    }), c = u.map((h) => ({ vals: t8.data.get(h.dataId).values, shape: h.shape }));
    i10 = w.computeOutShape(u.map((h) => h.shape), 1);
    let l = u[0].shape[0] === 1, m = up(c, i10, e8[0].dtype, l), d = w.computeOutShape(p.map((h) => h.shape), s), f = t8.makeTensorInfo(d, e8[0].dtype, m);
    return u.forEach((h) => t8.disposeIntermediateTensorInfo(h)), f;
  }
  var o$ = { kernelName: ea, backendName: "cpu", kernelFunc: gu };
  function cI(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dataFormat: p, dilations: u, dimRoundingMode: c } = o8;
    Q([n8, s], "conv2d");
    let l = w.convertConv2DDataFormat(p), m = w.computeConv2DInfo(n8.shape, s.shape, a, u, i10, c, false, l), d = m.filterHeight, f = m.filterWidth, h = m.dilationHeight, g = m.dilationWidth, x = m.padInfo.left, b = m.padInfo.top, C = m.dataFormat === "channelsLast", S = new tt(m.outShape, n8.dtype), k = y.computeStrides(n8.shape), _ = y.computeStrides(s.shape), E = k[0], R = C ? k[1] : k[2], D = C ? k[2] : 1, P = C ? 1 : k[1], O = S.strides[0], M = C ? S.strides[1] : S.strides[2], L = C ? S.strides[2] : 1, B = C ? 1 : S.strides[1], z = t8.data.get(n8.dataId).values, U = t8.data.get(s.dataId).values, j = S.values;
    for (let q = 0; q < m.batchSize; ++q) {
      let Y = q * E, J = q * O;
      for (let re = 0; re < m.outHeight; ++re) {
        let ne = J + re * M, ee = re * m.strideHeight - b;
        for (let oe = 0; oe < d; ++oe) {
          let ie = ee + oe * h;
          if (ie < 0 || ie >= m.inHeight)
            continue;
          let le = oe * _[0], be = Y + ie * R;
          for (let _e = 0; _e < m.outWidth; ++_e) {
            let ve = ne + _e * L, Fe = _e * m.strideWidth - x;
            for (let Pe = 0; Pe < f; ++Pe) {
              let st = Fe + Pe * g;
              if (st < 0 || st >= m.inWidth)
                continue;
              let lt = le + Pe * _[1], Ue = be + st * D, mt = lt;
              for (let it = 0; it < m.inChannels; ++it) {
                let gt = z[Ue + it * P];
                for (let xt = 0; xt < m.outChannels; ++xt)
                  j[ve + xt * B] += gt * U[mt + xt];
                mt += m.outChannels;
              }
            }
          }
        }
      }
    }
    return t8.makeTensorInfo(S.shape, S.dtype, j);
  }
  var n$ = { kernelName: tn, backendName: "cpu", kernelFunc: cI };
  function SY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, pad: i10, dataFormat: p, dimRoundingMode: u, filterShape: c } = o8;
    Q([n8, s], "conv2dBackpropFilter");
    let l = w.convertConv2DDataFormat(p), m = w.computeConv2DInfo(n8.shape, c, a, 1, i10, u, false, l), { strideHeight: d, strideWidth: f, filterHeight: h, filterWidth: g } = m, x = m.dataFormat === "channelsLast", b = new tt(m.filterShape, "float32"), C = m.padInfo.left, S = m.padInfo.top, k = t8.data.get(n8.dataId).values, _ = t8.data.get(s.dataId).values, E = new tt(n8.shape, n8.dtype, k), R = new tt(s.shape, s.dtype, _);
    for (let D = 0; D < h; ++D) {
      let P = Math.max(0, Math.ceil((S - D) / d)), O = Math.min(m.outHeight, (m.inHeight + S - D) / d);
      for (let M = 0; M < g; ++M) {
        let L = Math.max(0, Math.ceil((C - M) / f)), B = Math.min(m.outWidth, (m.inWidth + C - M) / f);
        for (let z = 0; z < m.inChannels; ++z)
          for (let U = 0; U < m.outChannels; ++U) {
            let j = 0;
            for (let q = 0; q < m.batchSize; ++q)
              for (let Y = P; Y < O; ++Y) {
                let J = D + Y * d - S;
                for (let re = L; re < B; ++re) {
                  let ne = M + re * f - C;
                  x ? j += E.get(q, J, ne, z) * R.get(q, Y, re, U) : j += E.get(q, z, J, ne) * R.get(q, U, Y, re);
                }
              }
            b.set(j, D, M, z, U);
          }
      }
    }
    return t8.makeTensorInfo(b.shape, b.dtype, b.values);
  }
  var s$ = { kernelName: Ai, backendName: "cpu", kernelFunc: SY };
  function IY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { inputShape: a, strides: i10, pad: p, dataFormat: u, dimRoundingMode: c } = o8;
    Q([n8, s], "conv2dBackpropInput");
    let l = y.computeStrides(s.shape), m = y.computeStrides(n8.shape), d = w.convertConv2DDataFormat(u), f = w.computeConv2DInfo(a, s.shape, i10, 1, p, c, false, d), h = new tt(f.inShape, "float32"), g = h.values, x = t8.data.get(n8.dataId).values, b = t8.data.get(s.dataId).values, [C, S, k] = l, { batchSize: _, filterHeight: E, filterWidth: R, inChannels: D, inHeight: P, inWidth: O, outChannels: M, outHeight: L, outWidth: B, strideHeight: z, strideWidth: U } = f;
    d = f.dataFormat;
    let j = E - 1 - f.padInfo.top, q = R - 1 - f.padInfo.left, Y = d === "channelsLast", J = h.strides[0], re = Y ? h.strides[1] : h.strides[2], ne = Y ? h.strides[2] : 1, ee = Y ? 1 : h.strides[1], oe = m[0], ie = Y ? m[1] : m[2], le = Y ? m[2] : 1, be = Y ? 1 : m[1];
    for (let _e = 0; _e < _; ++_e)
      for (let ve = 0; ve < D; ++ve)
        for (let Fe = 0; Fe < P; ++Fe) {
          let Pe = Fe - j, st = Math.max(0, Math.ceil(Pe / z)), lt = Math.min(L, (E + Pe) / z);
          for (let Ue = 0; Ue < O; ++Ue) {
            let mt = Ue - q, it = Math.max(0, Math.ceil(mt / U)), gt = Math.min(B, (R + mt) / U), xt = 0;
            for (let Mt = st; Mt < lt; ++Mt) {
              let eo = Mt * z - Pe;
              for (let or = it; or < gt; ++or) {
                let Tt = or * U - mt, nr = oe * _e + ie * Mt + le * or, sr = C * (E - 1 - eo) + S * (R - 1 - Tt) + k * ve;
                for (let to = 0; to < M; ++to) {
                  let ro = x[nr + be * to], fr = b[sr + to];
                  xt += ro * fr;
                }
              }
            }
            let Lr = J * _e + re * Fe + ne * Ue + ee * ve;
            g[Lr] = xt;
          }
        }
    return t8.makeTensorInfo(h.shape, h.dtype, h.values);
  }
  var a$ = { kernelName: rn, backendName: "cpu", kernelFunc: IY };
  function vY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p } = o8;
    Q([n8, s], "conv3d");
    let u = w.computeConv3DInfo(n8.shape, s.shape, a, p, i10), { filterDepth: c, filterHeight: l, filterWidth: m, dilationDepth: d, dilationHeight: f, dilationWidth: h, padInfo: g } = u, x = g.front, b = g.left, C = g.top, S = new tt(u.outShape, n8.dtype), k = t8.data.get(n8.dataId).values, _ = t8.data.get(s.dataId).values, E = S.values, R = y.computeStrides(n8.shape), D = y.computeStrides(s.shape);
    for (let P = 0; P < u.batchSize; ++P) {
      let O = P * R[0], M = P * S.strides[0];
      for (let L = 0; L < u.outDepth; ++L) {
        let B = M + L * S.strides[1], z = L * u.strideDepth - x;
        for (let U = 0; U < c; ++U) {
          let j = z + U * d;
          if (j < 0 || j >= u.inDepth)
            continue;
          let q = U * D[0], Y = O + j * R[1];
          for (let J = 0; J < u.outHeight; ++J) {
            let re = B + J * S.strides[2], ne = J * u.strideHeight - C;
            for (let ee = 0; ee < l; ++ee) {
              let oe = ne + ee * f;
              if (oe < 0 || oe >= u.inHeight)
                continue;
              let ie = q + ee * D[1], le = Y + oe * R[2];
              for (let be = 0; be < u.outWidth; ++be) {
                let _e = re + be * u.outChannels, ve = be * u.strideWidth - b;
                for (let Fe = 0; Fe < m; ++Fe) {
                  let Pe = ve + Fe * h;
                  if (Pe < 0 || Pe >= u.inWidth)
                    continue;
                  let st = ie + Fe * D[2], lt = le + Pe * u.inChannels, Ue = st;
                  for (let mt = 0; mt < u.inChannels; ++mt) {
                    let it = k[lt + mt];
                    for (let gt = 0; gt < u.outChannels; ++gt)
                      E[_e + gt] += it * _[Ue + gt];
                    Ue += u.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }
    return t8.makeTensorInfo(S.shape, S.dtype, S.values);
  }
  var i$ = { kernelName: on, backendName: "cpu", kernelFunc: vY };
  function kY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, pad: i10, filterShape: p } = o8;
    Q([n8, s], "conv3dBackpropFilterV2");
    let u = y.computeStrides(n8.shape), c = y.computeStrides(s.shape), l = w.computeConv3DInfo(n8.shape, p, a, 1, i10), m = l.strideDepth, d = l.strideHeight, f = l.strideWidth, h = l.filterDepth, g = l.filterHeight, x = l.filterWidth, b = new tt(l.filterShape, "float32"), C = b.values, [S, k, _, E] = b.strides, R = t8.data.get(s.dataId).values, [D, P, O, M] = c, L = t8.data.get(n8.dataId).values, [B, z, U, j] = u, q = l.padInfo.front, Y = l.padInfo.left, J = l.padInfo.top;
    for (let re = 0; re < h; ++re) {
      let ne = Math.max(0, Math.ceil((q - re) / m)), ee = Math.min(l.outDepth, (l.inDepth + q - re) / m), oe = re * S;
      for (let ie = 0; ie < g; ++ie) {
        let le = Math.max(0, Math.ceil((J - ie) / d)), be = Math.min(l.outHeight, (l.inHeight + J - ie) / d), _e = ie * k + oe;
        for (let ve = 0; ve < x; ++ve) {
          let Fe = Math.max(0, Math.ceil((Y - ve) / f)), Pe = Math.min(l.outWidth, (l.inWidth + Y - ve) / f), st = ve * _ + _e;
          for (let lt = 0; lt < l.inChannels; ++lt) {
            let Ue = lt * E + st;
            for (let mt = 0; mt < l.outChannels; ++mt) {
              let it = 0;
              for (let gt = 0; gt < l.batchSize; ++gt) {
                let xt = gt * B, Lr = gt * D;
                for (let Mt = ne; Mt < ee; ++Mt) {
                  let or = (re + Mt * m - q) * z + xt, Tt = Mt * P + Lr;
                  for (let nr = le; nr < be; ++nr) {
                    let to = (ie + nr * d - J) * U + or, ro = nr * O + Tt;
                    for (let fr = Fe; fr < Pe; ++fr) {
                      let Lo = (ve + fr * f - Y) * j + to, Hs = fr * M + ro;
                      it += L[Lo + lt] * R[Hs + mt];
                    }
                  }
                }
              }
              C[Ue + mt] = it;
            }
          }
        }
      }
    }
    return t8.makeTensorInfo(b.shape, b.dtype, b.values);
  }
  var u$ = { kernelName: Ka, backendName: "cpu", kernelFunc: kY };
  function NY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { pad: a, strides: i10, inputShape: p } = o8;
    Q([n8], "conv3dBackpropInputV2");
    let u = y.computeStrides(n8.shape), c = y.computeStrides(s.shape), l = w.computeConv3DInfo(p, s.shape, i10, 1, a), m = new tt(l.inShape, "float32"), d = m.values, [f, h, g, x] = m.strides, b = t8.data.get(n8.dataId).values, [C, S, k, _] = u, E = t8.data.get(s.dataId).values, [R, D, P, O] = c, { batchSize: M, filterDepth: L, filterHeight: B, filterWidth: z, inChannels: U, inDepth: j, inHeight: q, inWidth: Y, outChannels: J, outDepth: re, outHeight: ne, outWidth: ee, strideDepth: oe, strideHeight: ie, strideWidth: le } = l, be = L - 1 - l.padInfo.front, _e = B - 1 - l.padInfo.top, ve = z - 1 - l.padInfo.left;
    for (let Fe = 0; Fe < M; ++Fe)
      for (let Pe = 0; Pe < U; ++Pe)
        for (let st = 0; st < j; ++st) {
          let lt = st - be, Ue = Math.max(0, Math.ceil(lt / oe)), mt = Math.min(re, (L + lt) / oe);
          for (let it = 0; it < q; ++it) {
            let gt = it - _e, xt = Math.max(0, Math.ceil(gt / ie)), Lr = Math.min(ne, (B + gt) / ie);
            for (let Mt = 0; Mt < Y; ++Mt) {
              let eo = Mt - ve, or = Math.max(0, Math.ceil(eo / le)), Tt = Math.min(ee, (z + eo) / le), nr = 0;
              for (let sr = Ue; sr < mt; ++sr) {
                let to = sr * oe - lt;
                for (let ro = xt; ro < Lr; ++ro) {
                  let fr = ro * ie - gt;
                  for (let Ba = or; Ba < Tt; ++Ba) {
                    let Lo = Ba * le - eo, Hs = C * Fe + S * sr + k * ro + _ * Ba, Yt = R * (L - 1 - to) + D * (B - 1 - fr) + P * (z - 1 - Lo) + O * Pe;
                    for (let za = 0; za < J; ++za) {
                      let tl = b[Hs + za], rl = E[Yt + za];
                      nr += tl * rl;
                    }
                  }
                }
              }
              d[f * Fe + h * st + g * it + x * Mt + Pe] = nr;
            }
          }
        }
    return t8.makeTensorInfo(m.shape, m.dtype, m.values);
  }
  var p$ = { kernelName: nn, backendName: "cpu", kernelFunc: NY };
  var TY = Ie(sn, (r8) => Math.cos(r8));
  var c$ = { kernelName: sn, backendName: "cpu", kernelFunc: TY };
  var _Y = Ie(an, (r8) => Math.cosh(r8));
  var l$ = { kernelName: an, backendName: "cpu", kernelFunc: _Y };
  function $Y(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { image: n8, boxes: s, boxInd: a } = e8, { cropSize: i10, method: p, extrapolationValue: u } = o8, [c, l, m, d] = n8.shape, f = s.shape[0], [h, g] = i10, x = me([f, h, g, d], "float32"), b = t8.data.get(s.dataId).values, C = t8.data.get(a.dataId).values, S = t8.data.get(n8.dataId).values, k = y.computeStrides(n8.shape), _ = y.computeStrides(x.shape);
    for (let E = 0; E < f; E++) {
      let R = E * 4, D = b[R], P = b[R + 1], O = b[R + 2], M = b[R + 3], L = C[E];
      if (L >= c)
        continue;
      let B = h > 1 ? (O - D) * (l - 1) / (h - 1) : 0, z = g > 1 ? (M - P) * (m - 1) / (g - 1) : 0;
      for (let U = 0; U < h; U++) {
        let j = h > 1 ? D * (l - 1) + U * B : 0.5 * (D + O) * (l - 1);
        if (j < 0 || j > l - 1) {
          for (let q = 0; q < g; q++)
            for (let Y = 0; Y < d; Y++) {
              let J = Y + q * _[2] + U * _[1] + E * _[0];
              x.values[J] = u;
            }
          continue;
        }
        if (p === "bilinear") {
          let q = Math.floor(j), Y = Math.ceil(j), J = j - q;
          for (let re = 0; re < g; re++) {
            let ne = g > 1 ? P * (m - 1) + re * z : 0.5 * (P + M) * (m - 1);
            if (ne < 0 || ne > m - 1) {
              for (let le = 0; le < d; le++) {
                let be = le + re * _[2] + U * _[1] + E * _[0];
                x.values[be] = u;
              }
              continue;
            }
            let ee = Math.floor(ne), oe = Math.ceil(ne), ie = ne - ee;
            for (let le = 0; le < d; le++) {
              let be = le + ee * k[2] + q * k[1] + L * k[0], _e = S[be];
              be = le + oe * k[2] + q * k[1] + L * k[0];
              let ve = S[be];
              be = le + ee * k[2] + Y * k[1] + L * k[0];
              let Fe = S[be];
              be = le + oe * k[2] + Y * k[1] + L * k[0];
              let Pe = S[be], st = _e + (ve - _e) * ie, lt = Fe + (Pe - Fe) * ie;
              be = le + re * _[2] + U * _[1] + E * _[0], x.values[be] = st + (lt - st) * J;
            }
          }
        } else
          for (let q = 0; q < g; ++q) {
            let Y = g > 1 ? P * (m - 1) + q * z : 0.5 * (P + M) * (m - 1);
            if (Y < 0 || Y > m - 1) {
              for (let ne = 0; ne < d; ne++) {
                let ee = ne + q * _[2] + U * _[1] + E * _[0];
                x.values[ee] = u;
              }
              continue;
            }
            let J = Math.round(Y), re = Math.round(j);
            for (let ne = 0; ne < d; ne++) {
              let ee = ne + J * k[2] + re * k[1] + L * k[0], oe = ne + q * _[2] + U * _[1] + E * _[0];
              x.values[oe] = S[ee];
            }
          }
      }
    }
    return t8.makeTensorInfo(x.shape, x.dtype, x.values);
  }
  var m$ = { kernelName: cn, backendName: "cpu", kernelFunc: $Y };
  function EY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8;
    Q(n8, "cumprod");
    let p = w.getAxesPermutation([s], n8.shape.length), u = n8;
    p != null && (u = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: p } }));
    let c = w.getInnerMostAxes(1, n8.shape.length)[0];
    if (c !== u.shape.length - 1)
      throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length - 1} but got axis=${c}`);
    let l = dt(u.dtype, "int32"), m = y.makeOnesTypedArray(y.sizeFromShape(u.shape), l), d = t8.data.get(u.dataId).values, f = u.shape[u.shape.length - 1], h = i10 ? (x, b) => x + f - b - 1 : (x, b) => x + b;
    for (let x = 0; x < d.length; x += f)
      for (let b = 0; b < f; b++) {
        let C = h(x, b);
        if (b === 0)
          m[C] = a ? 1 : d[C];
        else {
          let S = h(x, b - 1);
          m[C] = a ? d[S] * m[S] : d[C] * m[S];
        }
      }
    let g = t8.makeTensorInfo(u.shape, l, m);
    if (p != null) {
      let x = w.getUndoAxesPermutation(p), b = It({ inputs: { x: g }, backend: t8, attrs: { perm: x } });
      return t8.disposeIntermediateTensorInfo(g), t8.disposeIntermediateTensorInfo(u), b;
    }
    return g;
  }
  var d$ = { kernelName: un, backendName: "cpu", kernelFunc: EY };
  function RY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8;
    Q(n8, "cumsum");
    let p = w.getAxesPermutation([s], n8.shape.length), u = n8;
    p != null && (u = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: p } }));
    let c = w.getInnerMostAxes(1, n8.shape.length)[0];
    if (c !== u.shape.length - 1)
      throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length - 1} but got axis=${c}`);
    let l = dt(u.dtype, "int32"), m = y.makeZerosTypedArray(y.sizeFromShape(u.shape), l), d = t8.data.get(u.dataId).values, f = u.shape[u.shape.length - 1], h = i10 ? (x, b) => x + f - b - 1 : (x, b) => x + b;
    for (let x = 0; x < d.length; x += f)
      for (let b = 0; b < f; b++) {
        let C = h(x, b);
        if (b === 0)
          m[C] = a ? 0 : d[C];
        else {
          let S = h(x, b - 1);
          m[C] = a ? d[S] + m[S] : d[C] + m[S];
        }
      }
    let g = t8.makeTensorInfo(u.shape, l, m);
    if (p != null) {
      let x = w.getUndoAxesPermutation(p), b = It({ inputs: { x: g }, backend: t8, attrs: { perm: x } });
      return t8.disposeIntermediateTensorInfo(g), t8.disposeIntermediateTensorInfo(u), b;
    }
    return g;
  }
  var f$ = { kernelName: pn, backendName: "cpu", kernelFunc: RY };
  function DY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, weights: s } = e8, { size: a, binaryOutput: i10 } = o8;
    if (n8.shape.length === 1) {
      let p = t8.data.get(n8.dataId).values, u = t8.data.get(s.dataId).values, c = bc(p, u, s.dtype, s.shape, a);
      return t8.makeTensorInfo([a], s.dtype, c);
    } else if (n8.shape.length === 2) {
      let p = t8.bufferSync(n8), u = t8.bufferSync(s), c = vf(p, u, a, i10);
      return t8.makeTensorInfo(c.shape, s.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n8.shape.length}.`);
  }
  var h$ = { kernelName: ta, backendName: "cpu", kernelFunc: DY };
  function AY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockSize: s, dataFormat: a } = o8;
    y.assert(a === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);
    let i10 = n8.shape[0], p = n8.shape[1], u = n8.shape[2], c = n8.shape[3], l = p * s, m = u * s, d = c / (s * s), f = t8.data.get(n8.dataId).values, h = new Float32Array(i10 * l * m * d), g = 0;
    for (let x = 0; x < i10; ++x)
      for (let b = 0; b < l; ++b) {
        let C = Math.floor(b / s), S = b % s;
        for (let k = 0; k < m; ++k) {
          let _ = Math.floor(k / s), E = k % s, R = (S * s + E) * d;
          for (let D = 0; D < d; ++D) {
            let O = D + R + c * (_ + u * (C + p * x));
            h[g++] = f[O];
          }
        }
      }
    return t8.makeTensorInfo([i10, l, m, d], n8.dtype, h);
  }
  var g$ = { kernelName: ln, backendName: "cpu", kernelFunc: AY };
  function lI(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p, dimRoundingMode: u } = o8;
    Q([n8, s], "depthwiseConv2DNative");
    let c = y.computeStrides(n8.shape), l = y.computeStrides(s.shape), m = p;
    m == null && (m = [1, 1]), y.assert(w.eitherStridesOrDilationsAreOne(a, m), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);
    let d = w.computeConv2DInfo(n8.shape, s.shape, a, m, i10, u, true), { filterHeight: f, filterWidth: h, dilationHeight: g, dilationWidth: x, padInfo: b } = d, C = b.left, S = b.top, k = d.outChannels / d.inChannels, _ = new tt(d.outShape, n8.dtype), E = t8.data.get(n8.dataId).values, R = t8.data.get(s.dataId).values, D = _.values;
    for (let P = 0; P < d.batchSize; ++P) {
      let O = P * c[0], M = P * _.strides[0];
      for (let L = 0; L < d.outHeight; ++L) {
        let B = M + L * _.strides[1], z = L * d.strideHeight - S;
        for (let U = 0; U < f; ++U) {
          let j = z + U * g;
          if (j < 0 || j >= d.inHeight)
            continue;
          let q = U * l[0], Y = O + j * c[1];
          for (let J = 0; J < d.outWidth; ++J) {
            let re = B + J * _.strides[2], ne = J * d.strideWidth - C;
            for (let ee = 0; ee < h; ++ee) {
              let oe = ne + ee * x;
              if (oe < 0 || oe >= d.inWidth)
                continue;
              let ie = q + ee * l[1], le = Y + oe * d.inChannels, be = re, _e = ie;
              for (let ve = 0; ve < d.inChannels; ++ve) {
                let Fe = E[le + ve];
                for (let Pe = 0; Pe < k; ++Pe)
                  D[be + Pe] += Fe * R[_e + Pe];
                be += k, _e += k;
              }
            }
          }
        }
      }
    }
    return t8.makeTensorInfo(_.shape, _.dtype, _.values);
  }
  var x$ = { kernelName: mn, backendName: "cpu", kernelFunc: lI };
  function FY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, dilations: i10, pad: p, dimRoundingMode: u, filterShape: c } = o8;
    Q([n8, s], "depthwiseConv2dNativeBackpropFilter");
    let l = w.computeConv2DInfo(n8.shape, c, a, i10, p, u, true), { strideHeight: m, strideWidth: d, filterHeight: f, filterWidth: h } = l, g = new tt(l.filterShape, "float32"), x = l.padInfo.left, b = l.padInfo.top, C = l.outChannels / l.inChannels, S = t8.data.get(n8.dataId).values, k = new tt(n8.shape, n8.dtype, S), _ = t8.data.get(s.dataId).values, E = new tt(s.shape, s.dtype, _);
    for (let R = 0; R < f; ++R) {
      let D = Math.max(0, Math.ceil((b - R) / m)), P = Math.min(l.outHeight, (l.inHeight + b - R) / m);
      for (let O = 0; O < h; ++O) {
        let M = Math.max(0, Math.ceil((x - O) / d)), L = Math.min(l.outWidth, (l.inWidth + x - O) / d);
        for (let B = 0; B < l.outChannels; ++B) {
          let z = Math.trunc(B / C), U = B % C, j = 0;
          for (let q = 0; q < l.batchSize; ++q)
            for (let Y = D; Y < P; ++Y) {
              let J = R + Y * m - b;
              for (let re = M; re < L; ++re) {
                let ne = O + re * d - x;
                j += k.get(q, J, ne, z) * E.get(q, Y, re, B);
              }
            }
          g.set(j, R, O, z, U);
        }
      }
    }
    return t8.makeTensorInfo(g.shape, g.dtype, g.values);
  }
  var y$ = { kernelName: Fi, backendName: "cpu", kernelFunc: FY };
  function PY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { strides: a, dilations: i10, pad: p, dimRoundingMode: u, inputShape: c } = o8;
    Q([n8, s], "depthwiseConv2DNativeBackpropInput");
    let l = y.computeStrides(n8.shape), m = y.computeStrides(s.shape), d = w.computeConv2DInfo(c, s.shape, a, i10, p, u, true), f = new tt(d.inShape, "float32"), h = f.values, [g, x, b] = f.strides, C = t8.data.get(n8.dataId).values, [S, k, _] = l, E = t8.data.get(s.dataId).values, [R, D, P] = m, { batchSize: O, filterHeight: M, filterWidth: L, inChannels: B, inHeight: z, inWidth: U, outChannels: j, outHeight: q, outWidth: Y, strideHeight: J, strideWidth: re } = d, ne = M - 1 - d.padInfo.top, ee = L - 1 - d.padInfo.left, oe = j / B;
    for (let ie = 0; ie < O; ++ie)
      for (let le = 0; le < B; ++le)
        for (let be = 0; be < z; ++be) {
          let _e = be - ne, ve = Math.max(0, Math.ceil(_e / J)), Fe = Math.min(q, (M + _e) / J);
          for (let Pe = 0; Pe < U; ++Pe) {
            let st = Pe - ee, lt = Math.max(0, Math.ceil(st / re)), Ue = Math.min(Y, (L + st) / re), mt = 0;
            for (let it = ve; it < Fe; ++it) {
              let gt = it * J - _e;
              for (let xt = lt; xt < Ue; ++xt) {
                let Lr = xt * re - st, Mt = S * ie + k * it + _ * xt, eo = R * (M - 1 - gt) + D * (L - 1 - Lr) + P * le;
                for (let or = 0; or < oe; ++or) {
                  let Tt = le * oe + or, nr = C[Mt + Tt], sr = E[eo + or];
                  mt += nr * sr;
                }
              }
            }
            h[g * ie + x * be + b * Pe + le] = mt;
          }
        }
    return t8.makeTensorInfo(f.shape, f.dtype, f.values);
  }
  var b$ = { kernelName: Pi, backendName: "cpu", kernelFunc: PY };
  function OY(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8, n8 = y.sizeFromShape(o8.shape), s = t8.data.get(o8.dataId).values, a = me([n8, n8], o8.dtype), i10 = a.values;
    for (let u = 0; u < s.length; u++)
      i10[u * n8 + u] = s[u];
    let p = [...o8.shape, ...o8.shape];
    return t8.makeTensorInfo(p, a.dtype, a.values);
  }
  var C$ = { kernelName: ra, backendName: "cpu", kernelFunc: OY };
  var w$ = { kernelName: dn, backendName: "cpu", kernelFunc: ({ inputs: r8, backend: e8, attrs: t8 }) => {
    let { x: o8, filter: n8 } = r8, { strides: s, pad: a, dilations: i10 } = t8, p = e8, u = p.data.get(o8.dataId).values, c = o8.shape.length, l = p.data.get(n8.dataId).values, m = n8.shape.length, { batchSize: d, inHeight: f, inWidth: h, inChannels: g, outHeight: x, outWidth: b, padInfo: C, strideHeight: S, strideWidth: k, filterHeight: _, filterWidth: E, dilationHeight: R, dilationWidth: D, outShape: P } = w.computeDilation2DInfo(o8.shape, n8.shape, s, a, "NHWC", i10), O = y.sizeFromShape(P), M = P.length, L = y.getArrayFromDType(o8.dtype, O);
    for (let z = 0; z < d; ++z)
      for (let U = 0; U < x; ++U) {
        let j = U * S - C.top;
        for (let q = 0; q < b; ++q) {
          let Y = q * k - C.left;
          for (let J = 0; J < g; ++J) {
            let re = Number.MIN_SAFE_INTEGER;
            for (let ee = 0; ee < _; ++ee) {
              let oe = j + ee * R;
              if (oe >= 0 && oe < f)
                for (let ie = 0; ie < E; ++ie) {
                  let le = Y + ie * D;
                  if (le >= 0 && le < h) {
                    let be = y.locToIndex([z, oe, le, J], c, y.computeStrides(o8.shape)), _e = y.locToIndex([ee, ie, J], m, y.computeStrides(n8.shape)), ve = u[be] + l[_e];
                    ve > re && (re = ve);
                  }
                }
            }
            let ne = y.locToIndex([z, U, q, J], M, y.computeStrides(P));
            L[ne] = re;
          }
        }
      }
    return { dataId: p.write(y.toTypedArray(L, o8.dtype), P, o8.dtype), shape: P, dtype: o8.dtype };
  } };
  var S$ = { kernelName: Mi, backendName: "cpu", kernelFunc: ({ inputs: r8, backend: e8, attrs: t8 }) => {
    let { x: o8, filter: n8, dy: s } = r8, { strides: a, pad: i10, dilations: p } = t8, u = e8, c = y.toNestedArray(o8.shape, u.data.get(o8.dataId).values), l = y.toNestedArray(n8.shape, u.data.get(n8.dataId).values), { batchSize: m, inHeight: d, inWidth: f, inChannels: h, outHeight: g, outWidth: x, padInfo: b, strideHeight: C, strideWidth: S, filterHeight: k, filterWidth: _, dilationHeight: E, dilationWidth: R, outShape: D } = w.computeDilation2DInfo(o8.shape, n8.shape, a, i10, "NHWC", p);
    y.assert(s.rank === D.length, () => `Error in ${Mi}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);
    let P = y.toNestedArray(D, u.data.get(s.dataId).values), O = y.makeZerosNestedTypedArray(n8.shape, n8.dtype);
    for (let L = 0; L < m; ++L)
      for (let B = 0; B < g; ++B) {
        let z = B * C - b.top;
        for (let U = 0; U < x; ++U) {
          let j = U * S - b.left;
          for (let q = 0; q < h; ++q) {
            let Y = Number.MIN_SAFE_INTEGER, J = 0, re = 0;
            for (let ne = 0; ne < k; ++ne) {
              let ee = z + ne * E;
              if (ee >= 0 && ee < d)
                for (let oe = 0; oe < _; ++oe) {
                  let ie = j + oe * R;
                  if (ie >= 0 && ie < f) {
                    let le = c[L][ee][ie][q] + l[ne][oe][q];
                    le > Y && (Y = le, J = ne, re = oe);
                  }
                }
            }
            O[J][re][q] += P[L][B][U][q];
          }
        }
      }
    return { dataId: u.write(y.toTypedArray(O, o8.dtype), n8.shape, n8.dtype), shape: n8.shape, dtype: n8.dtype };
  } };
  var I$ = { kernelName: Oi, backendName: "cpu", kernelFunc: ({ inputs: r8, backend: e8, attrs: t8 }) => {
    let { x: o8, filter: n8, dy: s } = r8, { strides: a, pad: i10, dilations: p } = t8, u = e8, c = y.toNestedArray(o8.shape, u.data.get(o8.dataId).values), l = y.toNestedArray(n8.shape, u.data.get(n8.dataId).values), { batchSize: m, inHeight: d, inWidth: f, inChannels: h, outHeight: g, outWidth: x, padInfo: b, strideHeight: C, strideWidth: S, filterHeight: k, filterWidth: _, dilationHeight: E, dilationWidth: R, outShape: D } = w.computeDilation2DInfo(o8.shape, n8.shape, a, i10, "NHWC", p);
    y.assert(s.rank === D.length, () => `Error in ${Oi}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);
    let P = y.toNestedArray(D, u.data.get(s.dataId).values), O = y.makeZerosNestedTypedArray(o8.shape, o8.dtype);
    for (let L = 0; L < m; ++L)
      for (let B = 0; B < g; ++B) {
        let z = B * C - b.top;
        for (let U = 0; U < x; ++U) {
          let j = U * S - b.left;
          for (let q = 0; q < h; ++q) {
            let Y = Number.MIN_SAFE_INTEGER, J = z < 0 ? 0 : z, re = j < 0 ? 0 : j;
            for (let ne = 0; ne < k; ++ne) {
              let ee = z + ne * E;
              if (ee >= 0 && ee < d)
                for (let oe = 0; oe < _; ++oe) {
                  let ie = j + oe * R;
                  if (ie >= 0 && ie < f) {
                    let le = c[L][ee][ie][q] + l[ne][oe][q];
                    le > Y && (Y = le, J = ee, re = ie);
                  }
                }
            }
            O[L][J][re][q] += P[L][B][U][q];
          }
        }
      }
    return { dataId: u.write(y.toTypedArray(O, o8.dtype), o8.shape, o8.dtype), shape: o8.shape, dtype: o8.dtype };
  } };
  function MY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { image: n8 } = e8, { canvas: s, options: a } = o8, { contextOptions: i10, imageOptions: p } = a || {}, u = (p == null ? void 0 : p.alpha) || 1, c = (i10 == null ? void 0 : i10.contextType) || "2d";
    if (c !== "2d")
      throw new Error(`Context type ${i10.contextType} is not supported by the CPU backend.`);
    let l = s.getContext(c, (i10 == null ? void 0 : i10.contextAttributes) || {});
    if (l == null)
      throw new Error(`Could not get the context with ${c} type.`);
    let [m, d] = n8.shape.slice(0, 2), f = n8.shape.length === 2 ? 1 : n8.shape[2], h = t8.data.get(n8.dataId).values, g = n8.dtype === "float32" ? 255 : 1, x = new Uint8ClampedArray(d * m * 4);
    for (let C = 0; C < m * d; ++C) {
      let S = [0, 0, 0, 255 * u];
      for (let _ = 0; _ < f; _++) {
        let E = h[C * f + _];
        if (n8.dtype === "float32") {
          if (E < 0 || E > 1)
            throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${E}.`);
        } else if (n8.dtype === "int32" && (E < 0 || E > 255))
          throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${E}.`);
        f === 1 ? (S[0] = E * g, S[1] = E * g, S[2] = E * g) : S[_] = E * g;
      }
      let k = C * 4;
      x[k + 0] = Math.round(S[0]), x[k + 1] = Math.round(S[1]), x[k + 2] = Math.round(S[2]), x[k + 3] = Math.round(S[3]);
    }
    s.width = d, s.height = m;
    let b = new ImageData(x, d, m);
    return l.putImageData(b, 0, 0), n8;
  }
  var v$ = { kernelName: qm, backendName: "cpu", kernelFunc: MY };
  function fi(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    Q(n8, "sum");
    let i10;
    n8.dtype === "bool" ? i10 = Ro({ inputs: { x: n8 }, backend: t8, attrs: { dtype: "int32" } }) : i10 = lr({ inputs: { x: n8 }, backend: t8 });
    let p = i10.shape.length, u = y.parseAxisParam(s, i10.shape), c = w.getAxesPermutation(u, p), l = u, m = i10;
    c != null && (m = It({ inputs: { x: i10 }, backend: t8, attrs: { perm: c } }), l = w.getInnerMostAxes(l.length, p)), w.assertAxesAreInnerMostDims("sum", l, m.shape.length);
    let [d, f] = w.computeOutAndReduceShapes(m.shape, l), h = w.upcastType(m.dtype, "int32"), g = xc(t8, d, h), x = y.sizeFromShape(f), b = t8.data.get(g.dataId).values, C = t8.data.get(m.dataId).values;
    for (let S = 0; S < b.length; ++S) {
      let k = S * x, _ = 0;
      for (let E = 0; E < x; ++E)
        _ += C[k + E];
      b[S] = _;
    }
    if (a) {
      let S = w.expandShapeToKeepDim(g.shape, u), k = g;
      g = Ve({ inputs: { x: g }, backend: t8, attrs: { shape: S } }), t8.disposeIntermediateTensorInfo(k);
    }
    return t8.disposeIntermediateTensorInfo(i10), c != null && t8.disposeIntermediateTensorInfo(m), g;
  }
  var k$ = { kernelName: Ss, backendName: "cpu", kernelFunc: fi };
  function LY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { equation: n8 } = o8, s = e8, { allDims: a, summedDims: i10, idDims: p } = w.decodeEinsumEquation(n8, s.length);
    w.checkEinsumDimSizes(a.length, p, s);
    let { path: u, steps: c } = w.getEinsumComputePath(i10, p), l = c.length, m = null, d = a.length, f = [];
    for (let h = 0; h < l; ++h) {
      for (let g of c[h]) {
        let { permutationIndices: x, expandDims: b } = w.getEinsumPermutation(d, p[g]), C;
        w.isIdentityPermutation(x) ? C = s[g] : (C = It({ inputs: { x: s[g] }, backend: t8, attrs: { perm: x } }), f.push(C));
        let S = C.shape.slice();
        for (let k = 0; k < b.length; ++k)
          S.splice(b[k], 0, 1);
        y.arraysEqual(C.shape, S) || (C = Ve({ inputs: { x: C }, backend: t8, attrs: { shape: S } }), f.push(C)), m === null ? m = C : (m = pp({ inputs: { a: C, b: m }, backend: t8 }), f.push(m));
      }
      h < l - 1 && (u[h] >= 0 && (m = fi({ inputs: { x: m }, backend: t8, attrs: { axis: u[h] - (a.length - d), keepDims: false } }), f.push(m)), d--);
    }
    for (let h of f)
      h !== m && t8.disposeIntermediateTensorInfo(h);
    return m;
  }
  var N$ = { kernelName: Li, backendName: "cpu", kernelFunc: LY };
  function BY(r8) {
    let { inputs: e8, backend: t8 } = r8, { dy: o8, y: n8 } = e8;
    Q([o8, n8], "eluGrad");
    let s = new Float32Array(y.sizeFromShape(n8.shape)), a = t8.data.get(n8.dataId).values, i10 = t8.data.get(o8.dataId).values;
    for (let p = 0; p < a.length; ++p) {
      let u = a[p];
      u >= 0 ? s[p] = i10[p] : s[p] = i10[p] * (u + 1);
    }
    return t8.makeTensorInfo(n8.shape, "float32", s);
  }
  var T$ = { kernelName: qa, backendName: "cpu", kernelFunc: BY };
  var zY = w.ERF_P;
  var VY = w.ERF_A1;
  var WY = w.ERF_A2;
  var UY = w.ERF_A3;
  var GY = w.ERF_A4;
  var HY = w.ERF_A5;
  var KY = Ie(gn, (r8) => {
    let e8 = Math.sign(r8), t8 = Math.abs(r8), o8 = 1 / (1 + zY * t8);
    return e8 * (1 - ((((HY * o8 + GY) * o8 + UY) * o8 + WY) * o8 + VY) * o8 * Math.exp(-t8 * t8));
  });
  var _$ = { kernelName: gn, backendName: "cpu", kernelFunc: KY };
  function kc(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { input: n8 } = e8, { dim: s } = o8, a = n8.shape.length, i10 = n8.shape.slice(), p = s;
    return s < 0 && (y.assert(-(a + 1) <= s, () => `Axis must be in the interval [${-(a + 1)}, ${a}]`), p = a + s + 1), i10.splice(p, 0, 1), Ve({ inputs: { x: n8 }, backend: t8, attrs: { shape: i10 } });
  }
  var $$ = { kernelName: oa, backendName: "cpu", kernelFunc: kc };
  var qY = ze((r8, e8) => r8 / e8);
  var zl = Ye(fn, qY);
  var Vl = { kernelName: fn, backendName: "cpu", kernelFunc: zl };
  function Bf(r8, e8, t8) {
    let o8 = r8.shape, n8 = o8[0], s = o8[1], a = t8.data.get(r8.dataId), i10 = a.complexTensorInfos.real, p = a.complexTensorInfos.imag, u = [n8, s], c = y.sizeFromShape(u), l = y.getTypedArrayFromDType("float32", c), m = y.getTypedArrayFromDType("float32", c);
    for (let g = 0; g < n8; g++) {
      let x = Ao({ inputs: { x: i10 }, backend: t8, attrs: { begin: [g, 0], size: [1, s] } }), b = Ao({ inputs: { x: p }, backend: t8, attrs: { begin: [g, 0], size: [1, s] } }), C = Kt({ inputs: { real: x, imag: b }, backend: t8 }), { real: S, imag: k } = jY(C, e8, t8), _ = w.mergeRealAndImagArrays(S, k);
      for (let E = 0; E < s; E++) {
        let R = w.getComplexWithIndex(_, E);
        l[g * s + E] = R.real, m[g * s + E] = R.imag;
      }
      t8.disposeIntermediateTensorInfo(x), t8.disposeIntermediateTensorInfo(b), t8.disposeIntermediateTensorInfo(C);
    }
    let d = t8.makeTensorInfo(u, "float32", l), f = t8.makeTensorInfo(u, "float32", m), h = Kt({ inputs: { real: d, imag: f }, backend: t8 });
    return t8.disposeIntermediateTensorInfo(d), t8.disposeIntermediateTensorInfo(f), h;
  }
  function jY(r8, e8, t8) {
    let o8 = y.sizeFromShape(r8.shape), n8 = t8.data.get(r8.dataId), s = t8.data.get(n8.complexTensorInfos.real.dataId).values, a = t8.data.get(n8.complexTensorInfos.imag.dataId).values;
    if (XY(o8)) {
      let i10 = mI(s, a, o8, e8, t8), p = [r8.shape[0], r8.shape[1]];
      if (e8) {
        let u = t8.makeTensorInfo(p, "float32", i10.real), c = t8.makeTensorInfo(p, "float32", i10.imag), l = t8.makeTensorInfo([], "float32", y.createScalarValue(o8, "float32")), m = lr({ inputs: { x: l }, backend: t8 }), d = Vl.kernelFunc({ inputs: { a: u, b: l }, backend: t8 }), f = Vl.kernelFunc({ inputs: { a: c, b: m }, backend: t8 }), h = t8.data.get(d.dataId).values, g = t8.data.get(f.dataId).values;
        return t8.disposeIntermediateTensorInfo(u), t8.disposeIntermediateTensorInfo(c), t8.disposeIntermediateTensorInfo(l), t8.disposeIntermediateTensorInfo(m), t8.disposeIntermediateTensorInfo(d), t8.disposeIntermediateTensorInfo(f), { real: h, imag: g };
      }
      return i10;
    } else {
      let i10 = w.mergeRealAndImagArrays(s, a), p = YY(i10, o8, e8);
      return w.splitRealAndImagArrays(p);
    }
  }
  function XY(r8) {
    return (r8 & r8 - 1) === 0;
  }
  function mI(r8, e8, t8, o8, n8) {
    if (t8 === 1)
      return { real: r8, imag: e8 };
    let s = w.mergeRealAndImagArrays(r8, e8), a = t8 / 2, i10 = w.complexWithEvenIndex(s), p = i10.real, u = i10.imag, c = [p.length], l = n8.makeTensorInfo(c, "float32", p), m = n8.makeTensorInfo(c, "float32", u), d = Kt({ inputs: { real: l, imag: m }, backend: n8 }), f = w.complexWithOddIndex(s), h = f.real, g = f.imag, x = [h.length], b = n8.makeTensorInfo(x, "float32", h), C = n8.makeTensorInfo(x, "float32", g), S = Kt({ inputs: { real: b, imag: C }, backend: n8 }), k = mI(p, u, a, o8, n8), _ = k.real, E = k.imag, R = [_.length], D = n8.makeTensorInfo(R, "float32", _), P = n8.makeTensorInfo(R, "float32", E), O = Kt({ inputs: { real: D, imag: P }, backend: n8 }), M = mI(h, g, a, o8, n8), L = M.real, B = M.imag, z = [L.length], U = n8.makeTensorInfo(z, "float32", L), j = n8.makeTensorInfo(z, "float32", B), q = Kt({ inputs: { real: U, imag: j }, backend: n8 }), Y = w.exponents(t8, o8), J = [Y.real.length], re = n8.makeTensorInfo(J, "float32", Y.real), ne = n8.makeTensorInfo(J, "float32", Y.imag), ee = Kt({ inputs: { real: re, imag: ne }, backend: n8 }), oe = pp({ inputs: { a: ee, b: q }, backend: n8 }), ie = Aa({ inputs: { a: O, b: oe }, backend: n8 }), le = Ll({ inputs: { a: O, b: oe }, backend: n8 }), be = Eo({ inputs: { input: ie }, backend: n8 }), _e = Eo({ inputs: { input: le }, backend: n8 }), ve = Fa({ inputs: { input: ie }, backend: n8 }), Fe = Fa({ inputs: { input: le }, backend: n8 }), Pe = gu({ inputs: [be, _e], backend: n8, attrs: { axis: 0 } }), st = gu({ inputs: [ve, Fe], backend: n8, attrs: { axis: 0 } }), lt = n8.data.get(Pe.dataId).values, Ue = n8.data.get(st.dataId).values;
    return n8.disposeIntermediateTensorInfo(l), n8.disposeIntermediateTensorInfo(m), n8.disposeIntermediateTensorInfo(d), n8.disposeIntermediateTensorInfo(b), n8.disposeIntermediateTensorInfo(C), n8.disposeIntermediateTensorInfo(S), n8.disposeIntermediateTensorInfo(D), n8.disposeIntermediateTensorInfo(P), n8.disposeIntermediateTensorInfo(O), n8.disposeIntermediateTensorInfo(U), n8.disposeIntermediateTensorInfo(j), n8.disposeIntermediateTensorInfo(q), n8.disposeIntermediateTensorInfo(re), n8.disposeIntermediateTensorInfo(ne), n8.disposeIntermediateTensorInfo(ee), n8.disposeIntermediateTensorInfo(oe), n8.disposeIntermediateTensorInfo(ie), n8.disposeIntermediateTensorInfo(le), n8.disposeIntermediateTensorInfo(be), n8.disposeIntermediateTensorInfo(ve), n8.disposeIntermediateTensorInfo(_e), n8.disposeIntermediateTensorInfo(Fe), n8.disposeIntermediateTensorInfo(Pe), n8.disposeIntermediateTensorInfo(st), { real: lt, imag: Ue };
  }
  function YY(r8, e8, t8) {
    let o8 = new Float32Array(e8 * 2);
    for (let n8 = 0; n8 < e8; n8++) {
      let s = 0, a = 0;
      for (let i10 = 0; i10 < e8; i10++) {
        let p = w.exponent(n8 * i10, e8, t8), u = w.getComplexWithIndex(r8, i10);
        s += u.real * p.real - u.imag * p.imag, a += u.real * p.imag + u.imag * p.real;
      }
      t8 && (s /= e8, a /= e8), w.assignToTypedArray(o8, s, a, n8);
    }
    return o8;
  }
  function QY(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = y.sizeFromShape(o8.shape), s = o8.shape[o8.shape.length - 1], a = n8 / s, i10 = Ve({ inputs: { x: o8 }, backend: t8, attrs: { shape: [a, s] } }), p = Bf(i10, false, t8), u = Ve({ inputs: { x: p }, backend: t8, attrs: { shape: o8.shape } });
    return t8.disposeIntermediateTensorInfo(i10), t8.disposeIntermediateTensorInfo(p), u;
  }
  var E$ = { kernelName: Bi, backendName: "cpu", kernelFunc: QY };
  function Wl(r8) {
    let { backend: e8, attrs: t8 } = r8, { shape: o8, value: n8, dtype: s } = t8, a = s || y.inferDtype(n8), i10 = y.getArrayFromDType(a, y.sizeFromShape(o8));
    return ZY(i10, n8), e8.makeTensorInfo(o8, a, i10);
  }
  var R$ = { kernelName: na, backendName: "cpu", kernelFunc: Wl };
  function ZY(r8, e8, t8) {
    r8.fill(e8);
  }
  var D$ = { kernelName: Cn, backendName: "cpu", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { image: o8 } = r8, n8 = t8, s = y.getTypedArrayFromDType(o8.dtype, y.sizeFromShape(o8.shape)), [a, i10, p, u] = o8.shape, c = n8.data.get(o8.dataId).values;
    for (let m = 0; m < a; m++) {
      let d = m * p * i10 * u;
      for (let f = 0; f < i10; f++) {
        let h = f * (p * u);
        for (let g = 0; g < p; g++) {
          let x = g * u;
          for (let b = 0; b < u; b++) {
            let C = Math.round(p - g - 1), S = d + h + x + b, k = c[S];
            if (C >= 0 && C < p) {
              let _ = C * u, E = d + h + _ + b;
              k = c[E];
            }
            s[S] = k;
          }
        }
      }
    }
    return { dataId: n8.write(s, o8.shape, o8.dtype), shape: o8.shape, dtype: o8.dtype };
  } };
  function JY(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dataFormat: c, dilations: l, dimRoundingMode: m, activation: d, leakyreluAlpha: f } = o8, h = cI({ inputs: { x: n8, filter: s }, backend: t8, attrs: { strides: p, pad: u, dataFormat: c, dilations: l, dimRoundingMode: m } });
    if (a) {
      let g = h;
      if (c === "NCHW" && a.shape.length === 1 && a.shape[0] !== 1) {
        let x = Ve({ inputs: { x: a }, backend: t8, attrs: { shape: [a.shape[0], 1, 1] } });
        h = Aa({ inputs: { a: h, b: x }, backend: t8 }), t8.disposeIntermediateTensorInfo(x);
      } else
        h = Aa({ inputs: { a: h, b: a }, backend: t8 });
      t8.disposeIntermediateTensorInfo(g);
    }
    if (d) {
      let g = h;
      if (c === "NCHW" && d === "prelu" && i10.shape.length === 1 && i10.shape[0] !== 1) {
        let x = Ve({ inputs: { x: i10 }, backend: t8, attrs: { shape: [i10.shape[0], 1, 1] } });
        h = gp(t8, h, d, x, f), t8.disposeIntermediateTensorInfo(x);
      } else
        h = gp(t8, h, d, i10, f);
      t8.disposeIntermediateTensorInfo(g);
    }
    return h;
  }
  var A$ = { kernelName: Io, backendName: "cpu", kernelFunc: JY };
  function e7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dataFormat: c, dilations: l, dimRoundingMode: m, activation: d, leakyreluAlpha: f } = o8, h = lI({ inputs: { x: n8, filter: s }, backend: t8, attrs: { strides: p, pad: u, dataFormat: c, dilations: l, dimRoundingMode: m } });
    if (a) {
      let g = h;
      h = Aa({ inputs: { a: h, b: a }, backend: t8 }), t8.disposeIntermediateTensorInfo(g);
    }
    if (d) {
      let g = h;
      h = gp(t8, h, d, i10, f), t8.disposeIntermediateTensorInfo(g);
    }
    return h;
  }
  var F$ = { kernelName: vo, backendName: "cpu", kernelFunc: e7 };
  function t7(r8) {
    let { inputs: e8, backend: t8 } = r8, { params: o8, indices: n8 } = e8, s = y.sizeFromShape(o8.shape), a = n8.shape, i10 = a[a.length - 1], [p, u, c, l] = w.prepareAndValidate(o8, n8);
    if (u === 0)
      return t8.makeTensorInfo(p, o8.dtype, []);
    let m = t8.data.get(n8.dataId).values, d = t8.bufferSync(o8), f = kf(m, d, o8.dtype, u, i10, c, l, o8.shape, s);
    return t8.makeTensorInfo(p, o8.dtype, f.values);
  }
  var P$ = { kernelName: vn, backendName: "cpu", kernelFunc: t7 };
  function r7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, indices: s } = e8, { axis: a, batchDims: i10 } = o8;
    Q([n8, s], "gatherV2");
    let p = y.parseAxisParam(a, n8.shape)[0], u = t8.data.get(s.dataId).values, c = n8.shape[p];
    for (let S = 0; S < u.length; ++S) {
      let k = u[S];
      y.assert(k <= c - 1 && k >= 0, () => `GatherV2: the index value ${k} is not in [0, ${c - 1}]`);
    }
    let l = i10;
    i10 == null && (l = 0);
    let m = y.sizeFromShape(s.shape), d = w.segment_util.collectGatherOpShapeInfo(n8, s, p, l), f = Ve({ inputs: { x: n8 }, backend: t8, attrs: { shape: [d.batchSize, d.outerSize, d.dimSize, d.sliceSize] } }), h = Ve({ inputs: { x: s }, backend: t8, attrs: { shape: [d.batchSize, m / d.batchSize] } }), g = [d.batchSize, d.outerSize, m / d.batchSize, d.sliceSize], x = t8.bufferSync(h), b = t8.bufferSync(f), C = Nf(b, x, g);
    return t8.disposeIntermediateTensorInfo(f), t8.disposeIntermediateTensorInfo(h), t8.makeTensorInfo(d.outputShape, C.dtype, C.values);
  }
  var O$ = { kernelName: sa, backendName: "cpu", kernelFunc: r7 };
  function o7(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = y.sizeFromShape(o8.shape), s = o8.shape[o8.shape.length - 1], a = n8 / s, i10 = Ve({ inputs: { x: o8 }, backend: t8, attrs: { shape: [a, s] } }), p = Bf(i10, true, t8), u = Ve({ inputs: { x: p }, backend: t8, attrs: { shape: o8.shape } });
    return t8.disposeIntermediateTensorInfo(i10), t8.disposeIntermediateTensorInfo(p), u;
  }
  var M$ = { kernelName: zi, backendName: "cpu", kernelFunc: o7 };
  var n7 = Ie(Tn, (r8) => Number.isFinite(r8) ? 1 : 0, "bool");
  var L$ = { kernelName: Tn, backendName: "cpu", kernelFunc: n7 };
  var s7 = Ie(_n, (r8) => Math.abs(r8) === 1 / 0 ? 1 : 0, "bool");
  var B$ = { kernelName: _n, backendName: "cpu", kernelFunc: s7 };
  var a7 = Ie($n, (r8) => Number.isNaN(r8) ? 1 : 0, "bool");
  var z$ = { kernelName: $n, backendName: "cpu", kernelFunc: a7 };
  function i7(r8) {
    let { backend: e8, attrs: t8 } = r8, { start: o8, stop: n8, num: s } = t8, a = Tf(o8, n8, s);
    return e8.makeTensorInfo([a.length], "float32", a);
  }
  var V$ = { kernelName: An, backendName: "cpu", kernelFunc: i7 };
  var u7 = Ie(Pn, (r8) => Math.log1p(r8));
  var W$ = { kernelName: Pn, backendName: "cpu", kernelFunc: u7 };
  var p7 = ze((r8, e8) => r8 && e8);
  var c7 = Ye(On, p7, null, "bool");
  var U$ = { kernelName: On, backendName: "cpu", kernelFunc: c7 };
  var l7 = Ie(Mn, (r8) => r8 ? 0 : 1, "bool");
  var G$ = { kernelName: Mn, backendName: "cpu", kernelFunc: l7 };
  var m7 = ze((r8, e8) => r8 || e8);
  var d7 = Ye(Ln, m7, null, "bool");
  var H$ = { kernelName: Ln, backendName: "cpu", kernelFunc: d7 };
  function f7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { depthRadius: s, bias: a, alpha: i10, beta: p } = o8;
    Q(n8, "LRN");
    let u = n8.shape[3], c = u - 1, l = t8.data.get(n8.dataId).values, m = y.sizeFromShape(n8.shape), d = new Float32Array(m);
    function f(h) {
      let g = h % u, x = h - g + Math.max(0, g - s), b = h - g + Math.min(g + s, c), C = 0;
      for (; x <= b; x++) {
        let S = l[x];
        C += S * S;
      }
      return C;
    }
    for (let h = 0; h < m; h++) {
      let g = f(h), x = l[h] * Math.pow(a + i10 * g, -p);
      d[h] = x;
    }
    return t8.makeTensorInfo(n8.shape, n8.dtype, d);
  }
  var K$ = { kernelName: Bn, backendName: "cpu", kernelFunc: f7 };
  function h7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, y: s, dy: a } = e8, { depthRadius: i10, bias: p, alpha: u, beta: c } = o8;
    Q(a, "LRNGrad");
    let l = y.sizeFromShape(a.shape), m = a.shape[3], d = t8.data.get(a.dataId).values, f = t8.data.get(n8.dataId).values, h = t8.data.get(s.dataId).values, g = new Float32Array(l), x = l;
    for (let b = 0; b < x; b++) {
      let C = b % m, S = b - C + Math.max(0, C - i10), k = b - C + Math.min(m, C + i10 + 1), _ = 0;
      for (let E = S; E < k; E++)
        _ += Math.pow(f[E], 2);
      _ = u * _ + p;
      for (let E = S; E < k; E++) {
        let R = -2 * u * c * f[E] * h[b] / _;
        b === E && (R += Math.pow(_, -c)), R *= d[b], g[E] += R;
      }
    }
    return t8.makeTensorInfo(a.shape, n8.dtype, g);
  }
  var q$ = { kernelName: ja, backendName: "cpu", kernelFunc: h7 };
  function dI(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { reductionIndices: s, keepDims: a } = o8, i10 = t8, p = n8.shape, u = p.length, c = y.parseAxisParam(s, p), l = c, m = w.getAxesPermutation(l, u), d = i10.data.get(n8.dataId).values;
    if (m != null) {
      let S = new Array(u);
      for (let k = 0; k < S.length; k++)
        S[k] = p[m[k]];
      d = Cc(d, p, n8.dtype, m, S), l = w.getInnerMostAxes(l.length, u), p = S;
    }
    Q(n8, "max"), w.assertAxesAreInnerMostDims("max", l, u);
    let [f, h] = w.computeOutAndReduceShapes(p, l), g = y.sizeFromShape(h), x = _f(d, g, f, n8.dtype), b = i10.write(x, f, n8.dtype), C = f;
    return a && (C = w.expandShapeToKeepDim(f, c)), { dataId: b, shape: C, dtype: n8.dtype };
  }
  var j$ = { kernelName: zn, backendName: "cpu", kernelFunc: dI };
  function g7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8;
    Q(n8, "maxPool");
    let { filterSize: s, strides: a, pad: i10, dimRoundingMode: p } = o8, u = 1;
    y.assert(w.eitherStridesOrDilationsAreOne(a, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
    let c = w.computePool2DInfo(n8.shape, s, a, u, i10, p), l;
    if (c.filterWidth === 1 && c.filterHeight === 1 && y.arraysEqual(c.inShape, c.outShape))
      l = lr({ inputs: { x: n8 }, backend: t8 });
    else {
      let m = t8.data.get(n8.dataId).values, d = y.computeStrides(n8.shape), f = vc(m, n8.shape, n8.dtype, d, c, "max");
      l = t8.makeTensorInfo(c.outShape, n8.dtype, f.values);
    }
    return l;
  }
  var X$ = { kernelName: Wn, backendName: "cpu", kernelFunc: g7 };
  function x7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dimRoundingMode: p, dataFormat: u } = o8;
    Q(n8, "maxPool3d");
    let c = w.computePool3DInfo(n8.shape, s, a, 1, i10, p, u), l = t8.data.get(n8.dataId).values, m = Lf(l, n8.shape, n8.dtype, y.computeStrides(n8.shape), c, "max");
    return t8.makeTensorInfo(m.shape, "float32", m.values);
  }
  var Y$ = { kernelName: aa, backendName: "cpu", kernelFunc: x7 };
  function y7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, { filterSize: a, strides: i10, pad: p, dimRoundingMode: u } = o8;
    Q([n8, s], "maxPool3DGrad");
    let c = w.computePool3DInfo(s.shape, a, i10, 1, p, u), l = t8.bufferSync(s), m = H_(l, c), d = c.strideDepth, f = c.strideHeight, h = c.strideWidth, g = c.dilationDepth, x = c.dilationHeight, b = c.dilationWidth, C = c.effectiveFilterDepth, S = c.effectiveFilterHeight, k = c.effectiveFilterWidth, _ = C - 1 - c.padInfo.front, E = k - 1 - c.padInfo.left, R = S - 1 - c.padInfo.top, D = me(s.shape, "float32"), P = t8.bufferSync(n8);
    for (let O = 0; O < c.batchSize; ++O)
      for (let M = 0; M < c.inChannels; ++M)
        for (let L = 0; L < c.inDepth; ++L)
          for (let B = 0; B < c.inHeight; ++B)
            for (let z = 0; z < c.inWidth; ++z) {
              let U = L - _, j = B - R, q = z - E, Y = 0;
              for (let J = 0; J < C; J += g) {
                let re = (U + J) / d;
                if (!(re < 0 || re >= c.outDepth || Math.floor(re) !== re))
                  for (let ne = 0; ne < S; ne += x) {
                    let ee = (j + ne) / f;
                    if (!(ee < 0 || ee >= c.outHeight || Math.floor(ee) !== ee))
                      for (let oe = 0; oe < k; oe += b) {
                        let ie = (q + oe) / h;
                        if (ie < 0 || ie >= c.outWidth || Math.floor(ie) !== ie)
                          continue;
                        let le = C * S * k - 1 - m.get(O, re, ee, ie, M), be = J * S * k + ne * k + oe, _e = le === be ? 1 : 0;
                        if (_e === 0)
                          continue;
                        let ve = P.get(O, re, ee, ie, M);
                        Y += ve * _e;
                      }
                  }
              }
              D.set(Y, O, L, B, z, M);
            }
    return t8.makeTensorInfo(D.shape, D.dtype, D.values);
  }
  var Q$ = { kernelName: Ui, backendName: "cpu", kernelFunc: y7 };
  function b7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s, output: a } = e8, i10 = s;
    Q([s, a], "maxPoolGrad");
    let { filterSize: p, strides: u, pad: c, dimRoundingMode: l } = o8, m = w.computePool2DInfo(i10.shape, p, u, 1, c, l), d = t8.data.get(i10.dataId).values, f = me(m.outShape, i10.dtype, Mf(d, i10.shape, i10.dtype, m).values), h = m.strideHeight, g = m.strideWidth, x = m.dilationHeight, b = m.dilationWidth, C = m.effectiveFilterHeight, S = m.effectiveFilterWidth, k = S - 1 - m.padInfo.left, _ = C - 1 - m.padInfo.top, E = me(i10.shape, "float32"), R = t8.data.get(n8.dataId).values, D = me(n8.shape, "float32", R);
    for (let P = 0; P < m.batchSize; ++P)
      for (let O = 0; O < m.inChannels; ++O)
        for (let M = 0; M < m.inHeight; ++M)
          for (let L = 0; L < m.inWidth; ++L) {
            let B = M - _, z = L - k, U = 0;
            for (let j = 0; j < C; j += x) {
              let q = (B + j) / h;
              if (!(q < 0 || q >= m.outHeight || Math.floor(q) !== q))
                for (let Y = 0; Y < S; Y += b) {
                  let J = (z + Y) / g;
                  if (J < 0 || J >= m.outWidth || Math.floor(J) !== J)
                    continue;
                  let re = C * S - 1 - f.get(P, q, J, O), ne = j * S + Y, ee = re === ne ? 1 : 0;
                  if (ee === 0)
                    continue;
                  let oe = D.get(P, q, J, O);
                  U += oe * ee;
                }
            }
            E.set(U, P, M, L, O);
          }
    return t8.makeTensorInfo(E.shape, E.dtype, E.values);
  }
  var Z$ = { kernelName: Wi, backendName: "cpu", kernelFunc: b7 };
  function J$(r8, e8, t8, o8, n8) {
    let s = y.computeStrides(e8), a = vc(r8, e8, t8, s, n8, "max"), i10 = Mf(r8, e8, t8, n8, true, o8);
    return [a.values, i10.values];
  }
  var eE = { kernelName: ia, backendName: "cpu", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { x: o8 } = r8, { filterSize: n8, strides: s, pad: a, includeBatchInIndex: i10 } = e8, p = t8;
    Q(o8, "MaxPoolWithArgmax");
    let u = p.data.get(o8.dataId).values, c = w.computePool2DInfo(o8.shape, n8, s, [1, 1], a), [l, m] = J$(u, o8.shape, o8.dtype, i10, c), d = p.write(l, c.outShape, o8.dtype), f = p.write(m, c.outShape, o8.dtype);
    return [{ dataId: d, shape: c.outShape, dtype: o8.dtype }, { dataId: f, shape: c.outShape, dtype: "int32" }];
  } };
  function C7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8, i10 = y.parseAxisParam(s, n8.shape), u = w.computeOutAndReduceShapes(n8.shape, i10)[1], c = y.sizeFromShape(u), l = [], m = t8.makeTensorInfo([], "float32", new Float32Array([c]));
    l.push(m);
    let d = Ro({ inputs: { x: n8 }, backend: t8, attrs: { dtype: "float32" } });
    l.push(d);
    let f = zl({ inputs: { a: d, b: m }, backend: t8 });
    l.push(f);
    let h = fi({ inputs: { x: f }, backend: t8, attrs: { axis: s, keepDims: a } });
    return l.forEach((g) => t8.disposeIntermediateTensorInfo(g)), h;
  }
  var tE = { kernelName: Un, backendName: "cpu", kernelFunc: C7 };
  function w7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    Q(n8, "min");
    let i10 = y.parseAxisParam(s, n8.shape), p = i10, u = w.getAxesPermutation(p, n8.shape.length), c = n8;
    u != null && (c = It({ inputs: { x: n8 }, backend: t8, attrs: { perm: u } }), p = w.getInnerMostAxes(p.length, n8.shape.length)), w.assertAxesAreInnerMostDims("min", p, c.shape.length);
    let [l, m] = w.computeOutAndReduceShapes(c.shape, p), d = y.sizeFromShape(m), f = y.makeZerosTypedArray(y.sizeFromShape(l), c.dtype), h = t8.data.get(c.dataId).values;
    for (let x = 0; x < f.length; ++x) {
      let b = x * d, C = h[b];
      for (let S = 0; S < d; ++S) {
        let k = h[b + S];
        (Number.isNaN(k) || k < C) && (C = k);
      }
      f[x] = C;
    }
    u != null && t8.disposeIntermediateTensorInfo(c);
    let g = t8.makeTensorInfo(l, c.dtype, f);
    if (a) {
      let x = w.expandShapeToKeepDim(l, i10), b = Ve({ inputs: { x: g }, backend: t8, attrs: { shape: x } });
      return t8.disposeIntermediateTensorInfo(g), b;
    }
    return g;
  }
  var rE = { kernelName: Gn, backendName: "cpu", kernelFunc: w7 };
  function S7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { paddings: s, mode: a } = o8;
    Q(n8, "mirrorPad");
    let i10 = s.map((C, S) => C[0] + n8.shape[S] + C[1]), p = s.map((C) => C[0]), u = s.map((C, S) => C[0] + n8.shape[S]), c = a === "reflect" ? 0 : 1, l = t8.data.get(n8.dataId).values, m = n8.shape.length, d = y.computeStrides(n8.shape), f = y.sizeFromShape(i10), h = i10.length, g = y.computeStrides(i10), x = y.getTypedArrayFromDType(n8.dtype, f);
    for (let C = 0; C < f; C++) {
      let S = y.indexToLoc(C, h, g);
      for (let _ = 0; _ < h; _++)
        S[_] < p[_] ? S[_] = p[_] * 2 - S[_] - c : S[_] >= u[_] && (S[_] = (u[_] - 1) * 2 - S[_] + c);
      S = S.map((_, E) => _ - p[E]);
      let k = y.locToIndex(S, m, d);
      x[C] = l[k];
    }
    return { dataId: t8.write(x, i10, n8.dtype), shape: i10, dtype: n8.dtype };
  }
  var oE = { kernelName: Kn, backendName: "cpu", kernelFunc: S7 };
  var I7 = ze((r8, e8) => {
    let t8 = r8 % e8;
    return r8 < 0 && e8 < 0 || r8 >= 0 && e8 >= 0 ? t8 : (t8 + e8) % e8;
  });
  var v7 = Ye(qn, I7);
  var nE = { kernelName: qn, backendName: "cpu", kernelFunc: v7 };
  var aE = Up(zw());
  function fI(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { logits: n8 } = e8, { dim: s } = o8, a = n8.shape.length, i10 = s;
    if (i10 === -1 && (i10 = a - 1), i10 !== a - 1)
      throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i10}`);
    let p = y.parseAxisParam([i10], n8.shape), u = dI({ inputs: { x: n8 }, backend: t8, attrs: { reductionIndices: p, keepDims: false } }), c = w.expandShapeToKeepDim(u.shape, p), l = Ve({ inputs: { x: u }, backend: t8, attrs: { shape: c } }), m = Ll({ inputs: { a: n8, b: l }, backend: t8 }), d = LS({ inputs: { x: m }, backend: t8 }), f = fi({ inputs: { x: d }, backend: t8, attrs: { axis: p, keepDims: false } }), h = Ve({ inputs: { x: f }, backend: t8, attrs: { shape: c } }), g = zl({ inputs: { a: d, b: h }, backend: t8 });
    return t8.disposeIntermediateTensorInfo(u), t8.disposeIntermediateTensorInfo(l), t8.disposeIntermediateTensorInfo(m), t8.disposeIntermediateTensorInfo(d), t8.disposeIntermediateTensorInfo(f), t8.disposeIntermediateTensorInfo(h), g;
  }
  var sE = { kernelName: Is, backendName: "cpu", kernelFunc: fI };
  function k7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { logits: n8 } = e8, { numSamples: s, seed: a, normalized: i10 } = o8;
    Q(n8, "multinomial");
    let p = i10 ? n8 : fI({ inputs: { logits: n8 }, backend: t8, attrs: { dim: -1 } }), u = p.shape[0], c = p.shape[1], l = t8.data.get(p.dataId).values, m = [u, s], d = y.makeZerosTypedArray(y.sizeFromShape(m), "int32");
    for (let f = 0; f < u; ++f) {
      let h = f * c, g = new Float32Array(c - 1);
      g[0] = l[h];
      for (let C = 1; C < g.length; ++C)
        g[C] = g[C - 1] + l[h + C];
      let x = aE.alea(a.toString()), b = f * s;
      for (let C = 0; C < s; ++C) {
        let S = x();
        d[b + C] = g.length;
        for (let k = 0; k < g.length; k++)
          if (S < g[k]) {
            d[b + C] = k;
            break;
          }
      }
    }
    return i10 || t8.disposeIntermediateTensorInfo(p), t8.makeTensorInfo(m, "int32", d);
  }
  var iE = { kernelName: jn, backendName: "cpu", kernelFunc: k7 };
  var N7 = Wt.nonMaxSuppressionV3Impl;
  function T7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p } = o8;
    Q(n8, "NonMaxSuppression");
    let u = t8.data.get(n8.dataId).values, c = t8.data.get(s.dataId).values, { selectedIndices: l } = N7(u, c, a, i10, p);
    return t8.makeTensorInfo([l.length], "int32", new Int32Array(l));
  }
  var uE = { kernelName: Qn, backendName: "cpu", kernelFunc: T7 };
  var _7 = Wt.nonMaxSuppressionV4Impl;
  function $7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p, padToMaxOutputSize: u } = o8;
    Q(n8, "NonMaxSuppressionPadded");
    let c = t8.data.get(n8.dataId).values, l = t8.data.get(s.dataId).values, { selectedIndices: m, validOutputs: d } = _7(c, l, a, i10, p, u);
    return [t8.makeTensorInfo([m.length], "int32", new Int32Array(m)), t8.makeTensorInfo([], "int32", new Int32Array([d]))];
  }
  var pE = { kernelName: Xa, backendName: "cpu", kernelFunc: $7 };
  var E7 = Wt.nonMaxSuppressionV5Impl;
  function R7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p, softNmsSigma: u } = o8;
    Q(n8, "NonMaxSuppressionWithScore");
    let c = t8.data.get(n8.dataId).values, l = t8.data.get(s.dataId).values, m = a, d = i10, f = p, h = u, { selectedIndices: g, selectedScores: x } = E7(c, l, m, d, f, h);
    return [t8.makeTensorInfo([g.length], "int32", new Int32Array(g)), t8.makeTensorInfo([x.length], "float32", new Float32Array(x))];
  }
  var cE = { kernelName: Zn, backendName: "cpu", kernelFunc: R7 };
  function D7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { indices: n8 } = e8, { dtype: s, depth: a, onValue: i10, offValue: p } = o8;
    Q(n8, "oneHot");
    let u = y.sizeFromShape(n8.shape), c = new Float32Array(u * a);
    c.fill(p);
    let l = t8.data.get(n8.dataId).values;
    for (let m = 0; m < u; ++m)
      l[m] >= 0 && l[m] < a && (c[m * a + l[m]] = i10);
    return t8.makeTensorInfo([...n8.shape, a], s, c);
  }
  var lE = { kernelName: Jn, backendName: "cpu", kernelFunc: D7 };
  function Ul(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (o8.dtype === "string")
      throw new Error("zerosLike is not supported for string tensors");
    if (o8.dtype === "complex64") {
      let n8 = Eo({ inputs: { input: o8 }, backend: t8 }), s = Ul({ inputs: { x: n8 }, backend: t8 }), a = Fa({ inputs: { input: o8 }, backend: t8 }), i10 = Ul({ inputs: { x: a }, backend: t8 }), p = Kt({ inputs: { real: s, imag: i10 }, backend: t8 });
      return t8.disposeIntermediateTensorInfo(n8), t8.disposeIntermediateTensorInfo(s), t8.disposeIntermediateTensorInfo(a), t8.disposeIntermediateTensorInfo(i10), p;
    } else
      return Wl({ backend: t8, attrs: { shape: o8.shape, value: 0, dtype: o8.dtype } });
  }
  var mE = { kernelName: ba, backendName: "cpu", kernelFunc: Ul };
  function dE(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (o8.dtype === "string")
      throw new Error("onesLike is not supported for string tensors");
    if (o8.dtype === "complex64") {
      let n8 = Eo({ inputs: { input: o8 }, backend: t8 }), s = dE({ inputs: { x: n8 }, backend: t8 }), a = Fa({ inputs: { input: o8 }, backend: t8 }), i10 = Ul({ inputs: { x: a }, backend: t8 }), p = Kt({ inputs: { real: s, imag: i10 }, backend: t8 });
      return t8.disposeIntermediateTensorInfo(n8), t8.disposeIntermediateTensorInfo(s), t8.disposeIntermediateTensorInfo(a), t8.disposeIntermediateTensorInfo(i10), p;
    } else
      return Wl({ backend: t8, attrs: { shape: o8.shape, value: 1, dtype: o8.dtype } });
  }
  var fE = { kernelName: pa, backendName: "cpu", kernelFunc: dE };
  function hI(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { axis: n8 } = o8;
    if (e8.length === 1)
      return kc({ inputs: { input: e8[0] }, backend: t8, attrs: { dim: n8 } });
    let s = e8[0].shape, a = e8[0].dtype;
    e8.forEach((c) => {
      y.assertShapesMatch(s, c.shape, "All tensors passed to stack must have matching shapes"), y.assert(a === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    let i10 = [], p = e8.map((c) => {
      let l = kc({ inputs: { input: c }, backend: t8, attrs: { dim: n8 } });
      return i10.push(l), l;
    }), u = gu({ inputs: p, backend: t8, attrs: { axis: n8 } });
    return i10.forEach((c) => t8.disposeIntermediateTensorInfo(c)), u;
  }
  var hE = { kernelName: ca, backendName: "cpu", kernelFunc: hI };
  function A7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { paddings: s, constantValue: a } = o8;
    Q(n8, "pad");
    let i10 = s.map((b, C) => b[0] + n8.shape[C] + b[1]), p = s.map((b) => b[0]), u = t8.data.get(n8.dataId).values, c = y.sizeFromShape(n8.shape), l = n8.shape.length, m = y.computeStrides(n8.shape), d = y.sizeFromShape(i10), f = i10.length, h = y.computeStrides(i10), g = y.getTypedArrayFromDType(n8.dtype, d);
    a !== 0 && g.fill(a);
    for (let b = 0; b < c; b++) {
      let S = y.indexToLoc(b, l, m).map((_, E) => _ + p[E]), k = y.locToIndex(S, f, h);
      g[k] = u[b];
    }
    return { dataId: t8.write(g, i10, n8.dtype), shape: i10, dtype: n8.dtype };
  }
  var zf = { kernelName: es, backendName: "cpu", kernelFunc: A7 };
  var F7 = ze((r8, e8) => Math.pow(r8, e8));
  var P7 = Ye(ts, F7);
  var gE = { kernelName: ts, backendName: "cpu", kernelFunc: P7 };
  function O7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { paramsNestedSplits: n8, paramsDenseValues: s, indices: a } = e8, p = n8.map((x) => t8.data.get(x.dataId).values), u = n8.map((x) => x.shape), c = t8.data.get(s.dataId).values, l = t8.data.get(a.dataId).values, [m, d, f] = $f(p, u, c, s.shape, s.dtype, l, a.shape), h = m.map((x) => t8.makeTensorInfo([x.length], "int32", x)), g = t8.makeTensorInfo(f, s.dtype, d);
    return h.concat([g]);
  }
  var xE = { kernelName: jp, backendName: "cpu", kernelFunc: O7 };
  function M7(r8) {
    let { inputs: e8, backend: t8 } = r8, { starts: o8, limits: n8, deltas: s } = e8, a = t8.data.get(o8.dataId).values, i10 = t8.data.get(n8.dataId).values, p = t8.data.get(s.dataId).values, [u, c] = Ef(a, o8.shape, o8.dtype, i10, n8.shape, p, s.shape), l = t8.makeTensorInfo([u.length], "int32", u), m = t8.makeTensorInfo([c.length], o8.dtype, c);
    return [l, m];
  }
  var yE = { kernelName: Xp, backendName: "cpu", kernelFunc: M7 };
  function L7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { shape: n8, values: s, defaultValue: a, rowPartitionTensors: i10 } = e8, { rowPartitionTypes: p } = o8, u = t8.data.get(n8.dataId).values, c = t8.data.get(s.dataId).values, l = t8.data.get(a.dataId).values, m = i10.map((g) => t8.data.get(g.dataId).values), d = i10.map((g) => g.shape), [f, h] = Rf(u, n8.shape, c, s.shape, s.dtype, l, a.shape, m, d, p);
    return t8.makeTensorInfo(f, s.dtype, h);
  }
  var bE = { kernelName: Yp, backendName: "cpu", kernelFunc: L7 };
  function B7(r8) {
    let { backend: e8, attrs: t8 } = r8, { start: o8, stop: n8, dtype: s, step: a } = t8, i10 = cp(o8, n8, a, s);
    return e8.makeTensorInfo([i10.length], s, i10);
  }
  var CE = { kernelName: la, backendName: "cpu", kernelFunc: B7 };
  var z7 = Ie(ns, (r8) => 1 / r8);
  var wE = { kernelName: ns, backendName: "cpu", kernelFunc: z7 };
  function V7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8 } = e8, { alignCorners: s, halfPixelCenters: a, size: i10 } = o8;
    Q(n8, "resizeBilinear");
    let p = y.computeStrides(n8.shape), [u, c] = i10, [l, m, d, f] = n8.shape, h = t8.data.get(n8.dataId).values, g = new Float32Array(y.sizeFromShape([l, u, c, f])), x = [s && u > 1 ? m - 1 : m, s && c > 1 ? d - 1 : d], b = [s && u > 1 ? u - 1 : u, s && c > 1 ? c - 1 : c], C = 0, S = x[0] / b[0], k = x[1] / b[1];
    for (let _ = 0; _ < l; _++)
      for (let E = 0; E < u; E++) {
        let R;
        a ? R = S * (E + 0.5) - 0.5 : R = S * E;
        let D = Math.max(0, Math.floor(R)), P = R - D, O = Math.min(m - 1, Math.ceil(R)), M = _ * p[0] + D * p[1], L = _ * p[0] + O * p[1];
        for (let B = 0; B < c; B++) {
          let z;
          a ? z = k * (B + 0.5) - 0.5 : z = k * B;
          let U = Math.max(0, Math.floor(z)), j = z - U, q = Math.min(d - 1, Math.ceil(z)), Y = M + U * p[2], J = L + U * p[2], re = M + q * p[2], ne = L + q * p[2];
          for (let ee = 0; ee < f; ee++) {
            let oe = h[Y + ee], ie = h[J + ee], le = h[re + ee], be = h[ne + ee], _e = oe + (le - oe) * j, ve = ie + (be - ie) * j, Fe = _e + (ve - _e) * P;
            g[C++] = Fe;
          }
        }
      }
    return t8.makeTensorInfo([l, u, c, f], "float32", g);
  }
  var SE = { kernelName: is, backendName: "cpu", kernelFunc: V7 };
  function W7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8;
    Q([s, n8], "resizeBilinearGrad");
    let i10 = y.computeStrides(n8.shape), [p, u, c, l] = n8.shape, [, m, d] = s.shape, f = new Float32Array(p * u * c * l), h = [a && m > 1 ? u - 1 : u, a && d > 1 ? c - 1 : c], g = [a && m > 1 ? m - 1 : m, a && d > 1 ? d - 1 : d], x = h[0] / g[0], b = h[1] / g[1], C = t8.data.get(s.dataId).values, S = 0;
    for (let k = 0; k < p; k++) {
      let _ = k * i10[0];
      for (let E = 0; E < m; E++) {
        let R = E * x, D = Math.floor(R), P = Math.min(Math.ceil(R), u - 1), O = _ + D * i10[1], M = _ + P * i10[1], L = R - D, B = 1 - L;
        for (let z = 0; z < d; z++) {
          let U = z * b, j = Math.floor(U), q = Math.min(Math.ceil(U), c - 1), Y = U - j, J = 1 - Y, re = O + j * i10[2], ne = O + q * i10[2], ee = M + j * i10[2], oe = M + q * i10[2], ie = B * J, le = B * Y, be = L * J, _e = L * Y;
          for (let ve = 0; ve < l; ve++) {
            let Fe = C[S++];
            f[re + ve] += Fe * ie, f[ne + ve] += Fe * le, f[ee + ve] += Fe * be, f[oe + ve] += Fe * _e;
          }
        }
      }
    }
    return t8.makeTensorInfo([p, c, u, l], "float32", f);
  }
  var IE = { kernelName: Qa, backendName: "cpu", kernelFunc: W7 };
  function U7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8 } = e8, { alignCorners: s, halfPixelCenters: a, size: i10 } = o8;
    Q(n8, "resizeNearestNeighbor");
    let p = y.computeStrides(n8.shape), [u, c] = i10, [l, m, d, f] = n8.shape, h = t8.data.get(n8.dataId).values, g = new Float32Array(l * u * c * f), x = [s && u > 1 ? m - 1 : m, s && c > 1 ? d - 1 : d], b = [s && u > 1 ? u - 1 : u, s && c > 1 ? c - 1 : c], C = x[0] / b[0], S = x[1] / b[1], k = 0;
    for (let _ = 0; _ < l; _++) {
      let E = _ * p[0];
      for (let R = 0; R < u; R++) {
        let D = a ? C * (R + 0.5) : C * R, P = Math.min(m - 1, s ? Math.round(D) : Math.floor(D));
        a && (P = Math.max(0, P));
        let O = E + P * p[1];
        for (let M = 0; M < c; M++) {
          let L = a ? S * (M + 0.5) : S * M, B = Math.min(d - 1, s ? Math.round(L) : Math.floor(L));
          a && (B = Math.max(0, B));
          let z = O + B * p[2];
          for (let U = 0; U < f; U++) {
            let j = h[z + U];
            g[k++] = j;
          }
        }
      }
    }
    return t8.makeTensorInfo([l, u, c, f], n8.dtype, g);
  }
  var vE = { kernelName: as, backendName: "cpu", kernelFunc: U7 };
  function G7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8;
    Q([s, n8], "resizeNearestNeighborGrad");
    let i10 = y.computeStrides(n8.shape), p = y.computeStrides(s.shape), [u, c, l, m] = n8.shape, [, d, f] = s.shape, h = new Float32Array(u * c * l * m), g = t8.data.get(s.dataId).values, x = [a && d > 1 ? c - 1 : c, a && f > 1 ? l - 1 : l], b = [a && d > 1 ? d - 1 : d, a && f > 1 ? f - 1 : f], C = x[0] / b[0], S = x[1] / b[1], k = 1 / C, _ = 1 / S, E = Math.ceil(k) * 2 + 2, R = Math.ceil(_) * 2 + 2;
    for (let D = 0; D < u; D++) {
      let P = D * i10[0];
      for (let O = 0; O < c; O++) {
        let M = P + O * i10[1], L = Math.floor(O * k), B = Math.floor(L - E / 2);
        for (let z = 0; z < l; z++) {
          let U = M + z * i10[2], j = Math.floor(z * _), q = Math.floor(j - R / 2);
          for (let Y = 0; Y < m; Y++) {
            let J = 0;
            for (let re = 0; re < E; re++) {
              let ne = re + B;
              if (ne < 0 || ne >= d)
                continue;
              let ee = P + ne * p[1], oe = ne * C, ie = Math.min(c - 1, a ? Math.round(oe) : Math.floor(oe));
              if (O === ie)
                for (let le = 0; le < R; le++) {
                  let be = le + q;
                  if (be < 0 || be >= f)
                    continue;
                  let _e = ee + be * p[2], ve = be * S, Fe = Math.min(l - 1, a ? Math.round(ve) : Math.floor(ve));
                  z === Fe && (J += g[_e + Y]);
                }
            }
            h[U + Y] = J;
          }
        }
      }
    }
    return t8.makeTensorInfo(n8.shape, n8.dtype, h);
  }
  var kE = { kernelName: Ya, backendName: "cpu", kernelFunc: G7 };
  function H7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { dims: s } = o8;
    Q(n8, "reverse");
    let a = n8.shape.length, i10 = y.parseAxisParam(s, n8.shape);
    if (a === 0)
      return lr({ inputs: { x: n8 }, backend: t8 });
    let p = new tt(n8.shape, n8.dtype), u = t8.bufferSync(n8);
    for (let c = 0; c < p.size; c++) {
      let l = p.indexToLoc(c), m = l.slice();
      i10.forEach((d) => m[d] = n8.shape[d] - 1 - m[d]), p.set(u.get(...m), ...l);
    }
    return t8.makeTensorInfo(p.shape, p.dtype, p.values);
  }
  var NE = { kernelName: ps, backendName: "cpu", kernelFunc: H7 };
  var TE = { kernelName: Ds, backendName: "cpu", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { image: o8 } = r8, { radians: n8, fillValue: s, center: a } = e8, i10 = t8, p = y.getTypedArrayFromDType(o8.dtype, y.sizeFromShape(o8.shape)), [u, c, l, m] = o8.shape, [d, f] = w.getImageCenter(a, c, l), h = 255, g = Math.sin(n8), x = Math.cos(n8), b = i10.data.get(o8.dataId).values;
    for (let S = 0; S < u; S++) {
      let k = S * l * c * m;
      for (let _ = 0; _ < c; _++) {
        let E = _ * (l * m);
        for (let R = 0; R < l; R++) {
          let D = R * m;
          for (let P = 0; P < m; P++) {
            let O = [u, _, R, P], M = O[2], L = O[1], B = (M - d) * x - (L - f) * g, z = (M - d) * g + (L - f) * x;
            B = Math.round(B + d), z = Math.round(z + f);
            let U = s;
            if (typeof s != "number" && (P === 3 ? U = h : U = s[P]), B >= 0 && B < l && z >= 0 && z < c) {
              let q = z * (l * m), Y = B * m, J = k + q + Y + P;
              U = b[J];
            }
            let j = k + E + D + P;
            p[j] = U;
          }
        }
      }
    }
    return { dataId: i10.write(p, o8.shape, o8.dtype), shape: o8.shape, dtype: o8.dtype };
  } };
  var K7 = Ie(cs, (r8) => {
    let e8 = Math.floor(r8);
    return r8 - e8 < 0.5 ? Math.floor(r8) : r8 - e8 > 0.5 ? Math.ceil(r8) : e8 % 2 === 0 ? e8 : e8 + 1;
  });
  var _E = { kernelName: cs, backendName: "cpu", kernelFunc: K7 };
  function q7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { indices: n8, updates: s } = e8, { shape: a } = o8, { sliceRank: i10, numUpdates: p, sliceSize: u, strides: c, outputSize: l } = w.calculateShapes(s, n8, a), m = true, d = t8.bufferSync(n8), f = t8.bufferSync(s), h = Ls(d, f, a, l, u, p, i10, c, 0, m);
    return t8.makeTensorInfo(a, h.dtype, h.values);
  }
  var $E = { kernelName: ms, backendName: "cpu", kernelFunc: q7 };
  function j7(r8, e8) {
    let t8 = 0, o8 = r8.length, n8 = 0;
    for (; t8 < o8; )
      n8 = Math.floor((t8 + o8) / 2), r8[n8] < e8 ? t8 = n8 + 1 : o8 = n8;
    return o8;
  }
  function X7(r8, e8) {
    let t8 = 0, o8 = r8.length, n8 = 0;
    for (; t8 < o8; )
      n8 = Math.floor((t8 + o8) / 2), r8[n8] <= e8 ? t8 = n8 + 1 : o8 = n8;
    return o8;
  }
  function EE(r8, e8, t8, o8, n8, s) {
    let a = y.getArrayFromDType("int32", t8 * n8);
    for (let i10 = 0; i10 < t8; ++i10) {
      let p = r8.slice(i10 * o8, (i10 + 1) * o8), u = i10 * n8;
      for (let c = 0; c < n8; ++c)
        a[u + c] = s === "left" ? j7(p, e8[c + u]) : X7(p, e8[c + u]);
    }
    return a;
  }
  function Y7(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { sortedSequence: n8, values: s } = e8, { side: a } = o8, i10 = t8.data.get(n8.dataId).values, p = t8.data.get(s.dataId).values, u = EE(i10, p, n8.shape[0], n8.shape[1], s.shape[1], a);
    return t8.makeTensorInfo(s.shape, "int32", u);
  }
  var RE = { kernelName: fs, backendName: "cpu", kernelFunc: Y7 };
  function Q7(r8) {
    let { inputs: e8, backend: t8 } = r8, { condition: o8, t: n8, e: s } = e8;
    Q([o8, n8, s], "select");
    let a = o8.shape.length, i10 = t8.data.get(o8.dataId).values, p = t8.data.get(n8.dataId).values, u = t8.data.get(s.dataId).values, c = dt(n8.dtype, s.dtype), l = y.makeZerosTypedArray(y.sizeFromShape(n8.shape), c), m = 0, d = a === 0 || a > 1 || n8.shape.length === 1 ? 1 : y.sizeFromShape(n8.shape.slice(1));
    for (let f = 0; f < i10.length; f++)
      for (let h = 0; h < d; h++)
        i10[f] === 1 ? l[m++] = p[f] : l[m++] = u[f];
    return t8.makeTensorInfo(n8.shape, c, l);
  }
  var DE = { kernelName: da, backendName: "cpu", kernelFunc: Q7 };
  var Z7 = w.SELU_SCALEALPHA;
  var J7 = w.SELU_SCALE;
  var eQ = Ie(hs, (r8) => r8 >= 0 ? J7 * r8 : Z7 * (Math.exp(r8) - 1));
  var AE = { kernelName: hs, backendName: "cpu", kernelFunc: eQ };
  var tQ = Ie(ys, (r8) => r8 < 0 ? -1 : r8 > 0 ? 1 : 0);
  var FE = { kernelName: ys, backendName: "cpu", kernelFunc: tQ };
  var rQ = Ie(gs, (r8) => Math.sin(r8));
  var PE = { kernelName: gs, backendName: "cpu", kernelFunc: rQ };
  var oQ = Ie(xs, (r8) => Math.sinh(r8));
  var OE = { kernelName: xs, backendName: "cpu", kernelFunc: oQ };
  var nQ = 11920928955078125e-23;
  var ME = Math.log(nQ) + 2;
  var sQ = Ie(Cs, (r8) => {
    let e8 = r8 > -ME, t8 = r8 < ME, o8 = Math.exp(r8), n8;
    return t8 ? n8 = o8 : e8 ? n8 = r8 : n8 = Math.log(1 + o8), n8;
  });
  var LE = { kernelName: Cs, backendName: "cpu", kernelFunc: sQ };
  function aQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, paddings: a } = o8;
    Q([n8], "spaceToBatchND");
    let i10 = y.sizeFromShape(s), p = [[0, 0]];
    p.push(...a);
    for (let _ = 1 + s.length; _ < n8.shape.length; ++_)
      p.push([0, 0]);
    let u = zf.kernelFunc({ inputs: { x: n8 }, backend: t8, attrs: { paddings: p, constantValue: 0 } }), c = w.getReshaped(u.shape, s, i10, false), l = w.getPermuted(c.length, s.length, false), m = w.getReshapedPermuted(u.shape, s, i10, false), h = Ve({ inputs: { x: u }, backend: t8, attrs: { shape: c } }), b = It({ inputs: { x: h }, backend: t8, attrs: { perm: l } }), k = Ve({ inputs: { x: b }, backend: t8, attrs: { shape: m } });
    return t8.disposeIntermediateTensorInfo(u), t8.disposeIntermediateTensorInfo(h), t8.disposeIntermediateTensorInfo(b), k;
  }
  var BE = { kernelName: ha, backendName: "cpu", kernelFunc: aQ };
  function iQ(r8) {
    let { inputs: e8, backend: t8 } = r8, { indices: o8, values: n8, denseShape: s, defaultValue: a } = e8;
    if (s.shape.length !== 1)
      throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);
    if (o8.shape.length !== 2)
      throw new Error(`Indices must be a matrix, saw:
        ${o8.shape}`);
    if (n8.shape.length !== 1)
      throw new Error(`Values must be a vector, saw:
        ${n8.shape}`);
    if (a.shape.length !== 0)
      throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);
    let i10 = t8.data.get(o8.dataId).values, p = t8.data.get(n8.dataId).values, u = t8.data.get(s.dataId).values, c = t8.data.get(a.dataId).values[0], [l, m, d, f, h] = Df(i10, o8.shape, o8.dtype, p, n8.dtype, u, c);
    return [t8.makeTensorInfo(m, o8.dtype, l), t8.makeTensorInfo([m[0]], n8.dtype, d), t8.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((g) => Number(g)))), t8.makeTensorInfo([h.length], o8.dtype, new Int32Array(h))];
  }
  var zE = { kernelName: Hi, backendName: "cpu", kernelFunc: iQ };
  function uQ(r8) {
    let { inputs: e8, backend: t8 } = r8, { inputIndices: o8, inputShape: n8, newShape: s } = e8;
    if (o8.shape.length !== 2)
      throw new Error(`Input indices should be a matrix but received shape
        ${o8.shape}`);
    if (n8.shape.length !== 1)
      throw new Error(`Input shape should be a vector but received shape
        ${n8.shape}`);
    if (s.shape.length !== 1)
      throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
    let a = Array.from(t8.data.get(n8.dataId).values), i10 = t8.data.get(o8.dataId).values, p = Array.from(t8.data.get(s.dataId).values), [u, c, l] = Af(i10, o8.shape, o8.dtype, a, p);
    return [t8.makeTensorInfo(c, o8.dtype, u), t8.makeTensorInfo([l.length], s.dtype, new Int32Array(l))];
  }
  var VE = { kernelName: Za, backendName: "cpu", kernelFunc: uQ };
  function pQ(r8) {
    let { inputs: e8, backend: t8 } = r8, { data: o8, indices: n8, segmentIds: s } = e8;
    if (o8.shape.length < 1)
      throw new Error("Data should be at least 1 dimensional but received scalar");
    if (n8.shape.length !== 1)
      throw new Error(`Indices should be a vector but received shape
          ${n8.shape}`);
    if (s.shape.length !== 1)
      throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);
    if (n8.shape[0] !== s.shape[0])
      throw new Error("segmentIds and indices should have same size.");
    let a = t8.data.get(o8.dataId).values, i10 = t8.data.get(n8.dataId).values, p = t8.data.get(s.dataId).values, [u, c] = Sc(a, o8.shape, o8.dtype, i10, p, true);
    return t8.makeTensorInfo(c, o8.dtype, u);
  }
  var WE = { kernelName: Ki, backendName: "cpu", kernelFunc: pQ };
  function cQ(r8) {
    let { inputs: e8, backend: t8 } = r8, { data: o8, indices: n8, segmentIds: s } = e8;
    if (o8.shape.length < 1)
      throw new Error("Data should be at least 1 dimensional but received scalar");
    if (n8.shape.length !== 1)
      throw new Error(`Indices should be a vector but received shape
         ${n8.shape}`);
    if (s.shape.length !== 1)
      throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);
    if (n8.shape[0] !== s.shape[0])
      throw new Error("segmentIds and indices should have same size.");
    let a = t8.data.get(o8.dataId).values, i10 = t8.data.get(n8.dataId).values, p = t8.data.get(s.dataId).values, [u, c] = Sc(a, o8.shape, o8.dtype, i10, p);
    return t8.makeTensorInfo(c, o8.dtype, u);
  }
  var UE = { kernelName: qi, backendName: "cpu", kernelFunc: cQ };
  function lQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { sparseIndices: n8, sparseValues: s, defaultValue: a } = e8, { outputShape: i10 } = o8, { sliceRank: p, numUpdates: u, sliceSize: c, strides: l, outputSize: m } = w.calculateShapes(s, n8, i10), d = false, f = t8.bufferSync(n8), h;
    switch (s.dtype) {
      case "bool": {
        let g = t8.bufferSync(s), x = !!t8.data.get(a.dataId).values[0];
        h = Ls(f, g, i10, m, c, u, p, l, x, d);
        break;
      }
      case "float32": {
        let g = t8.bufferSync(s), x = t8.data.get(a.dataId).values[0];
        h = Ls(f, g, i10, m, c, u, p, l, x, d);
        break;
      }
      case "int32": {
        let g = t8.bufferSync(s), x = t8.data.get(a.dataId).values[0];
        h = Ls(f, g, i10, m, c, u, p, l, x, d);
        break;
      }
      case "string": {
        let g = t8.bufferSync(s), x = y.decodeString(t8.data.get(a.dataId).values[0]);
        h = Ls(f, g, i10, m, c, u, p, l, x, d);
        break;
      }
      default:
        throw new Error(`Unsupported type ${s.dtype}`);
    }
    return t8.makeTensorInfo(i10, h.dtype, h.values);
  }
  var GE = { kernelName: vs, backendName: "cpu", kernelFunc: lQ };
  function mQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { numOrSizeSplits: s, axis: a } = o8, i10 = y.parseAxisParam(a, n8.shape)[0], p = w.prepareSplitSize(n8, s, i10), u = new Array(n8.shape.length).fill(0), c = n8.shape.slice();
    return p.map((l) => {
      let m = [...c];
      m[i10] = l;
      let d = Ao({ inputs: { x: n8 }, backend: t8, attrs: { begin: u, size: m } });
      return u[i10] += l, d;
    });
  }
  var HE = { kernelName: ga, backendName: "cpu", kernelFunc: mQ };
  var KE = { kernelName: ji, backendName: "cpu", kernelFunc: ({ inputs: r8, backend: e8 }) => {
    let { x: t8 } = r8, o8 = e8;
    Q(t8, "square");
    let n8 = o8.data.get(t8.dataId).values, s = new Float32Array(n8.length);
    for (let i10 = 0; i10 < n8.length; ++i10) {
      let p = n8[i10];
      s[i10] = p * p;
    }
    return { dataId: o8.write(s, t8.shape, t8.dtype), shape: t8.shape, dtype: t8.dtype };
  } };
  var dQ = Ie(wo, (r8, e8) => {
    let t8 = e8;
    return isNaN(r8) ? NaN : r8 > 0 ? 1 : t8.alpha;
  });
  var qE = { kernelName: wo, backendName: "cpu", kernelFunc: dQ };
  function fQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { begin: s, end: a, strides: i10, beginMask: p, endMask: u, ellipsisMask: c, newAxisMask: l, shrinkAxisMask: m } = o8;
    Q(n8, "stridedSlice");
    let { finalShapeSparse: d, finalShape: f, isIdentity: h, sliceDim0: g, isSimpleSlice: x, begin: b, end: C, strides: S } = ct.sliceInfo(n8.shape, s, a, i10, p, u, c, l, m), k;
    if (h)
      k = Ve({ inputs: { x: n8 }, backend: t8, attrs: { shape: f } });
    else if (g || x) {
      y.assert(n8.shape.length >= 1, () => `Input must have rank at least 1, got: ${n8.shape.length}`);
      let _ = ct.computeOutShape(b, C, S), E = Ao({ inputs: { x: n8 }, backend: t8, attrs: { begin: b, size: _ } });
      k = Ve({ inputs: { x: E }, backend: t8, attrs: { shape: f } }), t8.disposeIntermediateTensorInfo(E);
    } else {
      let _ = t8.bufferSync(n8), E = Ff(d, _, S, b);
      k = t8.makeTensorInfo(f, E.dtype, E.values);
    }
    return k;
  }
  var jE = { kernelName: Ns, backendName: "cpu", kernelFunc: fQ };
  function hQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { separator: n8, nGramWidths: s, leftPad: a, rightPad: i10, padWidth: p, preserveShortSequences: u } = o8, { data: c, dataSplits: l } = e8, m = t8.data.get(c.dataId).values, d = t8.data.get(l.dataId).values, [f, h] = mp(m, d, n8, s, a, i10, p, u);
    return [t8.makeTensorInfo([f.length], "string", f), t8.makeTensorInfo(l.shape, "int32", h)];
  }
  var XE = { kernelName: xa, backendName: "cpu", kernelFunc: hQ };
  function gQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { skipEmpty: n8 } = o8, { input: s, delimiter: a } = e8;
    if (s.dtype !== "string")
      throw new Error("Input must be of datatype string");
    if (s.shape.length !== 1)
      throw new Error(`Input must be a vector, got shape: ${s.shape}`);
    if (a.shape.length !== 0)
      throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);
    let i10 = t8.data.get(s.dataId).values, p = t8.data.get(a.dataId).values[0], [u, c, l] = dp(i10, p, n8), m = c.length;
    return [t8.makeTensorInfo([m, 2], "int32", u), t8.makeTensorInfo([m], "string", c), t8.makeTensorInfo([2], "int32", new Int32Array(l))];
  }
  var YE = { kernelName: Xi, backendName: "cpu", kernelFunc: gQ };
  function xQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { numBuckets: n8 } = o8, { input: s } = e8;
    if (s.dtype !== "string")
      throw new Error("Input must be of datatype string");
    if (n8 <= 0)
      throw new Error("Number of buckets must be at least 1");
    let a = t8.data.get(s.dataId).values, i10 = fp(a, n8);
    return t8.makeTensorInfo(s.shape, "int32", i10);
  }
  var QE = { kernelName: Yi, backendName: "cpu", kernelFunc: xQ };
  var yQ = Ie(_s, (r8) => Math.tan(r8));
  var ZE = { kernelName: _s, backendName: "cpu", kernelFunc: yQ };
  var bQ = Ie($s, (r8) => Math.tanh(r8));
  var JE = { kernelName: $s, backendName: "cpu", kernelFunc: bQ };
  function CQ(r8) {
    let { inputs: e8, backend: t8 } = r8, { tensor: o8, indices: n8, updates: s } = e8, { sliceRank: a, numUpdates: i10, sliceSize: p, strides: u, outputSize: c } = w.calculateShapes(s, n8, o8.shape), l = false, m = t8.bufferSync(n8), d = t8.bufferSync(s), f = t8.bufferSync(o8), h = Ls(m, d, o8.shape, c, p, i10, a, u, f, l);
    return t8.makeTensorInfo(o8.shape, h.dtype, h.values);
  }
  var eR = { kernelName: ds, backendName: "cpu", kernelFunc: CQ };
  function wQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { reps: s } = o8;
    Q(n8, "tile");
    let a = Pf(t8.bufferSync(n8), s);
    return t8.makeTensorInfo(a.shape, a.dtype, a.values);
  }
  var tR = { kernelName: uo, backendName: "cpu", kernelFunc: wQ };
  function SQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { k: s, sorted: a } = o8;
    Q(n8, "topk");
    let i10 = t8.data.get(n8.dataId).values, [p, u] = Of(i10, n8.shape, n8.dtype, s, a);
    return [t8.makeTensorInfo(p.shape, p.dtype, p.values), t8.makeTensorInfo(u.shape, u.dtype, u.values)];
  }
  var rR = { kernelName: Es, backendName: "cpu", kernelFunc: SQ };
  function IQ(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { image: n8, transforms: s } = e8, { interpolation: a, fillMode: i10, fillValue: p, outputShape: u } = t8, [c, l, m, d] = n8.shape, [f, h] = u != null ? u : [l, m], g = [c, f, h, d], x = y.computeStrides(n8.shape), b = x[0], C = x[1], S = x[2], k = y.computeStrides(g), _ = k[0], E = k[1], R = k[2], D = y.getTypedArrayFromDType(n8.dtype, y.sizeFromShape(g));
    D.fill(p);
    let P = o8.data.get(n8.dataId).values, O = o8.data.get(s.dataId).values;
    for (let L = 0; L < c; ++L) {
      let B = s.shape[0] === 1 ? O : O.subarray(L * 8, L * 8 + 8);
      for (let z = 0; z < f; ++z)
        for (let U = 0; U < h; ++U)
          for (let j = 0; j < d; ++j) {
            let q, Y = B[6] * U + B[7] * z + 1;
            if (Y === 0)
              continue;
            let J = (B[0] * U + B[1] * z + B[2]) / Y, re = (B[3] * U + B[4] * z + B[5]) / Y, ne = oR(J, m, i10), ee = oR(re, l, i10);
            switch (a) {
              case "nearest":
                q = _Q(P, l, m, b, C, S, L, ee, ne, j, p);
                break;
              case "bilinear":
                q = $Q(P, l, m, b, C, S, L, ee, ne, j, p);
                break;
              default:
                throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`);
            }
            let oe = L * _ + z * E + U * R + j;
            D[oe] = q;
          }
      return o8.makeTensorInfo(g, n8.dtype, D);
    }
    return { dataId: o8.write(D, g, n8.dtype), shape: n8.shape, dtype: n8.dtype };
  }
  var nR = { kernelName: Rs, backendName: "cpu", kernelFunc: IQ };
  function oR(r8, e8, t8) {
    switch (t8) {
      case "reflect":
        return vQ(r8, e8);
      case "wrap":
        return kQ(r8, e8);
      case "nearest":
        return TQ(r8, e8);
      case "constant":
      default:
        return NQ(r8);
    }
  }
  function vQ(r8, e8) {
    let t8 = r8;
    if (t8 < 0)
      if (e8 <= 1)
        t8 = 0;
      else {
        let o8 = 2 * e8;
        t8 < o8 && (t8 = o8 * Math.trunc(-t8 / o8) + t8), t8 = t8 < -e8 ? t8 + o8 : -t8 - 1;
      }
    else if (t8 > e8 - 1)
      if (e8 <= 1)
        t8 = 0;
      else {
        let o8 = 2 * e8;
        t8 -= o8 * Math.trunc(t8 / o8), t8 >= e8 && (t8 = o8 - t8 - 1);
      }
    return y.clamp(0, t8, e8 - 1);
  }
  function kQ(r8, e8) {
    let t8 = r8;
    if (t8 < 0)
      if (e8 <= 1)
        t8 = 0;
      else {
        let o8 = e8 - 1;
        t8 += e8 * (Math.trunc(-t8 / o8) + 1);
      }
    else if (t8 > e8 - 1)
      if (e8 <= 1)
        t8 = 0;
      else {
        let o8 = e8 - 1;
        t8 -= e8 * Math.trunc(t8 / o8);
      }
    return y.clamp(0, t8, e8 - 1);
  }
  function NQ(r8, e8) {
    return r8;
  }
  function TQ(r8, e8) {
    return y.clamp(0, r8, e8 - 1);
  }
  function Gl(r8, e8, t8, o8, n8, s, a, i10, p, u, c) {
    let l = a * o8 + i10 * n8 + p * s + u;
    return 0 <= i10 && i10 < e8 && 0 <= p && p < t8 ? r8[l] : c;
  }
  function _Q(r8, e8, t8, o8, n8, s, a, i10, p, u, c) {
    let l = Math.round(i10), m = Math.round(p);
    return Gl(r8, e8, t8, o8, n8, s, a, l, m, u, c);
  }
  function $Q(r8, e8, t8, o8, n8, s, a, i10, p, u, c) {
    let l = Math.floor(i10), m = Math.floor(p), d = l + 1, f = m + 1, h = (f - p) * Gl(r8, e8, t8, o8, n8, s, a, l, m, u, c) + (p - m) * Gl(r8, e8, t8, o8, n8, s, a, l, f, u, c), g = (f - p) * Gl(r8, e8, t8, o8, n8, s, a, d, m, u, c) + (p - m) * Gl(r8, e8, t8, o8, n8, s, a, d, f, u, c);
    return (d - i10) * h + (i10 - l) * g;
  }
  function EQ(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { axis: n8 } = t8, { x: s } = e8;
    Q(s, "unique");
    let a = o8.data.get(s.dataId).values, { outputValues: i10, outputShape: p, indices: u } = hp(a, n8, s.shape, s.dtype);
    return [o8.makeTensorInfo(p, s.dtype, i10), o8.makeTensorInfo([u.length], "int32", u)];
  }
  var sR = { kernelName: Qi, backendName: "cpu", kernelFunc: EQ };
  function RQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { value: n8 } = e8, { axis: s } = o8;
    s < 0 && (s += n8.shape.length);
    let a = n8.shape.length, i10 = n8.shape[s], p = new Array(a - 1), u = 0;
    for (let d = 0; d < a; d++)
      d !== s && (p[u++] = n8.shape[d]);
    let c = new Array(a).fill(0), l = n8.shape.slice();
    l[s] = 1;
    let m = new Array(i10);
    for (let d = 0; d < m.length; d++) {
      c[s] = d;
      let f = Ao({ inputs: { x: n8 }, backend: t8, attrs: { begin: c, size: l } });
      m[d] = Ve({ inputs: { x: f }, backend: t8, attrs: { shape: p } }), t8.disposeIntermediateTensorInfo(f);
    }
    return m;
  }
  var aR = { kernelName: ya, backendName: "cpu", kernelFunc: RQ };
  function DQ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, segmentIds: s } = e8, { numSegments: a } = o8;
    Q(n8, "unsortedSegmentSum");
    let i10 = n8.shape.length, p = s.shape.length, u = [], c = [], l = i10 - p, m = s;
    for (let f = 0; f < l; ++f) {
      let h = kc({ inputs: { input: m }, backend: t8, attrs: { dim: f + 1 } });
      m = h, c.push(h);
    }
    for (let f = 0; f < a; ++f) {
      let h = y.createScalarValue(f, "int32"), g = t8.makeTensorInfo([], "int32", h), x = OS({ inputs: { a: g, b: m }, backend: t8 }), b = Ro({ inputs: { x }, backend: t8, attrs: { dtype: "float32" } }), C = pp({ inputs: { a: b, b: n8 }, backend: t8 }), S = fi({ inputs: { x: C }, backend: t8, attrs: { axis: 0, keepDims: false } });
      u.push(S), c.push(g), c.push(x), c.push(b), c.push(C), c.push(S);
    }
    let d = hI({ inputs: u, backend: t8, attrs: { axis: 0 } });
    return c.forEach((f) => t8.disposeIntermediateTensorInfo(f)), d;
  }
  var iR = { kernelName: Zi, backendName: "cpu", kernelFunc: DQ };
  var AQ = [D_, zT, A_, F_, HT, P_, O_, M_, L_, B_, z_, V_, W_, U_, G_, K_, q_, j_, X_, R_, Y_, Q_, Z_, KT, J_, GT, qT, e$, VT, t$, o$, n$, s$, a$, i$, u$, p$, c$, l$, m$, d$, f$, h$, g$, x$, y$, b$, C$, w$, S$, I$, v$, N$, k_, T$, jT, _$, XT, $$, YT, E$, R$, D$, QT, ZT, A$, F$, P$, O$, JT, e_, WT, M$, r$, L$, B$, z$, N_, t_, r_, V$, o_, W$, U$, G$, H$, K$, q$, j$, n_, X$, Y$, Q$, Z$, eE, tE, rE, s_, oE, nE, iE, a_, i_, uE, pE, cE, u_, lE, fE, hE, zf, gE, T_, c_, xE, yE, bE, CE, UT, Vl, wE, __, $_, E_, SE, IE, vE, kE, NE, TE, _E, h_, $E, RE, DE, AE, x_, FE, PE, OE, y_, sE, LE, BE, zE, VE, WE, UE, GE, HE, C_, KE, w_, S_, qE, jE, XE, YE, QE, I_, k$, ZE, JE, eR, tR, rR, nR, p_, sR, aR, iR, mE];
  for (let r8 of AQ)
    Ja(r8);
  var $c = {};
  Ke($c, { assertNotComplex: () => Bs, bindCanvasToFramebuffer: () => WQ, bindColorTextureToFramebuffer: () => jl, bindTextureToProgramUniformSampler: () => RI, bindTextureUnit: () => lR, bindVertexBufferToProgramAttribute: () => Kf, callAndCheck: () => ce, canBeRepresented: () => bI, createFragmentShader: () => wI, createFramebuffer: () => _I, createProgram: () => SI, createStaticIndexBuffer: () => kI, createStaticVertexBuffer: () => vI, createTexture: () => NI, createVertexShader: () => CI, getBatchDim: () => gi, getExtensionOrThrow: () => Nc, getFramebufferErrorMessage: () => mR, getMaxTexturesInShader: () => FI, getNumChannels: () => zQ, getProgramUniformLocation: () => EI, getProgramUniformLocationOrThrow: () => $I, getRowsCols: () => xi, getShapeAs3D: () => _c, getTextureShapeFromLogicalShape: () => DI, getWebGLDisjointQueryTimerVersion: () => PI, getWebGLErrorMessage: () => cR, getWebGLMaxTextureSize: () => AI, hasExtension: () => qr, isCapableOfRenderingToFloatTexture: () => OI, isDownloadFloatTextureEnabled: () => MI, isReshapeFree: () => yu, isWebGLFenceEnabled: () => LI, isWebGLVersionEnabled: () => jf, linkProgram: () => II, logShaderSourceAndInfoLog: () => Hf, resetMaxTextureSize: () => UQ, resetMaxTexturesInShader: () => GQ, unbindColorTextureFromFramebuffer: () => qf, unbindTextureUnit: () => VQ, validateFramebuffer: () => Tc, validateProgram: () => ql, validateTextureSize: () => TI });
  var xp = {};
  var Vf = { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true };
  function gI(r8, e8) {
    xp[r8] = e8;
  }
  function Kr(r8, e8) {
    if (!(r8 in xp) || e8 != null) {
      let o8 = PQ(r8, e8);
      if (o8 !== null)
        xp[r8] = o8;
      else
        return console.log("Could not get context for WebGL version", r8), null;
    }
    let t8 = xp[r8];
    return t8 == null || t8.isContextLost() ? (delete xp[r8], Kr(r8)) : (t8.disable(t8.DEPTH_TEST), t8.disable(t8.STENCIL_TEST), t8.disable(t8.BLEND), t8.disable(t8.DITHER), t8.disable(t8.POLYGON_OFFSET_FILL), t8.disable(t8.SAMPLE_COVERAGE), t8.enable(t8.SCISSOR_TEST), t8.enable(t8.CULL_FACE), t8.cullFace(t8.BACK), xp[r8]);
  }
  function FQ(r8) {
    if (!A().getBool("IS_SAFARI") && typeof OffscreenCanvas != "undefined" && r8 === 2)
      return new OffscreenCanvas(300, 150);
    if (typeof document != "undefined")
      return document.createElement("canvas");
    throw new Error("Cannot create a canvas in this context");
  }
  function PQ(r8, e8) {
    if (r8 !== 1 && r8 !== 2)
      throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    let t8 = e8 == null ? FQ(r8) : e8;
    return t8.addEventListener("webglcontextlost", (o8) => {
      o8.preventDefault(), delete xp[r8];
    }, false), A().getBool("SOFTWARE_WEBGL_ENABLED") && (Vf.failIfMajorPerformanceCaveat = false), r8 === 1 ? t8.getContext("webgl", Vf) || t8.getContext("experimental-webgl", Vf) : t8.getContext("webgl2", Vf);
  }
  var xu;
  (function(r8) {
    r8[r8.DENSE = 0] = "DENSE", r8[r8.SHARED_BATCH = 1] = "SHARED_BATCH";
  })(xu || (xu = {}));
  var mr;
  (function(r8) {
    r8[r8.RENDER = 0] = "RENDER", r8[r8.UPLOAD = 1] = "UPLOAD", r8[r8.PIXELS = 2] = "PIXELS", r8[r8.DOWNLOAD = 3] = "DOWNLOAD";
  })(mr || (mr = {}));
  var tr;
  (function(r8) {
    r8[r8.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", r8[r8.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", r8[r8.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", r8[r8.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", r8[r8.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
  })(tr || (tr = {}));
  function yp(r8, e8) {
    return [e8, r8];
  }
  function uR(r8, e8) {
    return r8 * e8;
  }
  function Hl(r8) {
    let e8 = y.sizeFromShape(r8), t8 = Math.ceil(e8 / 4);
    return y.sizeToSquarishShape(t8);
  }
  function Pa(r8, e8) {
    return [Math.max(1, Math.ceil(e8 / 2)), Math.max(1, Math.ceil(r8 / 2))];
  }
  function pR(r8, e8) {
    let [t8, o8] = Pa(r8, e8);
    return t8 * o8 * 4;
  }
  function Kl(r8, e8) {
    let t8 = r8, o8, n8, s, a, i10, p, u, c, l, m;
    return A().getNumber("WEBGL_VERSION") === 2 ? (o8 = t8.R32F, n8 = t8.R16F, s = t8.RGBA16F, a = t8.RGBA32F, i10 = t8.RED, u = 4, c = 1, l = t8.HALF_FLOAT, m = t8.FLOAT, p = t8.RGBA8) : (o8 = r8.RGBA, n8 = r8.RGBA, s = r8.RGBA, a = t8.RGBA, i10 = r8.RGBA, u = 4, c = 4, l = e8 != null ? e8.HALF_FLOAT_OES : null, m = r8.FLOAT, p = r8.RGBA), { internalFormatFloat: o8, internalFormatHalfFloat: n8, internalFormatPackedHalfFloat: s, internalFormatPackedFloat: a, textureFormatFloat: i10, downloadTextureFormat: p, downloadUnpackNumChannels: u, defaultNumChannels: c, textureTypeHalfFloat: l, textureTypeFloat: m };
  }
  function ce(r8, e8) {
    let t8 = e8();
    return A().getBool("DEBUG") && OQ(r8), t8;
  }
  function OQ(r8) {
    let e8 = r8.getError();
    if (e8 !== r8.NO_ERROR)
      throw new Error("WebGL Error: " + cR(r8, e8));
  }
  var MQ = 596e-10;
  var LQ = 65504;
  function bI(r8) {
    return !!(A().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || r8 === 0 || MQ < Math.abs(r8) && Math.abs(r8) < LQ);
  }
  function cR(r8, e8) {
    switch (e8) {
      case r8.NO_ERROR:
        return "NO_ERROR";
      case r8.INVALID_ENUM:
        return "INVALID_ENUM";
      case r8.INVALID_VALUE:
        return "INVALID_VALUE";
      case r8.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case r8.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case r8.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case r8.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${e8}`;
    }
  }
  function Nc(r8, e8) {
    return hi(r8, () => r8.getExtension(e8), 'Extension "' + e8 + '" not supported on this browser.');
  }
  function CI(r8, e8) {
    let t8 = hi(r8, () => r8.createShader(r8.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    if (ce(r8, () => r8.shaderSource(t8, e8)), ce(r8, () => r8.compileShader(t8)), r8.getShaderParameter(t8, r8.COMPILE_STATUS) === false)
      throw console.log(r8.getShaderInfoLog(t8)), new Error("Failed to compile vertex shader.");
    return t8;
  }
  function wI(r8, e8) {
    let t8 = hi(r8, () => r8.createShader(r8.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    if (ce(r8, () => r8.shaderSource(t8, e8)), ce(r8, () => r8.compileShader(t8)), A().get("ENGINE_COMPILE_ONLY"))
      return t8;
    if (r8.getShaderParameter(t8, r8.COMPILE_STATUS) === false)
      throw Hf(e8, r8.getShaderInfoLog(t8)), new Error("Failed to compile fragment shader.");
    return t8;
  }
  var BQ = /ERROR: [0-9]+:([0-9]+):/g;
  function Hf(r8, e8) {
    let t8 = BQ.exec(e8);
    if (t8 == null) {
      console.log(`Couldn't parse line number in error: ${e8}`), console.log(r8);
      return;
    }
    let o8 = +t8[1], n8 = r8.split(`
`), s = n8.length.toString().length + 2, a = n8.map((l, m) => y.rightPad((m + 1).toString(), s) + l), i10 = 0;
    for (let l = 0; l < a.length; l++)
      i10 = Math.max(a[l].length, i10);
    let p = a.slice(0, o8 - 1), u = a.slice(o8 - 1, o8), c = a.slice(o8);
    console.log(p.join(`
`)), console.log(e8.split(`
`)[0]), console.log(`%c ${y.rightPad(u[0], i10)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join(`
`));
  }
  function SI(r8) {
    return hi(r8, () => r8.createProgram(), "Unable to create WebGLProgram.");
  }
  function II(r8, e8) {
    if (ce(r8, () => r8.linkProgram(e8)), !A().get("ENGINE_COMPILE_ONLY") && r8.getProgramParameter(e8, r8.LINK_STATUS) === false)
      throw console.log(r8.getProgramInfoLog(e8)), new Error("Failed to link vertex and fragment shaders.");
  }
  function ql(r8, e8) {
    if (ce(r8, () => r8.validateProgram(e8)), r8.getProgramParameter(e8, r8.VALIDATE_STATUS) === false)
      throw console.log(r8.getProgramInfoLog(e8)), new Error("Shader program validation failed.");
  }
  function vI(r8, e8) {
    let t8 = hi(r8, () => r8.createBuffer(), "Unable to create WebGLBuffer");
    return ce(r8, () => r8.bindBuffer(r8.ARRAY_BUFFER, t8)), ce(r8, () => r8.bufferData(r8.ARRAY_BUFFER, e8, r8.STATIC_DRAW)), t8;
  }
  function kI(r8, e8) {
    let t8 = hi(r8, () => r8.createBuffer(), "Unable to create WebGLBuffer");
    return ce(r8, () => r8.bindBuffer(r8.ELEMENT_ARRAY_BUFFER, t8)), ce(r8, () => r8.bufferData(r8.ELEMENT_ARRAY_BUFFER, e8, r8.STATIC_DRAW)), t8;
  }
  function zQ() {
    return A().getNumber("WEBGL_VERSION") === 2 ? 1 : 4;
  }
  function NI(r8) {
    return hi(r8, () => r8.createTexture(), "Unable to create WebGLTexture.");
  }
  function TI(r8, e8) {
    let t8 = A().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (r8 <= 0 || e8 <= 0) {
      let o8 = `[${r8}x${e8}]`;
      throw new Error("Requested texture size " + o8 + " is invalid.");
    }
    if (r8 > t8 || e8 > t8) {
      let o8 = `[${r8}x${e8}]`, n8 = `[${t8}x${t8}]`;
      throw new Error("Requested texture size " + o8 + " greater than WebGL maximum on this browser / GPU " + n8 + ".");
    }
  }
  function _I(r8) {
    return hi(r8, () => r8.createFramebuffer(), "Unable to create WebGLFramebuffer.");
  }
  function Kf(r8, e8, t8, o8, n8, s, a) {
    let i10 = r8.getAttribLocation(e8, t8);
    return i10 === -1 ? false : (ce(r8, () => r8.bindBuffer(r8.ARRAY_BUFFER, o8)), ce(r8, () => r8.vertexAttribPointer(i10, n8, r8.FLOAT, false, s, a)), ce(r8, () => r8.enableVertexAttribArray(i10)), true);
  }
  function lR(r8, e8, t8) {
    dR(r8, t8), ce(r8, () => r8.activeTexture(r8.TEXTURE0 + t8)), ce(r8, () => r8.bindTexture(r8.TEXTURE_2D, e8));
  }
  function VQ(r8, e8) {
    dR(r8, e8), ce(r8, () => r8.activeTexture(r8.TEXTURE0 + e8)), ce(r8, () => r8.bindTexture(r8.TEXTURE_2D, null));
  }
  function $I(r8, e8, t8) {
    return hi(r8, () => r8.getUniformLocation(e8, t8), 'uniform "' + t8 + '" not present in program.');
  }
  function EI(r8, e8, t8) {
    return r8.getUniformLocation(e8, t8);
  }
  function RI(r8, e8, t8, o8) {
    ce(r8, () => lR(r8, e8, o8)), ce(r8, () => r8.uniform1i(t8, o8));
  }
  function WQ(r8) {
    ce(r8, () => r8.bindFramebuffer(r8.FRAMEBUFFER, null)), ce(r8, () => r8.viewport(0, 0, r8.canvas.width, r8.canvas.height)), ce(r8, () => r8.scissor(0, 0, r8.canvas.width, r8.canvas.height));
  }
  function jl(r8, e8, t8) {
    ce(r8, () => r8.bindFramebuffer(r8.FRAMEBUFFER, t8)), ce(r8, () => r8.framebufferTexture2D(r8.FRAMEBUFFER, r8.COLOR_ATTACHMENT0, r8.TEXTURE_2D, e8, 0));
  }
  function qf(r8, e8) {
    ce(r8, () => r8.bindFramebuffer(r8.FRAMEBUFFER, e8)), ce(r8, () => r8.framebufferTexture2D(r8.FRAMEBUFFER, r8.COLOR_ATTACHMENT0, r8.TEXTURE_2D, null, 0));
  }
  function Tc(r8) {
    let e8 = r8.checkFramebufferStatus(r8.FRAMEBUFFER);
    if (e8 !== r8.FRAMEBUFFER_COMPLETE)
      throw new Error("Error binding framebuffer: " + mR(r8, e8));
  }
  function mR(r8, e8) {
    switch (e8) {
      case r8.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case r8.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case r8.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case r8.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${e8}`;
    }
  }
  function hi(r8, e8, t8) {
    let o8 = ce(r8, () => e8());
    if (o8 == null)
      throw new Error(t8);
    return o8;
  }
  function dR(r8, e8) {
    let t8 = r8.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, o8 = e8 + r8.TEXTURE0;
    if (o8 < r8.TEXTURE0 || o8 > t8) {
      let n8 = `[gl.TEXTURE0, gl.TEXTURE${t8}]`;
      throw new Error(`textureUnit must be in ${n8}.`);
    }
  }
  function gi(r8, e8 = 2) {
    return y.sizeFromShape(r8.slice(0, r8.length - e8));
  }
  function xi(r8) {
    if (r8.length === 0)
      throw Error("Cannot get rows and columns of an empty shape array.");
    return [r8.length > 1 ? r8[r8.length - 2] : 1, r8[r8.length - 1]];
  }
  function _c(r8) {
    let e8 = [1, 1, 1];
    return r8.length === 0 || r8.length === 1 && r8[0] === 1 || (e8 = [gi(r8), ...xi(r8)]), e8;
  }
  function DI(r8, e8 = false) {
    let t8 = A().getNumber("WEBGL_MAX_TEXTURE_SIZE"), o8 = A().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    o8 === 1 / 0 && A().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (o8 = t8 / 2), e8 && (t8 = t8 * 2, o8 = o8 * 2, r8 = r8.map((i10, p) => p >= r8.length - 2 ? y.nearestLargerEven(r8[p]) : r8[p]), r8.length === 1 && (r8 = [2, r8[0]])), r8.length !== 2 && (r8 = y.squeezeShape(r8).newShape);
    let n8 = y.sizeFromShape(r8), s = null;
    r8.length <= 1 && n8 <= t8 ? s = [1, n8] : r8.length === 2 && r8[0] <= t8 && r8[1] <= t8 ? s = r8 : r8.length === 3 && r8[0] * r8[1] <= t8 && r8[2] <= t8 ? s = [r8[0] * r8[1], r8[2]] : r8.length === 3 && r8[0] <= t8 && r8[1] * r8[2] <= t8 ? s = [r8[0], r8[1] * r8[2]] : r8.length === 4 && r8[0] * r8[1] * r8[2] <= t8 && r8[3] <= t8 ? s = [r8[0] * r8[1] * r8[2], r8[3]] : r8.length === 4 && r8[0] <= t8 && r8[1] * r8[2] * r8[3] <= t8 && (s = [r8[0], r8[1] * r8[2] * r8[3]]);
    let a = s != null && Math.max(...s) > o8 && Math.min(...s) <= (e8 ? 2 : 1) && Math.min(...s) > 0;
    if (s == null || a)
      if (e8) {
        let i10 = gi(r8), p = 2, u = 2;
        r8.length && ([p, u] = xi(r8)), n8 = i10 * (p / 2) * (u / 2), s = y.sizeToSquarishShape(n8).map((c) => c * 2);
      } else
        s = y.sizeToSquarishShape(n8);
    return s;
  }
  function Wf(r8) {
    return r8 % 2 === 0;
  }
  function yu(r8, e8) {
    if (r8 = r8.slice(-2), e8 = e8.slice(-2), y.arraysEqual(r8, e8) || !r8.length || !e8.length || r8[0] === 0 || r8[1] === 0 || e8[0] === 0 || e8[1] === 0)
      return true;
    if (r8.length !== e8.length) {
      let t8 = r8[r8.length - 1], o8 = e8[e8.length - 1];
      if (t8 === o8 || Wf(t8) && Wf(o8) && (r8[0] === 1 || e8[0] === 1))
        return true;
    }
    return r8[1] === e8[1] && Wf(r8[0]) && Wf(e8[0]);
  }
  var Uf;
  var Gf;
  function AI(r8) {
    if (Uf == null) {
      let e8 = Kr(r8);
      Uf = e8.getParameter(e8.MAX_TEXTURE_SIZE);
    }
    return Uf;
  }
  function UQ() {
    Uf = null;
  }
  function GQ() {
    Gf = null;
  }
  function FI(r8) {
    if (Gf == null) {
      let e8 = Kr(r8);
      Gf = e8.getParameter(e8.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, Gf);
  }
  function PI(r8) {
    if (r8 === 0)
      return 0;
    let e8, t8 = Kr(r8);
    return qr(t8, "EXT_disjoint_timer_query_webgl2") && r8 === 2 ? e8 = 2 : qr(t8, "EXT_disjoint_timer_query") ? e8 = 1 : e8 = 0, e8;
  }
  function qr(r8, e8) {
    return r8.getExtension(e8) != null;
  }
  function jf(r8) {
    try {
      if (Kr(r8) != null)
        return true;
    } catch (e8) {
      return console.log("Error when getting WebGL context: ", e8), false;
    }
    return false;
  }
  function OI(r8) {
    if (r8 === 0)
      return false;
    let e8 = Kr(r8);
    if (r8 === 1) {
      if (!qr(e8, "OES_texture_float"))
        return false;
    } else if (!qr(e8, "EXT_color_buffer_float"))
      return false;
    return yI(e8);
  }
  function MI(r8) {
    if (r8 === 0)
      return false;
    let e8 = Kr(r8);
    if (r8 === 1) {
      if (!qr(e8, "OES_texture_float") || !qr(e8, "WEBGL_color_buffer_float"))
        return false;
    } else {
      if (qr(e8, "EXT_color_buffer_float"))
        return yI(e8);
      let o8 = "EXT_color_buffer_half_float";
      if (qr(e8, o8)) {
        let n8 = e8.getExtension(o8);
        return HQ(e8, n8);
      }
      return false;
    }
    return yI(e8);
  }
  function yI(r8) {
    let e8 = Kl(r8), t8 = r8.createTexture();
    r8.bindTexture(r8.TEXTURE_2D, t8);
    let o8 = 1, n8 = 1;
    r8.texImage2D(r8.TEXTURE_2D, 0, e8.internalFormatFloat, o8, n8, 0, e8.textureFormatFloat, e8.textureTypeFloat, null);
    let s = r8.createFramebuffer();
    r8.bindFramebuffer(r8.FRAMEBUFFER, s), r8.framebufferTexture2D(r8.FRAMEBUFFER, r8.COLOR_ATTACHMENT0, r8.TEXTURE_2D, t8, 0);
    let a = r8.checkFramebufferStatus(r8.FRAMEBUFFER) === r8.FRAMEBUFFER_COMPLETE;
    return r8.bindTexture(r8.TEXTURE_2D, null), r8.bindFramebuffer(r8.FRAMEBUFFER, null), r8.deleteTexture(t8), r8.deleteFramebuffer(s), a;
  }
  function HQ(r8, e8) {
    let t8 = Kl(r8, e8), o8 = r8.createTexture();
    r8.bindTexture(r8.TEXTURE_2D, o8);
    let n8 = 1, s = 1;
    r8.texImage2D(r8.TEXTURE_2D, 0, t8.internalFormatHalfFloat, n8, s, 0, t8.textureFormatFloat, t8.textureTypeHalfFloat, null);
    let a = r8.createFramebuffer();
    r8.bindFramebuffer(r8.FRAMEBUFFER, a), r8.framebufferTexture2D(r8.FRAMEBUFFER, r8.COLOR_ATTACHMENT0, r8.TEXTURE_2D, o8, 0);
    let i10 = r8.checkFramebufferStatus(r8.FRAMEBUFFER) === r8.FRAMEBUFFER_COMPLETE;
    return r8.bindTexture(r8.TEXTURE_2D, null), r8.bindFramebuffer(r8.FRAMEBUFFER, null), r8.deleteTexture(o8), r8.deleteFramebuffer(a), i10;
  }
  function LI(r8) {
    return r8 !== 2 ? false : Kr(r8).fenceSync != null;
  }
  function Bs(r8, e8) {
    Array.isArray(r8) || (r8 = [r8]), r8.forEach((t8) => {
      t8 != null && y.assert(t8.dtype !== "complex64", () => `${e8} does not support complex64 tensors in the WebGL backend.`);
    });
  }
  var Se = A();
  Se.registerFlag("HAS_WEBGL", () => Se.getNumber("WEBGL_VERSION") > 0);
  Se.registerFlag("WEBGL_VERSION", () => jf(2) ? 2 : jf(1) ? 1 : 0);
  Se.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  Se.registerFlag("WEBGL_BUFFER_SUPPORTED", () => Se.get("WEBGL_VERSION") === 2);
  Se.registerFlag("WEBGL_CPU_FORWARD", () => true);
  Se.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  Se.registerFlag("WEBGL_PACK", () => Se.getBool("HAS_WEBGL"));
  Se.registerFlag("WEBGL_PACK_NORMALIZATION", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_PACK_CLIP", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_PACK_REDUCE", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_LAZILY_UNPACK", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_CONV_IM2COL", () => Se.getBool("WEBGL_PACK"));
  Se.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => AI(Se.getNumber("WEBGL_VERSION")));
  Se.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => FI(Se.getNumber("WEBGL_VERSION")));
  Se.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    let r8 = Se.getNumber("WEBGL_VERSION");
    return r8 === 0 ? 0 : PI(r8);
  });
  Se.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => Se.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !ru.isMobile());
  Se.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => OI(Se.getNumber("WEBGL_VERSION")));
  Se.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => Se.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : Se.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));
  Se.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => MI(Se.getNumber("WEBGL_VERSION")));
  Se.registerFlag("WEBGL_FENCE_API_ENABLED", () => LI(Se.getNumber("WEBGL_VERSION")));
  Se.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => Se.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0);
  Se.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (r8) => {
    if (r8 < 0 && r8 !== -1)
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r8}.`);
  });
  Se.registerFlag("WEBGL_FLUSH_THRESHOLD", () => ru.isMobile() ? 1 : -1, (r8) => {
    if (r8 < 0 && r8 !== -1)
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r8}.`);
  });
  Se.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  Se.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  Se.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  Se.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
  Se.registerFlag("WEBGL_EXP_CONV", () => false);
  Se.registerFlag("SOFTWARE_WEBGL_ENABLED", () => Se.getBool("IS_TEST"));
  Se.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0);
  Se.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
  Se.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
  Se.registerFlag("ENGINE_COMPILE_ONLY", () => false);
  function vt() {
    let r8, e8, t8, o8, n8, s, a, i10, p, u;
    return A().getNumber("WEBGL_VERSION") === 2 ? (r8 = "#version 300 es", e8 = "in", t8 = "out", o8 = "in", n8 = "texture", s = "outputColor", a = "out vec4 outputColor;", i10 = A().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "", p = "", u = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (r8 = "", e8 = "attribute", t8 = "varying", o8 = "varying", n8 = "texture2D", s = "gl_FragColor", a = "", i10 = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, p = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, u = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), { version: r8, attribute: e8, varyingVs: t8, varyingFs: o8, texture2D: n8, output: s, defineOutput: a, defineSpecialNaN: i10, defineSpecialInf: p, defineRound: u };
  }
  function zs(r8, e8, t8 = "index") {
    let o8 = y.computeStrides(e8);
    return o8.map((n8, s) => {
      let a = `int ${r8[s]} = ${t8} / ${n8}`, i10 = s === o8.length - 1 ? `int ${r8[s + 1]} = ${t8} - ${r8[s]} * ${n8}` : `index -= ${r8[s]} * ${n8}`;
      return `${a}; ${i10};`;
    }).join("");
  }
  function bp(r8, e8, t8 = "index") {
    let o8 = y.computeStrides(e8);
    return o8.map((n8, s) => {
      let a = `int ${r8[s]} = ${t8} / outShapeStrides[${s}]`, i10 = s === o8.length - 1 ? `int ${r8[s + 1]} = ${t8} - ${r8[s]} * outShapeStrides[${s}]` : `index -= ${r8[s]} * outShapeStrides[${s}]`;
      return `${a}; ${i10};`;
    }).join("");
  }
  function KQ(r8, e8) {
    let t8 = r8.length, o8 = r8.map((s) => `${e8}[${s}]`), n8 = new Array(t8 - 1);
    n8[t8 - 2] = o8[t8 - 1];
    for (let s = t8 - 3; s >= 0; --s)
      n8[s] = `(${n8[s + 1]} * ${o8[s + 1]})`;
    return n8;
  }
  function fR(r8, e8, t8 = "index") {
    let o8 = r8.map((s, a) => a), n8 = KQ(o8, e8);
    return n8.map((s, a) => {
      let i10 = `int ${r8[a]} = ${t8} / ${n8[a]}`, p = a === n8.length - 1 ? `int ${r8[a + 1]} = ${t8} - ${r8[a]} * ${n8[a]}` : `index -= ${r8[a]} * ${n8[a]}`;
      return `${i10}; ${p};`;
    }).join("");
  }
  function Ec(r8) {
    let e8 = y.computeStrides(r8).map((t8) => t8.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e8[0]} + coords.y * ${e8[1]} + coords.z;
  }
`;
  }
  function Rc() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
  }
  var Xf = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
  var { getBroadcastDims: hR } = w;
  function gR(r8, e8, t8) {
    let o8 = [];
    if (r8.forEach((d) => {
      let f = y.sizeFromShape(d.shapeInfo.logicalShape);
      if (d.shapeInfo.isUniform ? o8.push(`uniform float ${d.name}${f > 1 ? `[${f}]` : ""};`) : (o8.push(`uniform sampler2D ${d.name};`), o8.push(`uniform int offset${d.name};`)), t8.enableShapeUniforms) {
        let { uniformShape: h } = Yf(t8.packedInputs, d.shapeInfo.logicalShape, d.shapeInfo.texShape);
        switch (h.length) {
          case 1:
            o8.push(`uniform int ${d.name}Shape;`);
            break;
          case 2:
            o8.push(`uniform ivec2 ${d.name}Shape;`);
            break;
          case 3:
            o8.push(`uniform ivec3 ${d.name}Shape;`);
            break;
          case 4:
            o8.push(`uniform ivec4 ${d.name}Shape;`);
            break;
        }
        o8.push(`uniform ivec2 ${d.name}TexShape;`);
      }
    }), t8.enableShapeUniforms) {
      switch (e8.logicalShape.length) {
        case 1:
          o8.push("uniform int outShape;");
          break;
        case 2:
          o8.push("uniform ivec2 outShape;"), o8.push("uniform int outShapeStrides;");
          break;
        case 3:
          o8.push("uniform ivec3 outShape;"), o8.push("uniform ivec2 outShapeStrides;");
          break;
        case 4:
          o8.push("uniform ivec4 outShape;"), o8.push("uniform ivec3 outShapeStrides;");
          break;
      }
      o8.push("uniform ivec2 outTexShape;");
    }
    t8.customUniforms && t8.customUniforms.forEach((d) => {
      o8.push(`uniform ${d.type} ${d.name}${d.arrayIndex ? `[${d.arrayIndex}]` : ""};`);
    });
    let n8 = o8.join(`
`), s = r8.map((d) => qQ(d, e8, t8.packedInputs, t8.enableShapeUniforms)).join(`
`), a = e8.texShape, i10 = vt(), p = YQ(i10), u, c, l = JQ(i10);
    return e8.isPacked ? (u = jQ(e8.logicalShape, a, t8.enableShapeUniforms), c = ZQ(i10)) : (u = XQ(e8.logicalShape, a, t8.enableShapeUniforms), c = QQ(i10)), t8.packedInputs && (l += oZ), [l, p, c, n8, u, s, t8.userCode].join(`
`);
  }
  function Ac(r8, e8 = false) {
    let t8 = r8.shapeInfo.logicalShape;
    switch (t8.length) {
      case 0:
        return hZ(r8, e8);
      case 1:
        return xZ(r8, e8);
      case 2:
        return bZ(r8, e8);
      case 3:
        return wZ(r8, e8);
      case 4:
        return IZ(r8, e8);
      case 5:
        return vZ(r8);
      case 6:
        return kZ(r8);
      default:
        throw new Error(`${t8.length}-D input sampling is not yet supported`);
    }
  }
  function xR(r8, e8) {
    switch (r8.shapeInfo.logicalShape.length) {
      case 0:
        return fZ(r8);
      case 1:
        return gZ(r8, e8);
      case 2:
        return yZ(r8, e8);
      case 3:
        return CZ(r8, e8);
      default:
        return SZ(r8, e8);
    }
  }
  function qQ(r8, e8, t8 = false, o8) {
    let n8 = "";
    t8 ? n8 += xR(r8, o8) : n8 += Ac(r8, o8);
    let s = r8.shapeInfo.logicalShape, a = e8.logicalShape;
    return s.length <= a.length && (t8 ? n8 += NZ(r8, e8) : n8 += TZ(r8, e8)), n8;
  }
  function jQ(r8, e8, t8) {
    switch (r8.length) {
      case 0:
        return yR();
      case 1:
        return nZ(r8, e8, t8);
      case 2:
        return mZ(r8, e8, t8);
      case 3:
        return aZ(r8, e8, t8);
      default:
        return uZ(r8, e8, t8);
    }
  }
  function XQ(r8, e8, t8) {
    switch (r8.length) {
      case 0:
        return yR();
      case 1:
        return sZ(r8, e8, t8);
      case 2:
        return dZ(r8, e8, t8);
      case 3:
        return iZ(r8, e8, t8);
      case 4:
        return pZ(r8, e8, t8);
      case 5:
        return cZ(r8, e8);
      case 6:
        return lZ(r8, e8);
      default:
        throw new Error(`${r8.length}-D output sampling is not yet supported`);
    }
  }
  function YQ(r8) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r8.texture2D}(textureSampler, uv).r;
    }
  `;
  }
  function QQ(r8) {
    return `
    void setOutput(float val) {
      ${r8.output} = vec4(val, 0, 0, 0);
    }
  `;
  }
  function ZQ(r8) {
    return `
    void setOutput(vec4 val) {
      ${r8.output} = val;
    }
  `;
  }
  function JQ(r8) {
    return `${r8.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r8.varyingFs} vec2 resultUV;
    ${r8.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r8.defineSpecialNaN}
    ${r8.defineSpecialInf}
    ${r8.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${eZ}
    ${tZ}
    ${rZ}
  `;
  }
  var eZ = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var tZ = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var rZ = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var oZ = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
  function yR() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
  }
  function nZ(r8, e8, t8) {
    let o8 = [Math.ceil(e8[0] / 2), Math.ceil(e8[1] / 2)];
    return o8[0] === 1 ? t8 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${o8[1]}.0);
      }
    ` : o8[1] === 1 ? t8 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${o8[0]}.0);
      }
    ` : t8 ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o8[0]}, ${o8[1]}));
      return 2 * (resTexRC.x * ${o8[1]} + resTexRC.y);
    }
  `;
  }
  function sZ(r8, e8, t8) {
    return e8[0] === 1 ? t8 ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${e8[1]}.0);
      }
    ` : e8[1] === 1 ? t8 ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${e8[0]}.0);
      }
    ` : t8 ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e8[0]}, ${e8[1]}));
      return resTexRC.x * ${e8[1]} + resTexRC.y;
    }
  `;
  }
  function aZ(r8, e8, t8) {
    if (t8)
      return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    let o8 = [Math.ceil(e8[0] / 2), Math.ceil(e8[1] / 2)], n8 = Math.ceil(r8[2] / 2), s = n8 * Math.ceil(r8[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o8[0]}, ${o8[1]}));
      int index = resTexRC.x * ${o8[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n8});
      int c = imod(index, ${n8}) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  function iZ(r8, e8, t8) {
    if (t8)
      return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${bp(["r", "c", "d"], r8)}
    return ivec3(r, c, d);
  }
`;
    let o8 = zs(["r", "c", "d"], r8);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e8[0]}, ${e8[1]}));
      int index = resTexRC.x * ${e8[1]} + resTexRC.y;
      ${o8}
      return ivec3(r, c, d);
    }
  `;
  }
  function uZ(r8, e8, t8) {
    if (t8)
      return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    let o8 = [Math.ceil(e8[0] / 2), Math.ceil(e8[1] / 2)], n8 = Math.ceil(r8[r8.length - 1] / 2), s = n8 * Math.ceil(r8[r8.length - 2] / 2), a = s, i10 = "", p = "b, r, c";
    for (let u = 2; u < r8.length - 1; u++)
      a *= r8[r8.length - u - 1], i10 = `
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    ` + i10, p = `b${u}, ` + p;
    return `
    ivec${r8.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o8[0]}, ${o8[1]}));
      int index = resTexRC.x * ${o8[1]} + resTexRC.y;

      ${i10}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n8});
      int c = imod(index, ${n8}) * 2;

      return ivec${r8.length}(${p});
    }
  `;
  }
  function pZ(r8, e8, t8) {
    if (t8)
      return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${bp(["r", "c", "d", "d2"], r8)}
      return ivec4(r, c, d, d2);
    }
  `;
    let o8 = zs(["r", "c", "d", "d2"], r8);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e8[0]}, ${e8[1]}));
      int index = resTexRC.x * ${e8[1]} + resTexRC.y;
      ${o8}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  function cZ(r8, e8) {
    let t8 = zs(["r", "c", "d", "d2", "d3"], r8);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e8[0]},
                             ${e8[1]}));

      int index = resTexRC.x * ${e8[1]} + resTexRC.y;

      ${t8}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
  }
  function lZ(r8, e8) {
    let t8 = zs(["r", "c", "d", "d2", "d3", "d4"], r8);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e8[0]}, ${e8[1]}));
      int index = resTexRC.x * ${e8[1]} + resTexRC.y;

      ${t8}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
  }
  function mZ(r8, e8, t8) {
    let o8 = [Math.ceil(e8[0] / 2), Math.ceil(e8[1] / 2)];
    if (y.arraysEqual(r8, e8))
      return t8 ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${o8[0]}, ${o8[1]}));
      }
    `;
    let n8 = Math.ceil(r8[1] / 2);
    return t8 ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o8[0]}, ${o8[1]}));

      int index = resTexRC.x * ${o8[1]} + resTexRC.y;
      int r = 2 * (index / ${n8});
      int c = imod(index, ${n8}) * 2;

      return ivec2(r, c);
    }
  `;
  }
  function dZ(r8, e8, t8) {
    return y.arraysEqual(r8, e8) ? t8 ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e8[0]}, ${e8[1]}));
      }
    ` : r8[1] === 1 ? t8 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e8[0]}, ${e8[1]}));
        int index = resTexRC.x * ${e8[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : r8[0] === 1 ? t8 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e8[0]}, ${e8[1]}));
        int index = resTexRC.x * ${e8[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : t8 ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e8[0]}, ${e8[1]}));
      int index = resTexRC.x * ${e8[1]} + resTexRC.y;
      int r = index / ${r8[1]};
      int c = index - r * ${r8[1]};
      return ivec2(r, c);
    }
  `;
  }
  function Cp(r8) {
    return `offset${r8}`;
  }
  function fZ(r8) {
    let e8 = r8.name, t8 = "get" + e8.charAt(0).toUpperCase() + e8.slice(1), o8 = vt();
    return `
    vec4 ${t8}() {
      return ${o8.texture2D}(${e8}, halfCR);
    }
  `;
  }
  function hZ(r8, e8) {
    let t8 = r8.name, o8 = "get" + t8.charAt(0).toUpperCase() + t8.slice(1);
    if (r8.shapeInfo.isUniform)
      return `float ${o8}() {return ${t8};}`;
    let [n8, s] = r8.shapeInfo.texShape;
    if (n8 === 1 && s === 1)
      return `
      float ${o8}() {
        return sampleTexture(${t8}, halfCR);
      }
    `;
    let a = Cp(t8);
    if (e8)
      return `
    float ${o8}() {
      vec2 uv = uvFromFlat(${t8}TexShape[0], ${t8}TexShape[1], ${a});
      return sampleTexture(${t8}, uv);
    }
  `;
    let [i10, p] = r8.shapeInfo.texShape;
    return `
    float ${o8}() {
      vec2 uv = uvFromFlat(${i10}, ${p}, ${a});
      return sampleTexture(${t8}, uv);
    }
  `;
  }
  function gZ(r8, e8) {
    let t8 = r8.name, o8 = "get" + t8.charAt(0).toUpperCase() + t8.slice(1), n8 = r8.shapeInfo.texShape, s = vt();
    if (e8)
      return `
    vec4 ${o8}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t8}TexShape[0]) / 2.0), ceil(float(${t8}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t8}, uv);
    }
  `;
    let a = [Math.ceil(n8[0] / 2), Math.ceil(n8[1] / 2)];
    return `
    vec4 ${o8}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${t8}, uv);
    }
  `;
  }
  function xZ(r8, e8) {
    let t8 = r8.name, o8 = "get" + t8.charAt(0).toUpperCase() + t8.slice(1);
    if (r8.shapeInfo.isUniform)
      return `
      float ${o8}(int index) {
        ${Fc(r8)}
      }
    `;
    let n8 = r8.shapeInfo.texShape, s = n8[0], a = n8[1];
    if (a === 1 && s === 1)
      return `
      float ${o8}(int index) {
        return sampleTexture(${t8}, halfCR);
      }
    `;
    let i10 = Cp(t8);
    return a === 1 ? e8 ? `
      float ${o8}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i10}) + 0.5) / float(${t8}TexShape[0]));
        return sampleTexture(${t8}, uv);
      }
    ` : `
      float ${o8}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i10}) + 0.5) / ${s}.0);
        return sampleTexture(${t8}, uv);
      }
    ` : s === 1 ? e8 ? `
      float ${o8}(int index) {
        vec2 uv = vec2((float(index + ${i10}) + 0.5) / float(${t8}TexShape[1]), 0.5);
        return sampleTexture(${t8}, uv);
      }
    ` : `
      float ${o8}(int index) {
        vec2 uv = vec2((float(index + ${i10}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t8}, uv);
      }
    ` : e8 ? `
    float ${o8}(int index) {
      vec2 uv = uvFromFlat(${t8}TexShape[0], ${t8}TexShape[1], index + ${i10});
      return sampleTexture(${t8}, uv);
    }
  ` : `
    float ${o8}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i10});
      return sampleTexture(${t8}, uv);
    }
  `;
  }
  function yZ(r8, e8) {
    let t8 = r8.shapeInfo.logicalShape, o8 = r8.name, n8 = "get" + o8.charAt(0).toUpperCase() + o8.slice(1), s = r8.shapeInfo.texShape, a = s[0], i10 = s[1], p = vt();
    if (s != null && y.arraysEqual(t8, s))
      return e8 ? `
      vec4 ${n8}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o8}TexShape[1], ${o8}TexShape[0]);

        return ${p.texture2D}(${o8}, uv);
      }
    ` : `
      vec4 ${n8}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i10}.0, ${a}.0);

        return ${p.texture2D}(${o8}, uv);
      }
    `;
    if (e8)
      return `
    vec4 ${n8}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o8}TexShape[0]) / 2.0), ceil(float(${o8}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o8}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${p.texture2D}(${o8}, uv);
    }
  `;
    let u = [Math.ceil(s[0] / 2), Math.ceil(s[1] / 2)], c = Math.ceil(t8[1] / 2);
    return `
    vec4 ${n8}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${p.texture2D}(${o8}, uv);
    }
  `;
  }
  function bZ(r8, e8) {
    let t8 = r8.shapeInfo.logicalShape, o8 = r8.name, n8 = "get" + o8.charAt(0).toUpperCase() + o8.slice(1), s = r8.shapeInfo.texShape;
    if (s != null && y.arraysEqual(t8, s)) {
      if (e8)
        return `
      float ${n8}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o8}TexShape[1], ${o8}TexShape[0]);
        return sampleTexture(${o8}, uv);
      }
    `;
      let m = s[0], d = s[1];
      return `
    float ${n8}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${m}.0);
      return sampleTexture(${o8}, uv);
    }
  `;
    }
    let { newShape: a, keptDims: i10 } = y.squeezeShape(t8), p = a;
    if (p.length < t8.length) {
      let m = Pc(r8, p), d = ["row", "col"];
      return `
      ${Ac(m, e8)}
      float ${n8}(int row, int col) {
        return ${n8}(${Oc(d, i10)});
      }
    `;
    }
    if (r8.shapeInfo.isUniform)
      return `
      float ${n8}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t8[1]}, 1)));
        ${Fc(r8)}
      }
    `;
    let u = s[0], c = s[1], l = Cp(o8);
    return c === 1 ? e8 ? `
      float ${n8}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${o8}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${o8}TexShape[0]));
        return sampleTexture(${o8}, uv);
      }
    ` : `
    float ${n8}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${t8[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${o8}, uv);
    }
  ` : u === 1 ? e8 ? `
      float ${n8}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${o8}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${o8}TexShape[1]), 0.5);
        return sampleTexture(${o8}, uv);
      }
    ` : `
    float ${n8}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${t8[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${o8}, uv);
    }
  ` : e8 ? `
      float ${n8}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o8}Shape[1] + col + ${l};
        vec2 uv = uvFromFlat(${o8}TexShape[0], ${o8}TexShape[1], index);
        return sampleTexture(${o8}, uv);
      }
    ` : `
  float ${n8}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t8[1]} + col + ${l};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${o8}, uv);
  }
`;
  }
  function CZ(r8, e8) {
    let t8 = r8.shapeInfo.logicalShape, o8 = r8.name, n8 = "get" + o8.charAt(0).toUpperCase() + o8.slice(1), s = r8.shapeInfo.texShape, a = [Math.ceil(s[0] / 2), Math.ceil(s[1] / 2)];
    if (t8[0] === 1) {
      let m = t8.slice(1), d = [1, 2], f = Pc(r8, m), h = ["b", "row", "col"];
      return `
        ${xR(f, e8)}
        vec4 ${n8}(int b, int row, int col) {
          return ${n8}(${Oc(h, d)});
        }
      `;
    }
    let i10 = vt();
    if (e8)
      return `
    vec4 ${n8}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o8}TexShape[0]) / 2.0), ceil(float(${o8}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o8}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${o8}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i10.texture2D}(${o8}, uv);
    }
  `;
    let p = a[0], u = a[1], c = Math.ceil(t8[2] / 2), l = c * Math.ceil(t8[1] / 2);
    return `
    vec4 ${n8}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${u}, ${l}, ${c}, b, row, col);
      return ${i10.texture2D}(${o8}, uv);
    }
  `;
  }
  function wZ(r8, e8) {
    let t8 = r8.shapeInfo.logicalShape, o8 = r8.name, n8 = "get" + o8.charAt(0).toUpperCase() + o8.slice(1), s = t8[1] * t8[2], a = t8[2], { newShape: i10, keptDims: p } = y.squeezeShape(t8), u = i10;
    if (u.length < t8.length) {
      let h = Pc(r8, u), g = ["row", "col", "depth"];
      return `
        ${Ac(h, e8)}
        float ${n8}(int row, int col, int depth) {
          return ${n8}(${Oc(g, p)});
        }
      `;
    }
    if (r8.shapeInfo.isUniform)
      return `
      float ${n8}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${Fc(r8)}
      }
    `;
    let c = r8.shapeInfo.texShape, l = c[0], m = c[1], d = r8.shapeInfo.flatOffset;
    if (m === s && d == null)
      return e8 ? `
      float ${n8}(int row, int col, int depth) {
        int stride1 = ${o8}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o8}TexShape[1], ${o8}TexShape[0]);
        return sampleTexture(${o8}, uv);
      }
    ` : `
        float ${n8}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${l}.0);
          return sampleTexture(${o8}, uv);
        }
      `;
    if (m === a && d == null)
      return e8 ? `
      float ${n8}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${o8}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o8}TexShape[1], ${o8}TexShape[0]);
        return sampleTexture(${o8}, uv);
      }
    ` : `
    float ${n8}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t8[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${l}.0);
      return sampleTexture(${o8}, uv);
    }
  `;
    let f = Cp(o8);
    return e8 ? `
    float ${n8}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${o8}Shape[1] * ${o8}Shape[2];
      int stride1 = ${o8}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${o8}TexShape[0], ${o8}TexShape[1], index);
      return sampleTexture(${o8}, uv);
    }
    ` : `
      float ${n8}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${l}, ${m}, index);
        return sampleTexture(${o8}, uv);
      }
  `;
  }
  function SZ(r8, e8) {
    let t8 = r8.name, o8 = "get" + t8.charAt(0).toUpperCase() + t8.slice(1), n8 = vt();
    if (e8)
      return `
    vec4 ${o8}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t8}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t8}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t8}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t8}TexShape[0]) / 2.0), ceil(float(${t8}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${n8.texture2D}(${t8}, uv);
    }
  `;
    let s = r8.shapeInfo.logicalShape, a = s.length, i10 = r8.shapeInfo.texShape, p = [Math.ceil(i10[0] / 2), Math.ceil(i10[1] / 2)], u = p[0], c = p[1], l = Math.ceil(s[a - 1] / 2), m = l * Math.ceil(s[a - 2] / 2), d = "int b, int row, int col", f = `b * ${m} + (row / 2) * ${l} + (col / 2)`;
    for (let h = 2; h < a - 1; h++)
      d = `int b${h}, ` + d, m *= s[a - h - 1], f = `b${h} * ${m} + ` + f;
    return `
    vec4 ${o8}(${d}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${n8.texture2D}(${t8}, uv);
    }
  `;
  }
  function IZ(r8, e8) {
    let t8 = r8.shapeInfo.logicalShape, o8 = r8.name, n8 = "get" + o8.charAt(0).toUpperCase() + o8.slice(1), s = t8[3], a = t8[2] * s, i10 = t8[1] * a, { newShape: p, keptDims: u } = y.squeezeShape(t8);
    if (p.length < t8.length) {
      let b = Pc(r8, p), C = ["row", "col", "depth", "depth2"];
      return `
      ${Ac(b, e8)}
      float ${n8}(int row, int col, int depth, int depth2) {
        return ${n8}(${Oc(C, u)});
      }
    `;
    }
    if (r8.shapeInfo.isUniform)
      return `
      float ${n8}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i10}, ${a}, ${s}, 1)));
        ${Fc(r8)}
      }
    `;
    let c = r8.shapeInfo.flatOffset, l = r8.shapeInfo.texShape, m = l[0], d = l[1], f = `int stride2 = ${o8}Shape[3];`, h = `int stride1 = ${o8}Shape[2] * stride2;`, g = `int stride0 = ${o8}Shape[1] * stride1;`;
    if (d === i10 && c == null)
      return e8 ? `
      float ${n8}(int row, int col, int depth, int depth2) {
        ${f}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o8}TexShape[1], ${o8}TexShape[0]);
        return sampleTexture(${o8}, uv);
      }
    ` : `
      float ${n8}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${m}.0);
        return sampleTexture(${o8}, uv);
      }
    `;
    if (d === s && c == null)
      return e8 ? `
      float ${n8}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${o8}Shape[1] * ${o8}Shape[2], ${o8}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${o8}TexShape[1], ${o8}TexShape[0]);
        return sampleTexture(${o8}, uv);
      }
    ` : `
      float ${n8}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t8[1] * t8[2]}, ${t8[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${m}.0);
        return sampleTexture(${o8}, uv);
      }
    `;
    let x = Cp(o8);
    return e8 ? `
    float ${n8}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${o8}TexShape[0], ${o8}TexShape[1], index + ${x});
      return sampleTexture(${o8}, uv);
    }
  ` : `
    float ${n8}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i10} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${d}, index + ${x});
      return sampleTexture(${o8}, uv);
    }
  `;
  }
  function vZ(r8) {
    let e8 = r8.shapeInfo.logicalShape, t8 = r8.name, o8 = "get" + t8.charAt(0).toUpperCase() + t8.slice(1), n8 = e8[4], s = e8[3] * n8, a = e8[2] * s, i10 = e8[1] * a, { newShape: p, keptDims: u } = y.squeezeShape(e8);
    if (p.length < e8.length) {
      let h = Pc(r8, p), g = ["row", "col", "depth", "depth2", "depth3"];
      return `
      ${Ac(h)}
      float ${o8}(int row, int col, int depth, int depth2, int depth3) {
        return ${o8}(${Oc(g, u)});
      }
    `;
    }
    if (r8.shapeInfo.isUniform)
      return `
      float ${o8}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i10}, ${a}, ${s}, ${n8})) +
          depth3;
        ${Fc(r8)}
      }
    `;
    let c = r8.shapeInfo.flatOffset, l = r8.shapeInfo.texShape, m = l[0], d = l[1];
    if (d === i10 && c == null)
      return `
      float ${o8}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${n8}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${m}.0);
        return sampleTexture(${t8}, uv);
      }
    `;
    if (d === n8 && c == null)
      return `
      float ${o8}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e8[1] * e8[2] * e8[3]},
               ${e8[2] * e8[3]}, ${e8[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${m}.0);
        return sampleTexture(${t8}, uv);
      }
    `;
    let f = Cp(t8);
    return `
    float ${o8}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i10} + col * ${a} + depth * ${s} +
          depth2 * ${n8} + depth3 + ${f};
      vec2 uv = uvFromFlat(${m}, ${d}, index);
      return sampleTexture(${t8}, uv);
    }
  `;
  }
  function kZ(r8) {
    let e8 = r8.shapeInfo.logicalShape, t8 = r8.name, o8 = "get" + t8.charAt(0).toUpperCase() + t8.slice(1), { newShape: n8, keptDims: s } = y.squeezeShape(e8);
    if (n8.length < e8.length) {
      let g = Pc(r8, n8), x = ["row", "col", "depth", "depth2", "depth3", "depth4"];
      return `
      ${Ac(g)}
      float ${o8}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${o8}(${Oc(x, s)});
      }
    `;
    }
    let a = e8[5], i10 = e8[4] * a, p = e8[3] * i10, u = e8[2] * p, c = e8[1] * u;
    if (r8.shapeInfo.isUniform)
      return `
      float ${o8}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${p}, ${i10})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Fc(r8)}
      }
    `;
    let l = r8.shapeInfo.flatOffset, m = r8.shapeInfo.texShape, d = m[0], f = m[1];
    if (f === c && l == null)
      return `
      float ${o8}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${p}, ${i10}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t8}, uv);
      }
    `;
    if (f === a && l == null)
      return `
      float ${o8}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e8[1] * e8[2] * e8[3] * e8[4]},
               ${e8[2] * e8[3] * e8[4]},
               ${e8[3] * e8[4]},
               ${e8[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t8}, uv);
      }
    `;
    let h = Cp(t8);
    return `
    float ${o8}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${p} +
          depth2 * ${i10} + depth3 * ${a} + depth4 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t8}, uv);
    }
  `;
  }
  function Fc(r8) {
    let e8 = r8.name, t8 = y.sizeFromShape(r8.shapeInfo.logicalShape);
    return t8 < 2 ? `return ${e8};` : `
    for (int i = 0; i < ${t8}; i++) {
      if (i == index) {
        return ${e8}[i];
      }
    }
  `;
  }
  function NZ(r8, e8) {
    let t8 = r8.name, o8 = t8.charAt(0).toUpperCase() + t8.slice(1), n8 = "get" + o8 + "AtOutCoords", s = r8.shapeInfo.logicalShape.length, a = e8.logicalShape.length, i10 = hR(r8.shapeInfo.logicalShape, e8.logicalShape), p = Re(a), u = a - s, c, l = ["x", "y", "z", "w", "u", "v"];
    s === 0 ? c = "" : a < 2 && i10.length >= 1 ? c = "coords = 0;" : c = i10.map((b) => `coords.${l[b + u]} = 0;`).join(`
`);
    let m = "";
    a < 2 && s > 0 ? m = "coords" : m = r8.shapeInfo.logicalShape.map((b, C) => `coords.${l[C + u]}`).join(", ");
    let d = "return outputValue;", h = y.sizeFromShape(r8.shapeInfo.logicalShape) === 1, x = y.sizeFromShape(e8.logicalShape) === 1;
    if (s === 1 && !h && !x)
      d = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    else if (h && !x)
      a === 1 ? d = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : d = `
        return vec4(outputValue.x);
      `;
    else if (i10.length) {
      let b = s - 2, C = s - 1;
      i10.indexOf(b) > -1 && i10.indexOf(C) > -1 ? d = "return vec4(outputValue.x);" : i10.indexOf(b) > -1 ? d = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : i10.indexOf(C) > -1 && (d = "return vec4(outputValue.xx, outputValue.zz);");
    }
    return `
    vec4 ${n8}() {
      ${p} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${o8}(${m});
      ${d}
    }
  `;
  }
  function TZ(r8, e8) {
    let t8 = r8.name, o8 = t8.charAt(0).toUpperCase() + t8.slice(1), n8 = "get" + o8 + "AtOutCoords", s = e8.texShape, a = r8.shapeInfo.texShape, i10 = r8.shapeInfo.logicalShape.length, p = e8.logicalShape.length;
    if (!r8.shapeInfo.isUniform && i10 === p && r8.shapeInfo.flatOffset == null && y.arraysEqual(a, s))
      return `
      float ${n8}() {
        return sampleTexture(${t8}, resultUV);
      }
    `;
    let u = Re(p), c = hR(r8.shapeInfo.logicalShape, e8.logicalShape), l = p - i10, m, d = ["x", "y", "z", "w", "u", "v"];
    i10 === 0 ? m = "" : p < 2 && c.length >= 1 ? m = "coords = 0;" : m = c.map((h) => `coords.${d[h + l]} = 0;`).join(`
`);
    let f = "";
    return p < 2 && i10 > 0 ? f = "coords" : f = r8.shapeInfo.logicalShape.map((h, g) => `coords.${d[g + l]}`).join(", "), `
    float ${n8}() {
      ${u} coords = getOutputCoords();
      ${m}
      return get${o8}(${f});
    }
  `;
  }
  function Re(r8) {
    if (r8 <= 1)
      return "int";
    if (r8 === 2)
      return "ivec2";
    if (r8 === 3)
      return "ivec3";
    if (r8 === 4)
      return "ivec4";
    if (r8 === 5)
      return "ivec5";
    if (r8 === 6)
      return "ivec6";
    throw Error(`GPU for rank ${r8} is not yet supported`);
  }
  function Yf(r8, e8, t8) {
    let { newShape: o8, keptDims: n8 } = y.squeezeShape(e8), s = e8.length, a = r8 && s === 3 && e8[0] === 1, i10 = a ? e8.slice(1) : o8, p = !r8 && s > 1 && !y.arraysEqual(e8, t8) && o8.length < s || a;
    return { useSqueezeShape: p, uniformShape: p ? i10 : e8, keptDims: n8 };
  }
  function Pc(r8, e8) {
    let t8 = JSON.parse(JSON.stringify(r8));
    return t8.shapeInfo.logicalShape = e8, t8;
  }
  function Oc(r8, e8) {
    return e8.map((t8) => r8[t8]).join(", ");
  }
  function CR(r8, e8, t8, o8) {
    let n8 = t8.map((c, l) => {
      let m = { logicalShape: c.shape, texShape: c.isUniform ? null : c.texData.texShape, isUniform: c.isUniform, isPacked: c.isUniform ? false : c.texData.isPacked, flatOffset: null };
      return c.texData != null && c.texData.slice != null && c.texData.slice.flatOffset > 0 && (m.flatOffset = c.texData.slice.flatOffset), { name: e8.variableNames[l], shapeInfo: m };
    }), s = n8.map((c) => c.shapeInfo), a = { logicalShape: o8.shape, texShape: o8.texData.texShape, isUniform: false, isPacked: o8.texData.isPacked, flatOffset: null }, i10 = gR(n8, a, e8), p = wI(r8.gl, i10), u = r8.createProgram(p);
    return A().get("ENGINE_COMPILE_ONLY") ? { program: e8, fragmentShader: p, source: i10, webGLProgram: u, inShapeInfos: s, outShapeInfo: a, variablesLocations: null, customUniformLocations: null, infLoc: null, nanLoc: null, outShapeLocation: null, outShapeStridesLocation: null, outTexShapeLocation: null } : (r8.buildVao(u), Object.assign({ program: e8, fragmentShader: p, source: i10, webGLProgram: u, inShapeInfos: s, outShapeInfo: a }, BI(r8, e8, u)));
  }
  function BI(r8, e8, t8) {
    let o8 = [], n8 = [], s, a, i10, p = null, u = null;
    u = r8.getUniformLocation(t8, "NAN", false), A().getNumber("WEBGL_VERSION") === 1 && (p = r8.getUniformLocation(t8, "INFINITY", false));
    let c = false;
    for (let l of e8.variableNames) {
      let m = { name: l, uniform: r8.getUniformLocation(t8, l, c), offset: r8.getUniformLocation(t8, `offset${l}`, c) };
      e8.enableShapeUniforms && (m.shape = r8.getUniformLocation(t8, `${l}Shape`, c), m.texShape = r8.getUniformLocation(t8, `${l}TexShape`, c)), o8.push(m);
    }
    if (e8.enableShapeUniforms && (s = r8.getUniformLocation(t8, "outShape", c), i10 = r8.getUniformLocation(t8, "outShapeStrides", c), a = r8.getUniformLocation(t8, "outTexShape", c)), e8.customUniforms)
      for (let l of e8.customUniforms)
        n8.push(r8.getUniformLocation(t8, l.name, c));
    return { variablesLocations: o8, customUniformLocations: n8, infLoc: p, nanLoc: u, outShapeLocation: s, outShapeStridesLocation: i10, outTexShapeLocation: a };
  }
  function bR(r8, e8) {
    if (r8.length !== e8.length)
      throw Error(`Binary was compiled with ${r8.length} inputs, but was executed with ${e8.length} inputs`);
    r8.forEach((t8, o8) => {
      let n8 = t8.logicalShape, s = e8[o8], a = s.shape;
      if (!y.arraysEqual(n8, a))
        throw Error(`Binary was compiled with different shapes than the current args. Shapes ${n8} and ${a} must match`);
      if (t8.isUniform && s.isUniform)
        return;
      let i10 = t8.texShape, p = s.isUniform ? null : s.texData.texShape;
      if (!y.arraysEqual(i10, p))
        throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i10} and ${p} must match`);
    });
  }
  function wR(r8, e8, t8, o8, n8) {
    e8.program.enableShapeUniforms || (bR(e8.inShapeInfos, t8), bR([e8.outShapeInfo], [o8]));
    let s = o8.texData.texture, a = o8.texData.texShape;
    o8.texData.isPacked ? r8.setOutputPackedMatrixTexture(s.texture, a[0], a[1]) : r8.setOutputMatrixTexture(s.texture, a[0], a[1]), r8.setProgram(e8.webGLProgram), r8.bindVertexArray(e8.webGLProgram.vao), A().getNumber("WEBGL_VERSION") === 1 && e8.infLoc !== null && r8.gl.uniform1f(e8.infLoc, 1 / 0), e8.nanLoc !== null && r8.gl.uniform1f(e8.nanLoc, NaN);
    for (let p = 0; p < t8.length; ++p) {
      let u = t8[p], { uniform: c, offset: l, shape: m, texShape: d } = e8.variablesLocations[p];
      if (m) {
        let { uniformShape: f } = Yf(e8.program.packedInputs, u.shape, u.texData.texShape);
        switch (f.length) {
          case 1:
            r8.gl.uniform1iv(m, new Int32Array(f));
            break;
          case 2:
            r8.gl.uniform2iv(m, new Int32Array(f));
            break;
          case 3:
            r8.gl.uniform3iv(m, new Int32Array(f));
            break;
          case 4:
            r8.gl.uniform4iv(m, new Int32Array(f));
            break;
        }
      }
      if (d && r8.gl.uniform2i(d, u.texData.texShape[0], u.texData.texShape[1]), c != null) {
        if (u.isUniform) {
          if (y.sizeFromShape(u.shape) < 2)
            r8.gl.uniform1f(c, u.uniformValues[0]);
          else {
            let f = u.uniformValues;
            f instanceof Float32Array || (f = new Float32Array(f)), r8.gl.uniform1fv(c, f);
          }
          continue;
        }
        u.texData.slice != null && l != null && r8.gl.uniform1i(l, u.texData.slice.flatOffset), r8.setInputMatrixTexture(u.texData.texture.texture, c, p);
      }
    }
    let i10 = e8.outShapeLocation;
    if (i10)
      switch (o8.shape.length) {
        case 1:
          r8.gl.uniform1iv(i10, new Int32Array(o8.shape));
          break;
        case 2:
          r8.gl.uniform2iv(i10, new Int32Array(o8.shape));
          break;
        case 3:
          r8.gl.uniform3iv(i10, new Int32Array(o8.shape));
          break;
        case 4:
          r8.gl.uniform4iv(i10, new Int32Array(o8.shape));
          break;
      }
    if (e8.outShapeStridesLocation) {
      let p = y.computeStrides(o8.shape);
      switch (o8.shape.length) {
        case 2:
          r8.gl.uniform1iv(e8.outShapeStridesLocation, new Int32Array(p));
          break;
        case 3:
          r8.gl.uniform2iv(e8.outShapeStridesLocation, new Int32Array(p));
          break;
        case 4:
          r8.gl.uniform3iv(e8.outShapeStridesLocation, new Int32Array(p));
          break;
      }
    }
    if (e8.outTexShapeLocation && r8.gl.uniform2i(e8.outTexShapeLocation, o8.texData.texShape[0], o8.texData.texShape[1]), e8.program.customUniforms && n8)
      for (let p = 0; p < e8.program.customUniforms.length; ++p) {
        let u = e8.program.customUniforms[p], c = e8.customUniformLocations[p], l = n8[p];
        if (u.type === "float")
          r8.gl.uniform1fv(c, l);
        else if (u.type === "vec2")
          r8.gl.uniform2fv(c, l);
        else if (u.type === "vec3")
          r8.gl.uniform3fv(c, l);
        else if (u.type === "vec4")
          r8.gl.uniform4fv(c, l);
        else if (u.type === "int")
          r8.gl.uniform1iv(c, l);
        else if (u.type === "ivec2")
          r8.gl.uniform2iv(c, l);
        else if (u.type === "ivec3")
          r8.gl.uniform3iv(c, l);
        else if (u.type === "ivec4")
          r8.gl.uniform4iv(c, l);
        else
          throw Error(`uniform type ${u.type} is not supported yet.`);
      }
    r8.executeProgram();
  }
  function SR(r8, e8, t8) {
    let o8 = "";
    e8.concat(t8).forEach((a) => {
      let i10 = a.texData != null && a.texData.slice != null && a.texData.slice.flatOffset > 0;
      if (r8.enableShapeUniforms && !a.isUniform) {
        let p = a.texData.texShape, { useSqueezeShape: u, uniformShape: c, keptDims: l } = Yf(r8.packedInputs, a.shape, p), m = "", d = "", f = "";
        if (c.length === 1 && r8.packedInputs) {
          let k = [Math.ceil(p[0] / 2), Math.ceil(p[1] / 2)];
          m = `${k[0] > 1}_${k[1] > 1}`;
        } else if (c.length === 2 && !r8.packedInputs)
          d = `${c[0] > 1}_${c[1] > 1}`;
        else if (c.length > 2 && !r8.packedInputs) {
          let k = y.computeStrides(c);
          f = `${k[0] === p[1]}_${k[k.length - 1] === p[1]}`;
        }
        let h = a.shape.length, g = c.length === 2 && y.arraysEqual(a.shape, p), x = y.sizeFromShape(a.shape) === 1, b = w.getBroadcastDims(a.shape, t8.shape), C = !r8.packedInputs && h === t8.shape.length && y.arraysEqual(p, t8.texData.texShape), S = r8.packedInputs || c.length > 2 ? "" : `${p[0] > 1}_${p[1] > 1}`;
        o8 += `${h}_${C}_${u ? l : ""}_${c.length}_${x}_${b}_${g}_${m}_${d}_${f}_${S}_${i10}`;
      } else {
        let p = a.isUniform ? "uniform" : a.texData.texShape;
        o8 += `${a.shape}_${p}_${i10}`;
      }
    });
    let n8 = r8.userCode, s = r8.constructor.name;
    return s += "_" + o8 + "_" + n8 + `${A().getNumber("WEBGL_VERSION")}`, s;
  }
  function pt(r8) {
    return A().getBool("WEBGL_USE_SHAPES_UNIFORMS") && r8 <= 4;
  }
  var Qf = class {
    constructor(e8) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = xu.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let t8 = vt();
      this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? bp(["r", "c", "d"], e8) : zs(["r", "c", "d"], e8)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t8.output} = result;
      }
    `;
    }
  };
  var Zf = class {
    constructor(e8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = xu.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let t8 = vt();
      this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? bp(["r", "c", "d"], e8) : zs(["r", "c", "d"], e8)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t8.output} = result;
      }
    `;
    }
  };
  var Jf = class {
    constructor(e8) {
      this.variableNames = ["A"], this.outTexUsage = mr.DOWNLOAD;
      let t8 = vt();
      this.outputShape = e8, this.userCode = `
      ${Xf}

      void main() {
        float x = getAAtOutCoords();
        ${t8.output} = encode_float(x);
      }
    `;
    }
  };
  var eh = class {
    constructor(e8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = mr.DOWNLOAD;
      let t8 = vt();
      this.outputShape = e8, this.userCode = `
      ${Xf}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t8.output} = encode_float(x);
      }
    `;
    }
  };
  var EZ = { R: 0, G: 1, B: 2, A: 3 };
  var Xl = class {
    constructor(e8, t8 = false, o8 = "RGBA") {
      this.variableNames = ["A"], this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let n8 = vt();
      this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length);
      let s = "result";
      t8 && (s = "floor(result * 255. + 0.5)");
      let a = "";
      for (let i10 = 0; i10 < o8.length; i10++) {
        let p = o8[i10];
        a += `
          if(offset == ${i10}) {
            result = values[${EZ[p]}];
          }`;
      }
      this.userCode = `
      ${this.enableShapeUniforms ? Rc() : Ec(e8)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${o8.length});

        flatIndex = idiv(flatIndex, ${o8.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${n8.texture2D}(A, uv);
          ${a}
        }
        ${n8.output} = vec4(${s}, 0., 0., 0.);
      }
    `;
    }
  };
  var th = class {
    constructor(e8, t8 = false) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      let o8 = vt();
      this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length);
      let n8 = "", s = "result";
      t8 && (s = "floor(result * 255. + 0.5)");
      for (let a = 0; a <= 1; a++)
        for (let i10 = 0; i10 <= 1; i10++) {
          let p = a * 2 + i10;
          n8 += `
          localCoords = coords;
          if(localCoords[2] + ${i10} < ${this.enableShapeUniforms ? "outShape[2]" : `${e8[2]}`}) {
          localCoords[2] += ${i10};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms ? "outShape[1]" : `${e8[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${o8.texture2D}(A, uv);

            if (offset == 0) {
              result[${p}] = values[0];
            } else if (offset == 1) {
              result[${p}] = values[1];
            } else if (offset == 2) {
              result[${p}] = values[2];
            } else {
              result[${p}] = values[3];
            }
          }
        }
        `;
        }
      this.userCode = `
        ${this.enableShapeUniforms ? Rc() : Ec(e8)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${n8}

          ${o8.output} = ${s};
        }
    `;
    }
  };
  var rv = {};
  Ke(rv, { bindVertexProgramAttributeStreams: () => jI, createBufferFromOutputTexture: () => QI, createFloat16MatrixTexture: () => GI, createFloat16PackedMatrixTexture: () => qI, createFloat32MatrixTexture: () => UI, createIndexBuffer: () => WI, createPackedMatrixTexture: () => KI, createUnsignedBytesMatrixTexture: () => HI, createVertexBuffer: () => VI, createVertexShader: () => zI, downloadByteEncodedFloatMatrixFromOutputTexture: () => JI, downloadFloat32MatrixFromBuffer: () => ZI, downloadMatrixFromPackedOutputTexture: () => tv, downloadPackedMatrixFromBuffer: () => ev, getInternalFormatForFloat16MatrixTexture: () => oh, getInternalFormatForFloat16PackedMatrixTexture: () => ah, getInternalFormatForFloat32MatrixTexture: () => rh, getInternalFormatForPackedMatrixTexture: () => sh, getInternalFormatForUnsignedBytesMatrixTexture: () => nh, uploadDenseMatrixToTexture: () => XI, uploadPixelDataToTexture: () => YI });
  function zI(r8) {
    let e8 = vt(), t8 = `${e8.version}
    precision highp float;
    ${e8.attribute} vec3 clipSpacePos;
    ${e8.attribute} vec2 uv;
    ${e8.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return CI(r8, t8);
  }
  function VI(r8) {
    let e8 = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return vI(r8, e8);
  }
  function WI(r8) {
    let e8 = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return kI(r8, e8);
  }
  function Yl(r8, e8, t8, o8, n8, s) {
    TI(e8, t8);
    let a = NI(r8), i10 = r8.TEXTURE_2D;
    return ce(r8, () => r8.bindTexture(i10, a)), ce(r8, () => r8.texParameteri(i10, r8.TEXTURE_WRAP_S, r8.CLAMP_TO_EDGE)), ce(r8, () => r8.texParameteri(i10, r8.TEXTURE_WRAP_T, r8.CLAMP_TO_EDGE)), ce(r8, () => r8.texParameteri(i10, r8.TEXTURE_MIN_FILTER, r8.NEAREST)), ce(r8, () => r8.texParameteri(i10, r8.TEXTURE_MAG_FILTER, r8.NEAREST)), A().getNumber("WEBGL_VERSION") === 1 ? ce(r8, () => r8.texImage2D(i10, 0, o8, e8, t8, 0, n8, s, null)) : ce(r8, () => r8.texStorage2D(i10, 1, o8, e8, t8)), ce(r8, () => r8.bindTexture(r8.TEXTURE_2D, null)), { texture: a, texShape: [t8, e8] };
  }
  function rh(r8) {
    return r8.internalFormatFloat;
  }
  function UI(r8, e8, t8, o8) {
    let [n8, s] = yp(e8, t8);
    return Yl(r8, n8, s, rh(o8), o8.textureFormatFloat, r8.FLOAT);
  }
  function oh(r8) {
    return r8.internalFormatHalfFloat;
  }
  function GI(r8, e8, t8, o8) {
    let [n8, s] = yp(e8, t8);
    return Yl(r8, n8, s, oh(o8), o8.textureFormatFloat, o8.textureTypeHalfFloat);
  }
  function nh(r8) {
    return r8.downloadTextureFormat;
  }
  function HI(r8, e8, t8, o8) {
    let [n8, s] = yp(e8, t8);
    return Yl(r8, n8, s, nh(o8), r8.RGBA, r8.UNSIGNED_BYTE);
  }
  function sh(r8) {
    return r8.internalFormatPackedFloat;
  }
  function KI(r8, e8, t8, o8) {
    let [n8, s] = Pa(e8, t8);
    return Yl(r8, n8, s, sh(o8), r8.RGBA, r8.FLOAT);
  }
  function ah(r8) {
    return r8.internalFormatPackedHalfFloat;
  }
  function qI(r8, e8, t8, o8) {
    let [n8, s] = Pa(e8, t8);
    return Yl(r8, n8, s, ah(o8), r8.RGBA, o8.textureTypeHalfFloat);
  }
  function jI(r8, e8, t8) {
    return ce(r8, () => r8.bindBuffer(r8.ARRAY_BUFFER, t8)), Kf(r8, e8, "clipSpacePos", t8, 3, 20, 0) && Kf(r8, e8, "uv", t8, 2, 20, 12);
  }
  function XI(r8, e8, t8, o8, n8, s) {
    ce(r8, () => r8.bindTexture(r8.TEXTURE_2D, e8));
    let a, i10, p;
    n8 instanceof Uint8Array ? (a = new Uint8Array(t8 * o8 * 4), i10 = r8.UNSIGNED_BYTE, p = r8.RGBA) : (a = new Float32Array(t8 * o8 * 4), i10 = r8.FLOAT, p = s.internalFormatPackedFloat), a.set(n8), A().getNumber("WEBGL_VERSION") === 2 ? ce(r8, () => r8.texSubImage2D(r8.TEXTURE_2D, 0, 0, 0, t8, o8, r8.RGBA, i10, a)) : ce(r8, () => r8.texImage2D(r8.TEXTURE_2D, 0, p, t8, o8, 0, r8.RGBA, i10, a)), ce(r8, () => r8.bindTexture(r8.TEXTURE_2D, null));
  }
  function YI(r8, e8, t8) {
    ce(r8, () => r8.bindTexture(r8.TEXTURE_2D, e8)), t8.data instanceof Uint8Array ? A().getNumber("WEBGL_VERSION") === 2 ? ce(r8, () => r8.texSubImage2D(r8.TEXTURE_2D, 0, 0, 0, t8.width, t8.height, r8.RGBA, r8.UNSIGNED_BYTE, t8.data)) : ce(r8, () => r8.texImage2D(r8.TEXTURE_2D, 0, r8.RGBA, t8.width, t8.height, 0, r8.RGBA, r8.UNSIGNED_BYTE, t8.data)) : A().getNumber("WEBGL_VERSION") === 2 ? ce(r8, () => r8.texSubImage2D(r8.TEXTURE_2D, 0, 0, 0, r8.RGBA, r8.UNSIGNED_BYTE, t8)) : ce(r8, () => r8.texImage2D(r8.TEXTURE_2D, 0, r8.RGBA, r8.RGBA, r8.UNSIGNED_BYTE, t8)), ce(r8, () => r8.bindTexture(r8.TEXTURE_2D, null));
  }
  function QI(r8, e8, t8, o8) {
    let n8 = r8.createBuffer();
    ce(r8, () => r8.bindBuffer(r8.PIXEL_PACK_BUFFER, n8));
    let i10 = 4 * 4 * e8 * t8;
    return ce(r8, () => r8.bufferData(r8.PIXEL_PACK_BUFFER, i10, r8.STREAM_READ)), ce(r8, () => r8.readPixels(0, 0, t8, e8, r8.RGBA, r8.FLOAT, 0)), ce(r8, () => r8.bindBuffer(r8.PIXEL_PACK_BUFFER, null)), n8;
  }
  function ZI(r8, e8, t8) {
    let o8 = r8, n8 = new Float32Array(t8);
    return o8.bindBuffer(o8.PIXEL_PACK_BUFFER, e8), o8.getBufferSubData(o8.PIXEL_PACK_BUFFER, 0, n8), o8.bindBuffer(o8.PIXEL_PACK_BUFFER, null), n8;
  }
  function JI(r8, e8, t8, o8) {
    let [n8, s] = yp(e8, t8), a = 4, i10 = new Uint8Array(uR(e8 * t8, a));
    return ce(r8, () => r8.readPixels(0, 0, n8, s, o8.downloadTextureFormat, r8.UNSIGNED_BYTE, i10)), new Float32Array(i10.buffer);
  }
  function ev(r8, e8, t8, o8, n8, s, a, i10) {
    let p = r8, u = new Float32Array(pR(s, a));
    return p.bindBuffer(p.PIXEL_PACK_BUFFER, e8), p.getBufferSubData(p.PIXEL_PACK_BUFFER, 0, u), p.bindBuffer(p.PIXEL_PACK_BUFFER, null), u;
  }
  function tv(r8, e8, t8) {
    let o8 = new Float32Array(e8 * t8 * 4);
    return ce(r8, () => r8.readPixels(0, 0, t8, e8, r8.RGBA, r8.FLOAT, o8)), o8;
  }
  var wp = class {
    constructor(e8) {
      this.outputTexture = null, this.program = null, this.disposed = false, this.itemsToPoll = [];
      let t8 = A().getNumber("WEBGL_VERSION");
      if (e8 != null ? (this.gl = e8, gI(t8, e8)) : this.gl = Kr(t8), e8 = this.gl, A().getNumber("WEBGL_VERSION") === 2) {
        let s = e8;
        this.createVertexArray = () => ce(s, () => s.createVertexArray()), this.bindVertexArray = (a) => ce(s, () => s.bindVertexArray(a)), this.deleteVertexArray = (a) => ce(s, () => s.deleteVertexArray(a)), this.getVertexArray = () => ce(s, () => s.getParameter(s.VERTEX_ARRAY_BINDING));
      } else if (e8 != null) {
        let s = e8.getExtension("OES_vertex_array_object");
        if (s == null)
          throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        this.createVertexArray = () => ce(e8, () => s.createVertexArrayOES()), this.bindVertexArray = (a) => ce(e8, () => s.bindVertexArrayOES(a)), this.deleteVertexArray = (a) => ce(e8, () => s.deleteVertexArrayOES(a)), this.getVertexArray = () => ce(e8, () => e8.getParameter(s.VERTEX_ARRAY_BINDING_OES));
      }
      let o8 = "WEBGL_color_buffer_float", n8 = "EXT_color_buffer_half_float";
      if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), A().getNumber("WEBGL_VERSION") === 1) {
        let s = "OES_texture_float", a = "OES_texture_half_float";
        if (this.textureFloatExtension = Nc(this.gl, s), qr(this.gl, a))
          this.textureHalfFloatExtension = Nc(this.gl, a);
        else if (A().get("WEBGL_FORCE_F16_TEXTURES"))
          throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        if (this.colorBufferFloatExtension = this.gl.getExtension(o8), qr(this.gl, n8))
          this.colorBufferHalfFloatExtension = Nc(this.gl, n8);
        else if (A().get("WEBGL_FORCE_F16_TEXTURES"))
          throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      } else if (o8 = "EXT_color_buffer_float", qr(this.gl, o8))
        this.colorBufferFloatExtension = this.gl.getExtension(o8);
      else if (qr(this.gl, n8))
        this.colorBufferHalfFloatExtension = this.gl.getExtension(n8);
      else
        throw new Error("GL context does not support color renderable floats");
      this.vertexBuffer = VI(this.gl), this.indexBuffer = WI(this.gl), this.framebuffer = _I(this.gl), this.textureConfig = Kl(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
      return A().getBool("DEBUG");
    }
    dispose() {
      if (this.disposed)
        return;
      this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      let e8 = this.gl;
      ce(e8, () => e8.finish()), ce(e8, () => e8.bindFramebuffer(e8.FRAMEBUFFER, null)), ce(e8, () => e8.deleteFramebuffer(this.framebuffer)), ce(e8, () => e8.bindBuffer(e8.ARRAY_BUFFER, null)), ce(e8, () => e8.bindBuffer(e8.ELEMENT_ARRAY_BUFFER, null)), ce(e8, () => e8.deleteBuffer(this.indexBuffer)), this.disposed = true;
    }
    createFloat32MatrixTexture(e8, t8) {
      return this.throwIfDisposed(), UI(this.gl, e8, t8, this.textureConfig);
    }
    createFloat16MatrixTexture(e8, t8) {
      return this.throwIfDisposed(), GI(this.gl, e8, t8, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(e8, t8) {
      return this.throwIfDisposed(), HI(this.gl, e8, t8, this.textureConfig);
    }
    uploadPixelDataToTexture(e8, t8) {
      this.throwIfDisposed(), YI(this.gl, e8, t8);
    }
    uploadDenseMatrixToTexture(e8, t8, o8, n8) {
      this.throwIfDisposed(), XI(this.gl, e8, t8, o8, n8, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(e8, t8) {
      return this.throwIfDisposed(), qI(this.gl, e8, t8, this.textureConfig);
    }
    createPackedMatrixTexture(e8, t8) {
      return this.throwIfDisposed(), KI(this.gl, e8, t8, this.textureConfig);
    }
    deleteMatrixTexture(e8) {
      this.throwIfDisposed(), this.outputTexture === e8 && (qf(this.gl, this.framebuffer), this.outputTexture = null), ce(this.gl, () => this.gl.deleteTexture(e8));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(e8, t8, o8) {
      return this.downloadMatrixDriver(e8, () => JI(this.gl, t8, o8, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(e8, t8, o8, n8, s, a) {
      return ev(this.gl, e8, t8, o8, n8, s, a, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(e8, t8) {
      return ZI(this.gl, e8, t8);
    }
    createBufferFromTexture(e8, t8, o8) {
      this.bindTextureToFrameBuffer(e8);
      let n8 = QI(this.gl, t8, o8, this.textureConfig);
      return this.unbindTextureToFrameBuffer(), n8;
    }
    createAndWaitForFence() {
      let e8 = this.createFence(this.gl);
      return this.pollFence(e8);
    }
    createFence(e8) {
      let t8, o8;
      if (A().getBool("WEBGL_FENCE_API_ENABLED")) {
        let n8 = e8, s = n8.fenceSync(n8.SYNC_GPU_COMMANDS_COMPLETE, 0);
        e8.flush(), o8 = () => {
          let a = n8.clientWaitSync(s, 0, 0);
          return a === n8.ALREADY_SIGNALED || a === n8.CONDITION_SATISFIED;
        }, t8 = s;
      } else
        A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t8 = this.beginQuery(), this.endQuery(), o8 = () => this.isQueryAvailable(t8, A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : o8 = () => true;
      return { query: t8, isFencePassed: o8 };
    }
    downloadMatrixFromPackedTexture(e8, t8, o8) {
      return this.downloadMatrixDriver(e8, () => tv(this.gl, t8, o8));
    }
    createProgram(e8) {
      this.throwIfDisposed();
      let t8 = this.gl;
      this.vertexShader == null && (this.vertexShader = zI(t8));
      let o8 = SI(t8);
      ce(t8, () => t8.attachShader(o8, this.vertexShader)), ce(t8, () => t8.attachShader(o8, e8)), II(t8, o8);
      let n8 = Object.assign(o8, { vao: this.createVertexArray() });
      return this.debug && ql(t8, n8), n8;
    }
    buildVao(e8) {
      this.setProgram(e8), this.bindVertexArray(e8.vao);
      let t8 = this.gl;
      ce(t8, () => t8.bindBuffer(t8.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), jI(t8, e8, this.vertexBuffer);
    }
    deleteProgram(e8) {
      this.throwIfDisposed(), e8 === this.program && (this.program = null), e8 != null && (ce(this.gl, () => this.gl.deleteProgram(e8)), this.deleteVertexArray(e8.vao));
    }
    setProgram(e8) {
      this.throwIfDisposed(), this.program = e8, this.program != null && this.debug && ql(this.gl, this.program), ce(this.gl, () => this.gl.useProgram(e8));
    }
    getUniformLocation(e8, t8, o8 = true) {
      return this.throwIfDisposed(), o8 ? $I(this.gl, e8, t8) : EI(this.gl, e8, t8);
    }
    getAttributeLocation(e8, t8) {
      return this.throwIfDisposed(), ce(this.gl, () => this.gl.getAttribLocation(e8, t8));
    }
    getUniformLocationNoThrow(e8, t8) {
      return this.throwIfDisposed(), this.gl.getUniformLocation(e8, t8);
    }
    setInputMatrixTexture(e8, t8, o8) {
      this.throwIfDisposed(), this.throwIfNoProgram(), RI(this.gl, e8, t8, o8);
    }
    setOutputMatrixTexture(e8, t8, o8) {
      this.setOutputMatrixTextureDriver(e8, o8, t8);
    }
    setOutputPackedMatrixTexture(e8, t8, o8) {
      this.throwIfDisposed();
      let [n8, s] = Pa(t8, o8);
      this.setOutputMatrixTextureDriver(e8, n8, s);
    }
    setOutputMatrixWriteRegion(e8, t8, o8, n8) {
      this.setOutputMatrixWriteRegionDriver(o8, e8, n8, t8);
    }
    setOutputPackedMatrixWriteRegion(e8, t8, o8, n8) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
      this.program != null && ql(this.gl, this.program), Tc(this.gl);
    }
    executeProgram() {
      this.throwIfDisposed(), this.throwIfNoProgram();
      let e8 = this.gl;
      if (this.debug) {
        let t8 = this.getVertexArray();
        console.assert(t8 === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
      }
      ce(e8, () => e8.drawElements(e8.TRIANGLES, 6, e8.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
      this.throwIfDisposed(), ce(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
      return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = Nc(this.gl, A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
    beginQuery() {
      if (A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        let o8 = this.gl, n8 = this.getQueryTimerExtensionWebGL2(), s = o8.createQuery();
        return o8.beginQuery(n8.TIME_ELAPSED_EXT, s), s;
      }
      let e8 = this.getQueryTimerExtensionWebGL1(), t8 = e8.createQueryEXT();
      return e8.beginQueryEXT(e8.TIME_ELAPSED_EXT, t8), t8;
    }
    endQuery() {
      if (A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        let t8 = this.gl, o8 = this.getQueryTimerExtensionWebGL2();
        t8.endQuery(o8.TIME_ELAPSED_EXT);
        return;
      }
      let e8 = this.getQueryTimerExtensionWebGL1();
      e8.endQueryEXT(e8.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(e8) {
      return await y.repeatedTry(() => this.disposed || this.isQueryAvailable(e8, A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(e8, A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(e8, t8) {
      if (t8 === 0)
        return null;
      if (t8 === 2) {
        let o8 = this.gl;
        return o8.getQueryParameter(e8, o8.QUERY_RESULT) / 1e6;
      } else {
        let o8 = this.getQueryTimerExtensionWebGL1();
        return o8.getQueryObjectEXT(e8, o8.QUERY_RESULT_EXT) / 1e6;
      }
    }
    isQueryAvailable(e8, t8) {
      if (t8 === 0)
        return true;
      if (t8 === 2) {
        let o8 = this.gl, n8 = this.getQueryTimerExtensionWebGL2(), s = o8.getQueryParameter(e8, o8.QUERY_RESULT_AVAILABLE);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(n8.GPU_DISJOINT_EXT)), s && !this.disjoint;
      } else {
        let o8 = this.getQueryTimerExtensionWebGL1(), n8 = o8.getQueryObjectEXT(e8, o8.QUERY_RESULT_AVAILABLE_EXT);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(o8.GPU_DISJOINT_EXT)), n8 && !this.disjoint;
      }
    }
    pollFence(e8) {
      return new Promise((t8) => {
        this.addItemToPoll(() => e8.isFencePassed(), () => t8());
      });
    }
    pollItems() {
      let e8 = RZ(this.itemsToPoll.map((t8) => t8.isDoneFn));
      for (let t8 = 0; t8 <= e8; ++t8) {
        let { resolveFn: o8 } = this.itemsToPoll[t8];
        o8();
      }
      this.itemsToPoll = this.itemsToPoll.slice(e8 + 1);
    }
    addItemToPoll(e8, t8) {
      if (this.itemsToPoll.push({ isDoneFn: e8, resolveFn: t8 }), this.itemsToPoll.length > 1)
        return;
      let o8;
      "setTimeoutCustom" in A().platform && (o8 = A().platform.setTimeoutCustom.bind(A().platform)), y.repeatedTry(() => (this.pollItems(), this.itemsToPoll.length === 0), () => 0, null, o8);
    }
    bindTextureToFrameBuffer(e8) {
      this.throwIfDisposed(), jl(this.gl, e8, this.framebuffer), this.debug && Tc(this.gl);
    }
    unbindTextureToFrameBuffer() {
      this.outputTexture != null ? (jl(this.gl, this.outputTexture, this.framebuffer), this.debug && Tc(this.gl)) : qf(this.gl, this.framebuffer);
    }
    downloadMatrixDriver(e8, t8) {
      this.bindTextureToFrameBuffer(e8);
      let o8 = t8();
      return this.unbindTextureToFrameBuffer(), o8;
    }
    setOutputMatrixTextureDriver(e8, t8, o8) {
      this.throwIfDisposed();
      let n8 = this.gl;
      jl(n8, e8, this.framebuffer), this.debug && Tc(n8), this.outputTexture = e8, ce(n8, () => n8.viewport(0, 0, t8, o8)), ce(n8, () => n8.scissor(0, 0, t8, o8));
    }
    setOutputMatrixWriteRegionDriver(e8, t8, o8, n8) {
      this.throwIfDisposed(), ce(this.gl, () => this.gl.scissor(e8, t8, o8, n8));
    }
    throwIfDisposed() {
      if (this.disposed)
        throw new Error("Attempted to use disposed GPGPUContext.");
    }
    throwIfNoProgram() {
      if (this.program == null)
        throw new Error("No GPU program is currently set.");
    }
  };
  function RZ(r8) {
    let e8 = 0;
    for (; e8 < r8.length && r8[e8](); ++e8)
      ;
    return e8 - 1;
  }
  var { addImpl: IR, bincountImpl: ih, bincountReduceImpl: vR, bitwiseAndImpl: kR, castImpl: NR, ceilImpl: TR, concatImpl: _R, equalImpl: $R, expImpl: ER, expm1Impl: RR, floorImpl: DR, gatherNdImpl: AR, gatherV2Impl: FR, greaterImpl: PR, greaterEqualImpl: OR, lessImpl: MR, lessEqualImpl: LR, linSpaceImpl: BR, logImpl: zR, maxImpl: VR, maximumImpl: WR, minimumImpl: UR, multiplyImpl: GR, negImpl: HR, notEqualImpl: KR, prodImpl: qR, raggedGatherImpl: jR, raggedRangeImpl: XR, raggedTensorToTensorImpl: YR, rangeImpl: QR, rsqrtImpl: ZR, scatterImpl: JR, sigmoidImpl: eD, simpleAbsImpl: uh, sliceImpl: tD, sparseFillEmptyRowsImpl: rD, sparseReshapeImpl: oD, sparseSegmentReductionImpl: ph, sqrtImpl: nD, staticRegexReplaceImpl: sD, stridedSliceImpl: aD, stringNGramsImpl: iD, stringSplitImpl: uD, stringToHashBucketFastImpl: pD, subImpl: cD, tileImpl: lD, topKImpl: mD, transposeImpl: Sp, uniqueImpl: dD } = Ic;
  function ov(r8, e8) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, e8).map((t8) => `${r8}.${t8}`);
  }
  function Rt(r8, e8) {
    return e8 === 1 ? [r8] : ov(r8, e8);
  }
  function fD(r8, e8) {
    if (r8 === 1)
      return "rc";
    let t8 = "";
    for (let o8 = 0; o8 < r8; o8++)
      t8 += e8[o8], o8 < r8 - 1 && (t8 += ",");
    return t8;
  }
  var ch = class {
    constructor(e8) {
      if (this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = e8, this.rank = e8.length, this.enableShapeUniforms = pt(this.outputShape.length), this.rank === 0)
        this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
      else {
        let t8 = Rt("rc", this.rank), o8 = Re(this.rank), n8 = this.getOutOfBoundsCondition(t8), s = this.getSetup(t8), a = this.getOutput(t8);
        this.userCode = `
        void main() {
          ${o8} rc = getOutputCoords();

          if(${n8}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `;
      }
    }
    getSourceCoordsArr(e8) {
      let t8 = [];
      for (let o8 = 0; o8 <= 1; o8++)
        for (let n8 = 0; n8 <= 1; n8++) {
          let s = `${o8 === 0 ? "r" : "rp1"}, ${n8 === 0 ? "c" : "cp1"}`;
          for (let a = 2; a < this.rank; a++)
            s = `${e8[e8.length - 1 - a]},` + s;
          t8.push(s);
        }
      return t8;
    }
    getOutOfBoundsCondition(e8) {
      if (this.rank === 1)
        return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
      let t8 = "";
      for (let o8 = this.rank - 2; o8 < this.rank; o8++)
        t8 += `${e8[o8]} >= ${this.enableShapeUniforms ? `outShape[${o8}]` : this.outputShape[o8]}`, o8 < this.rank - 1 && (t8 += "||");
      return t8;
    }
    getSetup(e8) {
      if (this.rank === 1)
        return "";
      let t8 = e8.slice(-2), o8 = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], n8 = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
      return `
      int r = ${t8[0]};
      int c = ${t8[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${o8};
      bool rEdge = rp1 >= ${n8};
    `;
    }
    getOutput(e8) {
      let t8 = this.getSourceCoordsArr(e8);
      return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${t8[0]}),
            cEdge ? 0. : getA(${t8[1]}),
            rEdge ? 0. : getA(${t8[2]}),
            rEdge || cEdge ? 0. : getA(${t8[3]})`;
    }
  };
  var Mc = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec3" }], this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length);
      let o8 = "";
      for (let n8 = 0; n8 < 4; n8++) {
        let s = "thisRC = rc;";
        n8 % 2 === 1 && (s += "thisRC.z += 1;"), n8 > 1 && (s += "thisRC.y += 1;"), o8 += `
        ${s}
        ${n8 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${n8}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${n8 > 0 ? "}" : ""}
      `;
      }
      this.userCode = `
      ${DZ(t8, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? Rc() : Ec(e8)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : e8[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : e8[2]};

        ${o8}

        setOutput(result);
      }
    `;
    }
  };
  function DZ(r8, e8) {
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e8 ? fR(["r", "c", "d"], "inputShape") : zs(["r", "c", "d"], r8)}
      return ivec3(r, c, d);
    }
  `;
  }
  var lh = class {
    constructor(e8) {
      this.gpgpu = e8, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = false;
    }
    acquireTexture(e8, t8, o8) {
      let n8 = gD(t8, o8), s = xD(e8, n8, o8);
      s in this.freeTextures || (this.freeTextures[s] = []), s in this.usedTextures || (this.usedTextures[s] = []);
      let a = hD(e8, n8, this.gpgpu.gl, this.gpgpu.textureConfig, o8);
      if (this.freeTextures[s].length > 0) {
        this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= a, this.log();
        let p = this.freeTextures[s].pop();
        return this.usedTextures[s].push(p), p;
      }
      let i10;
      return n8 === tr.PACKED_2X2_FLOAT32 ? i10 = this.gpgpu.createPackedMatrixTexture(e8[0], e8[1]) : n8 === tr.PACKED_2X2_FLOAT16 ? i10 = this.gpgpu.createFloat16PackedMatrixTexture(e8[0], e8[1]) : n8 === tr.UNPACKED_FLOAT32 ? i10 = this.gpgpu.createFloat32MatrixTexture(e8[0], e8[1]) : n8 === tr.UNPACKED_FLOAT16 ? i10 = this.gpgpu.createFloat16MatrixTexture(e8[0], e8[1]) : n8 === tr.PACKED_4X1_UNSIGNED_BYTE && (i10 = this.gpgpu.createUnsignedBytesMatrixTexture(e8[0], e8[1])), this.usedTextures[s].push(i10), this.numUsedTextures++, this._numBytesAllocated += a, this.log(), i10;
    }
    releaseTexture(e8, t8, o8, n8) {
      if (this.freeTextures == null)
        return;
      let s = gD(o8, n8), a = xD(t8, s, n8);
      a in this.freeTextures || (this.freeTextures[a] = []);
      let i10 = hD(t8, s, this.gpgpu.gl, this.gpgpu.textureConfig, n8), p = A().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
      p !== -1 && this._numBytesAllocated > p ? (this.gpgpu.deleteMatrixTexture(e8.texture), this._numBytesAllocated -= i10) : (this.freeTextures[a].push(e8), this.numFreeTextures++, this._numBytesFree += i10), this.numUsedTextures--;
      let u = this.usedTextures[a], c = u && u.indexOf(e8);
      if (c == null || c < 0)
        throw new Error("Cannot release a texture that was never provided by this texture manager");
      u[c] = u[u.length - 1], u.pop(), this.log();
    }
    log() {
      if (!this.logEnabled)
        return;
      let e8 = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${e8})`);
      let t8 = this._numBytesFree / this._numBytesAllocated;
      console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * t8)}%)`);
    }
    get numBytesAllocated() {
      return this._numBytesAllocated;
    }
    get numBytesFree() {
      return this._numBytesFree;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      if (this.freeTextures != null) {
        for (let e8 in this.freeTextures)
          this.freeTextures[e8].forEach((t8) => {
            this.gpgpu.deleteMatrixTexture(t8.texture);
          });
        for (let e8 in this.usedTextures)
          this.usedTextures[e8].forEach((t8) => {
            this.gpgpu.deleteMatrixTexture(t8.texture);
          });
        this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
      }
    }
  };
  function AZ(r8, e8) {
    let t8 = r8;
    if (e8 === t8.R32F)
      return 4;
    if (e8 === t8.R16F)
      return 2;
    if (e8 === t8.RGBA32F)
      return 16;
    if (e8 === r8.RGBA)
      return 16;
    if (e8 === t8.RGBA16F)
      return 8;
    if (e8 === t8.RGBA8)
      return 4;
    throw new Error(`Unknown internal format ${e8}`);
  }
  function hD(r8, e8, t8, o8, n8) {
    let s = FZ(e8, o8), a;
    if (n8) {
      let [p, u] = Pa(r8[0], r8[1]);
      a = p * u;
    } else {
      let [p, u] = yp(r8[0], r8[1]);
      a = p * u;
    }
    let i10 = AZ(t8, s);
    return a * i10;
  }
  function FZ(r8, e8) {
    switch (r8) {
      case tr.PACKED_2X2_FLOAT32:
        return sh(e8);
      case tr.PACKED_2X2_FLOAT16:
        return ah(e8);
      case tr.UNPACKED_FLOAT32:
        return rh(e8);
      case tr.UNPACKED_FLOAT16:
        return oh(e8);
      case tr.PACKED_4X1_UNSIGNED_BYTE:
        return nh(e8);
      default:
        throw new Error(`Unknown physical texture type ${r8}`);
    }
  }
  function PZ(r8) {
    return A().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? r8 ? tr.PACKED_2X2_FLOAT32 : tr.UNPACKED_FLOAT32 : r8 ? tr.PACKED_2X2_FLOAT16 : tr.UNPACKED_FLOAT16;
  }
  function gD(r8, e8) {
    if (r8 === mr.UPLOAD)
      return tr.PACKED_2X2_FLOAT32;
    if (r8 === mr.RENDER || r8 == null)
      return PZ(e8);
    if (r8 === mr.DOWNLOAD || r8 === mr.PIXELS)
      return tr.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error(`Unknown logical texture type ${r8}`);
  }
  function xD(r8, e8, t8) {
    return `${r8[0]}_${r8[1]}_${e8}_${t8}`;
  }
  var rr = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${t8}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };
  var Ut = "if (isnan(x)) return x;";
  var yD = "return x;";
  var nv = "return abs(x);";
  var bD = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  var CD = Ut + `
  return (x < 0.0) ? 0.0 : x;
`;
  var wD = Ut + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var Oa = "return x;";
  var SD = "return 1.0 / (1.0 + exp(-1.0 * x));";
  var vD = "return x;";
  var kD = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var ND = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var TD = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var _D = "return 1.0 / (1.0 + exp(-1.0 * x));";
  var Fr = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${t8}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };
  var mh = class {
    constructor(e8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length);
      let t8 = e8.length, o8 = Rt("rc", t8), n8 = Re(t8), s = fD(t8, o8), a = o8.slice(-2), i10 = t8 <= 1 ? "rc" : `vec2(${a.join(",")})`;
      this.userCode = `
      void main() {
        ${n8} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i10}));
      }
    `;
    }
  };
  var MZ = Wt.whereImpl;
  var LZ = 1e-7;
  var BZ = 1e-4;
  var dh = {};
  function zZ(r8) {
    return r8 in dh || (dh[r8] = {}), dh[r8];
  }
  var VZ = A().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
  var WZ = 600;
  function UZ() {
    return A().global.screen == null ? 1024 : A().global.screen.height * A().global.screen.width * window.devicePixelRatio * WZ / 1024 / 1024;
  }
  var bu = class extends so {
    nextDataId() {
      return bu.nextDataId++;
    }
    constructor(e8) {
      if (super(), this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = false, this.pendingDeletes = 0, this.disposed = false, !A().getBool("HAS_WEBGL"))
        throw new Error("WebGL is not supported on this device");
      let t8;
      if (e8 != null) {
        if (e8 instanceof wp)
          t8 = e8;
        else {
          let o8 = Kr(A().getNumber("WEBGL_VERSION"), e8);
          t8 = new wp(o8);
        }
        this.binaryCache = {}, this.gpgpuCreatedLocally = false;
      } else {
        let o8 = Kr(A().getNumber("WEBGL_VERSION"));
        t8 = new wp(o8), this.binaryCache = zZ(A().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = true;
      }
      this.gpgpu = t8, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new lh(this.gpgpu), this.numMBBeforeWarning = UZ(), this.texData = new Bo(this, ur());
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    writeTexture(e8, t8, o8, n8, s, a) {
      let i10 = this.makeTensorInfo(t8, o8), p = this.texData.get(i10.dataId);
      p.isPacked = false, p.texture = { texture: e8, texShape: [n8, s] }, p.texShape = [n8, s];
      let u = _c(t8), c = new Xl(u, false, a), l = this.runWebGLProgram(c, [i10], o8, [[n8, s]]);
      return l.shape = t8, p.texture = null, this.disposeIntermediateTensorInfo(i10), l.dataId;
    }
    write(e8, t8, o8) {
      if ((A().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || A().getBool("DEBUG")) && this.checkNumericalProblems(e8), o8 === "complex64" && e8 != null)
        throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      let n8 = { id: this.nextDataId() };
      return this.texData.set(n8, { shape: t8, dtype: o8, values: e8, usage: mr.UPLOAD, refCount: 1 }), n8;
    }
    refCount(e8) {
      return this.texData.has(e8) ? this.texData.get(e8).refCount : 0;
    }
    incRef(e8) {
      let t8 = this.texData.get(e8);
      t8.refCount++;
    }
    decRef(e8) {
      if (this.texData.has(e8)) {
        let t8 = this.texData.get(e8);
        t8.refCount--;
      }
    }
    move(e8, t8, o8, n8, s) {
      if (A().getBool("DEBUG") && this.checkNumericalProblems(t8), n8 === "complex64")
        throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.texData.set(e8, { shape: o8, dtype: n8, values: t8, usage: mr.UPLOAD, refCount: s });
    }
    disposeIntermediateTensorInfo(e8) {
      this.disposeData(e8.dataId);
    }
    readSync(e8) {
      let t8 = this.texData.get(e8), { values: o8, dtype: n8, complexTensorInfos: s, slice: a, shape: i10, isPacked: p } = t8;
      if (a != null) {
        let m;
        p ? m = new Fr(i10, Oa) : m = new rr(i10, Oa);
        let d = this.runWebGLProgram(m, [{ dataId: e8, shape: i10, dtype: n8 }], n8), f = this.readSync(d.dataId);
        return this.disposeIntermediateTensorInfo(d), f;
      }
      if (o8 != null)
        return this.convertAndCacheOnCPU(e8);
      if (n8 === "string")
        return o8;
      let u = this.activeTimers != null, c;
      u && (c = y.now());
      let l;
      if (n8 === "complex64") {
        let m = this.readSync(s.real.dataId), d = this.readSync(s.imag.dataId);
        l = w.mergeRealAndImagArrays(m, d);
      } else
        l = this.getValuesFromTexture(e8);
      return u && (this.downloadWaitMs += y.now() - c), this.convertAndCacheOnCPU(e8, l);
    }
    async read(e8) {
      if (this.pendingRead.has(e8)) {
        let f = this.pendingRead.get(e8);
        return new Promise((h) => f.push(h));
      }
      let t8 = this.texData.get(e8), { values: o8, shape: n8, slice: s, dtype: a, complexTensorInfos: i10, isPacked: p } = t8;
      if (s != null) {
        let f;
        p ? f = new Fr(n8, Oa) : f = new rr(n8, Oa);
        let h = this.runWebGLProgram(f, [{ dataId: e8, shape: n8, dtype: a }], a), g = this.read(h.dataId);
        return this.disposeIntermediateTensorInfo(h), g;
      }
      if (o8 != null)
        return this.convertAndCacheOnCPU(e8);
      if (A().getBool("DEBUG") && !A().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && A().getNumber("WEBGL_VERSION") === 2)
        throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
      let u = null, c;
      if (a !== "complex64" && A().get("WEBGL_BUFFER_SUPPORTED")) {
        c = this.decode(e8);
        let f = this.texData.get(c.dataId);
        u = this.gpgpu.createBufferFromTexture(f.texture.texture, ...Hl(n8));
      }
      this.pendingRead.set(e8, []), a !== "complex64" && await this.gpgpu.createAndWaitForFence();
      let l;
      if (a === "complex64") {
        let f = await Promise.all([this.read(i10.real.dataId), this.read(i10.imag.dataId)]), h = f[0], g = f[1];
        l = w.mergeRealAndImagArrays(h, g);
      } else if (u == null)
        l = this.getValuesFromTexture(e8);
      else {
        let f = y.sizeFromShape(n8);
        l = this.gpgpu.downloadFloat32MatrixFromBuffer(u, f);
      }
      if (c != null && this.disposeIntermediateTensorInfo(c), u != null) {
        let f = this.gpgpu.gl;
        ce(f, () => f.deleteBuffer(u));
      }
      let m = this.convertAndCacheOnCPU(e8, l), d = this.pendingRead.get(e8);
      return this.pendingRead.delete(e8), d.forEach((f) => f(m)), this.pendingDisposal.has(e8) && (this.pendingDisposal.delete(e8), this.disposeData(e8) && ur().removeDataId(e8, this), this.pendingDeletes--), m;
    }
    readToGPU(e8, t8 = {}) {
      let o8 = this.texData.get(e8), { values: n8, shape: s, slice: a, dtype: i10, isPacked: p, texture: u } = o8;
      if (i10 === "complex64")
        throw new Error("Does not support reading texture for complex64 dtype.");
      if (a != null) {
        let d;
        p ? d = new Fr(s, Oa) : d = new rr(s, Oa);
        let f = this.runWebGLProgram(d, [{ dataId: e8, shape: s, dtype: i10 }], i10), h = this.readToGPU(f, t8);
        return this.disposeIntermediateTensorInfo(f), h;
      }
      if (u == null)
        throw n8 != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
      let c = this.decode(e8, t8.customTexShape), l = ur().makeTensorFromTensorInfo(c), m = this.texData.get(c.dataId);
      return Object.assign({ tensorRef: l }, m.texture);
    }
    bufferSync(e8) {
      let t8 = this.readSync(e8.dataId);
      if (e8.dtype === "string")
        try {
          let o8 = t8.map((n8) => y.decodeString(n8));
          return me(e8.shape, e8.dtype, o8);
        } catch (o8) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      return me(e8.shape, e8.dtype, t8);
    }
    checkNumericalProblems(e8) {
      if (e8 != null)
        for (let t8 = 0; t8 < e8.length; t8++) {
          let o8 = e8[t8];
          if (!bI(o8))
            throw A().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${o8} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${o8} cannot be represented on this device.`);
        }
    }
    getValuesFromTexture(e8) {
      let { shape: t8, dtype: o8, isPacked: n8 } = this.texData.get(e8), s = y.sizeFromShape(t8);
      if (A().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        let m = this.decode(e8), d = this.texData.get(m.dataId), f = this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture, ...Hl(t8)).subarray(0, s);
        return this.disposeIntermediateTensorInfo(m), f;
      }
      let a = A().getBool("WEBGL_PACK") && n8 === true, i10 = a ? _c(t8) : t8, p = a ? new eh(i10) : new Jf(i10), u = this.runWebGLProgram(p, [{ shape: i10, dtype: o8, dataId: e8 }], "float32"), c = this.texData.get(u.dataId), l = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture, c.texShape[0], c.texShape[1]).subarray(0, s);
      return this.disposeIntermediateTensorInfo(u), l;
    }
    timerAvailable() {
      return A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(e8) {
      let t8 = this.activeTimers, o8 = [], n8 = false;
      this.programTimersStack == null ? (this.programTimersStack = o8, n8 = true) : this.activeTimers.push(o8), this.activeTimers = o8, e8();
      let s = y.flatten(this.activeTimers.map((p) => p.query)).filter((p) => p != null), a = y.flatten(this.activeTimers.map((p) => p.name)).filter((p) => p != null);
      this.activeTimers = t8, n8 && (this.programTimersStack = null);
      let i10 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null };
      return (async () => {
        if (A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          let p = await Promise.all(s);
          i10.kernelMs = y.sum(p), i10.getExtraProfileInfo = () => p.map((u, c) => ({ name: a[c], ms: u })).map((u) => `${u.name}: ${u.ms}`).join(", ");
        } else
          i10.kernelMs = { error: "WebGL query timers are not supported in this environment." };
        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, i10;
      })();
    }
    memory() {
      return { unreliable: false, numBytesInGPU: this.numBytesInGPU, numBytesInGPUAllocated: this.textureManager.numBytesAllocated, numBytesInGPUFree: this.textureManager.numBytesFree };
    }
    startTimer() {
      return A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: y.now(), endMs: null };
    }
    endTimer(e8) {
      return A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e8) : (e8.endMs = y.now(), e8);
    }
    async getQueryTime(e8) {
      if (A().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)
        return this.gpgpu.waitForQueryAndGetTime(e8);
      let t8 = e8;
      return t8.endMs - t8.startMs;
    }
    disposeData(e8, t8 = false) {
      if (this.pendingDisposal.has(e8))
        return false;
      if (!this.texData.has(e8))
        return true;
      if (t8 ? this.texData.get(e8).refCount = 0 : this.texData.get(e8).refCount--, !t8 && this.texData.get(e8).refCount > 0)
        return false;
      if (this.pendingRead.has(e8))
        return this.pendingDisposal.add(e8), this.pendingDeletes++, false;
      this.releaseGPUData(e8);
      let { complexTensorInfos: o8 } = this.texData.get(e8);
      return o8 != null && (this.disposeData(o8.real.dataId, t8), this.disposeData(o8.imag.dataId, t8)), this.texData.delete(e8), true;
    }
    releaseGPUData(e8) {
      let { texture: t8, dtype: o8, texShape: n8, usage: s, isPacked: a, slice: i10 } = this.texData.get(e8), p = i10 && i10.origDataId || e8, u = this.dataRefCount.get(p);
      u > 1 ? this.dataRefCount.set(p, u - 1) : (this.dataRefCount.delete(p), t8 != null && (this.numBytesInGPU -= this.computeBytes(n8, o8), this.textureManager.releaseTexture(t8, n8, s, a)));
      let c = this.texData.get(e8);
      c.texture = null, c.texShape = null, c.isPacked = false, c.slice = null;
    }
    getTexture(e8) {
      return this.uploadToGPU(e8), this.texData.get(e8).texture.texture;
    }
    getDataInfo(e8) {
      return this.texData.get(e8);
    }
    shouldExecuteOnCPU(e8, t8 = VZ) {
      return A().getBool("WEBGL_CPU_FORWARD") && e8.every((o8) => this.texData.get(o8.dataId).texture == null && y.sizeFromShape(o8.shape) < t8);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(e8) {
      w.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      let t8 = e8.dataSync();
      return MZ(e8.shape, t8);
    }
    packedUnaryOp(e8, t8, o8) {
      let n8 = new Fr(e8.shape, t8), s = this.compileAndRun(n8, [e8], o8);
      return ur().makeTensorFromTensorInfo(s);
    }
    abs(e8) {
      if (this.shouldExecuteOnCPU([e8]) && e8.dtype !== "complex64") {
        let n8 = uh(this.texData.get(e8.dataId).values);
        return this.makeOutput(e8.shape, e8.dtype, n8);
      }
      if (A().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
        return this.packedUnaryOp(e8, nv, e8.dtype);
      let t8 = new rr(e8.shape, nv), o8 = this.compileAndRun(t8, [e8]);
      return ur().makeTensorFromTensorInfo(o8);
    }
    makeTensorInfo(e8, t8, o8) {
      let n8;
      if (t8 === "string" && o8 != null && o8.length > 0 && y.isString(o8[0])) {
        let s = o8.map((a) => y.encodeString(a));
        n8 = this.write(s, e8, t8);
      } else
        n8 = this.write(o8, e8, t8);
      return this.texData.get(n8).usage = null, { dataId: n8, shape: e8, dtype: t8 };
    }
    makeOutput(e8, t8, o8) {
      return ur().makeTensorFromTensorInfo(this.makeTensorInfo(e8, t8, o8), this);
    }
    unpackTensor(e8) {
      let t8 = new mh(e8.shape);
      return this.runWebGLProgram(t8, [e8], e8.dtype);
    }
    packTensor(e8) {
      let t8 = new ch(e8.shape), o8 = true;
      return this.runWebGLProgram(t8, [e8], e8.dtype, null, o8);
    }
    packedReshape(e8, t8) {
      let o8 = [gi(e8.shape), ...xi(e8.shape)], n8 = { dtype: e8.dtype, shape: o8, dataId: e8.dataId }, s = [gi(t8), ...xi(t8)], a = new Mc(s, o8), i10 = true, p = [o8], u = this.runWebGLProgram(a, [n8], e8.dtype, p, i10);
      return { dataId: u.dataId, shape: t8, dtype: u.dtype };
    }
    decode(e8, t8) {
      let o8 = this.texData.get(e8), { isPacked: n8, shape: s, dtype: a } = o8;
      if (t8 != null) {
        let m = y.sizeFromShape(s), d = t8[0] * t8[1] * 4;
        y.assert(m <= d, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
      }
      let i10 = _c(s), p;
      n8 ? p = new Zf(i10) : p = new Qf(i10);
      let u = true, c = [t8 != null ? t8 : Hl(i10)], l = this.runWebGLProgram(p, [{ shape: i10, dtype: a, dataId: e8 }], a, c, u, t8);
      return { dtype: a, shape: s, dataId: l.dataId };
    }
    runWebGLProgram(e8, t8, o8, n8, s = false, a) {
      let i10 = this.makeTensorInfo(e8.outputShape, o8), p = this.texData.get(i10.dataId);
      if (e8.packedOutput && (p.isPacked = true), e8.outPackingScheme === xu.DENSE) {
        let x = a != null ? a : Hl(e8.outputShape);
        p.texShape = x.map((b) => b * 2);
      }
      if (e8.outTexUsage != null && (p.usage = e8.outTexUsage), y.sizeFromShape(i10.shape) === 0)
        return p.values = y.getTypedArrayFromDType(i10.dtype, 0), i10;
      let u = [], c = t8.map((x) => {
        if (x.dtype === "complex64")
          throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        let b = this.texData.get(x.dataId);
        if (b.texture == null) {
          if (!e8.packedInputs && y.sizeFromShape(x.shape) <= A().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
            return { shape: x.shape, texData: null, isUniform: true, uniformValues: b.values };
          e8.packedInputs && (b.isPacked = true, b.shape = x.shape);
        }
        if (this.uploadToGPU(x.dataId), !!b.isPacked != !!e8.packedInputs)
          x = b.isPacked ? this.unpackTensor(x) : this.packTensor(x), u.push(x), b = this.texData.get(x.dataId);
        else if (b.isPacked && !yu(b.shape, x.shape)) {
          let C = x, S = x.shape;
          x.shape = b.shape, x = this.packedReshape(x, S), u.push(x), b = this.texData.get(x.dataId), C.shape = S;
        }
        return { shape: x.shape, texData: b, isUniform: false };
      });
      this.uploadToGPU(i10.dataId);
      let l = { shape: i10.shape, texData: p, isUniform: false }, m = SR(e8, c, l), d = this.getAndSaveBinary(m, () => CR(this.gpgpu, e8, c, l)), f = this.activeTimers != null, h;
      f && (h = this.startTimer()), A().get("ENGINE_COMPILE_ONLY") || wR(this.gpgpu, d, c, l, n8), u.forEach((x) => this.disposeIntermediateTensorInfo(x)), f && (h = this.endTimer(h), this.activeTimers.push({ name: e8.constructor.name, query: this.getQueryTime(h) }));
      let g = A().get("WEBGL_FLUSH_THRESHOLD");
      if (g > 0) {
        let x = y.now();
        x - this.lastGlFlushTime > g && (this.gpgpu.gl.flush(), this.lastGlFlushTime = x);
      }
      if (!A().getBool("WEBGL_LAZILY_UNPACK") && p.isPacked && s === false) {
        let x = this.unpackTensor(i10);
        return this.disposeIntermediateTensorInfo(i10), x;
      }
      return i10;
    }
    compileAndRun(e8, t8, o8, n8, s = false) {
      return o8 = o8 || t8[0].dtype, this.runWebGLProgram(e8, t8, o8, n8, s);
    }
    getAndSaveBinary(e8, t8) {
      return e8 in this.binaryCache || (this.binaryCache[e8] = t8()), this.binaryCache[e8];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      this.disposed || (A().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((t8) => {
        this.gpgpu.deleteProgram(this.binaryCache[t8].webGLProgram), delete this.binaryCache[t8];
      }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement != "undefined" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
    }
    floatPrecision() {
      return this.floatPrecisionValue == null && (this.floatPrecisionValue = De(() => {
        if (!A().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          let e8 = A().getBool("DEBUG");
          A().set("DEBUG", false);
          let t8 = this.abs(ke(1e-8)).dataSync()[0];
          if (A().set("DEBUG", e8), t8 > 0)
            return 32;
        }
        return 16;
      })), this.floatPrecisionValue;
    }
    epsilon() {
      return this.floatPrecision() === 32 ? LZ : BZ;
    }
    uploadToGPU(e8) {
      let t8 = this.texData.get(e8), { shape: o8, dtype: n8, values: s, texture: a, usage: i10, isPacked: p } = t8;
      if (a != null)
        return;
      let u = this.activeTimers != null, c;
      u && (c = y.now());
      let l = t8.texShape;
      if (l == null && (l = DI(o8, p), t8.texShape = l), s != null) {
        let m = _c(o8), d, f = l[1], h = l[0], g = s instanceof Uint8Array || s instanceof Uint8ClampedArray;
        (p || !g) && ([f, h] = Pa(l[0], l[1])), p ? d = new th(m, g) : d = new Xl(m, g);
        let x = g ? [h, f] : l, b = this.makeTensorInfo(x, n8), C = this.texData.get(b.dataId);
        g ? C.usage = mr.PIXELS : C.usage = mr.UPLOAD, C.texShape = x, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId), f, h, s);
        let S = [[h, f]], k = true, _ = this.runWebGLProgram(d, [b], n8, S, k), E = this.texData.get(_.dataId);
        t8.texShape = E.texShape, t8.isPacked = E.isPacked, t8.usage = E.usage, A().get("ENGINE_COMPILE_ONLY") ? this.disposeData(_.dataId) : (t8.texture = E.texture, t8.values = null, this.texData.delete(_.dataId)), this.disposeIntermediateTensorInfo(b), u && (this.uploadWaitMs += y.now() - c);
      } else {
        let m = this.acquireTexture(l, i10, n8, p);
        t8.texture = m;
      }
    }
    convertAndCacheOnCPU(e8, t8) {
      let o8 = this.texData.get(e8), { dtype: n8 } = o8;
      return t8 != null && (o8.values = GZ(t8, n8)), o8.values;
    }
    acquireTexture(e8, t8, o8, n8) {
      if (this.numBytesInGPU += this.computeBytes(e8, o8), !this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        let s = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true, console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(e8, t8, n8);
    }
    computeBytes(e8, t8) {
      return e8[0] * e8[1] * y.bytesPerElement(t8);
    }
    checkCompileCompletion() {
      for (let [, e8] of Object.entries(this.binaryCache))
        this.checkCompletion_(e8);
    }
    async checkCompileCompletionAsync() {
      let e8 = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (let [, t8] of Object.entries(this.binaryCache))
          e8.push(this.checkCompletionAsync_(t8));
        return Promise.all(e8);
      } else {
        for (let [, t8] of Object.entries(this.binaryCache)) {
          let o8 = new Promise((n8) => {
            try {
              this.checkCompletion_(t8), n8(true);
            } catch (s) {
              throw s;
            }
          });
          e8.push(o8);
        }
        return Promise.all(e8);
      }
    }
    async checkCompletionAsync_(e8) {
      return this.gpgpu.gl.getProgramParameter(e8.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(e8) : (await tS(), this.checkCompletionAsync_(e8));
    }
    checkCompletion_(e8) {
      if (this.gpgpu.gl.getProgramParameter(e8.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false)
        throw console.log(this.gpgpu.gl.getProgramInfoLog(e8.webGLProgram)), this.gpgpu.gl.getShaderParameter(e8.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false ? (Hf(e8.source, this.gpgpu.gl.getShaderInfoLog(e8.fragmentShader)), new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
      return true;
    }
    getUniformLocations() {
      for (let e8 of Object.values(this.binaryCache)) {
        this.gpgpu.buildVao(e8.webGLProgram);
        let { variablesLocations: t8, customUniformLocations: o8, infLoc: n8, nanLoc: s, outShapeLocation: a, outShapeStridesLocation: i10, outTexShapeLocation: p } = BI(this.gpgpu, e8.program, e8.webGLProgram);
        e8.variablesLocations = t8, e8.customUniformLocations = o8, e8.infLoc = n8, e8.nanLoc = s, e8.outShapeLocation = a, e8.outShapeStridesLocation = i10, e8.outTexShapeLocation = p;
      }
    }
    createTensorFromGPUData(e8, t8, o8) {
      e8.channels = e8.channels || "RGBA";
      let { texture: n8, height: s, width: a, channels: i10 } = e8, p = ur().backend;
      if (!p.gpgpu.gl.isTexture(n8))
        throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
      let u = p.writeTexture(n8, t8, o8, s, a, i10);
      return ur().makeTensorFromDataId(u, t8, o8, p);
    }
  };
  bu.nextDataId = 0;
  function GZ(r8, e8) {
    if (e8 === "float32" || e8 === "complex64")
      return r8;
    if (e8 === "int32" || e8 === "bool") {
      let t8 = e8 === "int32" ? new Int32Array(r8.length) : new Uint8Array(r8.length);
      for (let o8 = 0; o8 < t8.length; ++o8)
        t8[o8] = Math.round(r8[o8]);
      return t8;
    } else
      throw new Error(`Unknown dtype ${e8}`);
  }
  var HZ = "4.7.0";
  function $D() {
    A().set("WEBGL_FORCE_F16_TEXTURES", true);
  }
  ru.isBrowser() && nu("webgl", () => new bu(), 2);
  var tat = { forceHalfFloat: $D };
  var Lc = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  var Pr = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["A", "B"], this.outputShape = w.assertAndGetBroadcastShape(t8, o8), this.enableShapeUniforms = pt(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${e8}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
  };
  var Xr = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
  var jr = class {
    constructor(e8, t8, o8, n8 = false) {
      this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = w.assertAndGetBroadcastShape(t8, o8);
      let s = this.outputShape.length;
      this.enableShapeUniforms = pt(s);
      let a = "";
      if (n8)
        if (s === 0 || y.sizeFromShape(this.outputShape) === 1)
          a = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
        else if (a = `
          ${Re(s)} coords = getOutputCoords();
        `, s === 1)
          this.enableShapeUniforms ? a += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : a += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
        else {
          let p = Rt("coords", s);
          this.enableShapeUniforms ? a += `
            bool nextRowOutOfBounds =
              (${p[s - 2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${p[s - 1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : a += `
            bool nextRowOutOfBounds =
              (${p[s - 2]} + 1) >= ${this.outputShape[s - 2]};
            bool nextColOutOfBounds =
              (${p[s - 1]} + 1) >= ${this.outputShape[s - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
        }
      this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e8}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `;
    }
  };
  function Dt(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    return t8.incRef(o8.dataId), { dataId: o8.dataId, shape: o8.shape, dtype: o8.dtype };
  }
  var ED = { kernelName: Co, backendName: "webgl", kernelFunc: Dt };
  function Or(r8) {
    let { inputs: e8, backend: t8 } = r8, { real: o8, imag: n8 } = e8, s = t8.makeTensorInfo(o8.shape, "complex64"), a = t8.texData.get(s.dataId), i10 = Dt({ inputs: { x: o8 }, backend: t8 }), p = Dt({ inputs: { x: n8 }, backend: t8 });
    return a.complexTensorInfos = { real: i10, imag: p }, s;
  }
  var RD = { kernelName: Ri, backendName: "webgl", kernelFunc: Or };
  var sv = "return (a < 0.) ? b * a : a;";
  var av = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function KZ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { alpha: s } = o8, a = t8.makeTensorInfo([], "float32", y.createScalarValue(s, "float32")), i10 = A().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new jr(av, n8.shape, a.shape) : new Pr(sv, n8.shape, a.shape), p = t8.runWebGLProgram(i10, [n8, a], "float32");
    return t8.disposeIntermediateTensorInfo(a), p;
  }
  var DD = { kernelName: En, backendName: "webgl", kernelFunc: KZ };
  var iv = "return (a < 0.) ? b * a : a;";
  var uv = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function qZ(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8, alpha: n8 } = e8, s = A().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new jr(uv, o8.shape, n8.shape) : new Pr(iv, o8.shape, n8.shape);
    return t8.runWebGLProgram(s, [o8, n8], "float32");
  }
  var AD = { kernelName: rs, backendName: "webgl", kernelFunc: qZ };
  var Fo = "if (isnan(x)) return x;";
  function xe({ opSnippet: r8, packedOpSnippet: e8, cpuKernelImpl: t8, dtype: o8 }) {
    return ({ inputs: n8, backend: s }) => {
      let { x: a } = n8, i10 = s, p = o8 || a.dtype;
      if (i10.shouldExecuteOnCPU([a]) && t8 != null) {
        let l = i10.texData.get(a.dataId), m = t8(l.values, p);
        return i10.makeTensorInfo(a.shape, p, m);
      }
      let u = A().getBool("WEBGL_PACK_UNARY_OPERATIONS") && e8 != null, c;
      return u ? c = new Fr(a.shape, e8) : c = new rr(a.shape, r8), i10.runWebGLProgram(c, [a], p);
    };
  }
  function nt({ opSnippet: r8, packedOpSnippet: e8, checkOutOfBounds: t8 = false, supportsComplex: o8 = false, cpuKernelImpl: n8, dtype: s }) {
    return ({ inputs: a, backend: i10 }) => {
      let { a: p, b: u } = a, c = i10;
      if (o8 && p.dtype === "complex64") {
        let f = c.texData.get(p.dataId), h = c.texData.get(u.dataId), [g, x] = [[f.complexTensorInfos.real, h.complexTensorInfos.real], [f.complexTensorInfos.imag, h.complexTensorInfos.imag]].map((C) => {
          let [S, k] = C, _ = { dataId: S.dataId, dtype: S.dtype, shape: p.shape }, E = { dataId: k.dataId, dtype: k.dtype, shape: u.shape }, R = new Pr(r8, p.shape, u.shape);
          return c.runWebGLProgram(R, [_, E], dt(S.dtype, k.dtype));
        }), b = Or({ inputs: { real: g, imag: x }, backend: c });
        return c.disposeIntermediateTensorInfo(g), c.disposeIntermediateTensorInfo(x), b;
      }
      let l = s || dt(p.dtype, u.dtype);
      if ((p.dtype === "string" || u.dtype === "string" || c.shouldExecuteOnCPU([p, u])) && n8 != null) {
        let f = c.texData.get(p.dataId).values, h = c.texData.get(u.dataId).values, g = p.dtype === "string" ? w.fromUint8ToStringArray(f) : f, x = p.dtype === "string" ? w.fromUint8ToStringArray(h) : h, [b, C] = n8(p.shape, u.shape, g, x, l), S = c.makeTensorInfo(C, l), k = c.texData.get(S.dataId);
        return k.values = b, S;
      }
      let m = A().getBool("WEBGL_PACK_BINARY_OPERATIONS") && e8 != null, d;
      return m ? d = new jr(e8, p.shape, u.shape, t8) : d = new Pr(r8, p.shape, u.shape), c.runWebGLProgram(d, [p, u], l);
    };
  }
  function yi(r8, e8 = false) {
    if (r8 === "linear")
      return e8 ? vD : yD;
    if (r8 === "relu")
      return e8 ? ND : CD;
    if (r8 === "elu")
      return e8 ? kD : bD;
    if (r8 === "relu6")
      return e8 ? TD : wD;
    if (r8 === "prelu")
      return e8 ? uv : iv;
    if (r8 === "leakyrelu")
      return e8 ? av : sv;
    if (r8 === "sigmoid")
      return e8 ? _D : SD;
    throw new Error(`Activation ${r8} has not been implemented for the WebGL backend.`);
  }
  var Bc = class {
    constructor(e8, t8, o8, n8 = false, s = false, a = false, i10 = null, p = false, u = false) {
      this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = o8, this.enableShapeUniforms = pt(this.outputShape.length);
      let c = n8 ? e8[1] : e8[2], l = Math.ceil(c / 2), m = n8 ? "i * 2, rc.y" : "rc.y, i * 2", d = s ? "rc.z, i * 2" : "i * 2, rc.z", f = n8 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], h = s ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], g = "", x = "";
      i10 && (p ? g = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i10}
        }` : u ? g = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i10}
        }` : g = `vec4 activation(vec4 x) {
          ${i10}
        }`, x = "result = activation(result);");
      let b = a ? "result += getBiasAtOutCoords();" : "";
      a && this.variableNames.push("bias"), p && this.variableNames.push("preluActivationWeights"), u && this.variableNames.push("leakyreluAlpha");
      let C = "rc.x", S = "rc.x";
      e8[0] < t8[0] ? C = `imod(rc.x, ${e8[0]})` : t8[0] < e8[0] && (S = `imod(rc.x, ${t8[0]})`), this.userCode = `
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${l}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${C};
        int batchB = ${S};
        for (int i = 0; i < ${l}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${h[0]});
          result += (${f[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${x}

        setOutput(result);
      }
    `;
    }
  };
  var pv = { REAL: "return areal * breal - aimag * bimag;", IMAG: "return areal * bimag + aimag * breal;" };
  var Ql = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = w.assertAndGetBroadcastShape(t8, o8), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e8}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
  };
  var FD = "return a * b;";
  function Zl(r8) {
    let { inputs: e8, backend: t8 } = r8, { a: o8, b: n8 } = e8, s = w.upcastType(o8.dtype, n8.dtype);
    if (o8.dtype === "complex64") {
      let i10 = t8.texData.get(o8.dataId), p = t8.texData.get(n8.dataId), u = new Ql(pv.REAL, o8.shape, n8.shape), c = new Ql(pv.IMAG, o8.shape, n8.shape), l = [{ dataId: i10.complexTensorInfos.real.dataId, dtype: i10.complexTensorInfos.real.dtype, shape: o8.shape }, { dataId: i10.complexTensorInfos.imag.dataId, dtype: i10.complexTensorInfos.imag.dtype, shape: o8.shape }, { dataId: p.complexTensorInfos.real.dataId, dtype: p.complexTensorInfos.real.dtype, shape: n8.shape }, { dataId: p.complexTensorInfos.imag.dataId, dtype: p.complexTensorInfos.imag.dtype, shape: n8.shape }], m = t8.runWebGLProgram(u, l, "float32"), d = t8.runWebGLProgram(c, l, "float32"), f = Or({ inputs: { real: m, imag: d }, backend: t8 });
      return t8.disposeIntermediateTensorInfo(m), t8.disposeIntermediateTensorInfo(d), f;
    }
    if (t8.shouldExecuteOnCPU([o8, n8])) {
      let i10 = t8.texData.get(o8.dataId), p = t8.texData.get(n8.dataId), [u, c] = GR(o8.shape, n8.shape, i10.values, p.values, s), l = t8.makeTensorInfo(c, s), m = t8.texData.get(l.dataId);
      return m.values = u, l;
    }
    let a;
    return A().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? a = new jr(FD, o8.shape, n8.shape) : a = new Pr(FD, o8.shape, n8.shape), t8.runWebGLProgram(a, [o8, n8], s);
  }
  var PD = { kernelName: Xn, backendName: "webgl", kernelFunc: Zl };
  function OD(r8, e8, t8) {
    let o8 = [gi(r8.shape), ...xi(r8.shape)], n8 = { dtype: r8.dtype, shape: o8, dataId: r8.dataId }, s = [gi(e8), ...xi(e8)], a = new Mc(s, o8), i10 = true, p = [o8], u = t8.runWebGLProgram(a, [n8], r8.dtype, p, i10);
    return { dataId: u.dataId, shape: e8, dtype: u.dtype };
  }
  function te(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { shape: s } = o8, a = t8, i10 = y.sizeFromShape(n8.shape), p = y.inferFromImplicitShape(s, i10), u = y.sizeFromShape(p);
    y.assert(i10 === u, () => `The new shape (${p}) has ${u} elements and the old shape (${n8.shape}) has ${i10} elements. The new shape and old shape must have the same number of elements.`);
    let c = a.texData.get(n8.dataId);
    return c.isPacked && !yu(n8.shape, p) && !(c.texture !== null && yu(c.shape, p)) ? OD(n8, p, a) : (a.incRef(n8.dataId), { dataId: n8.dataId, shape: p, dtype: n8.dtype });
  }
  var MD = { kernelName: ma, backendName: "webgl", kernelFunc: te };
  var Jl = class {
    constructor(e8, t8) {
      this.variableNames = ["x"];
      let { windowSize: o8, batchSize: n8, inSize: s, outSize: a } = e8;
      this.outputShape = [n8, a];
      let i10 = Math.floor(o8 / 4) * 4, p = o8 % 4, u = "sumValue += dot(values, ones);";
      if (t8 != null) {
        let l = 1 / t8;
        u = `sumValue += dot(values * ${y.isInt(l) ? l.toPrecision(2) : l}, ones);`;
      }
      let c = "";
      s % o8 > 0 && (c = `
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o8};

        float sumValue = 0.0;

        for (int i = 0; i < ${i10}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i10};
        if (${p === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${p === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${p === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `;
    }
  };
  var fh = class {
    constructor(e8, t8) {
      this.variableNames = ["x"];
      let { windowSize: o8, batchSize: n8, inSize: s, outSize: a } = e8;
      this.outputShape = [n8, a];
      let i10 = "0.0", p = "";
      t8 === "prod" ? i10 = "1.0" : t8 === "min" ? (i10 = "1.0 / 1e-20", p = "min") : t8 === "max" && (i10 = "-1.0 / 1e-20", p = "max");
      let u = `${t8}(${t8}(${t8}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      t8 === "sum" ? u = "sumValue" : t8 === "prod" ? u = "prodValue" : t8 === "all" ? u = "allValue" : t8 === "any" && (u = "anyValue");
      let c = Math.floor(o8 / 4) * 4, l = o8 % 4, m = `
      if (${t8 === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${t8 === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${p}(values, minMaxValue);
        if (${t8 === "min"} || ${t8 === "max"}) {
          minMaxValue = ${p}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, d = "vec4";
      t8 === "all" ? (i10 = "1.0", m = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, d = "bvec4") : t8 === "any" && (i10 = "0.0", m = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, d = "bvec4");
      let f = "";
      s % o8 > 0 && (f = `
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${i10};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o8};

        vec4 minMaxValue = vec4(${i10});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${l === 1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${l === 2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${l === 3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${u});
      }
    `;
    }
  };
  function XZ(r8) {
    let e8 = [];
    for (; e8.length === 0 || e8[e8.length - 1].outSize !== 1; ) {
      let t8 = e8.length ? e8[e8.length - 1].outSize : r8[1], o8 = w.computeOptimalWindowSize(t8);
      e8.push({ inSize: t8, windowSize: o8, outSize: Math.ceil(t8 / o8) });
    }
    return e8;
  }
  function Yr(r8, e8, t8, o8) {
    let n8 = XZ(r8.shape), s = r8;
    for (let a = 0; a < n8.length; a++) {
      let { inSize: i10, windowSize: p, outSize: u } = n8[a], c, l;
      t8 === "mean" ? c = a === 0 ? new Jl({ windowSize: p, inSize: i10, batchSize: r8.shape[0], outSize: u }, i10) : new Jl({ windowSize: p, inSize: i10, batchSize: r8.shape[0], outSize: u }) : c = new fh({ windowSize: p, inSize: i10, batchSize: r8.shape[0], outSize: u }, t8), l = s, s = o8.runWebGLProgram(c, [s], e8), l.dataId !== r8.dataId && o8.disposeIntermediateTensorInfo(l);
    }
    return s;
  }
  var hh = class {
    constructor(e8, t8) {
      this.variableNames = ["A"];
      let o8 = new Array(e8.length);
      for (let a = 0; a < o8.length; a++)
        o8[a] = e8[t8[a]];
      this.outputShape = o8, this.rank = o8.length;
      let n8 = Re(this.rank), s = YZ(t8);
      this.userCode = `
    void main() {
      ${n8} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `;
    }
  };
  function YZ(r8) {
    let e8 = r8.length;
    if (e8 > 6)
      throw Error(`Transpose for rank ${e8} is not yet supported`);
    let t8 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], o8 = new Array(e8);
    for (let n8 = 0; n8 < r8.length; n8++)
      o8[r8[n8]] = t8[n8];
    return o8.join();
  }
  var gh = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
      let o8 = new Array(e8.length);
      for (let c = 0; c < o8.length; c++)
        o8[c] = e8[t8[c]];
      if (this.outputShape = o8, this.rank = o8.length, this.rank > 6)
        throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
      let n8 = Re(this.rank), s = ov("rc", this.rank), a = new Array(this.rank);
      for (let c = 0; c < t8.length; c++)
        a[t8[c]] = s[c];
      let i10 = `vec2(${a.slice(-2).join()})`, p = `++${s[this.rank - 1]} < ${o8[this.rank - 1]}`, u = `getChannel(getA(${a.join()}), ${i10})`;
      this.userCode = `
    void main() {
      ${n8} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${p}) {
        result[1] = ${u};
      }
      --${s[this.rank - 1]};
      if(++${s[this.rank - 2]} < ${o8[this.rank - 2]}) {
        result[2] = ${u};
        if(${p}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `;
    }
  };
  function Cu(r8, e8, t8) {
    let o8 = A().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new gh(r8.shape, e8) : new hh(r8.shape, e8);
    return t8.runWebGLProgram(o8, [r8], r8.dtype);
  }
  function LD(r8, e8, t8, o8) {
    let n8 = e8, s = r8.shape.length, a = y.parseAxisParam(n8, r8.shape), i10 = a, p = w.getAxesPermutation(i10, s), u = p != null, c = r8;
    u && (c = Cu(r8, p, o8), i10 = w.getInnerMostAxes(i10.length, s)), w.assertAxesAreInnerMostDims("sum", i10, s);
    let [l, m] = w.computeOutAndReduceShapes(c.shape, i10), d = l;
    t8 && (d = w.expandShapeToKeepDim(l, a));
    let f = y.sizeFromShape(m), g = y.sizeFromShape(r8.shape) / f, x = te({ inputs: { x: c }, attrs: { shape: [g, f] }, backend: o8 }), b = ti(r8.dtype), C = Yr(x, b, "sum", o8), S = te({ inputs: { x: C }, attrs: { shape: d }, backend: o8 });
    return o8.disposeIntermediateTensorInfo(x), o8.disposeIntermediateTensorInfo(C), u && o8.disposeIntermediateTensorInfo(c), S;
  }
  function Ip(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    return LD(n8, s, a, t8);
  }
  var BD = { kernelName: Ss, backendName: "webgl", kernelFunc: Ip };
  function Ct(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { perm: s } = o8, a = t8, i10 = n8.shape.length, p = new Array(i10);
    for (let c = 0; c < p.length; c++)
      p[c] = n8.shape[s[c]];
    let u;
    if (a.shouldExecuteOnCPU([n8])) {
      let l = a.texData.get(n8.dataId).values, m = Sp(l, n8.shape, n8.dtype, s, p);
      u = a.makeTensorInfo(p, n8.dtype);
      let d = a.texData.get(u.dataId);
      d.values = m;
    } else
      u = Cu(n8, s, a);
    return u;
  }
  var zD = { kernelName: po, backendName: "webgl", kernelFunc: Ct };
  var cv = 1e3;
  function vp({ a: r8, b: e8, transposeA: t8, transposeB: o8, backend: n8, bias: s = null, preluActivationWeights: a = null, leakyreluAlpha: i10 = 0, activation: p = null }) {
    let u = r8.shape.length, c = e8.shape.length, l = t8 ? r8.shape[u - 2] : r8.shape[u - 1], m = o8 ? e8.shape[c - 1] : e8.shape[c - 2], d = t8 ? r8.shape[u - 1] : r8.shape[u - 2], f = o8 ? e8.shape[c - 2] : e8.shape[c - 1], h = r8.shape.slice(0, -2), g = e8.shape.slice(0, -2), x = y.sizeFromShape(h), b = y.sizeFromShape(g), S = Ir.assertAndGetBroadcastShape(r8.shape.slice(0, -2), e8.shape.slice(0, -2)).concat([d, f]);
    y.assert(l === m, () => `Error in matMul: inner shapes (${l}) and (${m}) of Tensors with shapes ${r8.shape} and ${e8.shape} and transposeA=${t8} and transposeB=${o8} must match.`);
    let k = t8 ? [x, l, d] : [x, d, l], _ = o8 ? [b, f, m] : [b, m, f], E = te({ inputs: { x: r8 }, backend: n8, attrs: { shape: k } }), R = te({ inputs: { x: e8 }, backend: n8, attrs: { shape: _ } }), D = [E, R], P = Math.max(x, b), O = t8 ? E.shape[1] : E.shape[2], M = s != null, L = a != null, B = p === "leakyrelu", z = p != null ? yi(p, true) : null, U = M || L || B || z != null, j;
    if ((d === 1 || f === 1) && O > cv && U === false) {
      let Y = E, J = R;
      t8 && (Y = Ct({ inputs: { x: E }, backend: n8, attrs: { perm: [0, 2, 1] } }), D.push(Y)), o8 && (J = Ct({ inputs: { x: R }, backend: n8, attrs: { perm: [0, 2, 1] } }), D.push(J));
      let re = f !== 1, ne = f === 1, ee = Y;
      re && (ee = te({ inputs: { x: Y }, backend: n8, attrs: { shape: [P, O, 1] } }), D.push(ee));
      let oe = f === 1 ? 2 : 1, ie = J;
      ne && (ie = te({ inputs: { x: J }, backend: n8, attrs: { shape: [P, 1, O] } }), D.push(ie));
      let le = Zl({ inputs: { a: ee, b: ie }, backend: n8 });
      j = Ip({ inputs: { x: le }, backend: n8, attrs: { axis: oe, keepDims: true } }), D.push(le);
    } else {
      let Y = dt(r8.dtype, e8.dtype), J = new Bc(k, _, [P, d, f], t8, o8, M, z, L, B), re = [E, R];
      if (s != null && re.push(s), L && re.push(a), B) {
        let ne = n8.makeTensorInfo([], "float32", y.createScalarValue(i10, "float32"));
        re.push(ne), D.push(ne);
      }
      j = n8.runWebGLProgram(J, re, Y);
    }
    let q = te({ inputs: { x: j }, backend: n8, attrs: { shape: S } });
    D.push(j);
    for (let Y of D)
      n8.disposeIntermediateTensorInfo(Y);
    return q;
  }
  function QZ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s, bias: a, preluActivationWeights: i10 } = e8, { transposeA: p, transposeB: u, activation: c, leakyreluAlpha: l } = o8;
    return vp({ a: n8, b: s, transposeA: p, transposeB: u, backend: t8, bias: a, preluActivationWeights: i10, leakyreluAlpha: l, activation: c });
  }
  var VD = { kernelName: So, backendName: "webgl", kernelFunc: QZ };
  var WD = "return abs(x);";
  function ZZ(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (t8.shouldExecuteOnCPU([o8]) && o8.dtype !== "complex64") {
      let s = t8.texData.get(o8.dataId), a = uh(s.values);
      return t8.makeTensorInfo(o8.shape, o8.dtype, a);
    }
    let n8;
    return A().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? n8 = new Fr(o8.shape, WD) : n8 = new rr(o8.shape, WD), t8.runWebGLProgram(n8, [o8], o8.dtype);
  }
  var UD = { kernelName: js, backendName: "webgl", kernelFunc: ZZ };
  var JZ = Ut + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
  var e9 = xe({ opSnippet: JZ });
  var GD = { kernelName: Vo, backendName: "webgl", kernelFunc: e9 };
  var t9 = Ut + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
  var r9 = xe({ opSnippet: t9 });
  var HD = { kernelName: Wo, backendName: "webgl", kernelFunc: r9 };
  var KD = "return a + b;";
  var o9 = nt({ opSnippet: KD, packedOpSnippet: KD, supportsComplex: true, cpuKernelImpl: IR });
  var qD = { kernelName: io, backendName: "webgl", kernelFunc: o9 };
  var xh = class {
    constructor(e8, t8) {
      this.outputShape = [], this.outputShape = e8, this.variableNames = t8.map((s, a) => `T${a}`);
      let o8 = [];
      this.variableNames.forEach((s) => {
        o8.push(`float v${s} = get${s}AtOutCoords();`);
      });
      let n8 = this.variableNames.map((s) => `v${s}`).join(" + ");
      this.userCode = `
      void main() {
        ${o8.join(`
        `)}

        float result = ${n8};
        setOutput(result);
      }
    `;
    }
  };
  var yh = class {
    constructor(e8, t8) {
      this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = e8, this.variableNames = t8.map((s, a) => `T${a}`);
      let o8 = [];
      this.variableNames.forEach((s) => {
        o8.push(`vec4 v${s} = get${s}AtOutCoords();`);
      });
      let n8 = this.variableNames.map((s) => `v${s}`).join(" + ");
      this.userCode = `
      void main() {
        ${o8.join(`
        `)}

        vec4 result = ${n8};
        setOutput(result);
      }
    `;
    }
  };
  function bh(r8) {
    let { inputs: e8, backend: t8 } = r8, o8 = e8;
    if (o8.length === 1)
      return Dt({ inputs: { x: o8[0] }, backend: t8 });
    if (o8.length > A().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      let p = Math.floor(o8.length / 2), u = bh({ inputs: o8.slice(0, p), backend: t8 }), c = bh({ inputs: o8.slice(p), backend: t8 });
      return bh({ inputs: [u, c], backend: t8 });
    }
    let n8 = o8.map((p) => p.dtype).reduce((p, u) => dt(p, u)), s = o8.map((p) => p.shape), i10 = A().getBool("WEBGL_PACK") ? new yh(o8[0].shape, s) : new xh(o8[0].shape, s);
    return t8.runWebGLProgram(i10, o8, n8);
  }
  var jD = { kernelName: Uo, backendName: "webgl", kernelFunc: bh };
  function n9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8, i10 = n8.shape.length, p = y.parseAxisParam(s, n8.shape), u = p, c = w.getAxesPermutation(u, i10), l = n8;
    c != null && (l = Ct({ inputs: { x: n8 }, backend: t8, attrs: { perm: c } }), u = w.getInnerMostAxes(u.length, i10)), w.assertAxesAreInnerMostDims("all", u, i10);
    let [m, d] = w.computeOutAndReduceShapes(l.shape, u), f = y.sizeFromShape(d), h = te({ inputs: { x: l }, backend: t8, attrs: { shape: [-1, f] } }), g = Yr(h, h.dtype, "all", t8), x;
    if (a) {
      let b = w.expandShapeToKeepDim(m, p);
      x = te({ inputs: { x: g }, backend: t8, attrs: { shape: b } });
    } else
      x = te({ inputs: { x: g }, backend: t8, attrs: { shape: m } });
    return t8.disposeIntermediateTensorInfo(h), t8.disposeIntermediateTensorInfo(g), c != null && t8.disposeIntermediateTensorInfo(l), x;
  }
  var XD = { kernelName: Go, backendName: "webgl", kernelFunc: n9 };
  function s9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8, i10 = n8.shape.length, p = y.parseAxisParam(s, n8.shape), u = p, c = w.getAxesPermutation(u, i10), l = n8;
    c != null && (l = Ct({ inputs: { x: n8 }, backend: t8, attrs: { perm: c } }), u = w.getInnerMostAxes(u.length, i10)), w.assertAxesAreInnerMostDims("any", u, i10);
    let [m, d] = w.computeOutAndReduceShapes(l.shape, u), f = y.sizeFromShape(d), h = te({ inputs: { x: l }, backend: t8, attrs: { shape: [-1, f] } }), g = Yr(h, h.dtype, "any", t8), x;
    if (a) {
      let b = w.expandShapeToKeepDim(m, p);
      x = te({ inputs: { x: g }, backend: t8, attrs: { shape: b } });
    } else
      x = te({ inputs: { x: g }, backend: t8, attrs: { shape: m } });
    return t8.disposeIntermediateTensorInfo(h), t8.disposeIntermediateTensorInfo(g), c != null && t8.disposeIntermediateTensorInfo(l), x;
  }
  var YD = { kernelName: Ho, backendName: "webgl", kernelFunc: s9 };
  var Ch = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["A"];
      let { windowSize: n8, batchSize: s, outSize: a } = e8;
      o8 || this.variableNames.push("bestIndicesA"), this.outputShape = [s, a];
      let i10 = t8 === "max" ? ">" : "<", p = o8 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n8};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${n8}; i++) {
          int inIdx = ${p};
          float candidate = getA(batch, inIdx);
          if (candidate ${i10} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
  };
  var wh = class {
    constructor(e8, t8, o8, n8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, y.assert(e8.length > 2, () => `Packed arg${o8.charAt(0).toUpperCase() + o8.slice(1)} supports only inputs with rank above 2.`);
      let s = e8[e8.length - 1], a = Math.ceil(s / t8);
      this.outputShape = e8.slice(0, -1), a > 1 && this.outputShape.push(a), n8 || this.variableNames.push("bestIndicesA");
      let i10 = this.outputShape, p = i10.length, u = Re(p), c = Rt("coords", p), l, m;
      if (a === 1) {
        m = p + 1;
        let R = Re(m);
        l = `
        ${R} sourceLocR = ${R}(${c.join()}, 0);
        ++${c[p - 1]};
        ${R} sourceLocG = ${R}(${c.join()}, 0);
        ++${c[p - 2]};
        ${R} sourceLocA = ${R}(${c.join()}, 0);
        --${c[p - 1]};
        ${R} sourceLocB = ${R}(${c.join()}, 0);
        --${c[p - 2]};`;
      } else
        m = p, l = `
        ${u} sourceLocR = coords;
        ++${c[p - 1]};
        ${u} sourceLocG = coords;
        ++${c[p - 2]};
        ${u} sourceLocA = coords;
        --${c[p - 1]};
        ${u} sourceLocB = coords;
        --${c[p - 2]};`;
      let d = ["x", "y", "z", "w", "u", "v"].slice(0, m), f = "." + d[m - 1], h = d.map((R) => "int " + R), g = Rt("sourceLocR", m - 1).concat("inIdx.r"), x = Rt("sourceLocG", m - 1).concat("inIdx.g"), b = Rt("sourceLocB", m - 1).concat("inIdx.b"), C = Rt("sourceLocA", m - 1).concat("inIdx.a"), S = o8 === "max" ? "greaterThan" : "lessThan", k = n8 ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${C.join()})));`, _ = `vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`, E = n8 ? "" : `
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;
      this.userCode = `
      float getAChannel(${h.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[p - 1]} < ${i10[p - 1] - 1};
        bool hasNextRow = ${c[p - 2]} < ${i10[p - 2] - 1};
        ${l}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t8};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t8}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${S}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
  };
  function QD(r8, e8, t8, o8 = null) {
    let n8 = e8.shape[0], s = e8.shape[1];
    o8 != null && (n8 = o8.shape[0], s = o8.shape[1]);
    let a = w.computeOptimalWindowSize(s), i10 = { windowSize: a, inSize: s, batchSize: n8, outSize: Math.ceil(s / a) }, p = new Ch(i10, t8, o8 == null), u = [e8];
    o8 != null && u.push(o8);
    let c = r8.runWebGLProgram(p, u, "int32");
    if (c.shape[1] === 1)
      return c;
    let l = QD(r8, e8, t8, c);
    return r8.disposeIntermediateTensorInfo(c), l;
  }
  function ZD(r8, e8, t8, o8 = null) {
    let n8 = o8 != null ? o8.shape : e8.shape, s = n8[n8.length - 1], a = w.computeOptimalWindowSize(s), i10 = new wh(n8, a, t8, o8 == null), p = o8 == null ? [e8] : [e8, o8], u = r8.runWebGLProgram(i10, p, "int32");
    if (u.shape.length === e8.shape.length) {
      let c = ZD(r8, e8, t8, u);
      return r8.disposeIntermediateTensorInfo(u), c;
    }
    return u;
  }
  function Sh(r8, e8, t8, o8) {
    let n8 = [t8];
    if (w.assertAxesAreInnerMostDims("arg" + o8.charAt(0).toUpperCase() + o8.slice(1), n8, e8.shape.length), !A().getBool("WEBGL_PACK_REDUCE") || e8.shape.length <= 2) {
      let s = [], a = r8.texData.get(e8.dataId), i10 = a !== null && a.isPacked, p = e8;
      i10 && (p = r8.unpackTensor(e8), s.push(p));
      let [u, c] = w.computeOutAndReduceShapes(p.shape, n8), l = y.sizeFromShape(c), m = te({ inputs: { x: p }, backend: r8, attrs: { shape: [-1, l] } });
      s.push(m);
      let d = QD(r8, m, o8);
      s.push(d);
      let f = te({ inputs: { x: d }, backend: r8, attrs: { shape: u } });
      return s.forEach((h) => r8.disposeIntermediateTensorInfo(h)), f;
    }
    return ZD(r8, e8, o8);
  }
  function a9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s } = o8, a = y.parseAxisParam(s, n8.shape), i10 = w.getAxesPermutation(a, n8.shape.length), p = n8, u = [];
    i10 != null && (p = Ct({ inputs: { x: n8 }, backend: t8, attrs: { perm: i10 } }), u.push(p), a = w.getInnerMostAxes(a.length, p.shape.length)), w.assertAxesAreInnerMostDims("argMax", [a[0]], p.shape.length);
    let c = Sh(t8, p, a[0], "max");
    return u.forEach((l) => t8.disposeIntermediateTensorInfo(l)), c;
  }
  var JD = { kernelName: Xs, backendName: "webgl", kernelFunc: a9 };
  function i9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s } = o8, a = y.parseAxisParam(s, n8.shape), i10 = w.getAxesPermutation(a, n8.shape.length), p = n8, u = [];
    i10 != null && (p = Ct({ inputs: { x: n8 }, backend: t8, attrs: { perm: i10 } }), u.push(p), a = w.getInnerMostAxes(a.length, p.shape.length)), w.assertAxesAreInnerMostDims("argMin", [a[0]], p.shape.length);
    let c = Sh(t8, p, a[0], "min");
    return u.forEach((l) => t8.disposeIntermediateTensorInfo(l)), c;
  }
  var eA = { kernelName: Ys, backendName: "webgl", kernelFunc: i9 };
  var u9 = Ut + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
  var p9 = xe({ opSnippet: u9 });
  var tA = { kernelName: Ko, backendName: "webgl", kernelFunc: p9 };
  var c9 = Ut + "return log(x + sqrt(x * x + 1.0));";
  var l9 = xe({ opSnippet: c9 });
  var rA = { kernelName: qo, backendName: "webgl", kernelFunc: l9 };
  var m9 = Ut + `
  return atan(x);
`;
  var d9 = xe({ opSnippet: m9 });
  var oA = { kernelName: jo, backendName: "webgl", kernelFunc: d9 };
  var f9 = Lc + `
  return atan(a, b);
`;
  var h9 = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Xr + `
  return result;
`;
  var g9 = nt({ opSnippet: f9, packedOpSnippet: h9 });
  var nA = { kernelName: Yo, backendName: "webgl", kernelFunc: g9 };
  var x9 = Ut + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
  var y9 = xe({ opSnippet: x9 });
  var sA = { kernelName: Xo, backendName: "webgl", kernelFunc: y9 };
  var Vs = class {
    constructor(e8, t8, o8, n8 = false, s = false) {
      if (this.variableNames = ["x"], t8 === "avg" && o8)
        throw new Error("Cannot compute positions for average pool.");
      let a = e8.filterWidth, i10 = e8.strideHeight, p = e8.strideWidth, u = e8.dilationHeight, c = e8.dilationWidth, l = e8.effectiveFilterHeight, m = e8.effectiveFilterWidth, d = e8.padInfo.top, f = e8.padInfo.left;
      this.outputShape = e8.outShape;
      let h = t8 === "avg", g = `((batch  * ${e8.inHeight} + xR) * ${e8.inWidth} + xC) * ${e8.inChannels} + d`, x = `(xR * ${e8.inWidth} + xC) * ${e8.inChannels} + d`, b = "0.0";
      if (h || (b = "-1.0 / 1e-20"), o8) {
        let R = ">=";
        this.userCode = `
        const ivec2 strides = ivec2(${i10}, ${p});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${l};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e8.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e8.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${R} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${n8 ? s ? g : x : `wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      let C = "max", S = `${t8}(${t8}(${t8}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      t8 === "avg" && (S = "avgValue / max(count, 1.0)");
      let k = Math.floor(a / 4) * 4, _ = a % 4, E = `
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${i10}, ${p});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e8.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${l};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e8.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${k};
          if (${_ === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${_ === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${_ === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${S});
      }
    `;
    }
  };
  var wu = class {
    constructor(e8, t8, o8, n8 = false, s = false) {
      if (this.variableNames = ["x"], t8 === "avg" && o8)
        throw new Error("Cannot compute positions for average pool.");
      let a = e8.filterWidth, i10 = e8.strideDepth, p = e8.strideHeight, u = e8.strideWidth, c = e8.dilationDepth, l = e8.dilationHeight, m = e8.dilationWidth, d = e8.effectiveFilterDepth, f = e8.effectiveFilterHeight, h = e8.effectiveFilterWidth, g = e8.padInfo.front, x = e8.padInfo.top, b = e8.padInfo.left;
      this.outputShape = e8.outShape;
      let C = t8 === "avg", S = "0.0";
      if (C || (S = "-1.0 / 1e-20"), o8) {
        let P = ">=";
        this.userCode = `
        const ivec3 strides =
            ivec3(${i10}, ${p}, ${u});
        const ivec3 pads = ivec3(${g}, ${x}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e8.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${l}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e8.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e8.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${n8 ? s ? `(((batch * ${e8.inDepth} + xD) * ${e8.inHeight} + xR) * ${e8.inWidth} + xC) * ${e8.inChannels} + ch` : `((xD * ${e8.inHeight} + xR) * ${e8.inWidth} + xC) * ${e8.inChannels} + ch` : `wD * ${f} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      let k = "max", _ = `${t8}(${t8}(${t8}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      t8 === "avg" && (_ = "avgValue / max(count, 1.0)");
      let E = Math.floor(a / 4) * 4, R = a % 4, D = `
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${i10}, ${p}, ${u});
      const ivec3 pads = ivec3(${g}, ${x}, ${b});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e8.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e8.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e8.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${E};
            if (${R === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${_});
      }
    `;
    }
  };
  function b9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8;
    Bs(n8, "avgPool");
    let { filterSize: s, strides: a, pad: i10, dimRoundingMode: p } = o8, u = 1;
    y.assert(w.eitherStridesOrDilationsAreOne(a, u), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
    let c = w.computePool2DInfo(n8.shape, s, a, u, i10, p);
    if (c.filterWidth === 1 && c.filterHeight === 1 && y.arraysEqual(c.inShape, c.outShape))
      return Dt({ inputs: { x: n8 }, backend: t8 });
    let l = new Vs(c, "avg", false);
    return t8.runWebGLProgram(l, [n8], "float32");
  }
  var aA = { kernelName: Qo, backendName: "webgl", kernelFunc: b9 };
  function C9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dimRoundingMode: p, dataFormat: u } = o8, c = [1, 1, 1], l = w.computePool3DInfo(n8.shape, s, a, c, i10, p, u), m = new wu(l, "avg", false);
    return t8.runWebGLProgram(m, [n8], "float32");
  }
  var iA = { kernelName: Qs, backendName: "webgl", kernelFunc: C9 };
  var Ih = class {
    constructor(e8) {
      this.variableNames = ["dy"], this.outputShape = e8.inShape;
      let t8 = e8.filterHeight, o8 = e8.filterWidth, n8 = e8.strideHeight, s = e8.strideWidth, a = e8.dilationHeight, i10 = e8.dilationWidth, p = e8.effectiveFilterHeight, u = e8.effectiveFilterWidth, c = p - 1 - e8.padInfo.top, l = u - 1 - e8.padInfo.left, m = 1 / (t8 * o8);
      this.userCode = `
      const ivec2 pads = ivec2(${c}, ${l});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${n8}.0;

          if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i10}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e8.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var vh = class {
    constructor(e8) {
      this.variableNames = ["dy"], this.outputShape = e8.inShape;
      let t8 = e8.filterDepth, o8 = e8.filterHeight, n8 = e8.filterWidth, s = e8.strideDepth, a = e8.strideHeight, i10 = e8.strideWidth, p = e8.dilationDepth, u = e8.dilationHeight, c = e8.dilationWidth, l = e8.effectiveFilterDepth, m = e8.effectiveFilterHeight, d = e8.effectiveFilterWidth, f = l - 1 - e8.padInfo.front, h = m - 1 - e8.padInfo.top, g = d - 1 - e8.padInfo.left, x = 1 / (t8 * o8 * n8);
      this.userCode = `
      const ivec3 pads = ivec3(${f}, ${h}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
            wD += ${p}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e8.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i10}.0;

              if (dyC < 0.0 || dyC >= ${e8.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function w9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, a = s, { filterSize: i10, strides: p, pad: u, dimRoundingMode: c } = o8, l = [1, 1, 1], m = w.computePool3DInfo(a.shape, i10, p, l, u, c), d = new vh(m);
    return t8.runWebGLProgram(d, [n8], a.dtype);
  }
  var uA = { kernelName: Ei, backendName: "webgl", kernelFunc: w9 };
  function S9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, a = s;
    Bs([n8, s], "avgPoolGrad");
    let { filterSize: i10, strides: p, pad: u } = o8, c = w.computePool2DInfo(a.shape, i10, p, 1, u), l = new Ih(c);
    return t8.runWebGLProgram(l, [n8], a.dtype);
  }
  var pA = { kernelName: $i, backendName: "webgl", kernelFunc: S9 };
  function I9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s } = e8, { transposeA: a, transposeB: i10 } = o8;
    return vp({ a: n8, b: s, transposeA: a, transposeB: i10, backend: t8 });
  }
  var cA = { kernelName: Zo, backendName: "webgl", kernelFunc: I9 };
  var kh = class {
    constructor(e8, t8, o8, n8, s, a) {
      this.outputShape = [], this.variableNames = ["x", "mean", "variance"], w.assertAndGetBroadcastShape(e8, t8), w.assertAndGetBroadcastShape(e8, o8);
      let i10 = "0.0";
      n8 != null && (w.assertAndGetBroadcastShape(e8, n8), this.variableNames.push("offset"), i10 = "getOffsetAtOutCoords()");
      let p = "1.0";
      s != null && (w.assertAndGetBroadcastShape(e8, s), this.variableNames.push("scale"), p = "getScaleAtOutCoords()"), this.outputShape = e8, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i10};
        float scale = ${p};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
  };
  var Nh = class {
    constructor(e8, t8, o8, n8, s, a) {
      this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], w.assertAndGetBroadcastShape(e8, t8), w.assertAndGetBroadcastShape(e8, o8);
      let i10 = "vec4(0.0)";
      n8 != null && (w.assertAndGetBroadcastShape(e8, n8), this.variableNames.push("offset"), i10 = "getOffsetAtOutCoords()");
      let p = "vec4(1.0)";
      s != null && (w.assertAndGetBroadcastShape(e8, s), this.variableNames.push("scale"), p = "getScaleAtOutCoords()"), this.outputShape = e8, this.userCode = `
      void main() {
        vec4 offset = ${i10};
        vec4 scale = ${p};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
  };
  var v9 = ({ inputs: r8, backend: e8, attrs: t8 }) => {
    let { x: o8, mean: n8, variance: s, offset: a, scale: i10 } = r8;
    y.assert(n8.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), y.assert(a == null || n8.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), y.assert(i10 == null || n8.shape.length === i10.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let { varianceEpsilon: p } = t8;
    p == null && (p = 1e-3);
    let u = [o8, n8, s], c = null;
    a != null && (c = a.shape, u.push(a));
    let l = null;
    i10 != null && (l = i10.shape, u.push(i10));
    let m = A().getBool("WEBGL_PACK_NORMALIZATION") ? new Nh(o8.shape, n8.shape, s.shape, c, l, p) : new kh(o8.shape, n8.shape, s.shape, c, l, p);
    return e8.runWebGLProgram(m, u, u[0].dtype);
  };
  var lA = { kernelName: In, backendName: "webgl", kernelFunc: v9 };
  var Th = class {
    constructor(e8) {
      this.variableNames = ["source"], this.outputShape = e8, this.rank = e8.length;
      let t8 = Re(this.rank);
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      let o8 = k9(this.rank), n8, s = e8.map((a, i10) => `sourceLoc.${lv[i10]} = start[${i10}] + coords.${lv[i10]};`);
      n8 = `
        ${t8} sourceLoc;
        ${t8} coords = getOutputCoords();
        ${s.join(`
`)}
      `, this.userCode = `
      void main() {
        ${n8}
        setOutput(getSource(${o8}));
      }
    `;
    }
  };
  var lv = ["x", "y", "z", "w", "u", "v"];
  function k9(r8) {
    if (r8 === 1)
      return "sourceLoc";
    if (r8 <= 6)
      return lv.slice(0, r8).map((e8) => "sourceLoc." + e8).join(",");
    throw Error(`Slicing for rank ${r8} is not yet supported`);
  }
  var _h = class {
    constructor(e8) {
      this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e8, this.rank = e8.length, this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      let t8 = Re(this.rank), o8 = Rt("coords", this.rank), n8 = Rt("sourceLoc", this.rank), s = this.rank === 1 ? "sourceLoc" : `vec2(${n8.slice(-2).join()})`, a = `getChannel(getSource(${n8.join()}), ${s})`, i10 = `
      result.x = ${a};
      if (++${o8[this.rank - 1]} < ${e8[this.rank - 1]}) {
        ++${n8[this.rank - 1]};
        result.y = ${a};
        --${n8[this.rank - 1]};
      }
    `, p = this.rank === 1 ? "" : `
      --${o8[this.rank - 1]};
      if (++${o8[this.rank - 2]} < ${e8[this.rank - 2]}) {
        ++${n8[this.rank - 2]};
        result.z = ${a};
        if (++${o8[this.rank - 1]} < ${e8[this.rank - 1]}) {
          ++${n8[this.rank - 1]};
          result.w = ${a};
        }
      }
    `, u = this.rank <= 4 ? `sourceLoc = coords +
            ${t8}(${e8.map((c, l) => `start[${l}]`).join()});` : e8.map((c, l) => `${n8[l]} = ${o8[l]} + start[${l}];`).join(`
`);
      this.userCode = `
      void main() {
        ${t8} coords = getOutputCoords();
        ${t8} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i10}
        ${p}
        setOutput(result);
      }
    `;
    }
  };
  function N9(r8, e8, t8, o8) {
    let n8 = o8.texData.get(r8.dataId), s = o8.makeTensorInfo(t8, r8.dtype), a = o8.texData.get(s.dataId);
    Object.assign(a, n8), a.refCount = 1, a.shape = t8, a.dtype = r8.dtype;
    let i10 = ct.computeFlatOffset(e8, y.computeStrides(r8.shape));
    n8.slice && (i10 += n8.slice.flatOffset), a.slice = { flatOffset: i10, origDataId: n8.slice && n8.slice.origDataId || r8.dataId };
    let p = o8.dataRefCount.get(a.slice.origDataId) || 1;
    return o8.dataRefCount.set(a.slice.origDataId, p + 1), s;
  }
  function Ws(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { begin: s, size: a } = o8, [i10, p] = ct.parseSliceParams(n8, s, a);
    if (ct.assertParamsValid(n8, i10, p), y.sizeFromShape(p) === 0)
      return t8.makeTensorInfo(p, n8.dtype, []);
    if (t8.shouldExecuteOnCPU([n8]) || n8.dtype === "string") {
      let l = t8.texData.get(n8.dataId), m = tD(l.values, i10, p, n8.shape, n8.dtype);
      return t8.makeTensorInfo(p, n8.dtype, m);
    }
    let { isPacked: u } = t8.texData.get(n8.dataId), c = ct.isSliceContinous(n8.shape, i10, p);
    if (u || !c) {
      let l = A().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new _h(p) : new Th(p), m = [i10];
      return t8.runWebGLProgram(l, [n8], n8.dtype, m);
    }
    return t8.uploadToGPU(n8.dataId), N9(n8, i10, p, t8);
  }
  var mA = { kernelName: fa, backendName: "webgl", kernelFunc: Ws };
  var T9 = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, crops: a } = o8;
    y.assert(n8.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
    let i10 = s.reduce((b, C) => b * C), p = w.getReshaped(n8.shape, s, i10), u = w.getPermuted(p.length, s.length), c = w.getReshapedPermuted(n8.shape, s, i10), l = w.getSliceBeginCoords(a, s.length), m = w.getSliceSize(c, a, s.length), d = [], f = te({ inputs: { x: n8 }, backend: t8, attrs: { shape: p } }), h = Ct({ inputs: { x: f }, backend: t8, attrs: { perm: u } }), g = te({ inputs: { x: h }, backend: t8, attrs: { shape: c } }), x = Ws({ inputs: { x: g }, backend: t8, attrs: { begin: l, size: m } });
    return d.push(f), d.push(h), d.push(g), d.forEach((b) => t8.disposeIntermediateTensorInfo(b)), x;
  };
  var dA = { kernelName: Zs, backendName: "webgl", kernelFunc: T9 };
  function _9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, weights: s } = e8, { size: a } = o8, i10 = t8.readSync(n8.dataId), p = t8.readSync(s.dataId), u = ih(i10, p, s.dtype, s.shape, a);
    return t8.makeTensorInfo([a], s.dtype, u);
  }
  var fA = { kernelName: Jo, backendName: "webgl", kernelFunc: _9 };
  var $9 = `
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`;
  var E9 = `
  return float(int(a.r) & int(b.r));
`;
  function R9(r8) {
    let { inputs: e8, backend: t8 } = r8, { a: o8, b: n8 } = e8, s = A().getBool("WEBGL_PACK_BINARY_OPERATIONS"), a = A().getNumber("WEBGL_VERSION");
    if (t8.shouldExecuteOnCPU([o8, n8]) || a === 1) {
      let p = t8.texData.get(o8.dataId).values, u = t8.texData.get(n8.dataId).values, [c, l] = kR(o8.shape, n8.shape, p, u, o8.dtype), m = t8.makeTensorInfo(l, o8.dtype), d = t8.texData.get(m.dataId);
      return d.values = c, m;
    }
    let i10;
    return s ? i10 = new jr($9, o8.shape, n8.shape, false) : i10 = new Pr(E9, o8.shape, n8.shape), t8.runWebGLProgram(i10, [o8, n8], o8.dtype);
  }
  var hA = { kernelName: Ha, backendName: "webgl", kernelFunc: R9 };
  function D9(r8) {
    let { inputs: e8, backend: t8 } = r8, { s0: o8, s1: n8 } = e8, s = t8.readSync(o8.dataId), a = t8.readSync(n8.dataId), i10 = w.assertAndGetBroadcastShape(Array.from(s), Array.from(a));
    return t8.makeTensorInfo([i10.length], "int32", Int32Array.from(i10));
  }
  var gA = { kernelName: Js, backendName: "webgl", kernelFunc: D9 };
  var A9 = "return float(a != b);";
  var mv = nt({ opSnippet: A9, cpuKernelImpl: KR, dtype: "bool" });
  var xA = { kernelName: Yn, backendName: "webgl", kernelFunc: mv };
  function bi(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = t8.texData.get(o8.dataId);
    return Dt({ inputs: { x: n8.complexTensorInfos.real }, backend: t8 });
  }
  var yA = { kernelName: Gi, backendName: "webgl", kernelFunc: bi };
  var F9 = "return float(int(x));";
  function bA(r8, e8) {
    let t8 = new rr(r8.shape, F9), o8 = e8.runWebGLProgram(t8, [r8], "int32");
    return { dataId: o8.dataId, shape: o8.shape, dtype: o8.dtype };
  }
  function dv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { dtype: s } = o8;
    if (s === "complex64") {
      if (n8.dtype === "complex64")
        return Dt({ inputs: { x: n8 }, backend: t8 });
      let a = Gr(n8.shape), i10 = dv({ inputs: { x: n8 }, backend: t8, attrs: { dtype: "float32" } }), p = Or({ inputs: { real: i10, imag: a }, backend: t8 });
      return a.dispose(), t8.disposeIntermediateTensorInfo(i10), p;
    }
    if (n8.dtype === "complex64") {
      let a = bi({ inputs: { input: n8 }, backend: t8 }), i10 = dv({ inputs: { x: a }, backend: t8, attrs: { dtype: s } });
      return t8.disposeIntermediateTensorInfo(a), i10;
    }
    if (!y.hasEncodingLoss(n8.dtype, s)) {
      let a = Dt({ inputs: { x: n8 }, backend: t8 });
      return { dataId: a.dataId, shape: a.shape, dtype: s };
    }
    if (t8.shouldExecuteOnCPU([n8])) {
      let a = t8.texData.get(n8.dataId).values, [i10, p, u] = NR(a, n8.shape, n8.dtype, s);
      return t8.makeTensorInfo(i10, p, u);
    }
    if (s === "int32")
      return bA(n8, t8);
    if (s === "bool") {
      let a = t8.makeTensorInfo([], "bool", y.getTypedArrayFromDType("bool", 1)), p = mv({ inputs: { a: n8, b: a }, backend: t8 });
      return t8.disposeIntermediateTensorInfo(a), p;
    }
    throw new Error(`Error in Cast: failed to cast ${n8.dtype} to ${s}`);
  }
  var CA = { kernelName: yo, backendName: "webgl", kernelFunc: dv };
  var wA = "return ceil(x);";
  var P9 = xe({ opSnippet: wA, packedOpSnippet: wA, cpuKernelImpl: TR });
  var SA = { kernelName: en, backendName: "webgl", kernelFunc: P9 };
  var $h = class {
    constructor(e8) {
      this.variableNames = ["A"], this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = e8, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
  };
  var Eh = class {
    constructor(e8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = e8, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
  };
  function O9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { clipValueMin: s, clipValueMax: a } = o8, i10;
    A().getBool("WEBGL_PACK_CLIP") ? i10 = new Eh(n8.shape) : i10 = new $h(n8.shape);
    let p = [[s], [a]];
    return t8.runWebGLProgram(i10, [n8], n8.dtype, p);
  }
  var IA = { kernelName: bo, backendName: "webgl", kernelFunc: O9 };
  var Rh = class {
    constructor(e8) {
      this.variableNames = ["real", "imag"], this.outputShape = e8, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
  };
  function vA(r8, e8) {
    return { dataId: e8.dataId, dtype: e8.dtype, shape: r8.shape };
  }
  function M9(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8, n8 = t8.texData.get(o8.dataId), s = new Rh(o8.shape), a = [vA(o8, n8.complexTensorInfos.real), vA(o8, n8.complexTensorInfos.imag)];
    return t8.runWebGLProgram(s, a, a[0].dtype);
  }
  var kA = { kernelName: Di, backendName: "webgl", kernelFunc: M9 };
  var Dh = class {
    constructor(e8) {
      this.outputShape = [], this.outputShape = w.computeOutShape(e8, 1), this.variableNames = e8.map((a, i10) => `T${i10}`);
      let t8 = new Array(e8.length - 1);
      t8[0] = e8[0][1];
      for (let a = 1; a < t8.length; a++)
        t8[a] = t8[a - 1] + e8[a][1];
      let o8 = [`if (yC < ${t8[0]}) setOutput(getT0(yR, yC));`];
      for (let a = 1; a < t8.length; a++) {
        let i10 = t8[a - 1];
        o8.push(`else if (yC < ${t8[a]}) setOutput(getT${a}(yR, yC-${i10}));`);
      }
      let n8 = t8.length, s = t8[t8.length - 1];
      o8.push(`else setOutput(getT${n8}(yR, yC-${s}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${o8.join(`
        `)}
      }
    `;
    }
  };
  var Fh = class {
    constructor(e8, t8) {
      this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = w.computeOutShape(e8, t8);
      let o8 = this.outputShape, n8 = o8.length, s = Re(n8), a = Rt("coords", n8), i10 = ["x", "y", "z", "w", "u", "v"].slice(0, n8);
      this.variableNames = e8.map((h, g) => `T${g}`);
      let p = new Array(e8.length - 1);
      p[0] = e8[0][t8];
      for (let h = 1; h < p.length; h++)
        p[h] = p[h - 1] + e8[h][t8];
      let u = i10[t8], c = i10.slice(-2), l = i10.join(), m = `if (${u} < ${p[0]}) {
        return getChannel(
            getT0(${l}), vec2(${c.join()}));
        }`;
      for (let h = 1; h < p.length; h++) {
        let g = p[h - 1];
        m += `
        if (${u} < ${p[h]}  && ${u} >= ${p[h - 1]}) {
          return getChannel(
            getT${h}(${Ah(i10, u, g)}),
            vec2(${Ah(c, u, g)}));
        }`;
      }
      let d = p.length, f = p[p.length - 1];
      m += `
        return getChannel(
          getT${d}(${Ah(i10, u, f)}),
          vec2(${Ah(c, u, f)}));`, this.userCode = `
      float getValue(${i10.map((h) => "int " + h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[n8 - 1]} = ${a[n8 - 1]} + 1;
        if (${a[n8 - 1]} < ${o8[n8 - 1]}) {
          result.g = getValue(${a});
        }

        ${a[n8 - 2]} = ${a[n8 - 2]} + 1;
        if (${a[n8 - 2]} < ${o8[n8 - 2]}) {
          result.a = getValue(${a});
        }

        ${a[n8 - 1]} = ${a[n8 - 1]} - 1;
        if (${a[n8 - 2]} < ${o8[n8 - 2]} &&
            ${a[n8 - 1]} < ${o8[n8 - 1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `;
    }
  };
  function Ah(r8, e8, t8) {
    let o8 = r8.indexOf(e8);
    return r8.map((s, a) => a === o8 ? `${s} - ${t8}` : s).join();
  }
  function kp(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = t8.texData.get(o8.dataId);
    return Dt({ inputs: { x: n8.complexTensorInfos.imag }, backend: t8 });
  }
  var NA = { kernelName: Vi, backendName: "webgl", kernelFunc: kp };
  function zc(r8, e8, t8) {
    let o8 = r8[0].dtype;
    if (o8 === "complex64") {
      let d = r8.map((b) => bi({ inputs: { input: b }, backend: t8 })), f = r8.map((b) => kp({ inputs: { input: b }, backend: t8 })), h = zc(d, e8, t8), g = zc(f, e8, t8), x = Or({ inputs: { real: h, imag: g }, backend: t8 });
      return d.forEach((b) => t8.disposeIntermediateTensorInfo(b)), f.forEach((b) => t8.disposeIntermediateTensorInfo(b)), t8.disposeIntermediateTensorInfo(h), t8.disposeIntermediateTensorInfo(g), x;
    }
    let n8 = t8.shouldExecuteOnCPU(r8);
    if (o8 === "string" && (n8 = true), n8) {
      let d = r8.map((S) => {
        let _ = [-1, y.sizeFromShape(S.shape.slice(e8))];
        return te({ inputs: { x: S }, backend: t8, attrs: { shape: _ } });
      }), f = d.map((S) => ({ vals: t8.readSync(S.dataId), shape: S.shape })), h = w.computeOutShape(d.map((S) => S.shape), 1), g = d[0].shape[0] === 1, x = _R(f, h, o8, g), b = w.computeOutShape(r8.map((S) => S.shape), e8), C = t8.makeTensorInfo(b, o8, x);
      return d.forEach((S) => t8.disposeIntermediateTensorInfo(S)), C;
    }
    let s = r8.filter((d) => y.sizeFromShape(d.shape) > 0), a = A().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && s[0].shape.length > 1;
    if (s.length === 1) {
      let d = a ? new rr(r8[0].shape, Oa) : new Fr(r8[0].shape, Oa);
      return t8.runWebGLProgram(d, r8, o8);
    }
    let i10 = A().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if (s.length > i10) {
      let d = [];
      for (let h = 0; h < s.length; h += i10) {
        let g = s.slice(h, h + i10);
        d.push(zc(g, e8, t8));
      }
      let f = zc(d, e8, t8);
      for (let h of d)
        t8.disposeIntermediateTensorInfo(h);
      return f;
    }
    if (a) {
      let d = new Fh(s.map((f) => f.shape), e8);
      return t8.runWebGLProgram(d, s, o8);
    }
    let { tensors2D: p, outShape: u } = L9(s, e8, t8), c = new Dh(p.map((d) => d.shape)), l = t8.runWebGLProgram(c, p, o8);
    p.forEach((d) => t8.disposeIntermediateTensorInfo(d));
    let m = te({ inputs: { x: l }, attrs: { shape: u }, backend: t8 });
    return t8.disposeIntermediateTensorInfo(l), m;
  }
  function L9(r8, e8, t8) {
    let o8 = w.computeOutShape(r8.map((s) => s.shape), e8);
    return { tensors2D: r8.map((s) => te({ inputs: { x: s }, attrs: { shape: [-1, y.sizeFromShape(s.shape.slice(e8))] }, backend: t8 })), outShape: o8 };
  }
  function fv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { axis: n8 } = o8, s = y.parseAxisParam(n8, e8[0].shape)[0], a = e8.map((u) => u.shape);
    w.assertParamsConsistent(a, s);
    let i10 = w.computeOutShape(e8.map((u) => u.shape), s);
    if (y.sizeFromShape(i10) === 0)
      return t8.makeTensorInfo(i10, e8[0].dtype, []);
    let p = e8.filter((u) => y.sizeFromShape(u.shape) > 0);
    return p.length === 1 ? Dt({ inputs: { x: p[0] }, backend: t8 }) : zc(p, s, t8);
  }
  var TA = { kernelName: ea, backendName: "webgl", kernelFunc: fv };
  var Vc = class {
    constructor(e8, t8 = false, o8 = null, n8 = false, s = false) {
      this.variableNames = ["x", "W"], this.outputShape = e8.outShape;
      let a = e8.padInfo.top, i10 = e8.padInfo.left, p = e8.strideHeight, u = e8.strideWidth, c = e8.dilationHeight, l = e8.dilationWidth, m = e8.filterHeight, d = e8.filterWidth, f = Math.floor(e8.inChannels / 4) * 4, h = e8.inChannels % 4, g = e8.dataFormat === "channelsLast", x = g ? 1 : 2, b = g ? 2 : 3, C = g ? 3 : 1, S = "", k = "";
      o8 && (n8 ? S = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o8}
        }` : s ? S = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o8}
        }` : S = `
          float activation(float x) {
            ${o8}
          }
        `, k = "result = activation(result);");
      let _ = t8 ? "result += getBiasAtOutCoords();" : "";
      t8 && this.variableNames.push("bias"), n8 && this.variableNames.push("preluActivationWeights"), s && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${S}

      const ivec2 strides = ivec2(${p}, ${u});
      const ivec2 pads = ivec2(${a}, ${i10});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e8.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${l};

            if (xC < 0 || xC >= ${e8.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h === 1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${h === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${k}
        setOutput(result);
      }
    `;
    }
  };
  var Ph = class {
    constructor(e8) {
      this.variableNames = ["x", "W"], this.outputShape = e8.outShape;
      let t8 = e8.padInfo.front, o8 = e8.padInfo.top, n8 = e8.padInfo.left, s = e8.strideDepth, a = e8.strideHeight, i10 = e8.strideWidth, p = e8.dilationDepth, u = e8.dilationHeight, c = e8.dilationWidth, l = e8.filterDepth, m = e8.filterHeight, d = e8.filterWidth, f = Math.floor(e8.inChannels / 4) * 4, h = e8.inChannels % 4;
      this.userCode = `
      const ivec3 strides = ivec3(${s}, ${a}, ${i10});
      const ivec3 pads = ivec3(${t8}, ${o8}, ${n8});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${l}; wF++) {
          int xF = xFCorner + wF * ${p};

          if (xF < 0 || xF >= ${e8.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e8.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e8.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${h === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Wc = class {
    constructor(e8, t8 = false, o8 = null, n8 = false, s = false) {
      this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e8.outShape, this.enableShapeUniforms = pt(this.outputShape.length);
      let a = e8.padInfo.left, i10 = e8.strideWidth, p = e8.dilationWidth, u = e8.filterHeight, c = e8.filterWidth, l = c, m = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
      for (let g = 0; g < c; g++)
        m += `
           vec4 xTexelC${g * 2};
           int xTexelC${g * 2}Ready;
           vec4 xTexelC${g * 2 + 1};
           int xTexelC${g * 2 + 1}Ready;
           vec4 xC${g};`;
      m += `
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e8.inChannels}; d1 += 2) {
       `;
      for (let g = 0; g < c; g++)
        m += `
           xTexelC${g * 2} = vec4(0.0);
           xTexelC${g * 2}Ready = 0;
           xTexelC${g * 2 + 1} = vec4(0.0);
           xTexelC${g * 2 + 1}Ready = 0;
           xC${g} = vec4(0.0);`;
      m += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
      for (let g = 0; g < (l + 1) / 2; g++) {
        let x = g * 2;
        if (m += `
           xC = xCCorner + ${x * p};
           `, i10 === 1) {
          if (x < c && (a % 2 === 1 ? (m += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `, p === 1 && x > 0 ? m += `
                 xC${x} = vec4(xTexelC${x - 2}.zw, xTexelC${x}.xy);
                 ` : m += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `) : m += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `, x + 1 < c)) {
            let b = a % 2 === 0 ? y.nearestLargerEven(p) : p;
            p % 2 === 0 && a % 2 === 1 || p % 2 !== 0 && a % 2 !== 1 ? (m += `
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {
                     xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x + 1}.zw = vec2(0.0);
                     }
                     xTexelC${x + 1}Ready = 1;
                   }
                   `, p > 1 ? m += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x + 1} = vec4(previous.zw, xTexelC${x + 1}.xy);
                     } else {
                      xC${x + 1} = vec4(0.0, 0.0, xTexelC${x + 1}.xy);
                     }
                     ` : m += `
                     xC${x + 1} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.xy);
                     `) : b === 1 ? m += `
                     xC${x + 1} = xTexelC${x};
                     ` : m += `
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {
                       xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x + 1}.zw = vec2(0.0);
                       }
                       xTexelC${x + 1}Ready = 1;
                     }

                     xC${x + 1} = xTexelC${x + 1};
                     `;
          }
        } else
          x < c && (a % 2 === 1 ? (m += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x + 1}Ready == 0) {
                   xTexelC${x + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x + 1}.zw = vec2(0.0);
                   }
                   xTexelC${x + 1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.zw);
               `, x + 1 < c && (m += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x + 1} = vec4(xTexelC${x + 1}.xy, final.xy);
                 `)) : (m += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {
                   xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x + 1}.zw = vec2(0.);
                   }
                   xTexelC${x + 1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x + 1}.xy);
               `, x + 1 < c && (m += `
                   xC${x + 1} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.zw);
                 `)));
        x < c && (m += `
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e8.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, x + 1 < c && (m += `
               wTexel = getW(r, ${x + 1}, d1, d2);
               dotProd += xC${x + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e8.inChannels}) {
                 dotProd += xC${x + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
      }
      m += `
     }
   `, m += `
     }
   `, m += `
     }
   `;
      let d = "", f = "";
      o8 && (n8 ? d = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${o8}
         }` : s ? d = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${o8}
         }` : d = `vec4 activation(vec4 x) {
           ${o8}
         }`, f = "result = activation(result);");
      let h = t8 ? "result += getBiasAtOutCoords();" : "";
      t8 && this.variableNames.push("bias"), n8 && this.variableNames.push("preluActivationWeights"), s && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${f}
         setOutput(result);
       }
     `;
    }
  };
  var Oh = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec4" }, { name: "pad", type: "ivec2" }, { name: "stride", type: "ivec2" }, { name: "dilation", type: "ivec2" }, { name: "inChannels", type: "int" }, { name: "itemsPerBlockRow", type: "int" }, { name: "outWidth", type: "int" }], this.outputShape = e8, this.enableShapeUniforms = pt(this.outputShape.length);
      let { dataFormat: o8 } = t8, n8 = vt(), s = o8 === "channelsLast", a = s ? 1 : 2, i10 = s ? 2 : 3, p = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${e8[2]} && pos < ${e8[1]}) {`, u = "";
      for (let c = 0; c <= 1; c++)
        for (let l = 0; l <= 1; l++)
          u += `
          blockIndex = rc.z + ${l};
          pos = rc.y + ${c};

          ${p}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i10}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c * 2 + l}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c * 2 + l}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
      this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${n8.output} = result;
      }
    `;
    }
  };
  function Mh(r8, e8) {
    let t8 = r8.length;
    return t8 >= 3 ? e8 ? [...r8.slice(0, -3), r8[t8 - 3] * r8[t8 - 2], r8[t8 - 1]] : [...r8.slice(0, -3), r8[t8 - 3], r8[t8 - 2] * r8[t8 - 1]] : !e8 && t8 === 1 && r8[0] > 1 ? [r8[0], 1] : null;
  }
  function Lh({ x: r8, filter: e8, convInfo: t8, backend: o8, bias: n8 = null, preluActivationWeights: s = null, leakyreluAlpha: a = 0, activation: i10 = null }) {
    let p = r8.shape, u = o8.texData.get(r8.dataId), c = t8.inChannels, l = p[0] * p[1] * p[2], m = t8.outChannels, d = t8.dataFormat === "channelsLast", f = false, h = false, g, x = [];
    if (s != null) {
      let S = Mh(s.shape, d);
      S != null && (s = te({ inputs: { x: s }, backend: o8, attrs: { shape: S } }), x.push(s));
    }
    if (n8 != null) {
      let S = Mh(n8.shape, d);
      S != null && (n8 = te({ inputs: { x: n8 }, backend: o8, attrs: { shape: S } }), x.push(n8));
    }
    if (!((l === 1 || m === 1) && c > cv) && u.isPacked && d && u.texture != null && p[2] % 2 !== 0 && y.arraysEqual(u.shape.slice(-3), p.slice(-3))) {
      let S = p[0] * p[1] * (p[2] + 1), k = { dataId: r8.dataId, shape: [1, S, t8.inChannels], dtype: r8.dtype }, _ = u.shape;
      u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, y.assert(yu(u.shape, k.shape), () => `packed reshape ${u.shape} to ${k.shape} isn't free`);
      let E = te({ inputs: { x: e8 }, backend: o8, attrs: { shape: [1, t8.inChannels, t8.outChannels] } });
      x.push(E);
      let R = vp({ a: k, b: E, backend: o8, transposeA: f, transposeB: h, bias: n8, activation: i10, preluActivationWeights: s, leakyreluAlpha: a }), D = o8.texData.get(R.dataId);
      y.assert(D.isPacked, () => "batchMatMul result is expected to be packed"), u.shape = _, D.shape = t8.outShape, g = Dt({ inputs: { x: R }, backend: o8 }), g.shape = t8.outShape, x.push(R);
    } else {
      let S = t8.outHeight * t8.outWidth, k = te({ inputs: { x: r8 }, backend: o8, attrs: { shape: d ? [t8.batchSize, S, t8.inChannels] : [t8.batchSize, t8.inChannels, S] } }), _ = te({ inputs: { x: e8 }, backend: o8, attrs: { shape: [1, t8.inChannels, t8.outChannels] } }), E = vp({ a: d ? k : _, b: d ? _ : k, transposeA: !d, transposeB: h, backend: o8, bias: n8, activation: i10, preluActivationWeights: s, leakyreluAlpha: a });
      g = te({ inputs: { x: E }, backend: o8, attrs: { shape: t8.outShape } }), x.push(k), x.push(_), x.push(E);
    }
    for (let S of x)
      o8.disposeIntermediateTensorInfo(S);
    return g;
  }
  function Bh({ x: r8, filter: e8, convInfo: t8, backend: o8, bias: n8 = null, preluActivationWeights: s = null, leakyreluAlpha: a = 0, activation: i10 = null }) {
    let { filterWidth: p, filterHeight: u, inChannels: c, outWidth: l, outHeight: m, dataFormat: d } = t8, f = d === "channelsLast", h = p * u * c, g = m * l, x = [t8.batchSize, h, g], b = true, C = false, S = [];
    if (s != null) {
      let q = Mh(s.shape, f);
      q != null && (s = te({ inputs: { x: s }, backend: o8, attrs: { shape: q } }), S.push(s));
    }
    if (n8 != null) {
      let q = Mh(n8.shape, f);
      q != null && (n8 = te({ inputs: { x: n8 }, backend: o8, attrs: { shape: q } }), S.push(n8));
    }
    let k = te({ inputs: { x: e8 }, backend: o8, attrs: { shape: [1, h, y.sizeFromShape(e8.shape) / h] } });
    S.push(k);
    let _ = new Oh(x, t8), E = [r8.shape, [t8.padInfo.top, t8.padInfo.left], [t8.strideHeight, t8.strideWidth], [t8.dilationHeight, t8.dilationWidth], [t8.inChannels], [t8.filterWidth * t8.inChannels], [t8.outWidth]], R = o8.runWebGLProgram(_, [r8], "float32", E), D = te({ inputs: { x: R }, backend: o8, attrs: { shape: x } });
    S.push(R), S.push(D);
    let P = n8 != null, O = s != null, M = i10 === "leakyrelu", L = i10 ? yi(i10, true) : null, B = new Bc(f ? D.shape : k.shape, f ? k.shape : D.shape, f ? [t8.batchSize, g, t8.outChannels] : [t8.batchSize, t8.outChannels, g], b, C, P, L, O, M), z = f ? [D, k] : [k, D];
    if (n8 && z.push(n8), O && z.push(s), M) {
      let q = o8.makeTensorInfo([], "float32", y.createScalarValue(a, "float32"));
      z.push(q), S.push(q);
    }
    let U = o8.runWebGLProgram(B, z, "float32"), j = te({ inputs: { x: U }, backend: o8, attrs: { shape: t8.outShape } });
    S.push(U);
    for (let q of S)
      o8.disposeIntermediateTensorInfo(q);
    return j;
  }
  function B9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dataFormat: p, dilations: u, dimRoundingMode: c } = o8, l = w.convertConv2DDataFormat(p), m = w.computeConv2DInfo(n8.shape, s.shape, a, u, i10, c, false, l), d;
    if (m.filterHeight === 1 && m.filterWidth === 1 && m.dilationHeight === 1 && m.dilationWidth === 1 && m.strideHeight === 1 && m.strideWidth === 1 && (m.padInfo.type === "SAME" || m.padInfo.type === "VALID"))
      d = Lh({ x: n8, filter: s, convInfo: m, backend: t8 });
    else if (m.strideWidth <= 2 && l === "channelsLast" && A().getBool("WEBGL_EXP_CONV")) {
      let h = new Wc(m), g = [[m.padInfo.top, m.padInfo.left], [m.strideHeight, m.strideWidth], [m.dilationHeight, m.dilationWidth], [m.inHeight, m.inWidth]];
      d = t8.runWebGLProgram(h, [n8, s], "float32", g);
    } else if (A().getBool("WEBGL_CONV_IM2COL"))
      d = Bh({ x: n8, filter: s, convInfo: m, backend: t8 });
    else {
      let h = new Vc(m);
      d = t8.runWebGLProgram(h, [n8, s], "float32");
    }
    let f = te({ inputs: { x: d }, backend: t8, attrs: { shape: m.outShape } });
    return t8.disposeIntermediateTensorInfo(d), f;
  }
  var _A = { kernelName: tn, backendName: "webgl", kernelFunc: B9 };
  var zh = class {
    constructor(e8) {
      this.variableNames = ["x", "dy"], this.outputShape = e8.filterShape;
      let t8 = e8.strideHeight, o8 = e8.strideWidth, n8 = e8.padInfo.top, s = e8.padInfo.left, a = e8.dataFormat === "channelsLast";
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e8.batchSize}; b++) {
          for (int yR = 0; yR < ${e8.outHeight}; yR++) {
            int xR = wR + yR * ${t8} - ${n8};

            if (xR < 0 || xR >= ${e8.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e8.outWidth}; yC++) {
              int xC = wC + yC * ${o8} - ${s};

              if (xC < 0 || xC >= ${e8.inWidth}) {
                continue;
              }

              ${a ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Vh = class {
    constructor(e8) {
      this.variableNames = ["dy", "W"], this.outputShape = e8.inShape;
      let t8 = e8.filterHeight, o8 = e8.filterWidth, n8 = e8.strideHeight, s = e8.strideWidth, a = e8.dataFormat === "channelsLast", i10 = t8 - 1 - e8.padInfo.top, p = o8 - 1 - e8.padInfo.left, u = a ? 1 : 2, c = a ? 2 : 3, l = a ? 3 : 1;
      this.userCode = `
      const ivec2 pads = ivec2(${i10}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${l}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t8}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n8}.0;

          if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t8} - 1 - wR;

          for (int wC = 0; wC < ${o8}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e8.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o8} - 1 - wC;

            for (int d2 = 0; d2 < ${e8.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Wh = class {
    constructor(e8) {
      this.variableNames = ["x", "dy"], this.outputShape = e8.filterShape;
      let t8 = e8.strideDepth, o8 = e8.strideHeight, n8 = e8.strideWidth, s = e8.padInfo.front, a = e8.padInfo.top, i10 = e8.padInfo.left;
      this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e8.batchSize}; b++) {
          for (int yF = 0; yF < ${e8.outDepth}; yF++) {
            int xF = wF + yF * ${t8} - ${s};

            if (xF < 0 || xF >= ${e8.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e8.outHeight}; yR++) {
              int xR = wR + yR * ${o8} - ${a};

              if (xR < 0 || xR >= ${e8.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e8.outWidth}; yC++) {
                int xC = wC + yC * ${n8} - ${i10};

                if (xC < 0 || xC >= ${e8.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Uh = class {
    constructor(e8) {
      this.variableNames = ["dy", "W"], this.outputShape = e8.inShape;
      let t8 = e8.filterDepth, o8 = e8.filterHeight, n8 = e8.filterWidth, s = e8.strideDepth, a = e8.strideHeight, i10 = e8.strideWidth, p = t8 - 1 - e8.padInfo.front, u = o8 - 1 - e8.padInfo.top, c = n8 - 1 - e8.padInfo.left;
      this.userCode = `
      const ivec3 pads = ivec3(${p}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t8}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e8.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t8} - 1 - wF;

          for (int wR = 0; wR < ${o8}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${o8} - 1 - wR;

            for (int wC = 0; wC < ${n8}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i10}.0;

              if (dyC < 0.0 || dyC >= ${e8.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${n8} - 1 - wC;

              for (int d2 = 0; d2 < ${e8.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function z9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, pad: i10, dataFormat: p, dimRoundingMode: u, filterShape: c } = o8, l = w.convertConv2DDataFormat(p), m = w.computeConv2DInfo(n8.shape, c, a, 1, i10, u, false, l), d = new zh(m);
    return t8.runWebGLProgram(d, [n8, s], "float32");
  }
  var $A = { kernelName: Ai, backendName: "webgl", kernelFunc: z9 };
  var Gh = class {
    constructor(e8) {
      this.variableNames = ["dy", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "strides", type: "vec2" }], this.outputShape = e8.inShape, this.enableShapeUniforms = pt(this.outputShape.length);
      let t8 = e8.filterHeight, o8 = e8.filterWidth, n8 = t8 - 1 - e8.padInfo.top, s = o8 - 1 - e8.padInfo.left;
      this.userCode = `
      const ivec2 pads = ivec2(${n8}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t8}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t8} - 1 - wR;

          for (int wC = 0; wC < ${o8}; wC++) {
            int wCPerm = ${o8} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e8.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e8.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e8.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e8.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e8.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
    }
  };
  function V9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { inputShape: a, strides: i10, pad: p, dataFormat: u, dimRoundingMode: c } = o8, l = w.convertConv2DDataFormat(u), m = w.computeConv2DInfo(a, s.shape, i10, 1, p, c, false, l);
    if (A().getBool("WEBGL_PACK") && l === "channelsLast") {
      let d = [[m.strideHeight, m.strideWidth]], f = new Gh(m);
      return t8.runWebGLProgram(f, [n8, s], "float32", d);
    } else {
      let d = new Vh(m);
      return t8.runWebGLProgram(d, [n8, s], "float32");
    }
  }
  var EA = { kernelName: rn, backendName: "webgl", kernelFunc: V9 };
  function W9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p } = o8, u = w.computeConv3DInfo(n8.shape, s.shape, a, p, i10), c = new Ph(u);
    return t8.runWebGLProgram(c, [n8, s], "float32");
  }
  var RA = { kernelName: on, backendName: "webgl", kernelFunc: W9 };
  function U9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, pad: i10, filterShape: p } = o8, u = w.computeConv3DInfo(n8.shape, p, a, 1, i10), c = new Wh(u);
    return t8.runWebGLProgram(c, [n8, s], "float32");
  }
  var DA = { kernelName: Ka, backendName: "webgl", kernelFunc: U9 };
  function G9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { pad: a, strides: i10, inputShape: p } = o8, u = w.computeConv3DInfo(p, s.shape, i10, 1, a), c = new Uh(u);
    return t8.runWebGLProgram(c, [n8, s], "float32");
  }
  var AA = { kernelName: nn, backendName: "webgl", kernelFunc: G9 };
  var H9 = Fo + `
  return cos(x);
`;
  var K9 = `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Xr}
  return result;
`;
  var q9 = xe({ opSnippet: H9, packedOpSnippet: K9 });
  var FA = { kernelName: sn, backendName: "webgl", kernelFunc: q9 };
  var j9 = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
  var X9 = xe({ opSnippet: j9 });
  var PA = { kernelName: an, backendName: "webgl", kernelFunc: X9 };
  var Hh = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
      let [a, i10, p, u] = e8, [c] = t8, [l, m] = o8;
      this.outputShape = [c, l, m, u];
      let d = n8 === "bilinear" ? 1 : 0, [f, h] = [`${i10 - 1}.0`, `${p - 1}.0`], [g, x, b] = l > 1 ? [`${(i10 - 1) / (l - 1)}`, "(y2-y1) * height_ratio", `y1*${f} + float(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${f}`], [C, S, k] = m > 1 ? [`${(p - 1) / (m - 1)}`, "(x2-x1) * width_ratio", `x1*${h} + float(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${h}`];
      this.userCode = `
      const float height_ratio = float(${g});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${S};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
  };
  var Y9 = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { image: n8, boxes: s, boxInd: a } = e8, { cropSize: i10, method: p, extrapolationValue: u } = o8, c = new Hh(n8.shape, s.shape, i10, p, u);
    return t8.runWebGLProgram(c, [n8, s, a], "float32");
  };
  var OA = { kernelName: cn, backendName: "webgl", kernelFunc: Y9 };
  var Np;
  (function(r8) {
    r8.Prod = "*", r8.Sum = "+";
  })(Np || (Np = {}));
  var em = class {
    constructor(e8, t8, o8, n8) {
      this.op = e8, this.outputShape = t8, this.variableNames = ["x"], this.customUniforms = [{ name: "index", type: "float" }];
      let s = this.outputShape.length, a = this.op === Np.Prod ? "1.0" : "0.0", i10 = o8 ? a : `getX(${MA(s, "coords", this.op)})`, p = this.outputShape[this.outputShape.length - 1], u = "", c = "";
      o8 ? (u = n8 ? `end != ${p - 1}` : "end != 0", c = n8 ? "end + 1" : "end - 1") : (u = n8 ? `end + pow2 < ${p}` : "end >= pow2", c = n8 ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${Re(s)} coords = getOutputCoords();
        int end = ${LA(s, "coords", this.op)};
        float val = ${i10};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${LA(s, "coords", this.op)} = idx;
          val ${this.op}= getX(${MA(s, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
    }
  };
  function MA(r8, e8, t8) {
    if (r8 === 1)
      return `${e8}`;
    if (r8 === 2)
      return `${e8}.x, ${e8}.y`;
    if (r8 === 3)
      return `${e8}.x, ${e8}.y, ${e8}.z`;
    if (r8 === 4)
      return `${e8}.x, ${e8}.y, ${e8}.z, ${e8}.w`;
    throw new Error(`Cumulative ${t8} for rank ${r8} is not yet supported`);
  }
  function LA(r8, e8, t8) {
    if (r8 === 1)
      return `${e8}`;
    if (r8 === 2)
      return `${e8}.y`;
    if (r8 === 3)
      return `${e8}.z`;
    if (r8 === 4)
      return `${e8}.w`;
    throw new Error(`Cumulative ${t8} for rank ${r8} is not yet supported`);
  }
  function Kh(r8, e8, t8, o8, n8, s) {
    let a = e8.shape.length, i10 = w.getAxesPermutation([o8], a), p = e8;
    i10 != null && (p = Ct({ inputs: { x: e8 }, backend: t8, attrs: { perm: i10 } }));
    let u = w.getInnerMostAxes(1, a)[0];
    if (u !== a - 1)
      throw new Error(`WebGL cumprod shader expects an inner-most axis=${e8.shape.length - 1} but got axis=${o8}`);
    let c = p.shape[u], l = Dt({ inputs: { x: p }, backend: t8 });
    for (let m = 0; m <= Math.ceil(Math.log2(c)) - 1; m++) {
      let d = new em(r8, p.shape, false, s), f = [[m]], h = l;
      l = t8.runWebGLProgram(d, [l], l.dtype, f), t8.disposeIntermediateTensorInfo(h);
    }
    if (n8) {
      let m = new em(r8, p.shape, n8, s), d = l;
      l = t8.runWebGLProgram(m, [l], l.dtype), t8.disposeIntermediateTensorInfo(d);
    }
    if (i10 != null) {
      let m = w.getUndoAxesPermutation(i10), d = Ct({ inputs: { x: l }, backend: t8, attrs: { perm: m } });
      return t8.disposeIntermediateTensorInfo(l), t8.disposeIntermediateTensorInfo(p), d;
    }
    return l;
  }
  function Q9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8;
    return Kh(Np.Prod, n8, t8, s, a, i10);
  }
  var BA = { kernelName: un, backendName: "webgl", kernelFunc: Q9 };
  function Z9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8;
    return Kh(Np.Sum, n8, t8, s, a, i10);
  }
  var zA = { kernelName: pn, backendName: "webgl", kernelFunc: Z9 };
  function J9(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, weights: s } = e8, { size: a, binaryOutput: i10 } = o8;
    if (n8.shape.length === 1) {
      let p = t8.readSync(n8.dataId), u = t8.readSync(s.dataId), c = ih(p, u, s.dtype, s.shape, a);
      return t8.makeTensorInfo([a], s.dtype, c);
    } else if (n8.shape.length === 2) {
      let p = t8.bufferSync(n8), u = t8.bufferSync(s), c = vR(p, u, a, i10);
      return t8.makeTensorInfo(c.shape, s.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n8.shape.length}.`);
  }
  var VA = { kernelName: ta, backendName: "webgl", kernelFunc: J9 };
  var qh = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.outputShape = [], this.outputShape = e8, this.blockSize = t8, this.dataFormat = o8, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t8};
      int offset_h = imod(h, ${t8});
      int in_w = w / ${t8};
      int offset_w = imod(w, ${t8});
      int offset_d = (offset_h * ${t8} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
      return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
      return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
    }
    getInputSamplingString() {
      return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  };
  function eJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockSize: s, dataFormat: a } = o8, i10 = n8.shape[0], p = a === "NHWC" ? n8.shape[1] : n8.shape[2], u = a === "NHWC" ? n8.shape[2] : n8.shape[3], c = a === "NHWC" ? n8.shape[3] : n8.shape[1], l = p * s, m = u * s, d = c / (s * s), f = a === "NHWC" ? [i10, l, m, d] : [i10, d, l, m], h = new qh(f, s, a);
    return t8.runWebGLProgram(h, [n8], n8.dtype);
  }
  var WA = { kernelName: ln, backendName: "webgl", kernelFunc: eJ };
  var Uc = class {
    constructor(e8, t8 = false, o8 = null, n8 = false, s = false) {
      this.variableNames = ["x", "W"], this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e8.outShape, this.enableShapeUniforms = pt(this.outputShape.length);
      let a = e8.filterHeight, i10 = e8.filterWidth, p = e8.outChannels / e8.inChannels, u = "", c = "";
      o8 && (n8 ? u = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o8}
        }` : s ? u = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o8}
        }` : u = `
          float activation(float x) {
            ${o8}
          }
        `, c = "result = activation(result);");
      let l = t8 ? "result += getBiasAtOutCoords();" : "";
      t8 && this.variableNames.push("bias"), n8 && this.variableNames.push("preluActivationWeights"), s && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${p};
        int q = d2 - d1 * ${p};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i10}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${l}
        ${c}
        setOutput(result);
      }
    `;
    }
  };
  var Gc = class {
    constructor(e8, t8 = false, o8 = null, n8 = false, s = false) {
      this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e8.outShape, this.enableShapeUniforms = pt(this.outputShape.length);
      let a = e8.outChannels / e8.inChannels, i10 = e8.padInfo.left, p = e8.strideWidth, u = e8.dilationWidth, c = e8.filterHeight, l = e8.filterWidth, m = l, d = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
      for (let x = 0; x < l; x++)
        d += `
          vec4 xTexelC${x * 2};
          int xTexelC${x * 2}Ready;
          vec4 xTexelC${x * 2 + 1};
          int xTexelC${x * 2 + 1}Ready;
          vec4 xC${x};`;
      d += `
    for (int r = 0; r < ${c}; r++) {
      `;
      for (let x = 0; x < l; x++)
        d += `
          xTexelC${x * 2} = vec4(0.0);
          xTexelC${x * 2}Ready = 0;
          xTexelC${x * 2 + 1} = vec4(0.0);
          xTexelC${x * 2 + 1}Ready = 0;
          xC${x} = vec4(0.0);`;
      d += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let x = 0; x < (m + 1) / 2; x++) {
        let b = x * 2;
        if (d += `
          xC = xCCorner + ${b * u};
          `, p === 1) {
          if (b < l && (i10 % 2 === 1 ? (d += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `, u === 1 && b > 0 ? d += `
                xC${b} = vec4(xTexelC${b - 2}.zw, xTexelC${b}.xy);
                ` : d += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `) : d += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `, b + 1 < l)) {
            let C = i10 % 2 === 0 ? y.nearestLargerEven(u) : u;
            u % 2 === 0 && i10 % 2 === 1 || u % 2 !== 0 && i10 % 2 !== 1 ? (d += `
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {
                    xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b + 1}.zw = vec2(0.0);
                    }
                    xTexelC${b + 1}Ready = 1;
                  }
                  `, u > 1 ? d += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b + 1} = vec4(previous.zw, xTexelC${b + 1}.xy);
                    } else {
                     xC${b + 1} = vec4(0.0, 0.0, xTexelC${b + 1}.xy);
                    }
                    ` : d += `
                    xC${b + 1} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.xy);
                    `) : C === 1 ? d += `
                    xC${b + 1} = xTexelC${b};
                    ` : d += `
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {
                      xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b + 1}.zw = vec2(0.0);
                      }
                      xTexelC${b + 1}Ready = 1;
                    }

                    xC${b + 1} = xTexelC${b + 1};
                    `;
          }
        } else
          b < l && (i10 % 2 === 1 ? (d += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b + 1}Ready == 0) {
                  xTexelC${b + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b + 1}.zw = vec2(0.0);
                  }
                  xTexelC${b + 1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.zw);
              `, b + 1 < l && (d += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b + 1} = vec4(xTexelC${b + 1}.xy, final.xy);
                `)) : (d += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {
                  xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b + 1}.zw = vec2(0.);
                  }
                  xTexelC${b + 1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b + 1}.xy);
              `, b + 1 < l && (d += `
                  xC${b + 1} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.zw);
                `)));
        b < l && (d += `
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `, b + 1 < l && (d += `
              wTexel = getW(r, ${b + 1}, d1, q);
              dotProd += xC${b + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
      }
      d += `
    }
  `, d += `
      }
    `;
      let f = "", h = "";
      o8 && (n8 ? f = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o8}
        }` : s ? f = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o8}
        }` : f = `vec4 activation(vec4 x) {
          ${o8}
        }`, h = "result = activation(result);");
      let g = t8 ? "result += getBiasAtOutCoords();" : "";
      t8 && this.variableNames.push("bias"), n8 && this.variableNames.push("preluActivationWeights"), s && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `;
    }
  };
  function tJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p, dimRoundingMode: u } = o8, c = p;
    c == null && (c = [1, 1]), y.assert(w.eitherStridesOrDilationsAreOne(a, c), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);
    let l = w.computeConv2DInfo(n8.shape, s.shape, a, c, i10, u, true), m;
    A().getBool("WEBGL_PACK_DEPTHWISECONV") && l.strideWidth <= 2 && l.outChannels / l.inChannels === 1 ? m = new Gc(l) : m = new Uc(l);
    let d = [[l.padInfo.top, l.padInfo.left], [l.strideHeight, l.strideWidth], [l.dilationHeight, l.dilationWidth], [l.inHeight, l.inWidth]];
    return t8.runWebGLProgram(m, [n8, s], "float32", d);
  }
  var UA = { kernelName: mn, backendName: "webgl", kernelFunc: tJ };
  var jh = class {
    constructor(e8) {
      this.variableNames = ["x", "dy"], this.outputShape = e8.filterShape;
      let t8 = e8.strideHeight, o8 = e8.strideWidth, n8 = e8.padInfo.top, s = e8.padInfo.left, a = e8.outChannels / e8.inChannels;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e8.batchSize}; b++) {
          for (int yR = 0; yR < ${e8.outHeight}; yR++) {
            int xR = wR + yR * ${t8} - ${n8};

            if (xR < 0 || xR >= ${e8.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e8.outWidth}; yC++) {
              int xC = wC + yC * ${o8} - ${s};

              if (xC < 0 || xC >= ${e8.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Xh = class {
    constructor(e8) {
      this.variableNames = ["dy", "W"], this.outputShape = e8.inShape;
      let t8 = e8.filterHeight, o8 = e8.filterWidth, n8 = e8.strideHeight, s = e8.strideWidth, a = t8 - 1 - e8.padInfo.top, i10 = o8 - 1 - e8.padInfo.left, p = e8.outChannels / e8.inChannels;
      this.userCode = `
      const ivec2 pads = ivec2(${a}, ${i10});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t8}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n8}.0;

          if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t8} - 1 - wR;

          for (int wC = 0; wC < ${o8}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e8.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o8} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${p}; dm++) {
              int d2 = d1 * ${p} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function rJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, dilations: i10, pad: p, dimRoundingMode: u, filterShape: c } = o8, l = w.computeConv2DInfo(n8.shape, c, a, i10, p, u, true), m = new jh(l);
    return t8.runWebGLProgram(m, [n8, s], "float32");
  }
  var GA = { kernelName: Fi, backendName: "webgl", kernelFunc: rJ };
  function oJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { strides: a, dilations: i10, pad: p, dimRoundingMode: u, inputShape: c } = o8, l = w.computeConv2DInfo(c, s.shape, a, i10, p, u, true), m = new Xh(l);
    return t8.runWebGLProgram(m, [n8, s], "float32");
  }
  var HA = { kernelName: Pi, backendName: "webgl", kernelFunc: oJ };
  var Yh = class {
    constructor(e8) {
      this.variableNames = ["X"], this.outputShape = [e8, e8], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
  };
  function nJ(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8, n8 = [...o8.shape, ...o8.shape], s = y.sizeFromShape(o8.shape), a = te({ inputs: { x: o8 }, backend: t8, attrs: { shape: [s] } }), i10 = new Yh(s), p = t8.runWebGLProgram(i10, [a], a.dtype), u = te({ inputs: { x: p }, backend: t8, attrs: { shape: n8 } });
    return t8.disposeIntermediateTensorInfo(a), t8.disposeIntermediateTensorInfo(p), u;
  }
  var KA = { kernelName: ra, backendName: "webgl", kernelFunc: nJ };
  var Qh = class {
    constructor(e8) {
      this.variableNames = ["x", "W"], this.outputShape = e8.outShape;
      let { inHeight: t8, inWidth: o8, padInfo: n8, strideHeight: s, strideWidth: a, filterHeight: i10, filterWidth: p, dilationHeight: u, dilationWidth: c } = e8, { top: l, left: m } = n8;
      this.userCode = `
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${l}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i10}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t8}) {
            for (int w = 0; w < ${p}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${o8}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
  };
  function sJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p } = o8, u = w.computeDilation2DInfo(n8.shape, s.shape, a, i10, "NHWC", p), c, l = new Qh(u);
    c = t8.runWebGLProgram(l, [n8, s], "float32");
    let m = te({ inputs: { x: c }, backend: t8, attrs: { shape: u.outShape } });
    return t8.disposeIntermediateTensorInfo(c), m;
  }
  var qA = { kernelName: dn, backendName: "webgl", kernelFunc: sJ };
  function aJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { equation: n8 } = o8, s = e8, { allDims: a, summedDims: i10, idDims: p } = w.decodeEinsumEquation(n8, s.length);
    w.checkEinsumDimSizes(a.length, p, s);
    let { path: u, steps: c } = w.getEinsumComputePath(i10, p), l = c.length, m = null, d = a.length, f = [];
    for (let h = 0; h < l; ++h) {
      for (let g of c[h]) {
        let { permutationIndices: x, expandDims: b } = w.getEinsumPermutation(d, p[g]), C;
        w.isIdentityPermutation(x) ? C = s[g] : (C = Ct({ inputs: { x: s[g] }, backend: t8, attrs: { perm: x } }), f.push(C));
        let S = C.shape.slice();
        for (let k = 0; k < b.length; ++k)
          S.splice(b[k], 0, 1);
        y.arraysEqual(C.shape, S) || (C = te({ inputs: { x: C }, backend: t8, attrs: { shape: S } }), f.push(C)), m === null ? m = C : (m = Zl({ inputs: { a: C, b: m }, backend: t8 }), f.push(m));
      }
      h < l - 1 && (u[h] >= 0 && (m = Ip({ inputs: { x: m }, backend: t8, attrs: { axis: u[h] - (a.length - d), keepDims: false } }), f.push(m)), d--);
    }
    for (let h of f)
      h !== m && t8.disposeIntermediateTensorInfo(h);
    return m;
  }
  var jA = { kernelName: Li, backendName: "webgl", kernelFunc: aJ };
  var iJ = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  var uJ = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var pJ = xe({ opSnippet: iJ, packedOpSnippet: uJ });
  var XA = { kernelName: hn, backendName: "webgl", kernelFunc: pJ };
  var cJ = "return (b >= 0.0) ? a : a * (b + 1.0);";
  var lJ = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
  var mJ = (r8) => {
    let { inputs: e8, backend: t8 } = r8, { dy: o8, y: n8 } = e8, s = A().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new jr(lJ, o8.shape, n8.shape) : new Pr(cJ, o8.shape, n8.shape);
    return t8.runWebGLProgram(s, [o8, n8], o8.dtype);
  };
  var YA = { kernelName: qa, backendName: "webgl", kernelFunc: mJ };
  var dJ = `
  return vec4(equal(a, b));
`;
  var fJ = "return float(a == b);";
  var hJ = nt({ opSnippet: fJ, packedOpSnippet: dJ, dtype: "bool", cpuKernelImpl: $R });
  var QA = { kernelName: xn, backendName: "webgl", kernelFunc: hJ };
  var gJ = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${w.ERF_P};
  float a1 = ${w.ERF_A1};
  float a2 = ${w.ERF_A2};
  float a3 = ${w.ERF_A3};
  float a4 = ${w.ERF_A4};
  float a5 = ${w.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
  var xJ = xe({ opSnippet: gJ });
  var ZA = { kernelName: gn, backendName: "webgl", kernelFunc: xJ };
  var yJ = Fo + `
  return exp(x);
`;
  var bJ = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var hv = xe({ opSnippet: yJ, packedOpSnippet: bJ, cpuKernelImpl: ER, dtype: "float32" });
  var JA = { kernelName: yn, backendName: "webgl", kernelFunc: hv };
  function Zh(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { dim: n8 } = t8, { input: s } = e8, a = s.shape.length, i10 = s.shape.slice(), p = n8;
    return n8 < 0 && (y.assert(-(a + 1) <= n8, () => `Axis must be in the interval [${-(a + 1)}, ${a}]`), p = a + n8 + 1), i10.splice(p, 0, 1), te({ inputs: { x: s }, backend: o8, attrs: { shape: i10 } });
  }
  var eF = { kernelName: oa, backendName: "webgl", kernelFunc: Zh };
  var tF = "return exp(x) - 1.0;";
  var CJ = xe({ opSnippet: tF, packedOpSnippet: tF, cpuKernelImpl: RR });
  var rF = { kernelName: bn, backendName: "webgl", kernelFunc: CJ };
  var tm = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["real", "imag"];
      let n8 = t8[1];
      this.outputShape = t8;
      let s = o8 ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, a = o8 ? `${n8}.0` : "1.0", i10;
      if (e8 === "real")
        i10 = "return real * expR - imag * expI;";
      else if (e8 === "imag")
        i10 = "return real * expI + imag * expR;";
      else
        throw new Error(`FFT component must be either "real" or "imag", got ${e8}.`);
      this.userCode = `
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i10}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${n8});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${n8}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
  };
  function Jh(r8, e8, t8) {
    let o8 = t8.texData.get(r8.dataId), n8 = y.sizeFromShape(r8.shape), s = r8.shape[r8.shape.length - 1], a = n8 / s, i10 = te({ inputs: { x: r8 }, backend: t8, attrs: { shape: [a, s] } }), p = i10.shape, u = new tm("real", p, e8), c = new tm("imag", p, e8), l = [{ dataId: o8.complexTensorInfos.real.dataId, dtype: o8.complexTensorInfos.real.dtype, shape: p }, { dataId: o8.complexTensorInfos.imag.dataId, dtype: o8.complexTensorInfos.imag.dtype, shape: p }], m = t8.runWebGLProgram(u, l, "float32"), d = t8.runWebGLProgram(c, l, "float32"), f = Or({ inputs: { real: m, imag: d }, backend: t8 });
    t8.disposeIntermediateTensorInfo(m), t8.disposeIntermediateTensorInfo(d);
    let h = te({ inputs: { x: f }, backend: t8, attrs: { shape: r8.shape } });
    return t8.disposeIntermediateTensorInfo(i10), t8.disposeIntermediateTensorInfo(f), h;
  }
  function wJ(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8;
    return Jh(o8, false, t8);
  }
  var oF = { kernelName: Bi, backendName: "webgl", kernelFunc: wJ };
  var eg = class {
    constructor(e8, t8) {
      this.outputShape = [], this.customUniforms = [{ name: "value", type: "float" }], this.variableNames = ["x"], this.outputShape = e8, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
  };
  function Ci(r8) {
    let { backend: e8, attrs: t8 } = r8, { shape: o8, value: n8 } = t8, { dtype: s } = t8;
    if (s = s || y.inferDtype(n8), s === "string") {
      let a = y.getArrayFromDType(s, y.sizeFromShape(o8));
      return a.fill(n8), e8.makeTensorInfo(o8, s, a);
    } else {
      let a = new eg(o8, n8), i10 = [[n8]];
      return e8.runWebGLProgram(a, [], s, i10);
    }
  }
  var nF = { kernelName: na, backendName: "webgl", kernelFunc: Ci };
  var tg = class {
    constructor(e8) {
      this.variableNames = ["Image"], this.outputShape = [];
      let t8 = e8[2];
      this.outputShape = e8, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t8} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t8}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };
  var sF = { kernelName: Cn, backendName: "webgl", kernelFunc: ({ inputs: r8, backend: e8 }) => {
    let { image: t8 } = r8, o8 = e8, n8 = new tg(t8.shape);
    return o8.runWebGLProgram(n8, [t8], t8.dtype);
  } };
  var aF = "return floor(x);";
  var SJ = xe({ opSnippet: aF, packedOpSnippet: aF, cpuKernelImpl: DR });
  var iF = { kernelName: wn, backendName: "webgl", kernelFunc: SJ };
  var IJ = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
  var vJ = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
  var kJ = nt({ opSnippet: IJ, packedOpSnippet: vJ, dtype: "int32" });
  var uF = { kernelName: Sn, backendName: "webgl", kernelFunc: kJ };
  var rg = class {
    constructor(e8) {
      this.variableNames = ["A"];
      let t8 = vt(), [o8, n8] = e8;
      this.outputShape = e8, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n8}.0, ${o8}.0);

        vec4 values = ${t8.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
  };
  var og = class {
    constructor(e8) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
      let t8 = vt(), [o8, n8] = e8;
      this.outputShape = e8, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${n8}.0, ${o8}.0);
            vec4 values = ${t8.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t8.output} = result;
      }
    `;
    }
  };
  var pF = { kernelName: Au, backendName: "webgl", kernelFunc: NJ };
  var Hc;
  var gv = A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function NJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { pixels: n8 } = e8, { numChannels: s } = o8, a = typeof HTMLVideoElement != "undefined" && n8 instanceof HTMLVideoElement, i10 = typeof HTMLImageElement != "undefined" && n8 instanceof HTMLImageElement, [p, u] = a ? [n8.videoWidth, n8.videoHeight] : [n8.width, n8.height], c = [u, p], l = [u, p, s];
    if (i10 || a) {
      let h = A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
      (Hc == null || h !== gv) && (gv = h, Hc = document.createElement("canvas").getContext("2d", { willReadFrequently: gv })), Hc.canvas.width = p, Hc.canvas.height = u, Hc.drawImage(n8, 0, 0, p, u), n8 = Hc.canvas;
    }
    let m = t8.makeTensorInfo(c, "int32");
    t8.texData.get(m.dataId).usage = mr.PIXELS, t8.gpgpu.uploadPixelDataToTexture(t8.getTexture(m.dataId), n8);
    let d = A().getBool("WEBGL_PACK") ? new og(l) : new rg(l), f = t8.runWebGLProgram(d, [m], "int32");
    return t8.disposeData(m.dataId), f;
  }
  function TJ(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dataFormat: c, dilations: l, dimRoundingMode: m, activation: d, leakyreluAlpha: f } = o8, h = w.convertConv2DDataFormat(c), g = w.computeConv2DInfo(n8.shape, s.shape, p, l, u, m, false, h), x, b = [], C = a != null, S = i10 != null, k = d === "leakyrelu", _ = () => {
      let R = [n8, s], D = (P, O) => {
        if (O === "NCHW" && P.shape.length === 1 && P.shape[0] !== 1) {
          let M = te({ inputs: { x: P }, backend: t8, attrs: { shape: [P.shape[0], 1, 1] } });
          return b.push(M), M;
        }
        return P;
      };
      if (C && R.push(D(a, c)), S && R.push(D(i10, c)), k) {
        let P = t8.makeTensorInfo([], "float32", y.createScalarValue(f, "float32"));
        R.push(P), b.push(P);
      }
      return R;
    };
    if (g.filterHeight === 1 && g.filterWidth === 1 && g.dilationHeight === 1 && g.dilationWidth === 1 && g.strideHeight === 1 && g.strideWidth === 1 && (g.padInfo.type === "SAME" || g.padInfo.type === "VALID"))
      x = Lh({ x: n8, filter: s, convInfo: g, backend: t8, bias: a, activation: d, preluActivationWeights: i10, leakyreluAlpha: f });
    else if (g.strideWidth <= 2 && h === "channelsLast" && A().getBool("WEBGL_EXP_CONV")) {
      let R = d ? yi(d, true) : null, D = new Wc(g, C, R, S, k), P = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]], O = _();
      x = t8.runWebGLProgram(D, O, "float32", P);
    } else if (A().getBool("WEBGL_CONV_IM2COL"))
      x = Bh({ x: n8, filter: s, convInfo: g, backend: t8, bias: a, activation: d, preluActivationWeights: i10, leakyreluAlpha: f });
    else {
      let R = d ? yi(d, false) : null, D = new Vc(g, C, R, S, k), P = _();
      x = t8.runWebGLProgram(D, P, "float32");
    }
    let E = te({ inputs: { x }, backend: t8, attrs: { shape: g.outShape } });
    return b.push(x), b.forEach((R) => t8.disposeIntermediateTensorInfo(R)), E;
  }
  var cF = { kernelName: Io, backendName: "webgl", kernelFunc: TJ };
  function _J(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dilations: c, dimRoundingMode: l, activation: m, leakyreluAlpha: d } = o8, f = [], h = c;
    h == null && (h = [1, 1]), y.assert(w.eitherStridesOrDilationsAreOne(p, h), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${p} and dilations '${h}'`);
    let g = w.computeConv2DInfo(n8.shape, s.shape, p, h, u, l, true), x = A().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels === 1, b = m ? yi(m, x) : null, C = [n8, s], S = a != null, k = i10 != null, _ = m === "leakyrelu";
    if (S && C.push(a), k && C.push(i10), _) {
      let P = t8.makeTensorInfo([], "float32", y.createScalarValue(d, "float32"));
      C.push(P), f.push(P);
    }
    let E;
    x ? E = new Gc(g, S, b, k, _) : E = new Uc(g, S, b, k, _);
    let R = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]], D = t8.runWebGLProgram(E, C, "float32", R);
    return f.forEach((P) => t8.disposeIntermediateTensorInfo(P)), D;
  }
  var lF = { kernelName: vo, backendName: "webgl", kernelFunc: _J };
  var ng = class {
    constructor(e8, t8, o8, n8) {
      this.sliceDim = e8, this.strides = t8, this.paramsShape = n8, this.variableNames = ["x", "indices"], this.outputShape = o8;
      let s = Re(o8.length), a = `
    int index;`;
      for (let i10 = 0; i10 < this.sliceDim; i10++)
        a += `
          index = round(getIndices(coords[0], ${i10}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i10]};
          flattenIndex += index * ${this.strides[i10]};`;
      this.userCode = `
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
    }
  };
  function $J(r8) {
    let { inputs: e8, backend: t8 } = r8, { params: o8, indices: n8 } = e8, s = n8.shape, a = s[s.length - 1], i10 = y.sizeFromShape(o8.shape), [p, u, c, l] = w.prepareAndValidate(o8, n8), m = te({ inputs: { x: n8 }, backend: t8, attrs: { shape: [u, a] } }), d = te({ inputs: { x: o8 }, backend: t8, attrs: { shape: [y.sizeFromShape(o8.shape) / c, c] } });
    if (t8.shouldExecuteOnCPU([o8, n8]) || o8.dtype === "string") {
      let x = t8.readSync(n8.dataId), b = t8.bufferSync(o8), C = AR(x, b, o8.dtype, u, a, c, l, o8.shape, i10);
      return t8.makeTensorInfo(p, o8.dtype, C.values);
    }
    let f = new ng(a, l, [u, c], o8.shape), h = t8.runWebGLProgram(f, [d, m], d.dtype), g = te({ inputs: { x: h }, backend: t8, attrs: { shape: p } });
    return t8.disposeIntermediateTensorInfo(m), t8.disposeIntermediateTensorInfo(d), t8.disposeIntermediateTensorInfo(h), g;
  }
  var mF = { kernelName: vn, backendName: "webgl", kernelFunc: $J };
  var sg = class {
    constructor(e8, t8) {
      this.variableNames = ["A", "indices"], this.outputShape = t8, this.rank = t8.length;
      let o8 = Re(this.rank), n8 = EJ(e8);
      this.userCode = `
      void main() {
        ${o8} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e8[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${n8}));
      }
    `;
    }
  };
  function EJ(r8, e8) {
    let t8 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o8 = [];
    for (let n8 = 0; n8 < r8.length; n8++)
      n8 === 2 ? o8.push("index") : o8.push(`${t8[n8]}`);
    return o8.join();
  }
  function xv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, indices: s } = e8, { axis: a, batchDims: i10 } = o8, p = y.parseAxisParam(a, n8.shape)[0];
    if (A().get("DEBUG")) {
      let b = t8.readSync(s.dataId), C = n8.shape[p];
      for (let S = 0; S < b.length; ++S) {
        let k = b[S];
        y.assert(k <= C - 1 && k >= 0, () => `GatherV2: the index value ${k} is not in [0, ${C - 1}]`);
      }
    }
    let u = w.segment_util.collectGatherOpShapeInfo(n8, s, p, i10), c = y.sizeFromShape(s.shape), l = [], m = te({ inputs: { x: n8 }, backend: t8, attrs: { shape: [u.batchSize, u.outerSize, u.dimSize, u.sliceSize] } }), d = te({ inputs: { x: s }, backend: t8, attrs: { shape: [u.batchSize, c / u.batchSize] } });
    l.push(m), l.push(d);
    let f = [u.batchSize, u.outerSize, c / u.batchSize, u.sliceSize];
    if (t8.shouldExecuteOnCPU([n8, s]) || n8.dtype === "string") {
      let b = t8.bufferSync(d), C = t8.bufferSync(m), S = FR(C, b, f);
      return l.forEach((k) => t8.disposeIntermediateTensorInfo(k)), t8.makeTensorInfo(u.outputShape, S.dtype, S.values);
    }
    let h = new sg(m.shape, f), g = t8.runWebGLProgram(h, [m, d], m.dtype);
    l.push(g);
    let x = te({ inputs: { x: g }, backend: t8, attrs: { shape: u.outputShape } });
    return l.forEach((b) => t8.disposeIntermediateTensorInfo(b)), x;
  }
  var dF = { kernelName: sa, backendName: "webgl", kernelFunc: xv };
  var RJ = "return float(a > b);";
  var DJ = `
  return vec4(greaterThan(a, b));
`;
  var AJ = nt({ opSnippet: RJ, packedOpSnippet: DJ, cpuKernelImpl: PR, dtype: "bool" });
  var fF = { kernelName: kn, backendName: "webgl", kernelFunc: AJ };
  var FJ = "return float(a >= b);";
  var PJ = `
  return vec4(greaterThanEqual(a, b));
`;
  var OJ = nt({ opSnippet: FJ, packedOpSnippet: PJ, dtype: "bool", cpuKernelImpl: OR });
  var hF = { kernelName: Nn, backendName: "webgl", kernelFunc: OJ };
  function MJ(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8;
    return Jh(o8, true, t8);
  }
  var gF = { kernelName: zi, backendName: "webgl", kernelFunc: MJ };
  var LJ = "return float(!isnan(x) && !isinf(x));";
  var BJ = xe({ opSnippet: LJ, dtype: "bool" });
  var xF = { kernelName: Tn, backendName: "webgl", kernelFunc: BJ };
  var zJ = "return float(isinf(x));";
  var VJ = xe({ opSnippet: zJ, dtype: "bool" });
  var yF = { kernelName: _n, backendName: "webgl", kernelFunc: VJ };
  var WJ = "return float(isnan(x));";
  var UJ = xe({ opSnippet: WJ, dtype: "bool" });
  var bF = { kernelName: $n, backendName: "webgl", kernelFunc: UJ };
  var GJ = "return float(a < b);";
  var HJ = `
  return vec4(lessThan(a, b));
`;
  var KJ = nt({ opSnippet: GJ, packedOpSnippet: HJ, cpuKernelImpl: MR, dtype: "bool" });
  var CF = { kernelName: Rn, backendName: "webgl", kernelFunc: KJ };
  var qJ = "return float(a <= b);";
  var jJ = `
  return vec4(lessThanEqual(a, b));
`;
  var XJ = nt({ opSnippet: qJ, packedOpSnippet: jJ, cpuKernelImpl: LR, dtype: "bool" });
  var wF = { kernelName: Dn, backendName: "webgl", kernelFunc: XJ };
  function YJ(r8) {
    let { backend: e8, attrs: t8 } = r8, { start: o8, stop: n8, num: s } = t8, a = BR(o8, n8, s);
    return e8.makeTensorInfo([a.length], "float32", a);
  }
  var SF = { kernelName: An, backendName: "webgl", kernelFunc: YJ };
  var QJ = Fo + `
  return x < 0.0 ? 0./0. : log(x);
`;
  var ZJ = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`;
  var JJ = xe({ opSnippet: QJ, packedOpSnippet: ZJ, cpuKernelImpl: zR });
  var IF = { kernelName: Fn, backendName: "webgl", kernelFunc: JJ };
  var eee = Fo + `
  return log(1.0 + x);
`;
  var tee = xe({ opSnippet: eee });
  var vF = { kernelName: Pn, backendName: "webgl", kernelFunc: tee };
  var ree = "return float(a >= 1.0 && b >= 1.0);";
  var oee = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
  var nee = nt({ opSnippet: ree, packedOpSnippet: oee, dtype: "bool" });
  var kF = { kernelName: On, backendName: "webgl", kernelFunc: nee };
  var see = "return float(!(x >= 1.0));";
  var aee = xe({ opSnippet: see });
  var NF = { kernelName: Mn, backendName: "webgl", kernelFunc: aee };
  var iee = "return float(a >= 1.0 || b >= 1.0);";
  var uee = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
  var pee = nt({ opSnippet: iee, packedOpSnippet: uee, dtype: "bool" });
  var TF = { kernelName: Ln, backendName: "webgl", kernelFunc: pee };
  var ag = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["x"], this.outputShape = [];
      let a = t8, i10 = e8[3] - 1;
      this.outputShape = e8;
      let p, u = `float(${o8}) + float(${n8}) * sum`;
      s === 0.5 ? p = `inversesqrt(${u})` : s === 1 ? p = `1.0/(${u})` : p = `exp(log(${u}) * float(-${s}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i10}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${p};
        setOutput(val);
      }
    `;
    }
  };
  var ig = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
      let a = t8, i10 = e8[3] - 1;
      this.outputShape = e8;
      let p, u = `float(${o8}) + float(${n8}) * sum`;
      s === 0.5 ? p = `inversesqrt(${u})` : s === 1 ? p = `1.0/(${u})` : p = `exp(log(${u}) * float(-${s}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i10}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${p};
        setOutput(result);
      }
    `;
    }
  };
  var cee = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { depthRadius: s, bias: a, alpha: i10, beta: p } = o8, u = A().getBool("WEBGL_PACK_NORMALIZATION") ? new ig(n8.shape, s, a, i10, p) : new ag(n8.shape, s, a, i10, p);
    return t8.runWebGLProgram(u, [n8], n8.dtype);
  };
  var _F = { kernelName: Bn, backendName: "webgl", kernelFunc: cee };
  var ug = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e8, this.depth = e8[3], this.depthRadius = t8, this.bias = o8, this.alpha = n8, this.beta = s, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t8})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t8} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${n8}) * norm + float(${o8});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${n8})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
  };
  var lee = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, y: s, dy: a } = e8, { depthRadius: i10, bias: p, alpha: u, beta: c } = o8, l = new ug(n8.shape, i10, p, u, c);
    return t8.runWebGLProgram(l, [n8, s, a], n8.dtype);
  };
  var $F = { kernelName: ja, backendName: "webgl", kernelFunc: lee };
  function EF(r8, e8, t8, o8) {
    let n8 = y.sizeFromShape(e8), a = y.sizeFromShape(r8.shape) / n8, i10 = te({ inputs: { x: r8 }, attrs: { shape: [a, n8] }, backend: o8 }), p = Yr(i10, r8.dtype, "max", o8), u = te({ inputs: { x: p }, attrs: { shape: t8 }, backend: o8 });
    return o8.disposeIntermediateTensorInfo(i10), o8.disposeIntermediateTensorInfo(p), u;
  }
  function yv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { reductionIndices: s, keepDims: a } = o8, i10 = n8.shape.length, p = y.parseAxisParam(s, n8.shape), u = p, c = w.getAxesPermutation(u, i10), l = c != null, m = t8.shouldExecuteOnCPU([n8]), d = n8;
    if (l) {
      if (m) {
        let C = t8.texData.get(d.dataId).values, S = new Array(i10);
        for (let E = 0; E < S.length; E++)
          S[E] = n8.shape[c[E]];
        let k = Sp(C, n8.shape, n8.dtype, c, S);
        d = t8.makeTensorInfo(S, n8.dtype);
        let _ = t8.texData.get(d.dataId);
        _.values = k;
      } else
        d = Cu(n8, c, t8);
      u = w.getInnerMostAxes(u.length, i10);
    }
    w.assertAxesAreInnerMostDims("max", u, i10);
    let [f, h] = w.computeOutAndReduceShapes(d.shape, u), g = f;
    a && (g = w.expandShapeToKeepDim(f, p));
    let x;
    if (m) {
      let C = t8.texData.get(d.dataId).values, S = VR(C, y.sizeFromShape(h), g, n8.dtype);
      x = t8.makeTensorInfo(g, n8.dtype);
      let k = t8.texData.get(x.dataId);
      k.values = S;
    } else
      x = EF(d, h, g, t8);
    return l && t8.disposeIntermediateTensorInfo(d), x;
  }
  var RF = { kernelName: zn, backendName: "webgl", kernelFunc: yv };
  var mee = Lc + `
  return max(a, b);
`;
  var dee = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Xr + `
  return result;
`;
  var fee = nt({ opSnippet: mee, packedOpSnippet: dee, cpuKernelImpl: WR });
  var DF = { kernelName: Vn, backendName: "webgl", kernelFunc: fee };
  function hee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8;
    Bs(n8, "maxPool");
    let { filterSize: s, strides: a, pad: i10, dimRoundingMode: p } = o8, u = 1;
    y.assert(w.eitherStridesOrDilationsAreOne(a, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
    let c = w.computePool2DInfo(n8.shape, s, a, u, i10, p);
    if (c.filterWidth === 1 && c.filterHeight === 1 && y.arraysEqual(c.inShape, c.outShape))
      return Dt({ inputs: { x: n8 }, backend: t8 });
    let l = new Vs(c, "max", false);
    return t8.runWebGLProgram(l, [n8], n8.dtype);
  }
  var AF = { kernelName: Wn, backendName: "webgl", kernelFunc: hee };
  function gee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dataFormat: p, dimRoundingMode: u } = o8, c = [1, 1, 1], l = w.computePool3DInfo(n8.shape, s, a, c, i10, u, p), m = new wu(l, "max", false);
    return t8.runWebGLProgram(m, [n8], n8.dtype);
  }
  var FF = { kernelName: aa, backendName: "webgl", kernelFunc: gee };
  var pg = class {
    constructor(e8) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = e8.inShape;
      let t8 = e8.strideHeight, o8 = e8.strideWidth, n8 = e8.dilationHeight, s = e8.effectiveFilterHeight, a = e8.effectiveFilterWidth, i10 = s - 1 - e8.padInfo.top, p = a - 1 - e8.padInfo.left, u = s * a - 1;
      this.userCode = `
      const ivec2 pads = ivec2(${i10}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${n8}) {
          float dyR = float(dyRCorner + wR) / ${t8}.0;

          if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o8}.0;

            if (dyC < 0.0 || dyC >= ${e8.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var cg = class {
    constructor(e8) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = e8.inShape;
      let t8 = e8.strideDepth, o8 = e8.strideHeight, n8 = e8.strideWidth, s = e8.dilationDepth, a = e8.dilationHeight, i10 = e8.dilationWidth, p = e8.effectiveFilterDepth, u = e8.effectiveFilterHeight, c = e8.effectiveFilterWidth, l = p - 1 - e8.padInfo.front, m = u - 1 - e8.padInfo.top, d = c - 1 - e8.padInfo.left, f = p * u * c - 1;
      this.userCode = `
      const ivec3 pads = ivec3(${l}, ${m}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t8}.0;

          if (dyD < 0.0 || dyD >= ${e8.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${o8}.0;

            if (dyR < 0.0 || dyR >= ${e8.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i10}) {
              float dyC = float(dyCCorner + wC) / ${n8}.0;

              if (dyC < 0.0 || dyC >= ${e8.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function xee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, a = s, { filterSize: i10, strides: p, pad: u, dimRoundingMode: c } = o8, l = [1, 1, 1], m = w.computePool3DInfo(a.shape, i10, p, l, u, c), d = new wu(m, "max", true), f = t8.runWebGLProgram(d, [a], a.dtype), h = new cg(m), g = t8.runWebGLProgram(h, [n8, f], a.dtype);
    return t8.disposeIntermediateTensorInfo(f), g;
  }
  var PF = { kernelName: Ui, backendName: "webgl", kernelFunc: xee };
  function yee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s, output: a } = e8, i10 = s;
    Bs([s, a], "maxPoolGrad");
    let { filterSize: p, strides: u, pad: c, dimRoundingMode: l } = o8, m = w.computePool2DInfo(i10.shape, p, u, 1, c, l), d = true, f = new Vs(m, "max", d), h = t8.runWebGLProgram(f, [i10], i10.dtype), g = new pg(m), x = t8.runWebGLProgram(g, [n8, h], i10.dtype);
    return t8.disposeIntermediateTensorInfo(h), x;
  }
  var OF = { kernelName: Wi, backendName: "webgl", kernelFunc: yee };
  function MF(r8, e8, t8, o8) {
    let n8 = new Vs(t8, "max", false), s = o8.runWebGLProgram(n8, [r8], "float32");
    n8 = new Vs(t8, "max", true, true, e8);
    let a = o8.runWebGLProgram(n8, [r8], "float32");
    return [s, a];
  }
  var LF = { kernelName: ia, backendName: "webgl", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { x: o8 } = r8, { filterSize: n8, strides: s, pad: a, includeBatchInIndex: i10 } = e8, p = t8;
    y.assert(o8.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${o8.shape.length}.`);
    let u = [1, 1];
    y.assert(w.eitherStridesOrDilationsAreOne(s, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    let c = w.computePool2DInfo(o8.shape, n8, s, u, a), [l, m] = MF(o8, i10, c, p);
    return [l, m];
  } };
  function BF(r8, e8, t8, o8) {
    let n8 = y.sizeFromShape(e8), a = y.sizeFromShape(r8.shape) / n8, i10 = te({ inputs: { x: r8 }, attrs: { shape: [a, n8] }, backend: o8 }), p = Yr(i10, "float32", "mean", o8), u = te({ inputs: { x: p }, attrs: { shape: t8 }, backend: o8 });
    return o8.disposeIntermediateTensorInfo(i10), o8.disposeIntermediateTensorInfo(p), u;
  }
  var zF = { kernelName: Un, backendName: "webgl", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { x: o8 } = r8, { keepDims: n8, axis: s } = e8, a = t8, i10 = o8.shape.length, p = y.parseAxisParam(s, o8.shape), u = p, c = w.getAxesPermutation(u, i10), l = c != null, m = a.shouldExecuteOnCPU([o8]), d = [], f = o8;
    if (l) {
      if (m) {
        let S = a.texData.get(f.dataId).values, k = new Array(i10);
        for (let R = 0; R < k.length; R++)
          k[R] = o8.shape[c[R]];
        let _ = Sp(S, o8.shape, o8.dtype, c, k);
        f = a.makeTensorInfo(k, o8.dtype);
        let E = a.texData.get(f.dataId);
        E.values = _;
      } else
        f = Cu(o8, c, a);
      d.push(f), u = w.getInnerMostAxes(u.length, i10);
    }
    w.assertAxesAreInnerMostDims("sum", u, i10);
    let [h, g] = w.computeOutAndReduceShapes(f.shape, u), x = h;
    n8 && (x = w.expandShapeToKeepDim(h, p));
    let b = BF(f, g, x, a);
    for (let C of d)
      a.disposeIntermediateTensorInfo(C);
    return b;
  } };
  function bee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8, i10 = n8.shape.length, p = y.parseAxisParam(s, n8.shape), u = p, c = w.getAxesPermutation(u, i10), l = n8;
    c != null && (l = Ct({ inputs: { x: n8 }, backend: t8, attrs: { perm: c } }), u = w.getInnerMostAxes(u.length, n8.shape.length)), w.assertAxesAreInnerMostDims("min", u, i10);
    let [m, d] = w.computeOutAndReduceShapes(l.shape, u), f = y.sizeFromShape(d), h = te({ inputs: { x: l }, backend: t8, attrs: { shape: [-1, f] } }), g = Yr(h, h.dtype, "min", t8), x;
    if (a) {
      let b = w.expandShapeToKeepDim(m, p);
      x = te({ inputs: { x: g }, backend: t8, attrs: { shape: b } });
    } else
      x = te({ inputs: { x: g }, backend: t8, attrs: { shape: m } });
    return t8.disposeIntermediateTensorInfo(h), t8.disposeIntermediateTensorInfo(g), c != null && t8.disposeIntermediateTensorInfo(l), x;
  }
  var VF = { kernelName: Gn, backendName: "webgl", kernelFunc: bee };
  var Cee = Lc + `
  return min(a, b);
`;
  var wee = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Xr + `
  return result;
`;
  var See = nt({ opSnippet: Cee, packedOpSnippet: wee, cpuKernelImpl: UR });
  var WF = { kernelName: Hn, backendName: "webgl", kernelFunc: See };
  var lg = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.outputShape = t8.map((c, l) => c[0] + e8[l] + c[1]);
      let n8 = e8.length, s = Re(n8), a = t8.map((c) => c[0]).join(","), i10 = t8.map((c, l) => c[0] + e8[l]).join(","), p = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, n8), u = o8 === "reflect" ? 0 : 1;
      if (n8 === 1) {
        this.userCode = `
        int start = ${a};
        int end = ${i10};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;
        return;
      }
      this.userCode = `
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i10});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${n8}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${p}));
      }
    `;
    }
  };
  var mg = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t8.map((f, h) => f[0] + e8[h] + f[1]);
      let n8 = e8.length, s = Re(n8), a = t8.map((f) => f[0]).join(","), i10 = t8.map((f, h) => f[0] + e8[h]).join(","), p = Rt("rc", n8), u = Rt("source", n8), c = `${p[n8 - 1]} < ${this.outputShape[n8 - 1]}`, l = n8 === 1 ? "source" : `vec2(${u.slice(-2).join()})`, m = o8 === "reflect" ? 0 : 1, d = "";
      if (n8 === 1) {
        let f = `
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;
        d = `
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${p[n8 - 1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
      `;
      } else {
        let f = `
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;
        d = `
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${p[n8 - 1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
        rc = outputLoc;
        ${p[n8 - 2]} += 1;
        if(${p[n8 - 2]} < ${this.outputShape[n8 - 2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${l});
          ${p[n8 - 1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${l});
          }
        }
      `;
      }
      this.userCode = `
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i10});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `;
    }
  };
  var Iee = ({ inputs: r8, backend: e8, attrs: t8 }) => {
    let { x: o8 } = r8, { paddings: n8, mode: s } = t8, a = A().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new mg(o8.shape, n8, s) : new lg(o8.shape, n8, s);
    return e8.runWebGLProgram(a, [o8], o8.dtype);
  };
  var UF = { kernelName: Kn, backendName: "webgl", kernelFunc: Iee };
  var vee = `if (b == 0.0) return NAN;
  return mod(a, b);`;
  var kee = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + Xr + `
  return result;
`;
  var Nee = nt({ opSnippet: vee, packedOpSnippet: kee });
  var GF = { kernelName: qn, backendName: "webgl", kernelFunc: Nee };
  var dg = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["probs"], this.customUniforms = [{ name: "seed", type: "float" }], this.outputShape = [e8, o8], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t8 - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t8 - 1}));
      }
    `;
    }
  };
  var Tee = `
if (a == b) {
  return 1.0;
};
return a / b;`;
  var _ee = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
  var bv = nt({ opSnippet: Tee, packedOpSnippet: _ee, checkOutOfBounds: true });
  var HF = { kernelName: fn, backendName: "webgl", kernelFunc: bv };
  var KF = "return a - b;";
  var Cv = nt({ opSnippet: KF, packedOpSnippet: KF, supportsComplex: true, cpuKernelImpl: cD });
  var qF = { kernelName: Ts, backendName: "webgl", kernelFunc: Cv };
  function wv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { logits: n8 } = e8, { dim: s } = o8, a = y.parseAxisParam([s], n8.shape), i10 = yv({ inputs: { x: n8 }, backend: t8, attrs: { reductionIndices: a, keepDims: false } }), p = w.expandShapeToKeepDim(i10.shape, a), u = te({ inputs: { x: i10 }, backend: t8, attrs: { shape: p } }), c = Cv({ inputs: { a: n8, b: u }, backend: t8 }), l = hv({ inputs: { x: c }, backend: t8 }), m = Ip({ inputs: { x: l }, backend: t8, attrs: { axis: a, keepDims: false } }), d = te({ inputs: { x: m }, backend: t8, attrs: { shape: p } }), f = bv({ inputs: { a: l, b: d }, backend: t8 });
    return t8.disposeIntermediateTensorInfo(i10), t8.disposeIntermediateTensorInfo(u), t8.disposeIntermediateTensorInfo(c), t8.disposeIntermediateTensorInfo(l), t8.disposeIntermediateTensorInfo(m), t8.disposeIntermediateTensorInfo(d), f;
  }
  var jF = { kernelName: Is, backendName: "webgl", kernelFunc: wv };
  function $ee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { logits: n8 } = e8, { numSamples: s, seed: a, normalized: i10 } = o8, p = i10 ? n8 : wv({ inputs: { logits: n8 }, backend: t8, attrs: { dim: n8.shape.length - 1 } }), u = p.shape[0], c = p.shape[1], l = new dg(u, c, s), m = [[a]], d = t8.runWebGLProgram(l, [p], "int32", m);
    return i10 || t8.disposeIntermediateTensorInfo(p), d;
  }
  var XF = { kernelName: jn, backendName: "webgl", kernelFunc: $ee };
  var Eee = Ut + `
  return -x;
`;
  var Ree = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  function Dee(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (t8.shouldExecuteOnCPU([o8])) {
      let s = t8.texData.get(o8.dataId), [a, i10] = HR(s.values, o8.shape, o8.dtype);
      return t8.makeTensorInfo(i10, o8.dtype, a);
    }
    let n8;
    return A().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? n8 = new Fr(o8.shape, Ree) : n8 = new rr(o8.shape, Eee), t8.runWebGLProgram(n8, [o8], o8.dtype);
  }
  var YF = { kernelName: ua, backendName: "webgl", kernelFunc: Dee };
  var Aee = Wt.nonMaxSuppressionV3Impl;
  function Fee(r8) {
    w.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p } = o8, u = t8.readSync(n8.dataId), c = t8.readSync(s.dataId), { selectedIndices: l } = Aee(u, c, a, i10, p);
    return t8.makeTensorInfo([l.length], "int32", new Int32Array(l));
  }
  var QF = { kernelName: Qn, backendName: "webgl", kernelFunc: Fee };
  var Pee = Wt.nonMaxSuppressionV4Impl;
  function Oee(r8) {
    w.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p, padToMaxOutputSize: u } = o8, c = t8.readSync(n8.dataId), l = t8.readSync(s.dataId), { selectedIndices: m, validOutputs: d } = Pee(c, l, a, i10, p, u);
    return [t8.makeTensorInfo([m.length], "int32", new Int32Array(m)), t8.makeTensorInfo([], "int32", new Int32Array([d]))];
  }
  var ZF = { kernelName: Xa, backendName: "webgl", kernelFunc: Oee };
  var Mee = Wt.nonMaxSuppressionV5Impl;
  function Lee(r8) {
    w.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p, softNmsSigma: u } = o8, c = t8.readSync(n8.dataId), l = t8.readSync(s.dataId), m = a, d = i10, f = p, h = u, { selectedIndices: g, selectedScores: x } = Mee(c, l, m, d, f, h);
    return [t8.makeTensorInfo([g.length], "int32", new Int32Array(g)), t8.makeTensorInfo([x.length], "float32", new Float32Array(x))];
  }
  var JF = { kernelName: Zn, backendName: "webgl", kernelFunc: Lee };
  var fg = class {
    constructor(e8, t8, o8, n8) {
      this.variableNames = ["indices"], this.outputShape = [e8, t8], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${n8}), float(${o8}),
                      float(index == coords.y)));
      }
    `;
    }
  };
  var Bee = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { indices: n8 } = e8, { dtype: s, depth: a, onValue: i10, offValue: p } = o8, u = y.sizeFromShape(n8.shape), c = new fg(u, a, i10, p), l = te({ inputs: { x: n8 }, backend: t8, attrs: { shape: [u] } }), m = t8.runWebGLProgram(c, [l], s);
    t8.disposeIntermediateTensorInfo(l);
    let d = [...n8.shape, a], f = te({ inputs: { x: m }, backend: t8, attrs: { shape: d } });
    return t8.disposeIntermediateTensorInfo(m), f;
  };
  var e3 = { kernelName: Jn, backendName: "webgl", kernelFunc: Bee };
  function rm(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (o8.dtype === "complex64") {
      let n8 = bi({ inputs: { input: o8 }, backend: t8 }), s = rm({ inputs: { x: n8 }, backend: t8 }), a = kp({ inputs: { input: o8 }, backend: t8 }), i10 = rm({ inputs: { x: a }, backend: t8 }), p = Or({ inputs: { real: s, imag: i10 }, backend: t8 });
      return t8.disposeIntermediateTensorInfo(n8), t8.disposeIntermediateTensorInfo(s), t8.disposeIntermediateTensorInfo(a), t8.disposeIntermediateTensorInfo(i10), p;
    } else
      return Ci({ attrs: { shape: o8.shape, dtype: o8.dtype, value: o8.dtype === "string" ? "" : 0 }, backend: t8 });
  }
  var t3 = { kernelName: ba, backendName: "webgl", kernelFunc: rm };
  function r3(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (o8.dtype === "string")
      throw new Error("onesLike is not supported under string dtype");
    if (o8.dtype === "complex64") {
      let n8 = bi({ inputs: { input: o8 }, backend: t8 }), s = r3({ inputs: { x: n8 }, backend: t8 }), a = kp({ inputs: { input: o8 }, backend: t8 }), i10 = rm({ inputs: { x: a }, backend: t8 }), p = Or({ inputs: { real: s, imag: i10 }, backend: t8 });
      return t8.disposeIntermediateTensorInfo(n8), t8.disposeIntermediateTensorInfo(s), t8.disposeIntermediateTensorInfo(a), t8.disposeIntermediateTensorInfo(i10), p;
    } else
      return Ci({ attrs: { shape: o8.shape, dtype: o8.dtype, value: 1 }, backend: t8 });
  }
  var o3 = { kernelName: pa, backendName: "webgl", kernelFunc: r3 };
  function zee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { axis: n8 } = o8;
    if (e8.length === 1)
      return Zh({ inputs: { input: e8[0] }, backend: t8, attrs: { dim: n8 } });
    let s = e8[0].shape, a = e8[0].dtype;
    e8.forEach((c) => {
      y.assertShapesMatch(s, c.shape, "All tensors passed to stack must have matching shapes"), y.assert(a === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    let i10 = [], p = e8.map((c) => {
      let l = Zh({ inputs: { input: c }, backend: t8, attrs: { dim: n8 } });
      return i10.push(l), l;
    }), u = fv({ inputs: p, backend: t8, attrs: { axis: n8 } });
    return i10.forEach((c) => t8.disposeIntermediateTensorInfo(c)), u;
  }
  var n3 = { kernelName: ca, backendName: "webgl", kernelFunc: zee };
  var hg = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = t8.map((u, c) => u[0] + e8[c] + u[1]);
      let n8 = e8.length, s = Re(n8), a = t8.map((u) => u[0]).join(","), i10 = t8.map((u, c) => u[0] + e8[c]).join(","), p = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, n8);
      if (n8 === 1) {
        this.userCode = `
        int start = ${a};
        int end = ${i10};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
        return;
      }
      this.userCode = `
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i10});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${p}));
        }
      }
    `;
    }
  };
  var gg = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = t8.map((h, g) => h[0] + e8[g] + h[1]);
      let n8 = e8.length, s = Re(n8), a = t8.map((h) => h[0]).join(","), i10 = t8.map((h, g) => h[0] + e8[g]).join(","), p = Rt("rc", n8), u = Rt("source", n8), c = `${p[n8 - 1]} < ${this.outputShape[n8 - 1]}`, l = n8 === 1 ? "source" : `vec2(${u.slice(-2).join()})`, m = [`${s} rc = outputLoc;`, `${p[n8 - 1]} += 1;
       if(${c}) {
      `, n8 === 1 ? "" : `}
       rc = outputLoc;
       ${p[n8 - 2]} += 1;
       if(${p[n8 - 2]} < ${this.outputShape[n8 - 2]}) {`, n8 === 1 ? "" : `  ${p[n8 - 1]} += 1;
         if(${c}) {`], d = n8 === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", f = "";
      for (let h = 0, g = n8 === 1 ? 2 : 4; h < g; h++)
        f += `
        ${m[h]}
        if (${d}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${u.join()}), ${l});
        }
      `;
      f += n8 === 1 ? "} " : "}}", this.userCode = `
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i10});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `;
    }
  };
  var Sv = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { paddings: s, constantValue: a } = o8;
    if (y.sizeFromShape(n8.shape) === 0) {
      let u = s.map((c, l) => c[0] + n8.shape[l] + c[1]);
      return Ci({ backend: t8, attrs: { shape: u, value: a, dtype: n8.dtype } });
    }
    let i10 = A().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new gg(n8.shape, s, a) : new hg(n8.shape, s, a), p = [[a]];
    return t8.runWebGLProgram(i10, [n8], n8.dtype, p);
  };
  var s3 = { kernelName: es, backendName: "webgl", kernelFunc: Sv };
  var Vee = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
  var Wee = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + Xr + `
  return result;
`;
  var Uee = nt({ opSnippet: Vee, packedOpSnippet: Wee });
  var a3 = { kernelName: ts, backendName: "webgl", kernelFunc: Uee };
  function Gee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8, i10 = n8.shape.length, p = [], u = y.parseAxisParam(s, n8.shape), c = u, l = w.getAxesPermutation(c, i10), m = n8;
    l != null && (m = Ct({ inputs: { x: n8 }, backend: t8, attrs: { perm: l } }), c = w.getInnerMostAxes(c.length, i10), p.push(m)), w.assertAxesAreInnerMostDims("prod", c, i10);
    let d;
    if (t8.shouldExecuteOnCPU([m])) {
      let f = t8.texData.get(m.dataId).values, { outVals: h, outShape: g, outDtype: x } = qR(m.shape, m.dtype, f, c);
      d = t8.makeTensorInfo(g, x, h);
    } else {
      let [f, h] = w.computeOutAndReduceShapes(m.shape, c), g = y.sizeFromShape(h), x = te({ inputs: { x: m }, backend: t8, attrs: { shape: [-1, g] } }), b = ti(n8.dtype), C = Yr(x, b, "prod", t8);
      d = te({ inputs: { x: C }, backend: t8, attrs: { shape: f } }), p.push(x), p.push(C);
    }
    if (a) {
      p.push(d);
      let f = w.expandShapeToKeepDim(d.shape, u);
      d = te({ inputs: { x: d }, backend: t8, attrs: { shape: f } });
    }
    return p.forEach((f) => t8.disposeIntermediateTensorInfo(f)), d;
  }
  var i3 = { kernelName: os, backendName: "webgl", kernelFunc: Gee };
  function Hee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { paramsNestedSplits: n8, paramsDenseValues: s, indices: a } = e8, { outputRaggedRank: i10 } = o8, p = n8.map((x) => t8.readSync(x.dataId)), u = n8.map((x) => x.shape), c = t8.readSync(s.dataId), l = t8.readSync(a.dataId), [m, d, f] = jR(p, u, c, s.shape, s.dtype, l, a.shape, i10), h = m.map((x) => t8.makeTensorInfo([x.length], "int32", x)), g = t8.makeTensorInfo(f, s.dtype, d);
    return h.concat([g]);
  }
  var u3 = { kernelName: jp, backendName: "webgl", kernelFunc: Hee };
  function Kee(r8) {
    let { inputs: e8, backend: t8 } = r8, { starts: o8, limits: n8, deltas: s } = e8, a = t8.readSync(o8.dataId), i10 = t8.readSync(n8.dataId), p = t8.readSync(s.dataId), [u, c] = XR(a, o8.shape, o8.dtype, i10, n8.shape, p, s.shape), l = t8.makeTensorInfo([u.length], "int32", u), m = t8.makeTensorInfo([c.length], o8.dtype, c);
    return [l, m];
  }
  var p3 = { kernelName: Xp, backendName: "webgl", kernelFunc: Kee };
  function qee(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { shape: n8, values: s, defaultValue: a, rowPartitionTensors: i10 } = e8, { rowPartitionTypes: p } = o8, u = t8.readSync(n8.dataId), c = t8.readSync(s.dataId), l = t8.readSync(a.dataId), m = i10.map((g) => t8.readSync(g.dataId)), d = i10.map((g) => g.shape), [f, h] = YR(u, n8.shape, c, s.shape, s.dtype, l, a.shape, m, d, p);
    return t8.makeTensorInfo(f, s.dtype, h);
  }
  var c3 = { kernelName: Yp, backendName: "webgl", kernelFunc: qee };
  var Iv = (r8) => {
    let { backend: e8, attrs: t8 } = r8, { start: o8, stop: n8, step: s, dtype: a } = t8, i10 = QR(o8, n8, s, a);
    return e8.makeTensorInfo([i10.length], a, i10);
  };
  var l3 = { kernelName: la, backendName: "webgl", kernelFunc: Iv };
  var jee = "return 1.0 / x;";
  var Xee = xe({ opSnippet: jee });
  var m3 = { kernelName: ns, backendName: "webgl", kernelFunc: Xee };
  var Yee = Ut + `
  return (x < 0.0) ? 0.0 : x;
`;
  var Qee = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var Zee = xe({ opSnippet: Yee, packedOpSnippet: Qee });
  var d3 = { kernelName: ss, backendName: "webgl", kernelFunc: Zee };
  var Jee = Ut + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var ete = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var tte = xe({ opSnippet: Jee, packedOpSnippet: ete });
  var f3 = { kernelName: us, backendName: "webgl", kernelFunc: tte };
  var xg = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["A"], this.outputShape = [];
      let [a, i10, p, u] = e8;
      this.outputShape = [a, t8, o8, u];
      let c = [n8 && t8 > 1 ? i10 - 1 : i10, n8 && o8 > 1 ? p - 1 : p], l = [n8 && t8 > 1 ? t8 - 1 : t8, n8 && o8 > 1 ? o8 - 1 : o8], m;
      s ? m = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : m = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / l[0]},
          ${c[1] / l[1]});
      const vec2 inputShapeRC = vec2(${i10}.0, ${p}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
  };
  var yg = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      let [a, i10, p, u] = e8;
      this.outputShape = [a, t8, o8, u];
      let c = [n8 && t8 > 1 ? i10 - 1 : i10, n8 && o8 > 1 ? p - 1 : p], l = [n8 && t8 > 1 ? t8 - 1 : t8, n8 && o8 > 1 ? o8 - 1 : o8], m;
      s ? m = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : m = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / l[0]},
          ${c[1] / l[1]},
          ${c[1] / l[1]});
      const vec3 inputShapeRC = vec3(${i10}.0, ${p}.0,
                                     ${p}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u - 1};
        bool hasNextRow = coords.z < ${o8 - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
  };
  function rte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8 } = e8, { alignCorners: s, halfPixelCenters: a, size: i10 } = o8, [p, u] = i10, c = A().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new yg(n8.shape, p, u, s, a) : new xg(n8.shape, p, u, s, a);
    return t8.runWebGLProgram(c, [n8], "float32");
  }
  var h3 = { kernelName: is, backendName: "webgl", kernelFunc: rte };
  var bg = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t8;
      let [, n8, s] = t8, [, a, i10] = e8, p = [o8 && a > 1 ? n8 - 1 : n8, o8 && i10 > 1 ? s - 1 : s], u = [o8 && a > 1 ? a - 1 : a, o8 && i10 > 1 ? i10 - 1 : i10], c = p[0] / u[0], l = p[1] / u[1], m = 1 / c, d = 1 / l, f = Math.ceil(m) * 2 + 2, h = Math.ceil(d) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i10}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${n8 - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };
  function ote(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8, i10 = new bg(s.shape, n8.shape, a);
    return t8.runWebGLProgram(i10, [s], s.dtype);
  }
  var g3 = { kernelName: Qa, backendName: "webgl", kernelFunc: ote };
  var Cg = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["A"], this.outputShape = [];
      let [a, i10, p, u] = e8;
      this.outputShape = [a, t8, o8, u];
      let c = [n8 && t8 > 1 ? i10 - 1 : i10, n8 && o8 > 1 ? p - 1 : p], l = [n8 && t8 > 1 ? t8 - 1 : t8, n8 && o8 > 1 ? o8 - 1 : o8], m = n8 ? "0.5" : "0.0", d;
      s ? d = "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : d = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / l[0]},
          ${c[1] / l[1]});
      const vec2 inputShapeRC = vec2(${i10}.0, ${p}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
  };
  var wg = class {
    constructor(e8, t8, o8, n8, s) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      let [a, i10, p, u] = e8;
      this.outputShape = [a, t8, o8, u];
      let c = [n8 && t8 > 1 ? i10 - 1 : i10, n8 && o8 > 1 ? p - 1 : p], l = [n8 && t8 > 1 ? t8 - 1 : t8, n8 && o8 > 1 ? o8 - 1 : o8], m = n8 ? "0.5" : "0.0", d;
      s ? d = "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : d = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / l[0]},
          ${c[1] / l[1]},
          ${c[1] / l[1]});
      const vec3 inputShapeRC = vec3(${i10}.0, ${p}.0,
                                     ${p}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u - 1};
        bool hasNextRow = coords.z < ${o8 - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
  };
  function nte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8 } = e8, { alignCorners: s, halfPixelCenters: a, size: i10 } = o8, [p, u] = i10, c = A().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new wg(n8.shape, p, u, s, a) : new Cg(n8.shape, p, u, s, a);
    return t8.runWebGLProgram(c, [n8], n8.dtype);
  }
  var x3 = { kernelName: as, backendName: "webgl", kernelFunc: nte };
  var Sg = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t8;
      let [, n8, s] = t8, [, a, i10] = e8, p = [o8 && a > 1 ? n8 - 1 : n8, o8 && i10 > 1 ? s - 1 : s], u = [o8 && a > 1 ? a - 1 : a, o8 && i10 > 1 ? i10 - 1 : i10], c = p[0] / u[0], l = p[1] / u[1], m = 1 / c, d = 1 / l, f = Math.ceil(m) * 2 + 2, h = Math.ceil(d) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i10}) {
              continue;
            }

            float sourceFracRow =
              float(${p[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${p[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${n8}) - 1),
                ${o8} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${o8} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };
  function ste(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8, i10 = new Sg(s.shape, n8.shape, a);
    return t8.runWebGLProgram(i10, [s], s.dtype);
  }
  var y3 = { kernelName: Ya, backendName: "webgl", kernelFunc: ste };
  var Ig = class {
    constructor(e8, t8) {
      this.variableNames = ["x"];
      let o8 = e8.length;
      if (o8 > 4)
        throw new Error(`WebGL backend: Reverse of rank-${o8} tensor is not yet supported`);
      if (this.outputShape = e8, o8 === 1) {
        this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e8[0]} - coord - 1));
        }
      `;
        return;
      }
      let n8 = (i10) => t8.indexOf(i10) !== -1 && e8[i10] !== 1 ? `${e8[i10]} - coords[${i10}] - 1` : `coords[${i10}]`, s = e8.map((i10, p) => n8(p)).join(","), a = Re(o8);
      this.userCode = `
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `;
    }
  };
  var vg = class {
    constructor(e8, t8) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
      let o8 = e8.length;
      if (o8 > 4)
        throw new Error(`WebGL backend: Reverse of rank-${o8} tensor is not yet supported`);
      this.outputShape = e8;
      let n8 = Rt("rc", o8), s = `${n8[o8 - 1]} + 1 < ${this.outputShape[o8 - 1]}`, a = `${n8[o8 - 2]} + 1 < ${this.outputShape[o8 - 2]}`, i10 = Re(o8);
      o8 === 1 ? this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e8[0]} - rc - 1),
            ${e8[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e8[0]} - (rc  + 1) - 1),
                ${e8[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : this.userCode = `
        void main() {
          ${i10} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${p(n8.slice())};
          if(${s}){
            result.g = ${u(n8.slice())};
          }
          if(${a}) {
            result.b = ${c(n8.slice())};
            if(${s}) {
              result.a = ${l(n8.slice())};
            }
          }
          setOutput(result);
        }
    `;
      function p(f) {
        return m(f);
      }
      function u(f) {
        return f[o8 - 1] = "(" + f[o8 - 1] + " + 1)", m(f);
      }
      function c(f) {
        return f[o8 - 2] = "(" + f[o8 - 2] + " + 1)", m(f);
      }
      function l(f) {
        return f[o8 - 1] = "(" + f[o8 - 1] + " + 1)", f[o8 - 2] = "(" + f[o8 - 2] + " + 1)", m(f);
      }
      function m(f) {
        let h = e8.map((b, C) => d(C, f)), g = h.join(","), x = h.slice(-2).join(",");
        return `getChannel(getX(${g}), vec2(${x}))`;
      }
      function d(f, h) {
        return t8.indexOf(f) !== -1 && e8[f] !== 1 ? `${e8[f]} - ${h[f]} - 1` : `${h[f]}`;
      }
    }
  };
  function ate(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { dims: s } = o8, a = n8.shape.length, i10 = y.parseAxisParam(s, n8.shape);
    if (a === 0)
      return Dt({ inputs: { x: n8 }, backend: t8 });
    let p = A().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new vg(n8.shape, i10) : new Ig(n8.shape, i10);
    return t8.runWebGLProgram(p, [n8], n8.dtype);
  }
  var b3 = { kernelName: ps, backendName: "webgl", kernelFunc: ate };
  var kg = class {
    constructor(e8, t8) {
      this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{ name: "params", type: "vec4" }];
      let o8 = e8[1], n8 = e8[2];
      this.outputShape = e8;
      let s = "";
      typeof t8 == "number" ? s = `float outputValue = ${t8.toFixed(2)};` : s = `
        vec3 fill = vec3(${t8.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${n8} && coordY >= 0 && coordY < ${o8}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };
  var C3 = { kernelName: Ds, backendName: "webgl", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { image: o8 } = r8, { radians: n8, fillValue: s, center: a } = e8, i10 = t8, p = new kg(o8.shape, s), [u, c] = w.getImageCenter(a, o8.shape[1], o8.shape[2]), l = [[u, c, Math.sin(n8), Math.cos(n8)]];
    return i10.runWebGLProgram(p, [o8], o8.dtype, l);
  } };
  var ite = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
  var ute = xe({ opSnippet: ite });
  var w3 = { kernelName: cs, backendName: "webgl", kernelFunc: ute };
  var pte = "return inversesqrt(x);";
  var cte = xe({ opSnippet: pte, cpuKernelImpl: ZR });
  var S3 = { kernelName: ls, backendName: "webgl", kernelFunc: cte };
  var Su = class {
    constructor(e8, t8, o8, n8, s, a, i10 = true, p = false) {
      this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
      let u = Re(s.length), c = Re(a.length), l = "";
      o8 === 1 ? l = "i" : o8 === 2 && (l = "i, j");
      let m = `getIndices(${l})`, d = "";
      n8 === 1 ? d = "i" : n8 === 2 && (d = "i, coords[1]");
      let f = `getUpdates(${d})`, h = "";
      p && (h = "coords[0], coords[1]");
      let g = `getDefaultValue(${h})`, x = t8 > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e8}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t8}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `;
    }
  };
  var Ng = class {
    constructor(e8, t8, o8, n8, s, a, i10 = true, p = false) {
      this.variableNames = ["updates", "indices", "defaultValue"], this.packedInputs = true, this.packedOutput = true, this.outputShape = a;
      let u = Re(s.length), c = Re(a.length), l = "";
      o8 === 1 ? l = "i" : o8 === 2 && (l = "i, j");
      let m = `getIndices(${l})`, d = "";
      n8 === 1 ? d = "i" : n8 === 2 && (d = "i, coords[1]");
      let f = `getUpdates(${d})`, h = "";
      p && (h = "coords[0], coords[1]");
      let g = `getDefaultValue(${h})`, x = t8 > 1 ? "strides[j]" : "strides", b = t8 > 1 ? "strides[j + 1]" : "strides";
      this.userCode = `
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e8}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t8}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t8}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `;
    }
  };
  function lte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { indices: n8, updates: s } = e8, { shape: a } = o8, { sliceRank: i10, numUpdates: p, sliceSize: u, strides: c, outputSize: l } = w.calculateShapes(s, n8, a), m = [l / u, u];
    if (l === 0)
      return t8.makeTensorInfo(a, n8.dtype);
    let d = te({ inputs: { x: n8 }, backend: t8, attrs: { shape: [p, i10] } }), f = te({ inputs: { x: s }, backend: t8, attrs: { shape: [p, u] } }), h = t8.makeTensorInfo([], "float32", new Float32Array([0])), g;
    A().getBool("WEBGL_PACK") ? g = new Ng(p, i10, d.shape.length, f.shape.length, c, m) : g = new Su(p, i10, d.shape.length, f.shape.length, c, m);
    let x = t8.runWebGLProgram(g, [f, d, h], f.dtype), b = te({ inputs: { x }, backend: t8, attrs: { shape: a } });
    return t8.disposeIntermediateTensorInfo(d), t8.disposeIntermediateTensorInfo(f), t8.disposeIntermediateTensorInfo(x), t8.disposeIntermediateTensorInfo(h), b;
  }
  var I3 = { kernelName: ms, backendName: "webgl", kernelFunc: lte };
  var Tg = class {
    constructor(e8, t8, o8, n8) {
      this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{ name: "numInputs", type: "int" }], this.outputShape = [e8, o8];
      let s = "while (left < right) {", a = `for (int i = 0; i < ${Math.ceil(Math.log2(t8 + 1))}; ++i) { if (left >= right) break;`, i10 = A().getNumber("WEBGL_VERSION") === 2 ? s : a, p = n8 === "left" ? "<" : "<=";
      this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i10}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${p} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
    }
  };
  function mte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { sortedSequence: n8, values: s } = e8, { side: a } = o8, i10 = new Tg(n8.shape[0], n8.shape[1], s.shape[1], a), p = [[n8.shape[1]]];
    return t8.runWebGLProgram(i10, [n8, s], "int32", p);
  }
  var v3 = { kernelName: fs, backendName: "webgl", kernelFunc: mte };
  var _g = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["c", "a", "b"], this.outputShape = t8;
      let n8, s;
      if (o8 > 4)
        throw Error(`Where for rank ${o8} is not yet supported`);
      if (o8 === 1)
        s = "resRC", n8 = "resRC";
      else {
        let i10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], p = [], u = [];
        for (let c = 0; c < t8.length; c++)
          u.push(`${i10[c]}`), c < e8 && p.push(`${i10[c]}`);
        n8 = p.join(), s = u.join();
      }
      let a = Re(o8);
      this.userCode = `
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${n8});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `;
    }
  };
  function dte(r8) {
    let { inputs: e8, backend: t8 } = r8, { condition: o8, t: n8, e: s } = e8, a = new _g(o8.shape.length, n8.shape, n8.shape.length);
    return t8.runWebGLProgram(a, [o8, n8, s], dt(n8.dtype, s.dtype));
  }
  var k3 = { kernelName: da, backendName: "webgl", kernelFunc: dte };
  var fte = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${w.SELU_SCALEALPHA};
  float scale = ${w.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
  var hte = xe({ opSnippet: fte });
  var N3 = { kernelName: hs, backendName: "webgl", kernelFunc: hte };
  var gte = Fo + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`;
  var xte = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var yte = xe({ opSnippet: gte, packedOpSnippet: xte, cpuKernelImpl: eD });
  var T3 = { kernelName: bs, backendName: "webgl", kernelFunc: yte };
  var bte = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
  var Cte = xe({ opSnippet: bte });
  var _3 = { kernelName: ys, backendName: "webgl", kernelFunc: Cte };
  var wte = Fo + `
  return sin(x);
`;
  var Ste = `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Xr}
  return result;
`;
  var Ite = xe({ opSnippet: wte, packedOpSnippet: Ste });
  var $3 = { kernelName: gs, backendName: "webgl", kernelFunc: Ite };
  var vte = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
  var kte = xe({ opSnippet: vte });
  var E3 = { kernelName: xs, backendName: "webgl", kernelFunc: kte };
  var Nte = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
  var Tte = xe({ opSnippet: Nte });
  var R3 = { kernelName: Cs, backendName: "webgl", kernelFunc: Tte };
  var _te = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, paddings: a } = o8;
    y.assert(n8.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    let i10 = s.reduce((x, b) => x * b), p = [[0, 0]];
    p.push(...a);
    for (let x = 1 + s.length; x < n8.shape.length; ++x)
      p.push([0, 0]);
    let u = [], c = Sv({ inputs: { x: n8 }, backend: t8, attrs: { paddings: p, constantValue: 0 } }), l = w.getReshaped(c.shape, s, i10, false), m = w.getPermuted(l.length, s.length, false), d = w.getReshapedPermuted(c.shape, s, i10, false), f = te({ inputs: { x: c }, backend: t8, attrs: { shape: l } }), h = Ct({ inputs: { x: f }, backend: t8, attrs: { perm: m } }), g = te({ inputs: { x: h }, backend: t8, attrs: { shape: d } });
    return u.push(c), u.push(f), u.push(h), u.forEach((x) => t8.disposeIntermediateTensorInfo(x)), g;
  };
  var D3 = { kernelName: ha, backendName: "webgl", kernelFunc: _te };
  function $te(r8) {
    let { inputs: e8, backend: t8 } = r8, { indices: o8, values: n8, denseShape: s, defaultValue: a } = e8;
    if (s.shape.length !== 1)
      throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);
    if (o8.shape.length !== 2)
      throw new Error(`Indices must be a matrix, saw:
         ${o8.shape}`);
    if (n8.shape.length !== 1)
      throw new Error(`Values must be a vector, saw:
         ${n8.shape}`);
    if (a.shape.length !== 0)
      throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);
    let i10 = t8.readSync(o8.dataId), p = t8.readSync(n8.dataId), u = t8.readSync(s.dataId), c = t8.readSync(a.dataId)[0], [l, m, d, f, h] = rD(i10, o8.shape, o8.dtype, p, n8.dtype, u, c);
    return [t8.makeTensorInfo(m, o8.dtype, l), t8.makeTensorInfo([m[0]], n8.dtype, d), t8.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((g) => Number(g)))), t8.makeTensorInfo([h.length], o8.dtype, new Int32Array(h))];
  }
  var A3 = { kernelName: Hi, backendName: "webgl", kernelFunc: $te };
  function Ete(r8) {
    let { inputs: e8, backend: t8 } = r8, { inputIndices: o8, inputShape: n8, newShape: s } = e8;
    if (o8.shape.length !== 2)
      throw new Error(`Input indices should be a matrix but received shape ${o8.shape}`);
    if (n8.shape.length !== 1)
      throw new Error(`Input shape should be a vector but received shape ${n8.shape}`);
    if (s.shape.length !== 1)
      throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
    let a = Array.from(t8.readSync(n8.dataId)), i10 = t8.readSync(o8.dataId), p = Array.from(t8.readSync(s.dataId)), [u, c, l] = oD(i10, o8.shape, o8.dtype, a, p);
    return [t8.makeTensorInfo(c, o8.dtype, u), t8.makeTensorInfo([l.length], s.dtype, new Int32Array(l))];
  }
  var F3 = { kernelName: Za, backendName: "webgl", kernelFunc: Ete };
  function Rte(r8) {
    let { inputs: e8, backend: t8 } = r8, { data: o8, indices: n8, segmentIds: s } = e8;
    if (o8.shape.length < 1)
      throw new Error("Data should be at least 1 dimensional but received scalar");
    if (n8.shape.length !== 1)
      throw new Error(`Indices should be a vector but received shape
              ${n8.shape}`);
    if (s.shape.length !== 1)
      throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);
    let a = t8.readSync(o8.dataId), i10 = t8.readSync(n8.dataId), p = t8.readSync(s.dataId), [u, c] = ph(a, o8.shape, o8.dtype, i10, p, true);
    return t8.makeTensorInfo(c, o8.dtype, u);
  }
  var P3 = { kernelName: Ki, backendName: "webgl", kernelFunc: Rte };
  function Dte(r8) {
    let { inputs: e8, backend: t8 } = r8, { data: o8, indices: n8, segmentIds: s } = e8;
    if (o8.shape.length < 1)
      throw new Error("Data should be at least 1 dimensional but received scalar");
    if (n8.shape.length !== 1)
      throw new Error(`Indices should be a vector but received shape
             ${n8.shape}`);
    if (s.shape.length !== 1)
      throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);
    let a = t8.readSync(o8.dataId), i10 = t8.readSync(n8.dataId), p = t8.readSync(s.dataId), [u, c] = ph(a, o8.shape, o8.dtype, i10, p);
    return t8.makeTensorInfo(c, o8.dtype, u);
  }
  var O3 = { kernelName: qi, backendName: "webgl", kernelFunc: Dte };
  function Ate(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { sparseIndices: n8, sparseValues: s, defaultValue: a } = e8, { outputShape: i10 } = o8, { sliceRank: p, numUpdates: u, sliceSize: c, strides: l, outputSize: m } = w.calculateShapes(s, n8, i10), d = false;
    if (s.dtype === "string") {
      let x = t8.bufferSync(n8), b = t8.bufferSync(s), C = y.decodeString(t8.readSync(a.dataId)[0]), S = JR(x, b, i10, m, c, u, p, l, C, d);
      return t8.makeTensorInfo(i10, S.dtype, S.values);
    }
    let f = new Su(u, p, n8.shape.length, s.shape.length, l, [m, 1], d), h = t8.runWebGLProgram(f, [s, n8, a], s.dtype), g = te({ inputs: { x: h }, backend: t8, attrs: { shape: i10 } });
    return t8.disposeIntermediateTensorInfo(h), g;
  }
  var M3 = { kernelName: vs, backendName: "webgl", kernelFunc: Ate };
  function Fte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { numOrSizeSplits: s, axis: a } = o8, i10 = y.parseAxisParam(a, n8.shape)[0], p = w.prepareSplitSize(n8, s, i10), u = n8.shape.length, c = new Array(u).fill(0), l = n8.shape.slice();
    return p.map((m) => {
      let d = [...l];
      d[i10] = m;
      let f = Ws({ inputs: { x: n8 }, backend: t8, attrs: { begin: c, size: d } });
      return c[i10] += m, f;
    });
  }
  var L3 = { kernelName: ga, backendName: "webgl", kernelFunc: Fte };
  var B3 = "return sqrt(x);";
  var Pte = xe({ opSnippet: B3, packedOpSnippet: B3, cpuKernelImpl: nD });
  var z3 = { kernelName: ws, backendName: "webgl", kernelFunc: Pte };
  var Ote = "return x * x;";
  var Mte = xe({ opSnippet: Ote });
  var V3 = { kernelName: ji, backendName: "webgl", kernelFunc: Mte };
  var W3 = "return (a - b) * (a - b);";
  var Lte = nt({ opSnippet: W3, packedOpSnippet: W3 });
  var U3 = { kernelName: ks, backendName: "webgl", kernelFunc: Lte };
  function Bte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8;
    if (n8.dtype !== "string")
      throw new Error("Input must be of datatype string");
    let s = t8.readSync(n8.dataId), a = w.fromUint8ToStringArray(s), i10 = sD(a, "string", o8);
    return t8.makeTensorInfo(n8.shape, "string", i10);
  }
  var G3 = { kernelName: Du, backendName: "webgl", kernelFunc: Bte };
  function zte({ inputs: r8, attrs: e8, backend: t8 }) {
    let { x: o8 } = r8, n8 = Ut + `
    return x > 0.0 ? 1.0 : float(${e8.alpha});
  `, s = new rr(o8.shape, n8);
    return t8.runWebGLProgram(s, [o8], o8.dtype);
  }
  var H3 = { kernelName: wo, backendName: "webgl", kernelFunc: zte };
  var $g = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.outputShape = o8;
      let n8 = o8.length, s = Re(o8.length), a = Re(o8.length), i10 = "";
      if (n8 === 1)
        i10 = "coords * strides + begin";
      else {
        let p = 0;
        i10 = o8.map((u, c) => (p++, o8.length === 1 ? `coords * strides[${c}] + begin[${c}]` : `coords[${p - 1}] * strides[${c}] + begin[${c}]`)).join(",");
      }
      this.userCode = `
      ${s} begin = ${s}(${e8});
      ${s} strides = ${s}(${t8});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i10}));
      }
    `;
    }
  };
  function Vte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { begin: s, end: a, strides: i10, beginMask: p, endMask: u, ellipsisMask: c, newAxisMask: l, shrinkAxisMask: m } = o8, { finalShapeSparse: d, finalShape: f, isIdentity: h, sliceDim0: g, isSimpleSlice: x, begin: b, end: C, strides: S } = ct.sliceInfo(n8.shape, s, a, i10, p, u, c, l, m), k;
    if (h)
      k = te({ inputs: { x: n8 }, backend: t8, attrs: { shape: f } });
    else if (g || x) {
      y.assert(n8.shape.length >= 1, () => `Input must have rank at least 1, got: ${n8.shape.length}`);
      let E = ct.computeOutShape(b, C, S), R = Ws({ inputs: { x: n8 }, backend: t8, attrs: { begin: b, size: E } });
      k = te({ inputs: { x: R }, backend: t8, attrs: { shape: f } }), t8.disposeIntermediateTensorInfo(R);
    } else if (t8.shouldExecuteOnCPU([n8])) {
      let R = t8.readSync(n8.dataId), D = me(n8.shape, n8.dtype, R), P = aD(d, D, S, b);
      k = t8.makeTensorInfo(f, n8.dtype, P.values);
    } else {
      let R = new $g(b, S, d);
      k = t8.runWebGLProgram(R, [n8], n8.dtype);
    }
    let _ = te({ inputs: { x: k }, backend: t8, attrs: { shape: f } });
    return t8.disposeIntermediateTensorInfo(k), _;
  }
  var K3 = { kernelName: Ns, backendName: "webgl", kernelFunc: Vte };
  function Wte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { separator: n8, nGramWidths: s, leftPad: a, rightPad: i10, padWidth: p, preserveShortSequences: u } = o8, { data: c, dataSplits: l } = e8, m = t8.readSync(c.dataId), d = t8.readSync(l.dataId), [f, h] = iD(m, d, n8, s, a, i10, p, u);
    return [t8.makeTensorInfo([f.length], "string", f), t8.makeTensorInfo(l.shape, "int32", h)];
  }
  var q3 = { kernelName: xa, backendName: "webgl", kernelFunc: Wte };
  function Ute(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { skipEmpty: n8 } = o8, { input: s, delimiter: a } = e8;
    if (s.dtype !== "string")
      throw new Error("Input must be of datatype string");
    if (s.shape.length !== 1)
      throw new Error(`Input must be a vector, got shape: ${s.shape}`);
    if (a.shape.length !== 0)
      throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);
    let i10 = t8.readSync(s.dataId), p = t8.readSync(a.dataId)[0], [u, c, l] = uD(i10, p, n8), m = c.length;
    return [t8.makeTensorInfo([m, 2], "int32", u), t8.makeTensorInfo([m], "string", c), t8.makeTensorInfo([2], "int32", new Int32Array(l))];
  }
  var j3 = { kernelName: Xi, backendName: "webgl", kernelFunc: Ute };
  function Gte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { numBuckets: n8 } = o8, { input: s } = e8;
    if (s.dtype !== "string")
      throw new Error("Input must be of datatype string");
    if (n8 <= 0)
      throw new Error("Number of buckets must be at least 1");
    let a = t8.readSync(s.dataId), i10 = pD(a, n8);
    return t8.makeTensorInfo(s.shape, "int32", i10);
  }
  var X3 = { kernelName: Yi, backendName: "webgl", kernelFunc: Gte };
  var Hte = "return tan(x);";
  var Kte = xe({ opSnippet: Hte });
  var Y3 = { kernelName: _s, backendName: "webgl", kernelFunc: Kte };
  var qte = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
  var jte = xe({ opSnippet: qte });
  var Q3 = { kernelName: $s, backendName: "webgl", kernelFunc: jte };
  function Xte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { tensor: n8, indices: s, updates: a } = e8, { sliceRank: i10, numUpdates: p, sliceSize: u, strides: c, outputSize: l } = w.calculateShapes(a, s, n8.shape), m = [l / u, u];
    if (l === 0)
      return t8.makeTensorInfo(n8.shape, s.dtype);
    let d = te({ inputs: { x: s }, backend: t8, attrs: { shape: [p, i10] } }), f = te({ inputs: { x: a }, backend: t8, attrs: { shape: [p, u] } }), h = te({ inputs: { x: n8 }, backend: t8, attrs: { shape: m } }), g = new Su(p, i10, d.shape.length, f.shape.length, c, m, false, true), x = t8.runWebGLProgram(g, [f, d, h], h.dtype), b = te({ inputs: { x }, backend: t8, attrs: { shape: n8.shape } });
    return t8.disposeIntermediateTensorInfo(d), t8.disposeIntermediateTensorInfo(f), t8.disposeIntermediateTensorInfo(h), t8.disposeIntermediateTensorInfo(x), b;
  }
  var Z3 = { kernelName: ds, backendName: "webgl", kernelFunc: Xte };
  var Eg = class {
    constructor(e8, t8) {
      this.variableNames = ["A"];
      let o8 = new Array(e8.length);
      for (let a = 0; a < o8.length; a++)
        o8[a] = e8[a] * t8[a];
      this.outputShape = o8, this.rank = o8.length;
      let n8 = Re(this.rank), s = Yte(e8);
      this.userCode = `
      void main() {
        ${n8} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `;
    }
  };
  function Yte(r8) {
    let e8 = r8.length;
    if (e8 > 5)
      throw Error(`Tile for rank ${e8} is not yet supported`);
    if (e8 === 1)
      return `imod(resRC, ${r8[0]})`;
    let t8 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], o8 = [];
    for (let n8 = 0; n8 < r8.length; n8++)
      o8.push(`imod(${t8[n8]}, ${r8[n8]})`);
    return o8.join();
  }
  function vv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { reps: s } = o8;
    if (n8.dtype === "string" || n8.shape.length > 5) {
      let p = t8.readSync(n8.dataId), u = n8.dtype === "string" ? p.map((m) => y.decodeString(m)) : p, c = me(n8.shape, n8.dtype, u), l = lD(c, s);
      return t8.makeTensorInfo(l.shape, l.dtype, l.values);
    }
    let a = new Eg(n8.shape, s);
    return t8.runWebGLProgram(a, [n8], n8.dtype);
  }
  var J3 = { kernelName: uo, backendName: "webgl", kernelFunc: vv };
  var Rg = class {
    constructor(e8) {
      this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "negativeInf", type: "float" }, { name: "dir", type: "int" }, { name: "inc", type: "int" }], this.outputShape = e8, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
  };
  var Dg = class {
    constructor(e8) {
      this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "k", type: "int" }], this.outputShape = e8, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
  };
  function Tp(r8, e8) {
    e8 !== null && r8.disposeIntermediateTensorInfo(e8);
  }
  function eP(r8) {
    let e8 = 1;
    for (; e8 < r8; )
      e8 *= 2;
    return e8;
  }
  function Qte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { k: s, sorted: a } = o8, i10 = A().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), p = A().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), u = n8.shape, c = u[u.length - 1];
    if (t8.shouldExecuteOnCPU([n8]) || c < i10 || s > p) {
      let P = t8.readSync(n8.dataId), [O, M] = mD(P, u, n8.dtype, s, a);
      return [t8.makeTensorInfo(O.shape, O.dtype, O.values), t8.makeTensorInfo(M.shape, M.dtype, M.values)];
    }
    if (s === 0)
      return u[u.length - 1] = 0, [t8.makeTensorInfo(u, n8.dtype, []), t8.makeTensorInfo(u, "int32", [])];
    if (c === 1)
      return [n8, Ci({ attrs: { shape: u, dtype: "int32", value: 0 }, backend: t8 })];
    let l = t8.texData.get(n8.dataId), m = l !== null && l.isPacked, d = m ? t8.unpackTensor(n8) : n8, h = y.sizeFromShape(u) / c, g = te({ inputs: { x: d }, attrs: { shape: [h, c] }, backend: t8 });
    m && Tp(t8, d);
    let x = eP(s), b = eP(c), C = null, S = () => C === null ? [g, g] : [g, C], k = (P, O, M) => {
      let L = S(), B = new Rg(M), U = [[c], [C === null ? 1 : 0], [Number.NEGATIVE_INFINITY], [P], [O]], j = C;
      C = t8.runWebGLProgram(B, L, "int32", U), Tp(t8, j);
    };
    for (let P = 1; P < x; P *= 2) {
      let O = P * 2;
      for (let M = P; M >= 1; M /= 2)
        k(O, M, [h, b]);
    }
    for (let P = b; P > x; P /= 2) {
      let O = S(), M = new Dg([h, P / 2]), B = [[c], [C === null ? 1 : 0], [x]], z = C;
      C = t8.runWebGLProgram(M, O, "int32", B), Tp(t8, z);
      let U = x / 2, j = U * 2;
      for (let q = U; q >= 1; q /= 2)
        k(j, q, C.shape);
    }
    let _ = C;
    C = Ws({ inputs: { x: C }, backend: t8, attrs: { begin: 0, size: [h, s] } }), Tp(t8, _);
    let E = xv({ inputs: { x: g, indices: C }, backend: t8, attrs: { axis: 1, batchDims: 1 } });
    Tp(t8, g);
    let R = u.slice(0, -1);
    R.push(s), _ = C, C = te({ inputs: { x: C }, attrs: { shape: R }, backend: t8 }), Tp(t8, _);
    let D = E;
    return E = te({ inputs: { x: E }, attrs: { shape: R }, backend: t8 }), Tp(t8, D), [E, C];
  }
  var tP = { kernelName: Es, backendName: "webgl", kernelFunc: Qte };
  var Ag = class {
    constructor(e8, t8, o8, n8, s, a) {
      this.variableNames = ["Image", "Transforms"], this.outputShape = a;
      let i10 = o8 === "nearest" ? 1 : 2, p;
      switch (n8) {
        case "constant":
          p = 1;
          break;
        case "reflect":
          p = 2;
          break;
        case "wrap":
          p = 3;
          break;
        case "nearest":
          p = 4;
          break;
        default:
          p = 1;
          break;
      }
      this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${p} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${p} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${p} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e8} && 0 <= coordX && coordX < ${t8}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t8}));
                float mapY = mapCoord(inY, float(${e8}));

                if (${i10} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
  };
  function Zte(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { image: n8, transforms: s } = e8, { interpolation: a, fillMode: i10, fillValue: p, outputShape: u } = o8, [c, l, m, d] = n8.shape, [f, h] = u != null ? u : [l, m], g = [c, f, h, d], x = new Ag(l, m, a, i10, p, g);
    return t8.runWebGLProgram(x, [n8, s], "float32");
  }
  var rP = { kernelName: Rs, backendName: "webgl", kernelFunc: Zte };
  function Jte(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { axis: n8 } = t8, { x: s } = e8;
    Bs(s, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    let a = o8.readSync(s.dataId), { outputValues: i10, outputShape: p, indices: u } = dD(a, n8, s.shape, s.dtype);
    return [o8.makeTensorInfo(p, s.dtype, i10), o8.makeTensorInfo([u.length], "int32", u)];
  }
  var oP = { kernelName: Qi, backendName: "webgl", kernelFunc: Jte };
  function ere(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { value: n8 } = e8, { axis: s } = o8;
    s < 0 && (s += n8.shape.length);
    let a = n8, i10 = a.shape.length, p = n8.shape[s], u = new Array(i10 - 1), c = 0;
    for (let h = 0; h < i10; h++)
      h !== s && (u[c++] = a.shape[h]);
    let l = [], m = new Array(i10).fill(0), d = a.shape.slice();
    d[s] = 1;
    let f = new Array(p);
    for (let h = 0; h < f.length; h++) {
      m[s] = h;
      let g = Ws({ inputs: { x: a }, backend: t8, attrs: { begin: m, size: d } }), x = te({ inputs: { x: g }, backend: t8, attrs: { shape: u } });
      f[h] = x, l.push(g);
    }
    return l.forEach((h) => t8.disposeIntermediateTensorInfo(h)), f;
  }
  var nP = { kernelName: ya, backendName: "webgl", kernelFunc: ere };
  var Fg = class {
    constructor(e8, t8) {
      this.variableNames = ["x", "segmentIds"];
      let o8 = e8.windowSize, n8 = e8.batchSize, s = e8.inSize, a = e8.numSegments, i10 = a * Math.ceil(s / o8);
      this.outputShape = [n8, i10];
      let p = "0.0", u = "sumValue", c = Math.floor(o8 / 4) * 4, l = o8 % 4, m = `
        sumValue += dot(values, segFilter);
    `, d = "";
      s % o8 > 0 && (d = `
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);
      let f = "";
      s % o8 > 0 && (f = `
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = ${p};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${o8}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${l === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${l === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${l === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${u});
      }
    `;
    }
  };
  function tre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, segmentIds: s } = e8, { numSegments: a } = o8, i10 = n8.shape.length, p = [], u = 0, c = w.getAxesPermutation([u], i10), l = n8;
    c != null && (l = Ct({ inputs: { x: n8 }, backend: t8, attrs: { perm: c } }), p.push(l), u = w.getInnerMostAxes(1, i10)[0]);
    let m = w.segment_util.computeOutShape(l.shape, u, a), d = y.sizeFromShape([l.shape[u]]), f = te({ inputs: { x: l }, backend: t8, attrs: { shape: [-1, d] } });
    p.push(f);
    let h = ti(n8.dtype), g = (S, k, _, E, R) => {
      let D = S.shape[0], P = S.shape[1], O = w.segment_util.segOpComputeOptimalWindowSize(P, R), M = { windowSize: O, inSize: P, batchSize: D, numSegments: R }, L = new Fg(M, k), B = t8.compileAndRun(L, [S, _], E);
      if (p.push(B), B.shape[1] === R)
        return B;
      let z = Iv({ backend: t8, attrs: { start: 0, stop: R, step: 1, dtype: "float32" } }), U = vv({ inputs: { x: z }, backend: t8, attrs: { reps: [P / O] } });
      return p.push(z), p.push(U), g(B, k, U, E, R);
    }, x = g(f, "unsortedSegmentSum", s, h, a), b = te({ inputs: { x }, backend: t8, attrs: { shape: m } }), C = b;
    if (c != null) {
      p.push(b);
      let S = w.getUndoAxesPermutation(c);
      C = Ct({ inputs: { x: C }, backend: t8, attrs: { perm: S } });
    }
    return p.forEach((S) => t8.disposeIntermediateTensorInfo(S)), C;
  }
  var sP = { kernelName: Zi, backendName: "webgl", kernelFunc: tre };
  var rre = [VD, UD, GD, HD, qD, jD, XD, YD, JD, eA, tA, rA, oA, nA, sA, aA, iA, uA, pA, cA, lA, dA, fA, hA, gA, CA, SA, IA, RD, kA, TA, _A, $A, EA, RA, DA, AA, FA, PA, OA, BA, zA, VA, WA, UA, GA, HA, KA, qA, jA, XA, YA, QA, ZA, JA, eF, rF, oF, nF, sF, iF, uF, pF, cF, lF, mF, dF, fF, hF, ED, gF, NA, xF, yF, bF, DD, CF, wF, SF, IF, vF, kF, NF, TF, _F, $F, RF, DF, AF, FF, PF, OF, LF, zF, VF, WF, UF, GF, XF, PD, YF, QF, ZF, JF, xA, e3, o3, n3, s3, a3, AD, i3, u3, p3, c3, l3, yA, HF, m3, d3, f3, MD, h3, g3, x3, y3, b3, C3, w3, S3, I3, v3, k3, N3, T3, _3, $3, E3, mA, jF, R3, D3, A3, F3, P3, O3, M3, L3, z3, V3, U3, G3, H3, K3, q3, j3, X3, qF, BD, Y3, Q3, Z3, J3, tP, rP, zD, oP, nP, sP, t3];
  for (let r8 of rre)
    Ja(r8);
  var we;
  (function(r8) {
    r8[r8.float32 = 0] = "float32", r8[r8.int32 = 1] = "int32", r8[r8.bool = 2] = "bool", r8[r8.string = 3] = "string", r8[r8.complex64 = 4] = "complex64";
  })(we || (we = {}));
  var Iu;
  (function(r8) {
    r8[r8.linear = 0] = "linear", r8[r8.relu = 1] = "relu", r8[r8.relu6 = 2] = "relu6", r8[r8.prelu = 3] = "prelu", r8[r8.leakyrelu = 4] = "leakyrelu", r8[r8.sigmoid = 5] = "sigmoid", r8[r8.elu = 6] = "elu";
  })(Iu || (Iu = {}));
  var aP;
  function ore(r8) {
    aP = r8.wasm.cwrap(So, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function nre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s, bias: a, preluActivationWeights: i10 } = e8;
    if (n8.dtype !== "float32" || s.dtype !== "float32")
      throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");
    let { transposeA: p, transposeB: u, activation: c, leakyreluAlpha: l } = o8, m = t8.dataIdMap.get(n8.dataId).id, d = t8.dataIdMap.get(s.dataId).id, f = 0;
    if (a != null) {
      let R = t8.dataIdMap.get(a.dataId);
      if (R.shape.length !== 1)
        throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${R.shape.length}.`);
      f = R.id;
    }
    let h = i10 == null ? 0 : t8.dataIdMap.get(i10.dataId).id, g = Iu[c];
    if (g == null)
      throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);
    let x = p ? n8.shape[2] : n8.shape[1], b = u ? s.shape[1] : s.shape[2], C = Ir.assertAndGetBroadcastShape(n8.shape.slice(0, -2), s.shape.slice(0, -2)), S = t8.makeOutput([...C, x, b], n8.dtype), k = t8.dataIdMap.get(S.dataId).id, _ = new Uint8Array(new Int32Array(n8.shape).buffer), E = new Uint8Array(new Int32Array(s.shape).buffer);
    return aP(m, _, n8.shape.length, d, E, s.shape.length, p, u, g, f, h, l || 0, k), S;
  }
  var iP = { kernelName: So, backendName: "wasm", setupFunc: ore, kernelFunc: nre };
  function he(r8, e8) {
    let t8;
    function o8(s) {
      t8 = s.wasm.cwrap(r8, null, ["number", "number", "number"]);
    }
    function n8(s) {
      let { backend: a, inputs: { x: i10 } } = s, p = a.dataIdMap.get(i10.dataId).id, u = a.makeOutput(i10.shape, e8 || i10.dtype), c = a.dataIdMap.get(u.dataId).id;
      return y.sizeFromShape(u.shape) === 0 || t8(p, we[i10.dtype], c), u;
    }
    return { kernelName: r8, backendName: "wasm", setupFunc: o8, kernelFunc: n8 };
  }
  var uP = he(js);
  var pP = he(Vo);
  var cP = he(Wo);
  function We(r8, e8, t8) {
    let o8;
    function n8(a) {
      o8 = a.wasm.cwrap(r8, null, ["number", "array", "number", "number", "array", "number", "number", "number"]);
    }
    function s(a) {
      let { backend: i10, inputs: p } = a, { a: u, b: c } = p, l = i10.dataIdMap.get(u.dataId).id, m = i10.dataIdMap.get(c.dataId).id, d = t8 != null ? t8 : u.dtype, f = w.assertAndGetBroadcastShape(u.shape, c.shape), h = i10.makeOutput(f, d);
      if (y.sizeFromShape(f) === 0)
        return h;
      let g = new Uint8Array(new Int32Array(u.shape).buffer), x = new Uint8Array(new Int32Array(c.shape).buffer), b = i10.dataIdMap.get(h.dataId).id;
      return (() => o8(l, g, u.shape.length, m, x, c.shape.length, we[u.dtype], b))(), h;
    }
    return { kernelName: r8, backendName: "wasm", setupFunc: n8, kernelFunc: s };
  }
  var lP = We(io);
  var mP;
  function are(r8) {
    mP = r8.wasm.cwrap(Uo, null, ["array", "number", "number", "number"]);
  }
  function ire(r8) {
    let { inputs: e8, backend: t8 } = r8, o8 = t8.makeOutput(e8[0].shape, e8[0].dtype);
    if (y.sizeFromShape(o8.shape) === 0)
      return o8;
    let n8 = e8.map((i10) => t8.dataIdMap.get(i10.dataId).id), s = new Uint8Array(new Int32Array(n8).buffer), a = t8.dataIdMap.get(o8.dataId).id;
    return mP(s, n8.length, we[o8.dtype], a), o8;
  }
  var dP = { kernelName: Uo, backendName: "wasm", setupFunc: are, kernelFunc: ire };
  function _p(r8) {
    let { inputs: { x: e8 }, backend: t8 } = r8;
    if (e8.dtype === "string")
      return ir(t8.readSync(e8.dataId), e8.shape, e8.dtype);
    let o8 = t8.makeOutput(e8.shape, e8.dtype), n8 = t8.typedArrayFromHeap(e8);
    return t8.typedArrayFromHeap(o8).set(n8), o8;
  }
  var fP = { kernelName: Co, backendName: "wasm", kernelFunc: _p };
  var hP;
  function ure(r8) {
    hP = r8.wasm.cwrap(po, null, ["number", "array", "number", "number", "number", "array", "number"]);
  }
  function ho(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, [n8, s] = cre(e8.x.shape, o8.perm), a = true;
    for (let f = 0; f < s.length; f++)
      s[f] !== f && (a = false);
    let i10 = pre(e8.x.shape, o8.perm), p = { dataId: e8.x.dataId, shape: n8, dtype: e8.x.dtype };
    if (a) {
      let f = _p({ inputs: e8, backend: t8 });
      return f.shape = i10, f;
    }
    let u = t8.makeOutput(i10, p.dtype), c = t8.dataIdMap.get(p.dataId).id, l = t8.dataIdMap.get(u.dataId).id, m = new Uint8Array(new Int32Array(s).buffer), d = new Uint8Array(new Int32Array(p.shape).buffer);
    return hP(c, d, p.shape.length, we[p.dtype], l, m, s.length), u;
  }
  function pre(r8, e8) {
    let t8 = new Array(r8.length);
    for (let o8 = 0; o8 < t8.length; o8++)
      t8[o8] = r8[e8[o8]];
    return t8;
  }
  function cre(r8, e8) {
    let t8 = [], o8 = [];
    for (let n8 = 0; n8 < r8.length; ++n8)
      r8[n8] !== 1 && t8.push(r8[n8]), r8[e8[n8]] !== 1 && o8.push(e8[n8]);
    for (let n8 = 0; n8 < o8.length; ++n8) {
      let s = -1;
      for (let a = 0; a < o8.length; ++a)
        o8[a] >= n8 && (s === -1 || o8[s] > o8[a]) && (s = a);
      o8[s] = n8;
    }
    return [t8, o8];
  }
  var gP = { kernelName: po, backendName: "wasm", kernelFunc: ho, setupFunc: ure };
  function _r(r8, e8, t8) {
    let o8 = r8.shape, n8 = r8.shape.length, s = y.parseAxisParam(e8, o8), a = s, i10 = w.getAxesPermutation(a, n8), p = null, u = false;
    if (i10 != null) {
      let c = new Array(n8);
      for (let d = 0; d < c.length; d++)
        c[d] = o8[i10[d]];
      a = w.getInnerMostAxes(a.length, n8), p = ho({ inputs: { x: r8 }, attrs: { perm: i10 }, backend: t8 });
      let l = t8.dataIdMap.get(r8.dataId).id;
      t8.dataIdMap.get(p.dataId).id !== l && (u = true);
    }
    return { transposed: p, originalAxes: s, axes: a, inputWasTransposed: u };
  }
  var xP;
  function lre(r8) {
    xP = r8.wasm.cwrap(Go, null, ["number, number, number"]);
  }
  function mre(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { axis: n8, keepDims: s } = o8, { x: a } = t8, p = e8.dataIdMap.get(a.dataId).id, u = a, { transposed: c, axes: l, originalAxes: m, inputWasTransposed: d } = _r(a, n8, e8);
    if (d) {
      let C = e8.dataIdMap.get(c.dataId).id;
      u = c, p = C;
    }
    let f = u.shape.length;
    w.assertAxesAreInnerMostDims("all", l, f);
    let [h, g] = w.computeOutAndReduceShapes(u.shape, l), x = y.sizeFromShape(g), b = e8.makeOutput(h, a.dtype);
    if (y.sizeFromShape(u.shape) !== 0) {
      let C = e8.dataIdMap.get(b.dataId).id;
      xP(p, x, C);
    }
    if (d && e8.disposeData(c.dataId), s) {
      let C = w.expandShapeToKeepDim(b.shape, m);
      b.shape = C;
    }
    return b;
  }
  var yP = { kernelName: Go, backendName: "wasm", setupFunc: lre, kernelFunc: mre };
  var bP;
  function dre(r8) {
    bP = r8.wasm.cwrap(Ho, null, ["number, number, number"]);
  }
  function fre(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { axis: n8, keepDims: s } = o8, { x: a } = t8, p = e8.dataIdMap.get(a.dataId).id, u = a, { transposed: c, axes: l, originalAxes: m, inputWasTransposed: d } = _r(a, n8, e8);
    if (d) {
      let C = e8.dataIdMap.get(c.dataId).id;
      u = c, p = C;
    }
    let f = u.shape.length;
    w.assertAxesAreInnerMostDims("any", l, f);
    let [h, g] = w.computeOutAndReduceShapes(u.shape, l), x = y.sizeFromShape(g), b = e8.makeOutput(h, a.dtype);
    if (y.sizeFromShape(u.shape) !== 0) {
      let C = e8.dataIdMap.get(b.dataId).id;
      bP(p, x, C);
    }
    if (d && e8.disposeData(c.dataId), s) {
      let C = w.expandShapeToKeepDim(b.shape, m);
      b.shape = C;
    }
    return b;
  }
  var CP = { kernelName: Ho, backendName: "wasm", setupFunc: dre, kernelFunc: fre };
  function Pg(r8) {
    let e8;
    function t8(n8) {
      e8 = n8.wasm.cwrap(r8, null, ["number", "number", "number", "number", "number"]);
    }
    function o8(n8) {
      let { backend: s, inputs: a, attrs: i10 } = n8, { axis: p } = i10, { x: u } = a, c = s.dataIdMap.get(u.dataId).id, l = c, m = u, { transposed: d, axes: f, inputWasTransposed: h } = _r(u, p, s);
      if (h) {
        let k = s.dataIdMap.get(d.dataId).id;
        k !== c && (m = d, l = k);
      }
      let g = m.shape.slice(0, -1), x = s.makeOutput(g, "int32"), b = s.dataIdMap.get(x.dataId).id, C = y.sizeFromShape(x.shape), S = m.shape[f[0]];
      return e8(l, we[m.dtype], C, S, b), h && s.disposeData(d.dataId), x;
    }
    return { kernelName: r8, backendName: "wasm", setupFunc: t8, kernelFunc: o8 };
  }
  var wP = Pg(Xs);
  var SP = Pg(Ys);
  var IP = he(Ko);
  var vP = he(qo);
  var kP = he(jo);
  var NP = We(Yo);
  var TP = he(Xo);
  var _P;
  function hre(r8) {
    _P = r8.wasm.cwrap(Qo, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function gre(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, n8 = e8.x, s = o8.dataIdMap.get(n8.dataId).id, { filterSize: a, strides: i10, pad: p, dimRoundingMode: u } = t8, c = w.computePool2DInfo(n8.shape, a, i10, 1, p, u), l = c.filterHeight, m = c.filterWidth, d = c.padInfo.top, f = c.padInfo.right, h = c.padInfo.bottom, g = c.padInfo.left, x = c.strideHeight, b = c.strideWidth, C = c.inChannels;
    if (c.dataFormat !== "channelsLast")
      throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);
    if (c.dilationWidth !== 1 || c.dilationHeight !== 1)
      throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);
    let S = o8.makeOutput(c.outShape, "float32"), k = o8.dataIdMap.get(S.dataId).id;
    return _P(s, n8.shape[0], n8.shape[1], n8.shape[2], l, m, d, f, h, g, x, b, C, k), S;
  }
  var $P = { kernelName: Qo, backendName: "wasm", setupFunc: hre, kernelFunc: gre };
  var EP;
  function xre(r8) {
    EP = r8.wasm.cwrap("AvgPool3D", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function yre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dimRoundingMode: p, dataFormat: u } = o8, c = w.computePool3DInfo(n8.shape, s, a, 1, i10, p, u), l = t8.makeOutput(c.outShape, n8.dtype);
    return EP(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(l.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left), l;
  }
  var RP = { kernelName: Qs, backendName: "wasm", setupFunc: xre, kernelFunc: yre };
  var DP;
  function bre(r8) {
    DP = r8.wasm.cwrap("AvgPool3DGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Cre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, { filterSize: a, strides: i10, pad: p, dimRoundingMode: u } = o8, c = w.computePool3DInfo(s.shape, a, i10, 1, p, u), l = t8.makeOutput(s.shape, s.dtype);
    return DP(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(l.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left, c.filterDepth, c.filterHeight, c.filterWidth), l;
  }
  var AP = { kernelName: Ei, backendName: "wasm", setupFunc: bre, kernelFunc: Cre };
  var FP;
  function wre(r8) {
    FP = r8.wasm.cwrap("AvgPoolGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Sre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, { filterSize: a, strides: i10, pad: p } = o8, u = w.computePool2DInfo(s.shape, a, i10, 1, p), c = t8.makeOutput(s.shape, s.dtype);
    return FP(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(c.dataId).id, u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.top, u.padInfo.left, u.filterHeight, u.filterWidth), c;
  }
  var PP = { kernelName: $i, backendName: "wasm", setupFunc: wre, kernelFunc: Sre };
  function zt(r8) {
    let { inputs: e8, attrs: t8 } = r8, { x: o8 } = e8, { shape: n8 } = t8, s = y.sizeFromShape(o8.shape), a = y.inferFromImplicitShape(n8, s);
    return y.assert(s === y.sizeFromShape(a), () => `new shape: ${a}, old shape: ${o8.shape}. New shape and old shape must have the same number of elements.`), r8.backend.incRef(o8.dataId), { dataId: o8.dataId, shape: a, dtype: o8.dtype };
  }
  var OP = { kernelName: ma, backendName: "wasm", kernelFunc: zt };
  var MP;
  function Ire(r8) {
    MP = r8.wasm.cwrap(Zo, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number"]);
  }
  function vre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s } = e8, { transposeA: a, transposeB: i10 } = o8;
    if (n8.dtype !== "float32" || s.dtype !== "float32")
      throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");
    let p = n8.shape.length, u = s.shape.length, c = a ? n8.shape[p - 2] : n8.shape[p - 1], l = i10 ? s.shape[u - 1] : s.shape[u - 2], m = a ? n8.shape[p - 1] : n8.shape[p - 2], d = i10 ? s.shape[u - 2] : s.shape[u - 1], f = n8.shape.slice(0, -2), h = s.shape.slice(0, -2), g = y.sizeFromShape(f), x = y.sizeFromShape(h), C = Ir.assertAndGetBroadcastShape(n8.shape.slice(0, -2), s.shape.slice(0, -2)).concat([m, d]);
    y.assert(c === l, () => `Error in matMul: inner shapes (${c}) and (${l}) of Tensors with shapes ${n8.shape} and ${s.shape} and transposeA=${a} and transposeB=${i10} must match.`);
    let S = a ? [g, c, m] : [g, m, c], k = i10 ? [x, d, l] : [x, l, d], _ = zt({ inputs: { x: n8 }, backend: t8, attrs: { shape: S } }), E = zt({ inputs: { x: s }, backend: t8, attrs: { shape: k } }), R = t8.dataIdMap.get(_.dataId).id, D = t8.dataIdMap.get(E.dataId).id, P = a ? _.shape[2] : _.shape[1], O = i10 ? E.shape[1] : E.shape[2], M = Math.max(g, x), L = t8.makeOutput([M, P, O], _.dtype), B = t8.dataIdMap.get(L.dataId).id, z = new Uint8Array(new Int32Array(_.shape).buffer), U = new Uint8Array(new Int32Array(E.shape).buffer);
    return MP(R, z, _.shape.length, D, U, E.shape.length, a, i10, B), t8.disposeData(_.dataId), t8.disposeData(E.dataId), L.shape = C, L;
  }
  var LP = { kernelName: Zo, backendName: "wasm", setupFunc: Ire, kernelFunc: vre };
  function Po(r8) {
    let { inputs: { x: e8 }, attrs: { begin: t8, size: o8 }, backend: n8 } = r8, [s, a] = ct.parseSliceParams(e8, t8, o8), i10 = ct.isSliceContinous(e8.shape, s, a), p = n8.readSync(e8.dataId), u = n8.makeOutput(a, e8.dtype), c = y.computeStrides(e8.shape), l = n8.dataIdMap.get(u.dataId);
    if (i10) {
      let f = ct.computeFlatOffset(s, c);
      return e8.dtype === "string" ? l.stringBytes = p.slice(f, f + y.sizeFromShape(a)) : n8.typedArrayFromHeap(u).set(p.subarray(f, f + y.sizeFromShape(a))), u;
    }
    if (e8.dtype === "string") {
      let f = lp(p, s, a, e8.shape, e8.dtype);
      return l.stringBytes = f, u;
    }
    let m = n8.typedArrayFromHeap(u), d = e8.shape.length;
    if (d === 2)
      kre(p, c[0], m, s, a);
    else if (d === 3)
      Nre(p, c[0], c[1], m, s, a);
    else if (d === 4)
      Tre(p, c[0], c[1], c[2], m, s, a);
    else {
      let f = lp(p, s, a, e8.shape, e8.dtype);
      m.set(f);
    }
    return u;
  }
  function kre(r8, e8, t8, o8, n8) {
    let s = 0, a = o8[0], i10 = o8[1], p = a + n8[0];
    for (let u = a; u < p; u++) {
      let c = u * e8 + i10;
      t8.set(r8.subarray(c, c + n8[1]), s), s += n8[1];
    }
  }
  function Nre(r8, e8, t8, o8, n8, s) {
    let a = 0, i10 = n8[0], p = n8[1], u = n8[2], c = i10 + s[0], l = p + s[1];
    for (let m = i10; m < c; m++)
      for (let d = p; d < l; d++) {
        let f = m * e8 + d * t8 + u;
        o8.set(r8.subarray(f, f + s[2]), a), a += s[2];
      }
  }
  function Tre(r8, e8, t8, o8, n8, s, a) {
    let i10 = 0, p = s[0], u = s[1], c = s[2], l = p + a[0], m = u + a[1], d = c + a[2], f = s[3];
    for (let h = p; h < l; h++)
      for (let g = u; g < m; g++)
        for (let x = c; x < d; x++) {
          let b = h * e8 + g * t8 + x * o8 + f;
          n8.set(r8.subarray(b, b + a[3]), i10), i10 += a[3];
        }
  }
  var BP = { kernelName: fa, backendName: "wasm", kernelFunc: Po };
  function _re(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, crops: a } = o8, i10 = s.reduce((x, b) => x * b), p = w.getReshaped(n8.shape, s, i10), u = w.getPermuted(p.length, s.length), c = w.getReshapedPermuted(n8.shape, s, i10), l = w.getSliceBeginCoords(a, s.length), m = w.getSliceSize(c, a, s.length), d = zt({ inputs: { x: n8 }, backend: t8, attrs: { shape: p } }), f = ho({ inputs: { x: d }, backend: t8, attrs: { perm: u } }), h = zt({ inputs: { x: f }, backend: t8, attrs: { shape: c } }), g = Po({ inputs: { x: h }, backend: t8, attrs: { begin: l, size: m } });
    return t8.disposeData(d.dataId), t8.disposeData(f.dataId), t8.disposeData(d.dataId), g;
  }
  var zP = { kernelName: Zs, backendName: "wasm", kernelFunc: _re };
  var VP;
  function $re(r8) {
    VP = r8.wasm.cwrap(Jo, null, ["number", "number", "boolean", "number", "number", "number"]);
  }
  function Ere(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { x: n8, weights: s } = t8, { size: a } = o8, i10 = s.shape.reduce((l, m) => l * m, 1) !== 0, p = n8.shape.length === 1 ? [a] : [n8.shape[0], a], u = e8.makeOutput(p, s.dtype);
    function c(l) {
      return e8.dataIdMap.get(l.dataId).id;
    }
    return VP(c(n8), a, i10, c(s), we[s.dtype], c(u)), u;
  }
  var WP = { kernelName: Jo, backendName: "wasm", setupFunc: $re, kernelFunc: Ere };
  var UP = We(Ha);
  function Dre(r8) {
    let { inputs: e8, backend: t8 } = r8, { s0: o8, s1: n8 } = e8, s = t8.typedArrayFromHeap(o8), a = t8.typedArrayFromHeap(n8), i10 = w.assertAndGetBroadcastShape(Array.from(s), Array.from(a));
    return t8.makeOutput([i10.length], "int32", void 0, new Int32Array(i10));
  }
  var GP = { kernelName: Js, backendName: "wasm", kernelFunc: Dre };
  function Mr(r8) {
    let { inputs: { x: e8 }, attrs: { dtype: t8 }, backend: o8 } = r8, n8 = o8.makeOutput(e8.shape, t8), s = o8.typedArrayFromHeap(e8);
    return o8.typedArrayFromHeap(n8).set(s), n8;
  }
  var HP = { kernelName: yo, backendName: "wasm", kernelFunc: Mr };
  var KP = he(en);
  var qP;
  function Are(r8) {
    qP = r8.wasm.cwrap(bo, null, ["number", "number", "number", "number"]);
  }
  function Fre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { clipValueMin: s, clipValueMax: a } = o8, i10 = t8.dataIdMap.get(n8.dataId).id, p = t8.makeOutput(n8.shape, n8.dtype), u = t8.dataIdMap.get(p.dataId).id;
    return qP(i10, s, a, u), p;
  }
  var jP = { kernelName: bo, backendName: "wasm", setupFunc: Are, kernelFunc: Fre };
  function kv(r8) {
    let { inputs: e8, backend: t8 } = r8, o8 = y.parseAxisParam(r8.attrs.axis, e8[0].shape)[0], n8 = e8.map((d) => d.shape);
    w.assertParamsConsistent(n8, o8);
    let s = w.computeOutShape(e8.map((d) => d.shape), o8), a = e8.filter((d) => y.sizeFromShape(d.shape) > 0);
    if (a.length === 1)
      return _p({ inputs: { x: a[0] }, backend: t8 });
    let i10 = t8.makeOutput(s, e8[0].dtype);
    if (y.sizeFromShape(s) === 0)
      return i10;
    if (a[0].dtype === "string") {
      let d = a.map((C) => {
        let k = [-1, y.sizeFromShape(C.shape.slice(o8))];
        return zt({ inputs: { x: C }, backend: t8, attrs: { shape: k } });
      }), f = d.map((C) => ({ vals: t8.readSync(C.dataId), shape: C.shape }));
      s = w.computeOutShape(d.map((C) => C.shape), 1);
      let h = d[0].shape[0] === 1, g = up(f, s, e8[0].dtype, h), x = w.computeOutShape(a.map((C) => C.shape), o8);
      i10.shape = x;
      let b = t8.dataIdMap.get(i10.dataId);
      return b.stringBytes = w.fromStringArrayToUint8(g), d.forEach((C) => t8.disposeData(C.dataId)), i10;
    }
    let p = y.sizeFromShape(a[0].shape.slice(0, o8)), u = 0, c = a.map((d) => {
      let f = y.sizeFromShape(d.shape.slice(o8));
      return u += f, f;
    }), l = a.map((d) => t8.typedArrayFromHeap(d)), m = t8.typedArrayFromHeap(i10);
    for (let d = 0; d < p; d++) {
      let f = d * u;
      for (let h = 0; h < l.length; h++) {
        let g = c[h], x = d * g, b = l[h].subarray(x, x + g);
        m.set(b, f), f += g;
      }
    }
    return i10;
  }
  var XP = { kernelName: ea, backendName: "wasm", kernelFunc: kv };
  var YP;
  function Pre(r8) {
    YP = r8.wasm.cwrap(tn, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Ore(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { x: n8, filter: s } = e8, a = o8.dataIdMap.get(n8.dataId).id, i10 = o8.dataIdMap.get(s.dataId).id, { strides: p, dilations: u, pad: c, dimRoundingMode: l, dataFormat: m } = t8, d = w.convertConv2DDataFormat(m), f = w.computeConv2DInfo(n8.shape, s.shape, p, u, c, l, false, d), h = f.filterHeight, g = f.filterWidth, x = f.padInfo.top, b = f.padInfo.right, C = f.padInfo.bottom, S = f.padInfo.left, k = f.dilationHeight, _ = f.dilationWidth, E = f.strideHeight, R = f.strideWidth, D = f.inChannels, P = f.outChannels, O = f.padInfo.type === "SAME" ? 1 : 0;
    if (f.dataFormat !== "channelsLast")
      throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);
    let M = o8.makeOutput(f.outShape, "float32"), L = o8.dataIdMap.get(M.dataId).id;
    return YP(a, n8.shape[0], n8.shape[1], n8.shape[2], i10, h, g, x, b, C, S, O, k, _, E, R, D, P, L), M;
  }
  var QP = { kernelName: tn, backendName: "wasm", setupFunc: Pre, kernelFunc: Ore };
  var ZP;
  function Mre(r8) {
    ZP = r8.wasm.cwrap(rn, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Lre(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { dy: n8, filter: s } = t8, { strides: a, pad: i10, dataFormat: p, dimRoundingMode: u, inputShape: c } = o8, l = 1, m = w.convertConv2DDataFormat(p), d = w.computeConv2DInfo(c, s.shape, a, l, i10, u, false, m), { batchSize: f, filterHeight: h, filterWidth: g, inChannels: x, inHeight: b, inWidth: C, outChannels: S, outHeight: k, outWidth: _, strideHeight: E, strideWidth: R } = d, D = h - 1 - d.padInfo.top, P = g - 1 - d.padInfo.left, O = d.dataFormat === "channelsLast", M = y.computeStrides(d.inShape), L = y.computeStrides(n8.shape), [B, z, U] = y.computeStrides(s.shape), j = M[0], q = O ? M[1] : M[2], Y = O ? M[2] : 1, J = O ? 1 : M[1], re = L[0], ne = O ? L[1] : L[2], ee = O ? L[2] : 1, oe = O ? 1 : L[1], ie = e8.makeOutput(d.inShape, "float32"), le = e8.dataIdMap.get(ie.dataId).id, be = e8.dataIdMap.get(n8.dataId).id, _e = e8.dataIdMap.get(s.dataId).id;
    return ZP(be, _e, f, h, g, b, C, x, k, _, S, E, R, D, P, B, z, U, j, q, Y, J, re, ne, ee, oe, le), ie;
  }
  var JP = { kernelName: rn, backendName: "wasm", setupFunc: Mre, kernelFunc: Lre };
  var eO;
  function Bre(r8) {
    eO = r8.wasm.cwrap(on, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function zre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p } = o8;
    if (n8.dtype !== "float32")
      throw new Error(`Tensor x must have dtype float32, got ${n8.dtype}`);
    if (s.dtype !== "float32")
      throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
    let u = w.computeConv3DInfo(n8.shape, s.shape, a, p, i10), c = t8.makeOutput(u.outShape, n8.dtype);
    return eO(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(c.dataId).id, u.batchSize, u.inDepth, u.inHeight, u.inWidth, u.inChannels, u.outDepth, u.outHeight, u.outWidth, u.outChannels, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.filterDepth, u.filterHeight, u.filterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), c;
  }
  var tO = { kernelName: on, backendName: "wasm", setupFunc: Bre, kernelFunc: zre };
  var rO;
  function Vre(r8) {
    rO = r8.wasm.cwrap(Ka, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Wre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, pad: i10, filterShape: p } = o8;
    if (n8.dtype !== "float32")
      throw new Error(`Tensor dy must have dtype float32, got ${n8.dtype}`);
    if (s.dtype !== "float32")
      throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
    let u = w.computeConv3DInfo(n8.shape, p, a, 1, i10), c = t8.makeOutput(u.filterShape, s.dtype);
    return rO(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(c.dataId).id, u.batchSize, u.inDepth, u.inHeight, u.inWidth, u.inChannels, u.outDepth, u.outHeight, u.outWidth, u.outChannels, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.filterDepth, u.filterHeight, u.filterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), c;
  }
  var oO = { kernelName: Ka, backendName: "wasm", setupFunc: Vre, kernelFunc: Wre };
  var nO;
  function Ure(r8) {
    nO = r8.wasm.cwrap(nn, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Gre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { pad: a, strides: i10, inputShape: p } = o8;
    if (n8.dtype !== "float32")
      throw new Error(`Tensor dy must have dtype float32, got ${n8.dtype}`);
    if (s.dtype !== "float32")
      throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
    let u = w.computeConv3DInfo(p, s.shape, i10, 1, a), c = t8.makeOutput(u.inShape, n8.dtype);
    return nO(t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(c.dataId).id, u.batchSize, u.inDepth, u.inHeight, u.inWidth, u.inChannels, u.outDepth, u.outHeight, u.outWidth, u.outChannels, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.filterDepth, u.filterHeight, u.filterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), c;
  }
  var sO = { kernelName: nn, backendName: "wasm", setupFunc: Ure, kernelFunc: Gre };
  var aO = he(sn);
  var iO = he(an);
  var Nv;
  (function(r8) {
    r8[r8.bilinear = 0] = "bilinear", r8[r8.nearest = 1] = "nearest";
  })(Nv || (Nv = {}));
  var uO;
  function Hre(r8) {
    uO = r8.wasm.cwrap(cn, null, ["number", "number", "number", "number", "array", "number", "number", "number", "number", "number"]);
  }
  function Kre(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { method: n8, extrapolationValue: s, cropSize: a } = o8, { image: i10, boxes: p, boxInd: u } = t8, c = p.shape[0], [l, m] = a, d = [c, l, m, i10.shape[3]], f = e8.dataIdMap.get(i10.dataId), h;
    i10.dtype !== "float32" && (h = Mr({ backend: e8, inputs: { x: i10 }, attrs: { dtype: "float32" } }), f = e8.dataIdMap.get(h.dataId));
    let g = f.id, x = e8.dataIdMap.get(p.dataId).id, b = e8.dataIdMap.get(u.dataId).id, C = e8.makeOutput(d, "float32"), S = e8.dataIdMap.get(C.dataId).id, k = new Uint8Array(new Int32Array(i10.shape).buffer);
    return uO(g, x, b, c, k, l, m, Nv[n8], s, S), h != null && e8.disposeData(h.dataId), C;
  }
  var pO = { kernelName: cn, backendName: "wasm", setupFunc: Hre, kernelFunc: Kre };
  var cO;
  function qre(r8) {
    cO = r8.wasm.cwrap(un, null, ["number", "number", "number", "number", "number", "number"]);
  }
  function jre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8, p = n8.shape.length;
    y.assert(n8.dtype === "float32" || n8.dtype === "int32", () => `cumprod does not support ${n8.dtype} tensors in the WASM backend`);
    let u = w.getAxesPermutation([s], p), c = n8;
    u !== null && (c = ho({ inputs: { x: n8 }, attrs: { perm: u }, backend: t8 }));
    let l = w.getInnerMostAxes(1, p)[0];
    w.assertAxesAreInnerMostDims("cumprod", [l], p);
    let m = t8.makeOutput(c.shape, c.dtype), d = c.shape[l], f = t8.dataIdMap.get(c.dataId).id, h = t8.dataIdMap.get(m.dataId).id;
    cO(f, a ? 1 : 0, i10 ? 1 : 0, d, h, we[n8.dtype]);
    let g = m;
    if (u !== null) {
      let x = w.getUndoAxesPermutation(u);
      g = ho({ inputs: { x: m }, attrs: { perm: x }, backend: t8 }), t8.disposeData(c.dataId), t8.disposeData(m.dataId);
    }
    return g;
  }
  var lO = { kernelName: un, backendName: "wasm", setupFunc: qre, kernelFunc: jre };
  var mO;
  function Xre(r8) {
    mO = r8.wasm.cwrap(pn, null, ["number", "number", "number", "number", "number", "number"]);
  }
  function Yre(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8, p = n8.shape.length;
    y.assert(n8.dtype === "float32" || n8.dtype === "int32", () => `cumsum does not support ${n8.dtype} tensors in the WASM backend`);
    let u = w.getAxesPermutation([s], p), c = n8;
    u !== null && (c = ho({ inputs: { x: n8 }, attrs: { perm: u }, backend: t8 }));
    let l = w.getInnerMostAxes(1, p)[0];
    w.assertAxesAreInnerMostDims("cumsum", [l], p);
    let m = t8.makeOutput(c.shape, c.dtype), d = c.shape[l], f = t8.dataIdMap.get(c.dataId).id, h = t8.dataIdMap.get(m.dataId).id;
    mO(f, a ? 1 : 0, i10 ? 1 : 0, d, h, we[n8.dtype]);
    let g = m;
    if (u !== null) {
      let x = w.getUndoAxesPermutation(u);
      g = ho({ inputs: { x: m }, attrs: { perm: x }, backend: t8 }), t8.disposeData(c.dataId), t8.disposeData(m.dataId);
    }
    return g;
  }
  var dO = { kernelName: pn, backendName: "wasm", setupFunc: Xre, kernelFunc: Yre };
  var fO;
  function Qre(r8) {
    fO = r8.wasm.cwrap("DenseBincount", null, ["number", "array", "number", "number", "boolean", "number", "number", "boolean", "number"]);
  }
  function Zre(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { x: n8, weights: s } = t8, { size: a, binaryOutput: i10 } = o8, p = s.shape.reduce((m, d) => m * d, 1) !== 0, u = n8.shape.length === 1 ? [a] : [n8.shape[0], a], c = e8.makeOutput(u, s.dtype);
    function l(m) {
      return e8.dataIdMap.get(m.dataId).id;
    }
    return fO(l(n8), new Uint8Array(new Int32Array(n8.shape).buffer), n8.shape.length, a, p, l(s), we[s.dtype], i10, l(c)), c;
  }
  var hO = { kernelName: ta, backendName: "wasm", setupFunc: Qre, kernelFunc: Zre };
  var gO;
  function Jre(r8) {
    gO = r8.wasm.cwrap(ln, null, ["number", "number", "number", "array", "number", "array", "array", "number", "number"]);
  }
  function eoe(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { x: n8 } = t8, { blockSize: s, dataFormat: a } = o8, i10 = n8.shape[0], p = a === "NHWC" ? n8.shape[1] : n8.shape[2], u = a === "NHWC" ? n8.shape[2] : n8.shape[3], c = a === "NHWC" ? n8.shape[3] : n8.shape[1], l = p * s, m = u * s, d = c / (s * s), f = a === "NHWC" ? [i10, l, m, d] : [i10, d, l, m], h = e8.makeOutput(f, "float32"), x = e8.dataIdMap.get(n8.dataId).id, b = new Uint8Array(new Int32Array(y.computeStrides(n8.shape)).buffer), C = new Uint8Array(new Int32Array(f).buffer), S = new Uint8Array(new Int32Array(y.computeStrides(f)).buffer), k = e8.dataIdMap.get(h.dataId).id;
    return gO(x, s, a === "NHWC" ? 1 : 0, b, n8.shape.length - 1, C, S, f.length, k), h;
  }
  var xO = { kernelName: ln, backendName: "wasm", setupFunc: Jre, kernelFunc: eoe };
  var yO;
  function toe(r8) {
    yO = r8.wasm.cwrap(mn, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function roe(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { x: n8, filter: s } = e8, a = o8.dataIdMap.get(n8.dataId).id, i10 = o8.dataIdMap.get(s.dataId).id, { strides: p, dilations: u, pad: c, dimRoundingMode: l } = t8, m = u == null ? [1, 1] : u, d = w.computeConv2DInfo(n8.shape, s.shape, p, m, c, l, true), f = d.filterHeight, h = d.filterWidth, g = d.padInfo.top, x = d.padInfo.right, b = d.padInfo.bottom, C = d.padInfo.left, S = d.dilationHeight, k = d.dilationWidth, _ = d.strideHeight, E = d.strideWidth, R = d.inChannels, D = d.outChannels, P = d.padInfo.type === "SAME" ? 1 : 0;
    if (d.dataFormat !== "channelsLast")
      throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);
    let O = o8.makeOutput(d.outShape, "float32"), M = o8.dataIdMap.get(O.dataId).id;
    return yO(a, n8.shape[0], n8.shape[1], n8.shape[2], i10, f, h, g, x, b, C, P, S, k, _, E, R, D, M), O;
  }
  var bO = { kernelName: mn, backendName: "wasm", setupFunc: toe, kernelFunc: roe };
  var CO;
  function ooe(r8) {
    CO = r8.wasm.cwrap("Diag", null, ["number", "number", "number", "number"]);
  }
  function noe(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8, n8 = y.sizeFromShape(o8.shape), s = t8.makeOutput([...o8.shape, ...o8.shape], o8.dtype);
    return CO(t8.dataIdMap.get(o8.dataId).id, we[o8.dtype], n8, t8.dataIdMap.get(s.dataId).id), s;
  }
  var wO = { kernelName: ra, backendName: "wasm", setupFunc: ooe, kernelFunc: noe };
  var SO;
  function soe(r8) {
    SO = r8.wasm.cwrap(dn, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function aoe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p } = o8;
    if (n8.dtype !== s.dtype)
      throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${n8.dtype} and ${s.dtype}`);
    let u = w.computeDilation2DInfo(n8.shape, s.shape, a, i10, "NHWC", p), c = t8.makeOutput(u.outShape, n8.dtype);
    return SO(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(c.dataId).id, we[n8.dtype], u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.filterHeight, u.filterWidth, u.padInfo.top, u.padInfo.left), c;
  }
  var IO = { kernelName: dn, backendName: "wasm", setupFunc: soe, kernelFunc: aoe };
  var vO;
  function ioe(r8) {
    vO = r8.wasm.cwrap(Mi, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function uoe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, dy: a } = e8, { strides: i10, pad: p, dilations: u } = o8;
    if (n8.dtype !== s.dtype || n8.dtype !== a.dtype)
      throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${n8.dtype}, ${s.dtype}, and ${a.dtype}`);
    let c = w.computeDilation2DInfo(n8.shape, s.shape, i10, p, "NHWC", u), l = t8.makeOutput(s.shape, s.dtype);
    return vO(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(a.dataId).id, t8.dataIdMap.get(l.dataId).id, we[n8.dtype], c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.filterHeight, c.filterWidth, c.padInfo.top, c.padInfo.left), l;
  }
  var kO = { kernelName: Mi, backendName: "wasm", setupFunc: ioe, kernelFunc: uoe };
  var NO;
  function poe(r8) {
    NO = r8.wasm.cwrap(Oi, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function coe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, dy: a } = e8, { strides: i10, pad: p, dilations: u } = o8;
    if (n8.dtype !== s.dtype || n8.dtype !== a.dtype)
      throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${n8.dtype}, ${s.dtype}, and ${a.dtype}`);
    let c = w.computeDilation2DInfo(n8.shape, s.shape, i10, p, "NHWC", u), l = t8.makeOutput(n8.shape, n8.dtype);
    return NO(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(a.dataId).id, t8.dataIdMap.get(l.dataId).id, we[n8.dtype], c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.filterHeight, c.filterWidth, c.padInfo.top, c.padInfo.left), l;
  }
  var TO = { kernelName: Oi, backendName: "wasm", setupFunc: poe, kernelFunc: coe };
  var _O = he(hn);
  var $O;
  function loe(r8) {
    $O = r8.wasm.cwrap(qa, null, ["number", "number", "number"]);
  }
  function moe(r8) {
    let { inputs: e8, backend: t8 } = r8, { dy: o8, y: n8 } = e8, s = t8.makeOutput(n8.shape, "float32"), a = (i10) => t8.dataIdMap.get(i10.dataId).id;
    return $O(a(n8), a(o8), a(s)), s;
  }
  var EO = { kernelName: qa, backendName: "wasm", setupFunc: loe, kernelFunc: moe };
  var doe = false;
  var RO = We(xn, doe, "bool");
  var DO = he(gn);
  var AO = he(yn, "float32");
  function Og(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { input: n8 } = e8, { dim: s } = t8, a = n8.shape.length, i10 = n8.shape.slice(), p = s;
    return s < 0 && (y.assert(-(a + 1) <= s, () => `Axis must be in the interval [${-(a + 1)}, ${a}]`), p = a + s + 1), i10.splice(p, 0, 1), zt({ inputs: { x: n8 }, backend: o8, attrs: { shape: i10 } });
  }
  var FO = { kernelName: oa, backendName: "wasm", kernelFunc: Og };
  var PO = he(bn, "float32");
  function Tv(r8) {
    let { attrs: { shape: e8, value: t8, dtype: o8 }, backend: n8 } = r8, s = n8.makeOutput(e8, o8);
    return n8.typedArrayFromHeap(s).fill(t8), s;
  }
  var OO = { kernelName: na, backendName: "wasm", kernelFunc: Tv };
  var MO;
  function foe(r8) {
    MO = r8.wasm.cwrap(Cn, null, ["number", "number", "number", "number", "number", "number"]);
  }
  function hoe(r8) {
    let { inputs: e8, backend: t8 } = r8, { image: o8 } = e8, n8 = t8.makeOutput(o8.shape, o8.dtype), s = t8.dataIdMap.get(o8.dataId).id, a = t8.dataIdMap.get(n8.dataId).id, [i10, p, u, c] = o8.shape;
    return MO(s, i10, p, u, c, a), n8;
  }
  var LO = { kernelName: Cn, backendName: "wasm", kernelFunc: hoe, setupFunc: foe };
  var BO = he(wn);
  var zO = We(Sn);
  var VO;
  function xoe(r8) {
    VO = r8.wasm.cwrap(In, null, ["number", "number", "number", "number", "number", "number", "number"]);
  }
  function yoe(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { varianceEpsilon: n8 } = o8, { x: s, mean: a, variance: i10, offset: p, scale: u } = t8, c = e8.dataIdMap.get(s.dataId).id, l = e8.dataIdMap.get(a.dataId).id, m = e8.dataIdMap.get(i10.dataId).id, d = p != null ? e8.dataIdMap.get(p.dataId).id : 0, f = u != null ? e8.dataIdMap.get(u.dataId).id : 0, h = e8.makeOutput(s.shape, s.dtype);
    if (y.sizeFromShape(s.shape) === 0)
      return h;
    let g = e8.dataIdMap.get(h.dataId).id;
    return VO(c, l, m, d, f, n8, g), h;
  }
  var WO = { kernelName: In, backendName: "wasm", setupFunc: xoe, kernelFunc: yoe };
  var UO;
  function boe(r8) {
    UO = r8.wasm.cwrap(Io, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Coe(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dilations: c, dataFormat: l, dimRoundingMode: m, activation: d, leakyreluAlpha: f } = t8, h = w.computeConv2DInfo(n8.shape, s.shape, p, c, u, m), g = Iu[d];
    if (g == null)
      throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);
    let x = o8.dataIdMap.get(n8.dataId).id, b = o8.dataIdMap.get(s.dataId).id, C = h.outChannels, S = 0;
    if (a != null) {
      let ee = o8.dataIdMap.get(a.dataId);
      if (ee.shape.length !== 1)
        throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ee.shape.length}.`);
      if (ee.shape[0] !== C)
        throw new Error(`FusedConv2D bias shape (${ee.shape}) does not match the number of output channels (${C})`);
      S = ee.id;
    }
    let k = h.filterHeight, _ = h.filterWidth, E = h.padInfo.top, R = h.padInfo.right, D = h.padInfo.bottom, P = h.padInfo.left, O = h.dilationHeight, M = h.dilationWidth, L = h.strideHeight, B = h.strideWidth, z = h.inChannels, U = h.padInfo.type === "SAME" ? 1 : 0, j = h.batchSize, q = h.inHeight, Y = h.inWidth;
    if (l !== "NHWC")
      throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${l}'. Please use 'NHWC'.`);
    let J = o8.makeOutput(h.outShape, "float32"), re = o8.dataIdMap.get(J.dataId).id, ne = i10 == null ? 0 : o8.dataIdMap.get(i10.dataId).id;
    return UO(x, j, q, Y, b, k, _, S, E, R, D, P, U, O, M, L, B, z, C, g, ne, f || 0, re), J;
  }
  var GO = { kernelName: Io, backendName: "wasm", setupFunc: boe, kernelFunc: Coe };
  var HO;
  function woe(r8) {
    HO = r8.wasm.cwrap(vo, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Soe(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dilations: c, dataFormat: l, dimRoundingMode: m, activation: d, leakyreluAlpha: f } = t8, h = w.computeConv2DInfo(n8.shape, s.shape, p, c, u, m, true), g = Iu[d];
    if (g == null)
      throw new Error(`${d} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
    let x = o8.dataIdMap.get(n8.dataId).id, b = o8.dataIdMap.get(s.dataId).id, C = h.outChannels, S = 0;
    if (a != null) {
      let ee = o8.dataIdMap.get(a.dataId);
      if (ee.shape.length !== 1)
        throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ee.shape.length}.`);
      if (ee.shape[0] !== C)
        throw new Error(`FusedDepthwiseConv2D bias shape (${ee.shape}) does not match the number of output channels (${C})`);
      S = ee.id;
    }
    let k = h.filterHeight, _ = h.filterWidth, E = h.padInfo.top, R = h.padInfo.right, D = h.padInfo.bottom, P = h.padInfo.left, O = h.dilationHeight, M = h.dilationWidth, L = h.strideHeight, B = h.strideWidth, z = h.inChannels, U = h.padInfo.type === "SAME" ? 1 : 0, j = h.batchSize, q = h.inHeight, Y = h.inWidth;
    if (l !== "NHWC")
      throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${l}'. Please use 'NHWC'.`);
    let J = o8.makeOutput(h.outShape, "float32"), re = o8.dataIdMap.get(J.dataId).id, ne = i10 == null ? 0 : o8.dataIdMap.get(i10.dataId).id;
    return HO(x, j, q, Y, b, k, _, S, E, R, D, P, U, O, M, L, B, z, C, g, ne, f || 0, re), J;
  }
  var KO = { kernelName: vo, backendName: "wasm", setupFunc: woe, kernelFunc: Soe };
  var qO;
  function Ioe(r8) {
    qO = r8.wasm.cwrap(vn, null, ["number", "number", "number", "number", "number", "number", "array", "number"]);
  }
  function voe(r8) {
    let { backend: e8, inputs: t8 } = r8, { params: o8, indices: n8 } = t8, [s, a, i10, p] = nf.prepareAndValidate(o8, n8), u = e8.makeOutput(s, o8.dtype);
    if (a === 0)
      return u;
    let c = n8.shape, l = c[c.length - 1], d = e8.dataIdMap.get(o8.dataId).id, h = e8.dataIdMap.get(n8.dataId).id, g = new Uint8Array(new Int32Array(p).buffer), x = e8.dataIdMap.get(u.dataId).id;
    return qO(d, we[o8.dtype], h, a, l, i10, g, x), u;
  }
  var jO = { kernelName: vn, backendName: "wasm", setupFunc: Ioe, kernelFunc: voe };
  var XO;
  function koe(r8) {
    XO = r8.wasm.cwrap("Gather", null, ["number", "number", "array", "number", "number", "number", "array", "number"]);
  }
  function Noe(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { x: n8, indices: s } = t8, { axis: a, batchDims: i10 } = o8, p = y.parseAxisParam(a, n8.shape)[0], u = e8.readSync(s.dataId), c = n8.shape[p];
    for (let D = 0; D < u.length; ++D) {
      let P = u[D];
      y.assert(P <= c - 1 && P >= 0, () => `GatherV2: the index value ${P} is not in [0, ${c - 1}]`);
    }
    let l = w.segment_util.collectGatherOpShapeInfo(n8, s, p, i10), m = zt({ inputs: { x: n8 }, attrs: { shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize] }, backend: e8 }), d = y.sizeFromShape(s.shape), f = zt({ inputs: { x: s }, attrs: { shape: [l.batchSize, d / l.batchSize] }, backend: e8 }), h = [l.batchSize, l.outerSize, d / l.batchSize, l.sliceSize], g = e8.makeOutput(h, n8.dtype);
    if (y.sizeFromShape(n8.shape) === 0)
      return g;
    let x = m.shape.length - 1, C = e8.dataIdMap.get(m.dataId).id, k = e8.dataIdMap.get(f.dataId).id, _ = e8.dataIdMap.get(g.dataId).id, E = new Uint8Array(new Int32Array(y.computeStrides(m.shape)).buffer), R = new Uint8Array(new Int32Array(y.computeStrides(h)).buffer);
    return XO(C, we[n8.dtype], E, x, k, l.batchSize, R, _), e8.disposeData(m.dataId), e8.disposeData(f.dataId), g.shape = l.outputShape, g;
  }
  var YO = { kernelName: sa, backendName: "wasm", setupFunc: koe, kernelFunc: Noe };
  var Toe = false;
  var QO = We(kn, Toe, "bool");
  var _oe = false;
  var ZO = We(Nn, _oe, "bool");
  var JO = he(Tn, "bool");
  var eM = he(_n, "bool");
  var tM = he($n, "bool");
  var rM;
  function $oe(r8) {
    rM = r8.wasm.cwrap(En, null, ["number", "number", "number", "number"]);
  }
  function Eoe(r8) {
    let { inputs: { x: e8 }, attrs: { alpha: t8 }, backend: o8 } = r8, n8 = o8.dataIdMap.get(e8.dataId).id, s = o8.makeOutput(e8.shape, "float32");
    if (y.sizeFromShape(e8.shape) !== 0) {
      let a = o8.dataIdMap.get(s.dataId).id;
      rM(n8, we[e8.dtype], t8, a);
    }
    return s;
  }
  var oM = { kernelName: En, backendName: "wasm", setupFunc: $oe, kernelFunc: Eoe };
  var Roe = false;
  var nM = We(Rn, Roe, "bool");
  var Doe = false;
  var sM = We(Dn, Doe, "bool");
  var aM;
  function Aoe(r8) {
    aM = r8.wasm.cwrap(An, null, ["number", "number", "number", "number"]);
  }
  function Foe(r8) {
    let { attrs: e8, backend: t8 } = r8, { start: o8, stop: n8, num: s } = e8, a = Math.floor(s), i10 = t8.makeOutput([a], "float32");
    return aM(t8.dataIdMap.get(i10.dataId).id, o8, n8, a), i10;
  }
  var iM = { kernelName: An, backendName: "wasm", setupFunc: Aoe, kernelFunc: Foe };
  var uM = he(Fn);
  var pM = he(Pn);
  var Poe = false;
  var cM = We(On, Poe, "bool");
  var lM = he(Mn);
  var Ooe = false;
  var mM = We(Ln, Ooe, "bool");
  var Moe = false;
  var dM = We(w0, Moe, "bool");
  var fM;
  function Loe(r8) {
    fM = r8.wasm.cwrap(Bn, null, ["number", "number", "number", "number", "number", "number", "number"]);
  }
  function Boe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { depthRadius: s, bias: a, alpha: i10, beta: p } = o8;
    if (n8.dtype !== "float32")
      throw new Error("LRN error: x must have dtype float32");
    let u = t8.makeOutput(n8.shape, n8.dtype);
    return fM(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(u.dataId).id, n8.shape[3], s, a, i10, p), u;
  }
  var hM = { kernelName: Bn, backendName: "wasm", setupFunc: Loe, kernelFunc: Boe };
  var gM;
  function zoe(r8) {
    gM = r8.wasm.cwrap(ja, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Voe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, y: s, dy: a } = e8, { depthRadius: i10, bias: p, alpha: u, beta: c } = o8;
    if (n8.dtype !== "float32" || s.dtype !== "float32" || a.dtype !== "float32")
      throw new Error("LRNGrad error: x, y, and dy must have dtype float32");
    let l = t8.makeOutput(n8.shape, n8.dtype);
    return gM(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(a.dataId).id, t8.dataIdMap.get(l.dataId).id, a.shape[3], i10, p, u, c), l;
  }
  var xM = { kernelName: ja, backendName: "wasm", setupFunc: zoe, kernelFunc: Voe };
  var yM;
  function Woe(r8) {
    yM = r8.wasm.cwrap(zn, null, ["number", "number", "number", "number"]);
  }
  function Uoe(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { reductionIndices: n8, keepDims: s } = o8, { x: a } = t8, p = e8.dataIdMap.get(a.dataId).id, u = a, { transposed: c, axes: l, originalAxes: m, inputWasTransposed: d } = _r(a, n8, e8);
    if (d) {
      let C = e8.dataIdMap.get(c.dataId).id;
      u = c, p = C;
    }
    let f = u.shape.length;
    w.assertAxesAreInnerMostDims("max", l, f);
    let [h, g] = w.computeOutAndReduceShapes(u.shape, l), x = y.sizeFromShape(g), b = e8.makeOutput(h, a.dtype);
    if (y.sizeFromShape(u.shape) !== 0) {
      let C = e8.dataIdMap.get(b.dataId).id;
      yM(p, we[a.dtype], x, C);
    }
    if (d && e8.disposeData(c.dataId), s) {
      let C = w.expandShapeToKeepDim(b.shape, m);
      b.shape = C;
    }
    return b;
  }
  var bM = { kernelName: zn, backendName: "wasm", setupFunc: Woe, kernelFunc: Uoe };
  var CM = We(Vn);
  var wM;
  function Hoe(r8) {
    wM = r8.wasm.cwrap(Wn, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Koe(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, n8 = e8.x, s = o8.dataIdMap.get(n8.dataId).id;
    y.assert(n8.dtype === "float32", () => `Error in MaxPool: only float32 input is supported. Got ${n8.dtype}.`);
    let { filterSize: a, strides: i10, pad: p, dimRoundingMode: u } = t8, c = w.computePool2DInfo(n8.shape, a, i10, 1, p, u), l = c.filterHeight, m = c.filterWidth, d = c.padInfo.top, f = c.padInfo.right, h = c.padInfo.bottom, g = c.padInfo.left, x = c.dilationHeight, b = c.dilationWidth, C = c.strideHeight, S = c.strideWidth, k = c.inChannels, _ = c.outChannels;
    if (c.dataFormat !== "channelsLast")
      throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);
    let E = o8.makeOutput(c.outShape, "float32"), R = o8.dataIdMap.get(E.dataId).id;
    return wM(s, n8.shape[0], n8.shape[1], n8.shape[2], l, m, d, f, h, g, x, b, C, S, k, _, R), E;
  }
  var SM = { kernelName: Wn, backendName: "wasm", setupFunc: Hoe, kernelFunc: Koe };
  var IM;
  function qoe(r8) {
    IM = r8.wasm.cwrap("MaxPool3D", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function joe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dimRoundingMode: p, dataFormat: u } = o8, c = w.computePool3DInfo(n8.shape, s, a, 1, i10, p, u), l = t8.makeOutput(c.outShape, n8.dtype);
    return IM(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(l.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left), l;
  }
  var vM = { kernelName: aa, backendName: "wasm", setupFunc: qoe, kernelFunc: joe };
  var kM;
  function Xoe(r8) {
    kM = r8.wasm.cwrap("MaxPool3DGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Yoe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, { filterSize: a, strides: i10, pad: p, dimRoundingMode: u } = o8, c = w.computePool3DInfo(s.shape, a, i10, 1, p, u), l = t8.makeOutput(s.shape, s.dtype);
    return kM(t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(l.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left), l;
  }
  var NM = { kernelName: Ui, backendName: "wasm", setupFunc: Xoe, kernelFunc: Yoe };
  var TM;
  function Qoe(r8) {
    TM = r8.wasm.cwrap("MaxPoolGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Zoe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, { filterSize: a, strides: i10, pad: p, dimRoundingMode: u } = o8, c = w.computePool2DInfo(s.shape, a, i10, 1, p, u), l = t8.makeOutput(s.shape, s.dtype);
    return TM(t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(l.dataId).id, c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.top, c.padInfo.left), l;
  }
  var _M = { kernelName: Wi, backendName: "wasm", setupFunc: Qoe, kernelFunc: Zoe };
  var $M;
  function Joe(r8) {
    $M = r8.wasm.cwrap("MaxPoolWithArgmax", null, ["number", "number", "number", "number", "boolean", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function ene(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, includeBatchInIndex: p } = o8;
    y.assert(n8.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${n8.shape.length}.`);
    let u = [1, 1];
    y.assert(w.eitherStridesOrDilationsAreOne(a, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
    let c = w.computePool2DInfo(n8.shape, s, a, [1, 1], i10), l = t8.makeOutput(c.outShape, n8.dtype), m = t8.makeOutput(c.outShape, "int32");
    return $M(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(l.dataId).id, t8.dataIdMap.get(m.dataId).id, we[n8.dtype], p, c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.top, c.padInfo.left), [l, m];
  }
  var EM = { kernelName: ia, backendName: "wasm", setupFunc: Joe, kernelFunc: ene };
  var RM;
  function tne(r8) {
    RM = r8.wasm.cwrap(Un, null, ["number, number, number"]);
  }
  function rne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { axis: n8, keepDims: s } = o8, { x: a } = t8, i10 = e8.dataIdMap.get(a.dataId).id, p = i10, u = a, { transposed: c, axes: l, originalAxes: m, inputWasTransposed: d } = _r(a, n8, e8), f = l;
    if (d) {
      let S = e8.dataIdMap.get(c.dataId).id;
      S !== i10 && (u = c, p = S, f = w.getInnerMostAxes(f.length, u.shape.length));
    }
    w.assertAxesAreInnerMostDims("mean", f, u.shape.length);
    let [h, g] = w.computeOutAndReduceShapes(u.shape, f), x = y.sizeFromShape(g), b = u;
    u.dtype !== "float32" && (b = Mr({ backend: e8, inputs: { x: u }, attrs: { dtype: "float32" } }), p = e8.dataIdMap.get(b.dataId).id);
    let C = e8.makeOutput(h, "float32");
    if (y.sizeFromShape(u.shape) !== 0) {
      let S = e8.dataIdMap.get(C.dataId).id;
      RM(p, x, S);
    }
    if (d && e8.disposeData(c.dataId), s) {
      let S = w.expandShapeToKeepDim(C.shape, m);
      C.shape = S;
    }
    return u.dtype !== "float32" && e8.disposeData(b.dataId), C;
  }
  var DM = { kernelName: Un, backendName: "wasm", setupFunc: tne, kernelFunc: rne };
  var AM;
  function one(r8) {
    AM = r8.wasm.cwrap(Gn, null, ["number", "number", "number", "number"]);
  }
  function nne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { axis: n8, keepDims: s } = o8, { x: a } = t8, i10 = e8.dataIdMap.get(a.dataId).id, p = i10, u = a, { transposed: c, axes: l, originalAxes: m, inputWasTransposed: d } = _r(a, n8, e8);
    if (d) {
      let C = e8.dataIdMap.get(c.dataId).id;
      C !== i10 && (u = c, p = C);
    }
    let f = u.shape.length;
    w.assertAxesAreInnerMostDims("min", l, f);
    let [h, g] = w.computeOutAndReduceShapes(u.shape, l), x = y.sizeFromShape(g), b = e8.makeOutput(h, u.dtype);
    if (y.sizeFromShape(u.shape) !== 0) {
      let C = e8.dataIdMap.get(b.dataId).id;
      AM(p, we[a.dtype], x, C);
    }
    if (d && e8.disposeData(c.dataId), s) {
      let C = w.expandShapeToKeepDim(b.shape, m);
      b.shape = C;
    }
    return b;
  }
  var FM = { kernelName: Gn, backendName: "wasm", setupFunc: one, kernelFunc: nne };
  var PM = We(Hn);
  var _v;
  (function(r8) {
    r8[r8.reflect = 0] = "reflect", r8[r8.symmetric = 1] = "symmetric";
  })(_v || (_v = {}));
  var OM;
  function ane(r8) {
    OM = r8.wasm.cwrap(Kn, null, ["number", "array", "number", "number", "array", "array", "number", "number"]);
  }
  function ine(r8) {
    let { inputs: { x: e8 }, backend: t8, attrs: { paddings: o8, mode: n8 } } = r8, s = o8.map((f, h) => f[0] + e8.shape[h] + f[1]), a = t8.dataIdMap.get(e8.dataId).id, i10 = t8.makeOutput(s, e8.dtype), p = t8.dataIdMap.get(i10.dataId).id, u = new Uint8Array(new Int32Array(e8.shape).buffer), c = o8.map((f) => f[0]), l = o8.map((f) => f[1]), m = new Uint8Array(new Int32Array(c).buffer), d = new Uint8Array(new Int32Array(l).buffer);
    return OM(a, u, e8.shape.length, we[e8.dtype], m, d, _v[n8], p), i10;
  }
  var MM = { kernelName: Kn, backendName: "wasm", kernelFunc: ine, setupFunc: ane };
  var LM;
  function une(r8) {
    LM = r8.wasm.cwrap(Is, null, ["number", "number", "number", "number"]);
  }
  function $v(r8) {
    let { backend: e8, inputs: { logits: t8 }, attrs: { dim: o8 } } = r8, n8 = e8.dataIdMap.get(t8.dataId).id, s = e8.makeOutput(t8.shape, t8.dtype), a = e8.dataIdMap.get(s.dataId).id, i10 = t8.shape[o8], p = y.sizeFromShape(t8.shape) / i10;
    return y.sizeFromShape(s.shape) === 0 || LM(n8, a, i10, p), s;
  }
  var BM = { kernelName: Is, backendName: "wasm", setupFunc: une, kernelFunc: $v };
  var zM;
  function pne(r8) {
    zM = r8.wasm.cwrap(jn, null, ["number", "number", "number", "number", "number", "number"]);
  }
  function cne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { logits: n8 } = e8, { numSamples: s, seed: a, normalized: i10 } = o8;
    if (n8.dtype !== "float32")
      throw new Error(`Tensor logits must have dtype float32, got ${n8.dtype}`);
    let p = i10 ? n8 : $v({ inputs: { logits: n8 }, backend: t8, attrs: { dim: n8.shape.length - 1 } }), [u, c] = p.shape, l = t8.makeOutput([u, s], "int32");
    return zM(t8.dataIdMap.get(p.dataId).id, u, c, s, a, t8.dataIdMap.get(l.dataId).id), i10 || t8.disposeData(p.dataId), l;
  }
  var VM = { kernelName: jn, backendName: "wasm", setupFunc: pne, kernelFunc: cne };
  var WM = We(qn);
  var UM = We(Xn);
  var GM = he(ua);
  function Kc(r8, e8) {
    let t8 = new Int32Array(r8.wasm.HEAPU8.buffer, e8, 4), o8 = t8[0], n8 = t8[1], s = t8[2], a = t8[3];
    return r8.wasm._free(e8), { pSelectedIndices: o8, selectedSize: n8, pSelectedScores: s, pValidOutputs: a };
  }
  var HM;
  function mne(r8) {
    HM = r8.wasm.cwrap(Qn, "number", ["number", "number", "number", "number", "number"]);
  }
  function dne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { iouThreshold: n8, maxOutputSize: s, scoreThreshold: a } = o8, { boxes: i10, scores: p } = t8, u = e8.dataIdMap.get(i10.dataId).id, c = e8.dataIdMap.get(p.dataId).id, l = HM(u, c, s, n8, a), { pSelectedIndices: m, selectedSize: d, pSelectedScores: f, pValidOutputs: h } = Kc(e8, l);
    return e8.wasm._free(f), e8.wasm._free(h), e8.makeOutput([d], "int32", m);
  }
  var KM = { kernelName: Qn, backendName: "wasm", setupFunc: mne, kernelFunc: dne };
  var qM;
  function fne(r8) {
    qM = r8.wasm.cwrap(Xa, "number", ["number", "number", "number", "number", "number", "bool"]);
  }
  function hne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { iouThreshold: n8, maxOutputSize: s, scoreThreshold: a, padToMaxOutputSize: i10 } = o8, { boxes: p, scores: u } = t8, c = e8.dataIdMap.get(p.dataId).id, l = e8.dataIdMap.get(u.dataId).id, m = qM(c, l, s, n8, a, i10), { pSelectedIndices: d, selectedSize: f, pSelectedScores: h, pValidOutputs: g } = Kc(e8, m);
    e8.wasm._free(h);
    let x = e8.makeOutput([f], "int32", d), b = e8.makeOutput([], "int32", g);
    return [x, b];
  }
  var jM = { kernelName: Xa, backendName: "wasm", setupFunc: fne, kernelFunc: hne };
  var XM;
  function gne(r8) {
    XM = r8.wasm.cwrap(Zn, "number", ["number", "number", "number", "number", "number", "number"]);
  }
  function xne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { iouThreshold: n8, maxOutputSize: s, scoreThreshold: a, softNmsSigma: i10 } = o8, { boxes: p, scores: u } = t8, c = e8.dataIdMap.get(p.dataId).id, l = e8.dataIdMap.get(u.dataId).id, m = XM(c, l, s, n8, a, i10), { pSelectedIndices: d, selectedSize: f, pSelectedScores: h, pValidOutputs: g } = Kc(e8, m);
    e8.wasm._free(g);
    let x = e8.makeOutput([f], "int32", d), b = e8.makeOutput([f], "float32", h);
    return [x, b];
  }
  var YM = { kernelName: Zn, backendName: "wasm", setupFunc: gne, kernelFunc: xne };
  var yne = false;
  var QM = We(Yn, yne, "bool");
  var ZM;
  function bne(r8) {
    ZM = r8.wasm.cwrap(Jn, null, ["number", "number", "number", "number", "number"]);
  }
  function Cne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { indices: n8 } = e8, { dtype: s, depth: a, onValue: i10, offValue: p } = o8, u = t8.makeOutput([...n8.shape, a], s), c = t8.dataIdMap.get(u.dataId).id, m = t8.dataIdMap.get(n8.dataId).id;
    return ZM(m, a, i10, p, c), u;
  }
  var JM = { kernelName: Jn, backendName: "wasm", setupFunc: bne, kernelFunc: Cne };
  function wne(r8) {
    let { inputs: { x: e8 }, backend: t8 } = r8, o8 = t8.makeOutput(e8.shape, e8.dtype);
    return t8.typedArrayFromHeap(o8).fill(1), o8;
  }
  var eL = { kernelName: pa, backendName: "wasm", kernelFunc: wne };
  function Sne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { axis: n8 } = o8;
    if (e8.length === 1)
      return Og({ inputs: { input: e8[0] }, backend: t8, attrs: { dim: n8 } });
    let s = e8[0].shape, a = e8[0].dtype;
    e8.forEach((c) => {
      y.assertShapesMatch(s, c.shape, "All tensors passed to stack must have matching shapes"), y.assert(a === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    let i10 = [], p = e8.map((c) => {
      let l = Og({ inputs: { input: c }, backend: t8, attrs: { dim: n8 } });
      return i10.push(l), l;
    }), u = kv({ inputs: p, backend: t8, attrs: { axis: n8 } });
    return i10.forEach((c) => t8.disposeData(c.dataId)), u;
  }
  var tL = { kernelName: ca, backendName: "wasm", kernelFunc: Sne };
  var rL;
  function Ine(r8) {
    rL = r8.wasm.cwrap(es, null, ["number", "array", "number", "number", "array", "array", "number", "number"]);
  }
  function vne(r8) {
    let { inputs: { x: e8 }, backend: t8, attrs: { paddings: o8, constantValue: n8 } } = r8, s = o8.map((h, g) => h[0] + e8.shape[g] + h[1]);
    if (y.sizeFromShape(e8.shape) === 0)
      return Tv({ backend: t8, attrs: { shape: s, value: n8, dtype: e8.dtype } });
    let a = t8.dataIdMap.get(e8.dataId).id, i10 = t8.makeOutput(s, e8.dtype), u = t8.dataIdMap.get(i10.dataId).id, c = new Uint8Array(new Int32Array(e8.shape).buffer), l = o8.map((h) => h[0]), m = o8.map((h) => h[1]), d = new Uint8Array(new Int32Array(l).buffer), f = new Uint8Array(new Int32Array(m).buffer);
    return rL(a, c, e8.shape.length, we[e8.dtype], d, f, n8, u), i10;
  }
  var Mg = { kernelName: es, backendName: "wasm", kernelFunc: vne, setupFunc: Ine };
  var oL = We(ts);
  var nL;
  function Nne(r8) {
    nL = r8.wasm.cwrap(rs, null, ["number", "number", "number"]);
  }
  function Tne(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8, alpha: n8 } = e8, s = t8.dataIdMap.get(o8.dataId).id, a = t8.dataIdMap.get(n8.dataId).id, i10 = s, p = o8, u = p;
    p.dtype !== "float32" && (u = Mr({ backend: t8, inputs: { x: o8 }, attrs: { dtype: "float32" } }), i10 = t8.dataIdMap.get(u.dataId).id);
    let c = t8.makeOutput(o8.shape, "float32"), l = t8.dataIdMap.get(c.dataId).id;
    return nL(i10, a, l), p.dtype !== "float32" && t8.disposeData(u.dataId), c;
  }
  var sL = { kernelName: rs, backendName: "wasm", setupFunc: Nne, kernelFunc: Tne };
  var aL;
  function _ne(r8) {
    aL = r8.wasm.cwrap(os, null, ["number", "number", "number", "number"]);
  }
  function $ne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { axis: n8, keepDims: s } = o8, { x: a } = t8, i10 = e8.dataIdMap.get(a.dataId).id, p = i10, u = a, { transposed: c, axes: l, originalAxes: m, inputWasTransposed: d } = _r(a, n8, e8), f = l;
    if (d) {
      let C = e8.dataIdMap.get(c.dataId).id;
      C !== i10 && (u = c, p = C, f = w.getInnerMostAxes(f.length, u.shape.length));
    }
    w.assertAxesAreInnerMostDims("prod", f, u.shape.length);
    let [h, g] = w.computeOutAndReduceShapes(u.shape, f), x = y.sizeFromShape(g), b = e8.makeOutput(h, u.dtype);
    if (y.sizeFromShape(u.shape) !== 0) {
      let C = e8.dataIdMap.get(b.dataId).id;
      aL(p, x, we[b.dtype], C);
    }
    if (d && e8.disposeData(c.dataId), s) {
      let C = w.expandShapeToKeepDim(b.shape, m);
      b.shape = C;
    }
    return b;
  }
  var iL = { kernelName: os, backendName: "wasm", setupFunc: _ne, kernelFunc: $ne };
  var Ene = (r8) => {
    let { backend: e8, attrs: t8 } = r8, { start: o8, stop: n8, step: s, dtype: a } = t8, i10 = cp(o8, n8, s, a), p = e8.makeOutput([i10.length], a);
    return e8.typedArrayFromHeap(p).set(i10), p;
  };
  var uL = { kernelName: la, backendName: "wasm", kernelFunc: Ene };
  var pL = We(fn);
  var cL = he(ns);
  var lL = he(ss);
  var mL = he(us);
  var dL;
  function Dne(r8) {
    dL = r8.wasm.cwrap(is, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Ane(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { images: n8 } = t8, { alignCorners: s, halfPixelCenters: a, size: i10 } = o8, [p, u] = i10, [c, l, m, d] = n8.shape, f = [c, p, u, d], h = e8.dataIdMap.get(n8.dataId), g;
    h.dtype !== "float32" && (g = Mr({ backend: e8, inputs: { x: n8 }, attrs: { dtype: "float32" } }), h = e8.dataIdMap.get(g.dataId));
    let x = h.id, b = e8.makeOutput(f, "float32");
    if (y.sizeFromShape(n8.shape) === 0)
      return b;
    let C = e8.dataIdMap.get(b.dataId).id;
    return dL(x, c, l, m, d, p, u, s ? 1 : 0, a ? 1 : 0, C), g != null && e8.disposeData(g.dataId), b;
  }
  var fL = { kernelName: is, backendName: "wasm", setupFunc: Dne, kernelFunc: Ane };
  var hL;
  function Fne(r8) {
    hL = r8.wasm.cwrap(Qa, null, ["number", "number", "number", "array", "array", "boolean"]);
  }
  function Pne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8, i10 = t8.makeOutput(n8.shape, "float32"), p = t8.dataIdMap.get(n8.dataId), u;
    return p.dtype !== "float32" && (u = Mr({ backend: t8, inputs: { x: n8 }, attrs: { dtype: "float32" } }), p = t8.dataIdMap.get(u.dataId)), hL(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(i10.dataId).id, new Uint8Array(new Int32Array(n8.shape).buffer), new Uint8Array(new Int32Array(s.shape).buffer), a), u != null && t8.disposeData(u.dataId), i10;
  }
  var gL = { kernelName: Qa, backendName: "wasm", setupFunc: Fne, kernelFunc: Pne };
  var xL;
  function One(r8) {
    xL = r8.wasm.cwrap(as, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Mne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { images: n8 } = t8, { alignCorners: s, halfPixelCenters: a, size: i10 } = o8, [p, u] = i10, [c, l, m, d] = n8.shape, f = [c, p, u, d], h = e8.makeOutput(f, "float32");
    if (y.sizeFromShape(n8.shape) === 0)
      return h;
    let g = e8.dataIdMap.get(n8.dataId), x;
    g.dtype !== "float32" && (x = Mr({ backend: e8, inputs: { x: n8 }, attrs: { dtype: "float32" } }), g = e8.dataIdMap.get(x.dataId));
    let b = g.id, C = e8.dataIdMap.get(h.dataId).id;
    return xL(b, c, l, m, d, p, u, s ? 1 : 0, a ? 1 : 0, C), x != null && e8.disposeData(x.dataId), h;
  }
  var yL = { kernelName: as, backendName: "wasm", setupFunc: One, kernelFunc: Mne };
  var bL;
  function Lne(r8) {
    bL = r8.wasm.cwrap(Ya, null, ["number", "number", "number", "array", "array", "boolean"]);
  }
  function Bne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8, i10 = t8.makeOutput(n8.shape, "float32"), p = t8.dataIdMap.get(n8.dataId), u;
    return p.dtype !== "float32" && (u = Mr({ backend: t8, inputs: { x: n8 }, attrs: { dtype: "float32" } }), p = t8.dataIdMap.get(u.dataId)), bL(t8.dataIdMap.get(n8.dataId).id, t8.dataIdMap.get(s.dataId).id, t8.dataIdMap.get(i10.dataId).id, new Uint8Array(new Int32Array(n8.shape).buffer), new Uint8Array(new Int32Array(s.shape).buffer), a), u != null && t8.disposeData(u.dataId), i10;
  }
  var CL = { kernelName: Ya, backendName: "wasm", setupFunc: Lne, kernelFunc: Bne };
  var wL;
  function zne(r8) {
    wL = r8.wasm.cwrap(ps, null, ["number", "array", "number", "array", "number", "number"]);
  }
  function Vne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { dims: s } = o8, a = y.parseAxisParam(s, n8.shape);
    if (n8.shape.length === 0)
      return _p({ inputs: { x: n8 }, backend: t8 });
    let i10 = t8.makeOutput(n8.shape, n8.dtype), p = t8.dataIdMap.get(n8.dataId).id, u = t8.dataIdMap.get(i10.dataId).id, c = new Uint8Array(new Int32Array(a).buffer), l = new Uint8Array(new Int32Array(n8.shape).buffer);
    wL(p, c, a.length, l, n8.shape.length, u);
    let m = zt({ inputs: { x: i10 }, attrs: { shape: n8.shape }, backend: t8 });
    return t8.disposeData(i10.dataId), m;
  }
  var SL = { kernelName: ps, backendName: "wasm", kernelFunc: Vne, setupFunc: zne };
  var IL;
  function Wne(r8) {
    IL = r8.wasm.cwrap(Ds, null, ["number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number"]);
  }
  function Une(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { image: n8 } = e8, { radians: s, fillValue: a, center: i10 } = o8, p = t8.makeOutput(n8.shape, n8.dtype), u = t8.dataIdMap.get(n8.dataId).id, c = t8.dataIdMap.get(p.dataId).id, [l, m, d, f] = n8.shape, [h, g] = w.getImageCenter(i10, m, d), x = a === 0, b = 255, C = typeof a == "number" ? [a, a, a, x ? 0 : b] : [...a, b], S = new Uint8Array(new Int32Array(C).buffer);
    return IL(u, l, m, d, f, s, h, g, S, C.length, c), p;
  }
  var vL = { kernelName: Ds, backendName: "wasm", kernelFunc: Une, setupFunc: Wne };
  var kL = he(cs);
  var NL = he(ls);
  var TL;
  function Gne(r8) {
    TL = r8.wasm.cwrap(ms, null, ["number", "number", "number", "number", "number", "number", "array", "number", "number"]);
  }
  function Hne(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { indices: n8, updates: s } = t8, { shape: a } = o8, i10 = e8.makeOutput(a, s.dtype);
    if (y.sizeFromShape(a) === 0)
      return i10;
    let { sliceRank: p, numUpdates: u, sliceSize: c, strides: l, outputSize: m } = du.calculateShapes(s, n8, a), f = e8.dataIdMap.get(n8.dataId).id, g = e8.dataIdMap.get(s.dataId).id, x = new Uint8Array(new Int32Array(l).buffer), b = e8.dataIdMap.get(i10.dataId).id;
    return TL(f, g, we[s.dtype], p, u, c, x, m, b), i10;
  }
  var _L = { kernelName: ms, backendName: "wasm", setupFunc: Gne, kernelFunc: Hne };
  var $L;
  function Kne(r8) {
    $L = r8.wasm.cwrap(fs, null, ["number", "number", "number", "number", "number", "number", "bool", "number"]);
  }
  function qne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { sortedSequence: n8, values: s } = e8, { side: a } = o8;
    if (n8.dtype !== s.dtype)
      throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${n8.dtype} and ${s.dtype}`);
    let i10 = t8.makeOutput(s.shape, "int32");
    function p(u) {
      return t8.dataIdMap.get(u.dataId).id;
    }
    return $L(p(n8), p(s), n8.shape[0], n8.shape[1], s.shape[1], we[n8.dtype], a === "left", p(i10)), i10;
  }
  var EL = { kernelName: fs, backendName: "wasm", setupFunc: Kne, kernelFunc: qne };
  var RL;
  function jne(r8) {
    RL = r8.wasm.cwrap("SelectV2", null, ["number", "number", "number", "number", "number"]);
  }
  function Xne(r8) {
    let { inputs: e8, backend: t8 } = r8, { condition: o8, t: n8, e: s } = e8, a = t8.dataIdMap.get(o8.dataId).id, i10 = t8.dataIdMap.get(n8.dataId).id, p = t8.dataIdMap.get(s.dataId).id, u = t8.makeOutput(n8.shape, n8.dtype), c = t8.dataIdMap.get(u.dataId).id, l = o8.shape.length, m = n8.shape.length, d = l === 0 || l > 1 || m === 1 ? 1 : y.sizeFromShape(n8.shape.slice(1));
    return RL(a, i10, p, d, c), u;
  }
  var DL = { kernelName: da, backendName: "wasm", kernelFunc: Xne, setupFunc: jne };
  var AL = he(hs);
  var FL;
  function Yne(r8) {
    FL = r8.wasm.cwrap(bs, null, ["number", "number"]);
  }
  function Qne(r8) {
    let { backend: e8, inputs: { x: t8 } } = r8, o8 = e8.dataIdMap.get(t8.dataId).id, n8 = e8.makeOutput(t8.shape, t8.dtype), s = e8.dataIdMap.get(n8.dataId).id;
    return y.sizeFromShape(n8.shape) === 0 || FL(o8, s), n8;
  }
  var PL = { kernelName: "Sigmoid", backendName: "wasm", setupFunc: Yne, kernelFunc: Qne };
  var OL = he(ys);
  var ML = he(gs);
  var LL = he(xs);
  var BL = he(Cs);
  function Zne(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, paddings: a } = o8, i10 = y.sizeFromShape(s), p = [[0, 0]];
    p.push(...a);
    for (let _ = 1 + s.length; _ < n8.shape.length; ++_)
      p.push([0, 0]);
    let u = Mg.kernelFunc({ inputs: { x: n8 }, backend: t8, attrs: { paddings: p, constantValue: 0 } }), c = w.getReshaped(u.shape, s, i10, false), l = w.getPermuted(c.length, s.length, false), m = w.getReshapedPermuted(u.shape, s, i10, false), h = zt({ inputs: { x: u }, backend: t8, attrs: { shape: c } }), b = ho({ inputs: { x: h }, backend: t8, attrs: { perm: l } }), k = zt({ inputs: { x: b }, backend: t8, attrs: { shape: m } });
    return t8.disposeData(u.dataId), t8.disposeData(h.dataId), t8.disposeData(b.dataId), k;
  }
  var zL = { kernelName: ha, backendName: "wasm", kernelFunc: Zne };
  var VL;
  function Jne(r8) {
    VL = r8.wasm.cwrap("SparseFillEmptyRows", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function ese(r8) {
    let { backend: e8, inputs: t8 } = r8, { indices: o8, values: n8, denseShape: s, defaultValue: a } = t8, i10 = o8.shape[0], p = o8.shape[1], u = e8.readSync(s.dataId)[0], c = [i10 + u, p], l = e8.dataIdMap.get(o8.dataId).id, m = e8.dataIdMap.get(n8.dataId).id, d = e8.dataIdMap.get(a.dataId).id, f = e8.makeOutput(c, o8.dtype), h = e8.dataIdMap.get(f.dataId).id, g = e8.makeOutput(c.slice(0, 1), n8.dtype), x = e8.dataIdMap.get(g.dataId).id, b = e8.makeOutput([u], "bool"), C = e8.dataIdMap.get(b.dataId).id, S = e8.makeOutput([i10], o8.dtype), k = e8.dataIdMap.get(S.dataId).id, _ = e8.makeOutput([4], "int32"), E = e8.dataIdMap.get(_.dataId).id, R = VL(l, m, we[n8.dtype], i10, u, p, d, h, x, C, k, E), D = e8.readSync(_.dataId), P;
    switch (D[0]) {
      case 1: {
        P = w.getSparseFillEmptyRowsIndicesDenseShapeMismatch(D[1]);
        break;
      }
      case 2: {
        P = w.getSparseFillEmptyRowsNegativeIndexErrorMessage(D[1], D[2]);
        break;
      }
      case 3:
        P = w.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(D[1], D[2], D[3]);
        break;
      default:
        P = "";
    }
    if (e8.disposeData(_.dataId), P)
      throw e8.disposeData(f.dataId), e8.disposeData(g.dataId), e8.disposeData(b.dataId), e8.disposeData(S.dataId), new Error(P);
    let O = f, M = g;
    return R !== c[0] && (O = Po({ inputs: { x: f }, attrs: { begin: 0, size: [R, p] }, backend: e8 }), M = Po({ inputs: { x: g }, attrs: { begin: 0, size: R }, backend: e8 }), e8.disposeData(f.dataId), e8.disposeData(g.dataId)), [O, M, b, S];
  }
  var WL = { kernelName: Hi, backendName: "wasm", setupFunc: Jne, kernelFunc: ese };
  var UL;
  function tse(r8) {
    UL = r8.wasm.cwrap(Za, null, ["number", "number", "number", "number", "number", "number", "number"]);
  }
  function rse(r8) {
    let { backend: e8, inputs: t8 } = r8, { inputIndices: o8, inputShape: n8, newShape: s } = t8;
    if (o8.shape.length !== 2)
      throw new Error(`Input indices should be a matrix but received shape
        ${o8.shape}`);
    if (n8.shape.length !== 1)
      throw new Error(`Input shape should be a vector but received shape
        ${n8.shape}`);
    if (s.shape.length !== 1)
      throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
    let a = e8.dataIdMap.get(o8.dataId).id, i10 = e8.dataIdMap.get(n8.dataId).id, p = e8.dataIdMap.get(s.dataId).id, u = o8.shape[0], c = y.sizeFromShape(s.shape), l = e8.makeOutput([u, c], o8.dtype), m = e8.dataIdMap.get(l.dataId).id, d = e8.makeOutput([c], s.dtype), f = e8.dataIdMap.get(d.dataId).id, h = e8.makeOutput([3], "int32"), g = e8.dataIdMap.get(h.dataId).id;
    UL(a, i10, p, u, m, f, g);
    let x = e8.readSync(h.dataId), b;
    switch (x[0]) {
      case 0: {
        b = w.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(x[1], x[2]);
        break;
      }
      case 1: {
        b = w.getSparseReshapeNegativeOutputDimErrorMessage(x[1], x[2]);
        break;
      }
      case 2:
        b = w.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
        break;
      case 3: {
        let C = Array.from(e8.readSync(n8.dataId)), S = Array.from(e8.readSync(d.dataId));
        b = w.getSparseReshapeInputOutputMultipleErrorMessage(C, S);
        break;
      }
      case 4: {
        let C = Array.from(e8.readSync(n8.dataId)), S = Array.from(e8.readSync(d.dataId));
        b = w.getSparseReshapeInputOutputMismatchErrorMessage(C, S);
        break;
      }
      default:
        b = "";
    }
    if (e8.disposeData(h.dataId), b)
      throw e8.disposeData(l.dataId), e8.disposeData(d.dataId), new Error(b);
    return [l, d];
  }
  var GL = { kernelName: Za, backendName: "wasm", setupFunc: tse, kernelFunc: rse };
  var HL;
  function Lg(r8) {
    HL = r8.wasm.cwrap("SparseSegmentReduction", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number"]);
  }
  function Bg(r8, e8) {
    let { backend: t8, inputs: o8 } = r8, { data: n8, indices: s, segmentIds: a } = o8, i10 = s.shape[0], p = t8.readSync(a.dataId, i10 - 1, i10)[0], c = i10 > 0 ? p + 1 : 0;
    if (c < 0)
      throw new Error(w.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let l = n8.shape.slice();
    l[0] = c;
    let m = t8.dataIdMap.get(n8.dataId).id, d = t8.dataIdMap.get(s.dataId).id, f = t8.dataIdMap.get(a.dataId).id, h = t8.makeOutput(l, n8.dtype), g = t8.dataIdMap.get(h.dataId).id, x = t8.makeOutput([4], "int32"), b = t8.dataIdMap.get(x.dataId).id;
    HL(m, we[n8.dtype], n8.shape[0], d, f, g, b, e8, 0);
    let C = t8.readSync(x.dataId), S;
    switch (C[0]) {
      case 0: {
        S = w.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
        break;
      }
      case 1: {
        S = w.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
        break;
      }
      case 2:
        S = w.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(C[1], C[2]);
        break;
      case 3:
        S = w.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(C[1], C[2], C[3]);
        break;
      default:
        S = "";
    }
    if (t8.disposeData(x.dataId), S)
      throw t8.disposeData(h.dataId), new Error(S);
    return h;
  }
  function ose(r8) {
    return Bg(r8, true);
  }
  var KL = { kernelName: Ki, backendName: "wasm", setupFunc: Lg, kernelFunc: ose };
  function nse(r8) {
    return Bg(r8, false);
  }
  var qL = { kernelName: qi, backendName: "wasm", setupFunc: Lg, kernelFunc: nse };
  var jL;
  function sse(r8) {
    jL = r8.wasm.cwrap(vs, null, ["number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number"]);
  }
  function ase(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { sparseIndices: n8, sparseValues: s, defaultValue: a } = t8, { outputShape: i10 } = o8, p = e8.makeOutput(i10, a.dtype);
    if (y.sizeFromShape(i10) === 0)
      return p;
    let { sliceRank: u, numUpdates: c, sliceSize: l, strides: m, outputSize: d } = w.calculateShapes(s, n8, i10), f = e8.dataIdMap.get(n8.dataId).id, h = e8.dataIdMap.get(s.dataId).id, g = e8.dataIdMap.get(a.dataId).id, x = new Uint8Array(new Int32Array(m).buffer), b = e8.dataIdMap.get(p.dataId).id;
    return jL(f, h, s.shape.length, g, we[a.dtype], u, c, l, x, d, b), p;
  }
  var XL = { kernelName: vs, backendName: "wasm", setupFunc: sse, kernelFunc: ase };
  function ise(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { x: n8 } = e8, { numOrSizeSplits: s, axis: a } = t8, i10 = y.parseAxisParam(a, n8.shape)[0], p = w.prepareSplitSize(n8, s, i10), u = new Array(n8.shape.length).fill(0), c = n8.shape.slice();
    return p.map((l) => {
      let m = [...c];
      m[i10] = l;
      let d = Po({ inputs: { x: n8 }, attrs: { begin: u, size: m }, backend: o8 });
      return u[i10] += l, d;
    });
  }
  var YL = { kernelName: ga, backendName: "wasm", kernelFunc: ise };
  var QL = he(ws);
  var ZL = he(ji);
  var JL = We(ks);
  var eB;
  function pse(r8) {
    eB = r8.wasm.cwrap(wo, null, ["number", "number", "number", "number"]);
  }
  function cse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { alpha: n8 } = o8, { x: s } = t8, a = e8.dataIdMap.get(s.dataId).id, i10 = e8.makeOutput(s.shape, s.dtype), p = e8.dataIdMap.get(i10.dataId).id;
    return eB(a, n8, we[s.dtype], p), i10;
  }
  var tB = { kernelName: wo, backendName: "wasm", setupFunc: pse, kernelFunc: cse };
  var rB;
  function lse(r8) {
    rB = r8.wasm.cwrap(Ns, null, ["number", "array", "number", "array", "array", "array", "array", "array", "number", "number"]);
  }
  function mse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { x: n8 } = t8, { begin: s, end: a, strides: i10, beginMask: p, endMask: u, ellipsisMask: c, newAxisMask: l, shrinkAxisMask: m } = o8, { finalShapeSparse: d, finalShape: f, isIdentity: h, sliceDim0: g, isSimpleSlice: x, begin: b, end: C, strides: S } = ct.sliceInfo(n8.shape, s, a, i10, p, u, c, l, m), k;
    if (h)
      k = zt({ inputs: { x: n8 }, backend: e8, attrs: { shape: f } });
    else if (g || x) {
      y.assert(n8.shape.length >= 1, () => `Input must have rank at least 1, got: ${n8.shape.length}`);
      let _ = ct.computeOutShape(b, C, S), E = Po({ inputs: { x: n8 }, backend: e8, attrs: { begin: b, size: _ } });
      k = zt({ inputs: { x: E }, backend: e8, attrs: { shape: f } }), e8.disposeData(E.dataId);
    } else {
      let _ = e8.makeOutput(d, "float32"), E = e8.dataIdMap.get(n8.dataId).id, R = new Uint8Array(new Int32Array(y.computeStrides(n8.shape)).buffer), D = new Uint8Array(new Int32Array(b).buffer), P = new Uint8Array(new Int32Array(C).buffer), O = new Uint8Array(new Int32Array(S).buffer), M = new Uint8Array(new Int32Array(d).buffer), L = new Uint8Array(new Int32Array(y.computeStrides(d)).buffer), B = e8.dataIdMap.get(_.dataId).id;
      rB(E, R, n8.shape.length, D, P, O, M, L, d.length, B), k = zt({ inputs: { x: _ }, backend: e8, attrs: { shape: f } }), e8.disposeData(_.dataId);
    }
    return k;
  }
  var oB = { kernelName: Ns, backendName: "wasm", setupFunc: lse, kernelFunc: mse };
  function dse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { data: n8, dataSplits: s } = t8, { separator: a, nGramWidths: i10, leftPad: p, rightPad: u, padWidth: c, preserveShortSequences: l } = o8, m = e8.readSync(n8.dataId), d = e8.readSync(s.dataId), [f, h] = mp(m, d, a, i10, p, u, c, l), g = e8.makeOutput([f.length], "string"), x = e8.dataIdMap.get(g.dataId);
    x.stringBytes = f;
    let b = e8.makeOutput(s.shape, "int32");
    return e8.typedArrayFromHeap(b).set(h), [g, b];
  }
  var nB = { kernelName: xa, backendName: "wasm", kernelFunc: dse };
  function fse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { input: n8, delimiter: s } = t8, { skipEmpty: a } = o8, i10 = e8.readSync(n8.dataId), p = e8.readSync(s.dataId), [u, c, l] = dp(i10, p[0], a), m = c.length, d = e8.makeOutput([m, 2], "int32");
    e8.typedArrayFromHeap(d).set(u);
    let h = e8.makeOutput([m], "string"), g = e8.dataIdMap.get(h.dataId);
    g.stringBytes = c;
    let x = e8.makeOutput([2], "int32");
    return e8.typedArrayFromHeap(x).set(l), [d, h, x];
  }
  var sB = { kernelName: Xi, backendName: "wasm", kernelFunc: fse };
  function hse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { input: n8 } = t8, { numBuckets: s } = o8, a = e8.readSync(n8.dataId), i10 = fp(a, s), p = e8.makeOutput(n8.shape, "int32");
    return e8.typedArrayFromHeap(p).set(i10), p;
  }
  var aB = { kernelName: Yi, backendName: "wasm", kernelFunc: hse };
  var iB = We(Ts);
  var uB;
  function xse(r8) {
    uB = r8.wasm.cwrap(Ss, null, ["number", "number", "number", "number"]);
  }
  function yse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { axis: n8, keepDims: s } = o8, { x: a } = t8, i10 = e8.dataIdMap.get(a.dataId).id, p = i10, u = a, { transposed: c, axes: l, originalAxes: m, inputWasTransposed: d } = _r(a, n8, e8), f = l;
    if (d) {
      let C = e8.dataIdMap.get(c.dataId).id;
      C !== i10 && (u = c, p = C, f = w.getInnerMostAxes(f.length, u.shape.length));
    }
    w.assertAxesAreInnerMostDims("sum", f, u.shape.length);
    let [h, g] = w.computeOutAndReduceShapes(u.shape, f), x = y.sizeFromShape(g), b = e8.makeOutput(h, u.dtype);
    if (y.sizeFromShape(u.shape) !== 0) {
      let C = e8.dataIdMap.get(b.dataId).id;
      uB(p, x, we[b.dtype], C);
    }
    if (d && e8.disposeData(c.dataId), s) {
      let C = w.expandShapeToKeepDim(b.shape, m);
      b.shape = C;
    }
    return b;
  }
  var pB = { kernelName: Ss, backendName: "wasm", setupFunc: xse, kernelFunc: yse };
  var cB = he(_s);
  var lB = he($s);
  var mB;
  function bse(r8) {
    mB = r8.wasm.cwrap(ds, null, ["number", "number", "number", "number", "number", "number", "array", "number", "number", "number"]);
  }
  function Cse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { tensor: n8, indices: s, updates: a } = t8, i10 = e8.makeOutput(n8.shape, n8.dtype);
    if (y.sizeFromShape(n8.shape) === 0)
      return i10;
    let { sliceRank: p, numUpdates: u, sliceSize: c, strides: l, outputSize: m } = du.calculateShapes(a, s, n8.shape), f = e8.dataIdMap.get(s.dataId).id, g = e8.dataIdMap.get(a.dataId).id, b = e8.dataIdMap.get(n8.dataId).id, C = new Uint8Array(new Int32Array(l).buffer), S = e8.dataIdMap.get(i10.dataId).id;
    return mB(f, g, we[a.dtype], p, u, c, C, m, S, b), i10;
  }
  var dB = { kernelName: ds, backendName: "wasm", setupFunc: bse, kernelFunc: Cse };
  var fB;
  function wse(r8) {
    fB = r8.wasm.cwrap(uo, null, ["number", "array", "number", "array", "number", "number"]);
  }
  function Sse(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, s = t8.dataIdMap.get(n8.dataId).id, { reps: a } = o8, i10 = new Array(n8.shape.length);
    for (let m = 0; m < i10.length; m++)
      i10[m] = n8.shape[m] * a[m];
    let p = new Uint8Array(new Int32Array(n8.shape).buffer), u = new Uint8Array(new Int32Array(i10).buffer), c = t8.makeOutput(i10, n8.dtype), l = t8.dataIdMap.get(c.dataId).id;
    return fB(s, p, n8.shape.length, u, i10.length, we[c.dtype], l), c;
  }
  var hB = { kernelName: uo, backendName: "wasm", setupFunc: wse, kernelFunc: Sse };
  var gB;
  function Ise(r8) {
    gB = r8.wasm.cwrap(Es, null, ["number", "array", "number", "number", "number", "bool", "number", "number"]);
  }
  var vse = ({ inputs: r8, backend: e8, attrs: t8 }) => {
    let { x: o8 } = r8, { k: n8, sorted: s } = t8, a = e8.dataIdMap.get(o8.dataId).id, i10 = new Uint8Array(new Int32Array(o8.shape).buffer), p = o8.shape.slice();
    p[p.length - 1] = n8;
    let u = e8.makeOutput(p, o8.dtype), c = e8.dataIdMap.get(u.dataId).id, l = e8.makeOutput(p, "int32"), m = e8.dataIdMap.get(l.dataId).id;
    return gB(a, i10, o8.shape.length, we[o8.dtype], n8, s, c, m), [u, l];
  };
  var xB = { kernelName: Es, backendName: "wasm", setupFunc: Ise, kernelFunc: vse };
  var yB;
  function kse(r8) {
    yB = r8.wasm.cwrap(Rs, null, ["number", "number", "bool", "number", "number", "number", "number", "number", "number", "array", "number", "array", "number", "number", "number", "number", "number"]);
  }
  function Nse(r8) {
    let { backend: e8, inputs: t8, attrs: o8 } = r8, { image: n8, transforms: s } = t8, { interpolation: a, fillMode: i10, fillValue: p, outputShape: u } = o8, [c, l, m, d] = n8.shape, [f, h] = u != null ? u : [l, m], g = [c, f, h, d], x = new Uint8Array(new Int32Array(y.computeStrides(n8.shape)).buffer), b = new Uint8Array(new Int32Array(y.computeStrides(g)).buffer), C = e8.makeOutput(g, n8.dtype), S = e8.dataIdMap.get(C.dataId).id, _ = e8.dataIdMap.get(n8.dataId).id, R = e8.dataIdMap.get(s.dataId).id, D = a === "nearest" ? 1 : 2, P;
    switch (i10) {
      case "constant":
        P = 1;
        break;
      case "reflect":
        P = 2;
        break;
      case "wrap":
        P = 3;
        break;
      case "nearest":
        P = 4;
        break;
      default:
        P = 1;
        break;
    }
    return yB(_, R, s.shape[0] > 1, c, f, h, d, m, l, x, n8.shape.length - 1, b, g.length - 1, D, P, p, S), C;
  }
  var bB = { kernelName: Rs, backendName: "wasm", setupFunc: kse, kernelFunc: Nse };
  function Tse(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { axis: n8 } = t8, { x: s } = e8, { outputValues: a, outputShape: i10, indices: p } = hp(o8.readSync(s.dataId), n8, s.shape, s.dtype);
    return [o8.makeOutput(i10, s.dtype, void 0, a), o8.makeOutput([p.length], "int32", void 0, p)];
  }
  var CB = { kernelName: Qi, backendName: "wasm", kernelFunc: Tse };
  function _se(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { value: n8 } = e8, { axis: s } = o8;
    s < 0 && (s += n8.shape.length);
    let a = n8.shape[s], i10 = n8.shape.length, p = new Array(i10 - 1), u = 0;
    for (let d = 0; d < i10; d++)
      d !== s && (p[u++] = n8.shape[d]);
    let c = new Array(a), l = new Array(i10).fill(0), m = n8.shape.slice();
    m[s] = 1;
    for (let d = 0; d < c.length; d++)
      l[s] = d, c[d] = Po({ inputs: { x: n8 }, attrs: { begin: l, size: m }, backend: t8 });
    return c.map(({ dataId: d, dtype: f }) => ({ dataId: d, dtype: f, shape: p }));
  }
  var wB = { kernelName: ya, backendName: "wasm", kernelFunc: _se };
  function $se(r8) {
    let { inputs: { x: e8 }, backend: t8 } = r8, o8 = t8.makeOutput(e8.shape, e8.dtype);
    return t8.typedArrayFromHeap(o8).fill(0), o8;
  }
  var SB = { kernelName: ba, backendName: "wasm", kernelFunc: $se };
  var Ese = [iP, uP, pP, cP, lP, dP, yP, CP, wP, SP, IP, vP, kP, NP, TP, $P, PP, RP, AP, LP, zP, WP, UP, GP, HP, KP, jP, XP, QP, JP, tO, oO, sO, aO, iO, pO, lO, dO, hO, xO, bO, wO, IO, kO, TO, _O, EO, RO, DO, AO, FO, PO, OO, LO, BO, zO, WO, GO, KO, jO, YO, QO, ZO, fP, JO, eM, tM, oM, nM, sM, iM, pM, uM, cM, lM, mM, dM, hM, xM, bM, CM, SM, vM, NM, _M, EM, DM, FM, PM, MM, VM, WM, UM, GM, KM, jM, YM, QM, JM, eL, tL, Mg, oL, sL, iL, uL, pL, cL, lL, mL, OP, fL, gL, yL, CL, SL, vL, kL, NL, _L, EL, DL, AL, PL, OL, ML, LL, BP, BM, BL, zL, WL, GL, KL, qL, XL, YL, QL, ZL, JL, tB, oB, nB, sB, aB, iB, pB, cB, lB, dB, hB, xB, bB, gP, CB, wB, SB];
  for (let r8 of Ese)
    Ja(r8);
  var Ev = A();
  Ev.registerFlag("WASM_HAS_SIMD_SUPPORT", async () => {
    try {
      return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]));
    } catch (r8) {
      return false;
    }
  });
  Ev.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", async () => {
    if (Ev.get("IS_NODE"))
      return false;
    try {
      return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
    } catch (r8) {
      return false;
    }
  });
  var Lv = Up(NB());
  var DB = Up(_B());
  var Bv = Up($B());
  var EB = Lv.default || Lv;
  var Rse = Bv.default || Bv;
  var am = class extends so {
    constructor(e8) {
      super(), this.wasm = e8, this.dataIdNextNumber = 1, this.wasm.tfjs.initWithThreadsCount(FB), Mv = this.wasm.tfjs.getThreadsCount(), this.dataIdMap = new Bo(this, ur());
    }
    write(e8, t8, o8) {
      let n8 = { id: this.dataIdNextNumber++ };
      return this.move(n8, e8, t8, o8, 1), n8;
    }
    numDataIds() {
      return this.dataIdMap.numDataIds();
    }
    async time(e8) {
      let t8 = y.now();
      return e8(), { kernelMs: y.now() - t8 };
    }
    move(e8, t8, o8, n8, s) {
      let a = this.dataIdNextNumber++;
      if (n8 === "string") {
        let c = t8;
        this.dataIdMap.set(e8, { id: a, stringBytes: c, shape: o8, dtype: n8, memoryOffset: null, refCount: s });
        return;
      }
      let i10 = y.sizeFromShape(o8), p = i10 * y.bytesPerElement(n8), u = this.wasm._malloc(p) >>> 0;
      this.dataIdMap.set(e8, { id: a, memoryOffset: u, shape: o8, dtype: n8, refCount: s }), this.wasm.tfjs.registerTensor(a, i10, u), t8 != null && this.wasm.HEAPU8.set(new Uint8Array(t8.buffer, t8.byteOffset, p), u);
    }
    async read(e8) {
      return this.readSync(e8);
    }
    readSync(e8, t8, o8) {
      let { memoryOffset: n8, dtype: s, shape: a, stringBytes: i10 } = this.dataIdMap.get(e8);
      if (s === "string")
        return (t8 == null || t8 === 0) && (o8 == null || o8 >= i10.length) ? i10 : i10.slice(t8, o8);
      t8 = t8 || 0, o8 = o8 || y.sizeFromShape(a);
      let p = y.bytesPerElement(s), u = this.wasm.HEAPU8.slice(n8 + t8 * p, n8 + o8 * p);
      return Ase(u.buffer, s);
    }
    disposeData(e8, t8 = false) {
      if (this.dataIdMap.has(e8)) {
        let o8 = this.dataIdMap.get(e8);
        if (o8.refCount--, !t8 && o8.refCount > 0)
          return false;
        this.wasm._free(o8.memoryOffset), this.wasm.tfjs.disposeData(o8.id), this.dataIdMap.delete(e8);
      }
      return true;
    }
    refCount(e8) {
      return this.dataIdMap.has(e8) ? this.dataIdMap.get(e8).refCount : 0;
    }
    incRef(e8) {
      let t8 = this.dataIdMap.get(e8);
      t8 != null && t8.refCount++;
    }
    floatPrecision() {
      return 32;
    }
    getMemoryOffset(e8) {
      return this.dataIdMap.get(e8).memoryOffset;
    }
    dispose() {
      this.wasm.tfjs.dispose(), "PThread" in this.wasm && this.wasm.PThread.terminateAllThreads(), this.wasm = null;
    }
    memory() {
      return { unreliable: false };
    }
    makeOutput(e8, t8, o8, n8) {
      let s;
      if (o8 == null)
        s = this.write(n8 != null ? n8 : null, e8, t8);
      else {
        let a = this.dataIdNextNumber++;
        s = { id: a }, this.dataIdMap.set(s, { id: a, memoryOffset: o8, shape: e8, dtype: t8, refCount: 1 });
        let i10 = y.sizeFromShape(e8);
        this.wasm.tfjs.registerTensor(a, i10, o8);
      }
      return { dataId: s, shape: e8, dtype: t8 };
    }
    typedArrayFromHeap({ shape: e8, dtype: t8, dataId: o8 }) {
      let n8 = this.wasm.HEAPU8.buffer, { memoryOffset: s } = this.dataIdMap.get(o8), a = y.sizeFromShape(e8);
      switch (t8) {
        case "float32":
          return new Float32Array(n8, s, a);
        case "int32":
          return new Int32Array(n8, s, a);
        case "bool":
          return new Uint8Array(n8, s, a);
        default:
          throw new Error(`Unknown dtype ${t8}`);
      }
    }
  };
  function Dse(r8) {
    return (e8, t8) => (y.fetch(r8, { credentials: "same-origin" }).then((o8) => {
      o8.ok || e8.env.a(`failed to load wasm binary file at '${r8}'`), o8.arrayBuffer().then((n8) => {
        WebAssembly.instantiate(n8, e8).then((s) => {
          t8(s.instance, s.module);
        });
      });
    }), {});
  }
  function RB(r8, e8, t8) {
    if (Wg != null)
      return Wg;
    let o8 = "tfjs-backend-wasm.wasm";
    return r8 && e8 ? o8 = "tfjs-backend-wasm-threaded-simd.wasm" : r8 && (o8 = "tfjs-backend-wasm-simd.wasm"), nm != null && nm[o8] != null ? nm[o8] : t8 + o8;
  }
  async function AB() {
    let [r8, e8] = await Promise.all([A().getAsync("WASM_HAS_SIMD_SUPPORT"), A().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);
    return new Promise((t8, o8) => {
      let n8 = {};
      n8.locateFile = (i10, p) => {
        if (i10.endsWith(".worker.js")) {
          let u = DB.wasmWorkerContents.replace(/\n/g, "\\n"), c = new Blob([u], { type: "application/javascript" });
          return URL.createObjectURL(c);
        }
        return i10.endsWith(".wasm") ? RB(r8, e8, om != null ? om : p) : p + i10;
      }, zv && (n8.instantiateWasm = Dse(RB(r8, e8, om != null ? om : "")));
      let s = false;
      n8.onAbort = () => {
        if (s || sm)
          return;
        sm = true, o8({ message: "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers" });
      };
      let a;
      e8 && r8 && Wg == null ? (n8.mainScriptUrlOrBlob = new Blob(["var WasmBackendModuleThreadedSimd = " + EB.toString()], { type: "text/javascript" }), a = EB(n8)) : a = Rse(n8), a.then((i10) => {
        s = true, sm = false;
        let p = null;
        i10.tfjs = { init: i10.cwrap("init", null, []), initWithThreadsCount: i10.cwrap("init_with_threads_count", null, ["number"]), getThreadsCount: i10.cwrap("get_threads_count", "number", []), registerTensor: i10.cwrap("register_tensor", null, ["number", "number", "number"]), disposeData: i10.cwrap("dispose_data", p, ["number"]), dispose: i10.cwrap("dispose", p, []) }, t8({ wasm: i10 });
      }).catch(o8);
    });
  }
  function Ase(r8, e8) {
    switch (e8) {
      case "float32":
        return new Float32Array(r8);
      case "int32":
        return new Int32Array(r8);
      case "bool":
        return new Uint8Array(r8);
      default:
        throw new Error(`Unknown dtype ${e8}`);
    }
  }
  var Fse = ["tfjs-backend-wasm.wasm", "tfjs-backend-wasm-simd.wasm", "tfjs-backend-wasm-threaded-simd.wasm"];
  var Wg = null;
  var om = null;
  var nm = {};
  var sm = false;
  var zv = false;
  function Pse(r8, e8 = false) {
    if (_w("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."), sm)
      throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");
    Wg = r8, zv = e8;
  }
  function Ose(r8, e8 = false) {
    if (sm)
      throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
    if (typeof r8 == "string")
      om = r8;
    else {
      nm = r8;
      let t8 = Fse.filter((o8) => nm[o8] == null);
      if (t8.length > 0)
        throw new Error(`There were no entries found for the following binaries: ${t8.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`);
    }
    zv = e8;
  }
  var FB = -1;
  var Mv = -1;
  function Mse(r8) {
    FB = r8;
  }
  function Lse() {
    if (Mv === -1)
      throw new Error("WASM backend not initialized.");
    return Mv;
  }
  var Bse = "4.7.0";
  var zse = 2;
  nu("wasm", async () => {
    let { wasm: r8 } = await AB();
    return new am(r8);
  }, zse);
  var go = A();
  go.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15);
  go.registerFlag("WEBGPU_CPU_FORWARD", () => true);
  go.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE", () => -1);
  go.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => true);
  go.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => false);
  go.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e3);
  go.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => false);
  go.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE", () => true);
  go.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG", () => false);
  go.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL", () => 0);
  go.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => false);
  go.registerFlag("WEBGPU_PRINT_SHADER", () => "");
  go.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY", () => false);
  var Ug = class {
    constructor(e8) {
      e8 && (this.vendor = e8.vendor, this.architecture = e8.architecture, this.intelGPUGeneration = this.getIntelGPUGeneration());
    }
    getIntelGPUGeneration() {
      if (this.isIntel()) {
        if (this.architecture.startsWith("gen"))
          return Number(this.architecture.match(/\d+/));
        if (this.architecture.startsWith("xe"))
          return 12;
      }
      return 0;
    }
    isIntel() {
      return this.vendor === "intel";
    }
  };
  var Gg = class {
    constructor(e8) {
      this.device = e8, this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireBuffer(e8, t8, o8 = false, n8 = true) {
      let s, a = PB(e8, t8);
      return n8 ? (this.freeBuffers.has(a) || this.freeBuffers.set(a, []), this.freeBuffers.get(a).length > 0 ? (s = this.freeBuffers.get(a).pop(), this.numFreeBuffers--) : (s = this.device.createBuffer({ size: e8, usage: t8, mappedAtCreation: o8 }), this.numBytesAllocated += e8)) : (s = this.device.createBuffer({ size: e8, usage: t8, mappedAtCreation: o8 }), this.numBytesAllocated += e8), this.usedBuffers.has(a) || this.usedBuffers.set(a, []), this.usedBuffers.get(a).push(s), this.numUsedBuffers++, this.numBytesUsed += e8, s;
    }
    releaseBuffer(e8, t8 = true) {
      if (this.freeBuffers.size === 0)
        return;
      let o8 = e8.size, n8 = e8.usage, s = PB(o8, n8), a = this.usedBuffers.get(s), i10 = a.indexOf(e8);
      if (i10 < 0)
        throw new Error("Cannot find the buffer in buffer manager");
      a[i10] = a[a.length - 1], a.pop(), this.numUsedBuffers--, this.numBytesUsed -= o8, t8 ? (this.freeBuffers.get(s).push(e8), this.numFreeBuffers++) : (e8.destroy(), this.numBytesAllocated -= o8);
    }
    getNumUsedBuffers() {
      return this.numUsedBuffers;
    }
    getNumFreeBuffers() {
      return this.numFreeBuffers;
    }
    dispose() {
      this.freeBuffers.forEach((e8, t8) => {
        e8.forEach((o8) => {
          o8.destroy();
        });
      }), this.usedBuffers.forEach((e8, t8) => {
        e8.forEach((o8) => {
          o8.destroy();
        });
      }), this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
  };
  function PB(r8, e8) {
    return `${r8}_${e8}`;
  }
  var Hg = class {
    constructor(e8) {
      this.device = e8, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireTexture(e8, t8, o8, n8) {
      let s = MB(o8), a = e8 * t8 * s, i10 = OB(e8, t8, o8, n8);
      if (this.freeTextures.has(i10) || this.freeTextures.set(i10, []), this.usedTextures.has(i10) || this.usedTextures.set(i10, []), this.numBytesUsed += a, this.numUsedTextures++, this.freeTextures.get(i10).length > 0) {
        this.numFreeTextures--;
        let u = this.freeTextures.get(i10).shift();
        return this.usedTextures.get(i10).push(u), u;
      }
      this.numBytesAllocated += a;
      let p = this.device.createTexture({ size: [e8, t8], format: o8, usage: n8 });
      return this.usedTextures.get(i10).push(p), p;
    }
    releaseTexture(e8) {
      if (this.freeTextures.size === 0)
        return;
      let t8 = e8.width, o8 = e8.height, n8 = e8.format, s = e8.usage, a = OB(t8, o8, n8, s);
      this.freeTextures.has(a) || this.freeTextures.set(a, []), this.freeTextures.get(a).push(e8), this.numFreeTextures++, this.numUsedTextures--;
      let i10 = this.usedTextures.get(a), p = i10.indexOf(e8);
      if (p < 0)
        throw new Error("Cannot release a texture that was never provided by this texture manager");
      i10.splice(p, 1);
      let u = MB(n8), c = t8 * o8 * u;
      this.numBytesUsed -= c;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      this.freeTextures.forEach((e8, t8) => {
        e8.forEach((o8) => {
          o8.destroy();
        });
      }), this.usedTextures.forEach((e8, t8) => {
        e8.forEach((o8) => {
          o8.destroy();
        });
      }), this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numUsedTextures = 0, this.numFreeTextures = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
  };
  function OB(r8, e8, t8, o8) {
    return `${r8}_${e8}_${t8}_${o8}`;
  }
  function MB(r8) {
    if (r8 === "rgba8unorm")
      return 16;
    throw new Error(`${r8} is not supported!`);
  }
  function LB(r8, e8) {
    if (Math.max(...r8) > 5)
      throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");
    let t8 = r8.length, o8 = "xyzwuv", n8 = r8.map((a) => `${e8}.${o8[a]}`), s = new Array(t8 - 1);
    s[t8 - 2] = n8[t8 - 1];
    for (let a = t8 - 3; a >= 0; --a)
      s[a] = `(${s[a + 1]} * ${n8[a + 1]})`;
    return s;
  }
  var Us = (r8, e8, t8) => t8 === "int32" ? `atomicAdd(${r8}, bitcast<i32>(${e8}));` : `
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e8});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${r8}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;
  var WB = (r8, e8, t8, o8, n8) => {
    let s = { dtype: o8.dtype, shape: o8.shape }, a = Wse(t8, s, e8), i10 = r8.createShaderModule({ code: a, label: e8.constructor.name }), p = A().get("WEBGPU_PRINT_SHADER");
    if (p !== "") {
      p = p.toLowerCase();
      let u = p.split(",");
      (p === "all" || u.some((c) => e8.shaderKey.toLowerCase().includes(c))) && (console.group(e8.shaderKey), console.debug(a), console.groupEnd());
    }
    return n8 ? r8.createComputePipelineAsync({ compute: { module: i10, entryPoint: "_start" }, label: e8.constructor.name, layout: "auto" }) : r8.createComputePipeline({ compute: { module: i10, entryPoint: "_start" }, label: e8.constructor.name, layout: "auto" });
  };
  var Ae = (r8, e8 = "f32") => {
    switch (r8) {
      case 1:
        return `${e8}`;
      case 2:
        return `vec2<${e8}>`;
      case 3:
        return `vec3<${e8}>`;
      case 4:
        return `vec4<${e8}>`;
      default:
        throw new Error(`${r8}-component ${e8} is not supported.`);
    }
  };
  function ht(r8) {
    if (r8 <= 1)
      return "i32";
    if (r8 === 2)
      return "vec2<i32>";
    if (r8 === 3)
      return "vec3<i32>";
    if (r8 === 4)
      return "vec4<i32>";
    if (r8 === 5)
      return "vec5";
    if (r8 === 6)
      return "vec6";
    throw Error(`GPU for rank ${r8} is not yet supported`);
  }
  function Oo(r8) {
    if (r8 === 0)
      return "x";
    if (r8 === 1)
      return "y";
    if (r8 === 2)
      return "z";
    if (r8 === 3)
      return "w";
    if (r8 === 4)
      return "u";
    if (r8 === 5)
      return "v";
    throw Error(`Index ${r8} is not yet supported`);
  }
  function H(...r8) {
    let e8;
    switch (r8.length) {
      case 0:
        e8 = `
        fn main()
      `;
        break;
      case 1:
        e8 = `
        fn main(${r8[0]} : i32)
      `;
        break;
      default:
        throw Error("Unreachable");
    }
    return e8;
  }
  function BB(r8, e8) {
    let t8;
    return t8 = `
     ${Vse(e8)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${r8 ? "main(getGlobalIndex());" : "main();"};
      }
    `, t8;
  }
  function Vse(r8) {
    return `
  @compute @workgroup_size(${r8.workgroupSize[0]}, ${r8.workgroupSize[1]}, ${r8.workgroupSize[2]})
`;
  }
  function Wse(r8, e8, t8) {
    let o8 = [], n8 = t8.workgroupSize[0] * t8.workgroupSize[1] * t8.workgroupSize[2];
    if (t8.outputComponent = t8.outputComponent ? t8.outputComponent : 1, o8.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${GB(t8) ? "  return i32(globalId.x);" : `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${n8}u +
                localIndex);
        `}
      }
    `), t8.isFromPixels) {
      o8.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${$p(e8.dtype, t8.outputComponent)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
      let f = VB(t8);
      return [zB, o8.join(`
`), im(e8.shape), t8.getUserCode(), BB(f, t8)].join(`
`);
    }
    let s, a, i10 = "struct Uniforms { NAN : f32, INFINITY : f32, ";
    t8.variableNames.forEach((f, h) => {
      let g = ht(r8[h].shape.length);
      i10 += `${f.charAt(0).toLowerCase() + f.slice(1)}Shape : ${g}, `, s = r8[h].shape.length - 1, a = ht(s), i10 += `${f.charAt(0).toLowerCase() + f.slice(1)}ShapeStrides: ${a}, `;
    });
    let p = ht(e8.shape.length);
    i10 += `outShape : ${p}, `, s = e8.shape.length - 1, a = ht(s), i10 += `
         outShapeStrides: ${a}, `, t8.size && (i10 += "size : i32, "), t8.uniforms && (i10 += t8.uniforms), i10 += "};", i10 = Yse(i10), o8.push(i10), t8.atomic ? o8.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `) : o8.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${$p(e8.dtype, t8.outputComponent)}>;
    `), t8.variableNames.forEach((f, h) => {
      o8.push(`
      @group(0) @binding(${1 + h}) var<storage, read> ${f}: array<${t8.variableComponents ? $p(r8[h].dtype, t8.variableComponents[h]) : $p(r8[h].dtype, t8.outputComponent)}>;
        `);
    }), i10 !== "" && o8.push(`
      @group(0) @binding(${1 + t8.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
    let u = qse(e8.shape, t8.dispatchLayout), c = [zB, o8.join(`
`) + Use, im(e8.shape), u, jse(e8.shape.length)];
    t8.atomic || c.push(Xse(e8.shape, e8.dtype, t8.outputComponent)), t8.variableNames.forEach((f, h) => {
      c.push(`${im(r8[h].shape, f)}`);
    });
    let l = r8.map((f, h) => Kse(f, e8.shape, t8.variableComponents ? t8.variableComponents[h] : t8.outputComponent, t8.dispatchLayout.x.length === e8.shape.length)).join(`
`);
    c.push(l), c.push(t8.getUserCode());
    let m = VB(t8);
    return c.push(BB(m, t8)), c.join(`
`);
  }
  function UB(r8, e8, t8) {
    let o8 = r8.shaderKey;
    if (r8.isFromPixels)
      return o8;
    let n8 = [], s = [];
    e8.forEach((c) => {
      n8.push(c.shape), s.push(c.dtype);
    }), n8.push(t8.shape), s.push(t8.dtype);
    let a = e8.map((c) => w.getBroadcastDims(c.shape, t8.shape)), i10 = e8.map((c) => y.arraysEqual(c.shape, t8.shape)).join("_"), p = a.map((c) => c.join("_")).join(";"), u = GB(r8) ? "flatDispatch" : "";
    return o8 += "_" + (r8.workgroupSize ? r8.workgroupSize.join(",") : "") + n8.map((c) => c.length).join(",") + s.join(",") + r8.variableNames.join(",") + p + i10 + u, o8;
  }
  var zB = `
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`;
  var Use = `
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;
  function im(r8, e8 = "") {
    let t8 = r8.length, o8 = e8 !== "" ? `get${e8.charAt(0).toUpperCase() + e8.slice(1)}CoordsFromIndex` : "getCoordsFromIndex", n8 = e8 !== "" ? `${e8.charAt(0).toLowerCase() + e8.slice(1)}ShapeStrides` : "outShapeStrides";
    if (t8 <= 1)
      return `fn ${o8}(index : i32) -> i32 { return index; }`;
    let s = y.computeStrides(r8), a = ht(t8), i10 = [];
    for (let u = 0; u < t8; u++)
      i10.push(`d${u}`);
    if (s.length === 1)
      return `    fn ${o8}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${n8}; let d1 = index - d0 * uniforms.${n8};
      return vec2<i32>(d0, d1);
    }`;
    let p;
    return p = "var index2 = index;" + s.map((u, c) => {
      let l = `let ${i10[c]} = index2 / uniforms.${n8}.${Oo(c)}`, m = c === s.length - 1 ? `let ${i10[c + 1]} = index2 - ${i10[c]} * uniforms.${n8}.${Oo(c)}` : `index2 = index2 - ${i10[c]} * uniforms.${n8}.${Oo(c)}`;
      return `${l}; ${m};`;
    }).join(""), `
    fn ${o8}(index : i32) -> ${a} {
      ${p}
      return ${a}(${i10.join(",")});
    }
  `;
  }
  function Gse(r8, e8) {
    let t8 = r8.name, o8 = r8.shape.length, n8 = ht(o8), s = "get" + t8.charAt(0).toUpperCase() + t8.slice(1), a = ["d0", "d1", "d2", "d3", "d4", "d5"].slice(0, o8), i10 = a.map((c) => `${c} : i32`).join(", ");
    if (o8 < 1)
      return `
      fn ${s}() -> ${Ae(e8)} {
        return ${Ae(e8)}(${t8}[0]);
      }
    `;
    let p = `uniforms.${t8.charAt(0).toLowerCase() + t8.slice(1)}Shape`, u = `${o8}D`;
    return o8 === 0 && (u = "1D"), `
    fn ${s}(${i10}) -> ${Ae(e8)} {
      return ${Ae(e8)}(${t8}[getIndexFromCoords${u}(${n8}(${a.join(",")}),
        ${p})${e8 === 1 ? "" : ` / ${e8}`}]);
    }
   `;
  }
  function Hse(r8, e8, t8, o8) {
    let n8 = r8.name, s = n8.charAt(0).toUpperCase() + n8.slice(1), a = "get" + s + "ByOutput", i10 = r8.shape.length, p = e8.length, u = ht(p);
    if (y.arraysEqual(r8.shape, e8) && o8)
      return `
    fn ${a}Index(globalIndex : i32) -> ${Ae(t8)} {
      return ${Ae(t8)}(${n8}[globalIndex]);
    }

    fn ${a}Coords(coords : ${u}) -> ${Ae(t8)} {
      return ${Ae(t8)}(${n8}[${p > 1 ? "getOutputIndexFromCoords(coords)" : "coords"}${t8 === 1 ? "" : ` / ${t8}`}]);
    }
    `;
    let c = w.getBroadcastDims(r8.shape, e8), l = p - i10, m = "";
    if (i10 === 0)
      return `
    fn ${a}Index(globalIndex : i32) -> ${Ae(t8)}{
      return get${s}();
    }

    fn ${a}Coords(coords : ${u}) -> ${Ae(t8)}{
      return get${s}();
    }
  `;
    p < 2 && c.length >= 1 ? m = "coords = 0;" : m = c.map((g) => `coords.${Oo(g + l)} = 0;`).join(`
`);
    let d = "";
    if (p < 2 && i10 > 0)
      d = "coords";
    else if (p > 1) {
      let g = ht(i10), x = r8.shape.map((b, C) => `coords.${Oo(C + l)}`).join(", ");
      d = `${g}(${x})`;
    } else
      d = "coords";
    let f = `uniforms.${n8.charAt(0).toLowerCase() + n8.slice(1)}Shape`, h = `${i10}D`;
    return `
  fn ${a}Index(globalIndex : i32) -> ${Ae(t8)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${m}
    return ${Ae(t8)}(${n8}[getIndexFromCoords${h}(${d}, ${f})${t8 === 1 ? "" : ` / ${t8}`}]);
  }

  fn ${a}Coords(coordsIn : ${u}) -> ${Ae(t8)} {
    var coords = coordsIn;
    ${m}
    return ${Ae(t8)}(${n8}[getIndexFromCoords${h}(${d}, ${f})${t8 === 1 ? "" : ` / ${t8}`}]);
  }
`;
  }
  function Kse(r8, e8, t8, o8) {
    let n8 = Gse(r8, t8);
    return r8.shape.length <= e8.length && (n8 += Hse(r8, e8, t8, o8)), n8;
  }
  function qse(r8, e8) {
    let { x: t8, y: o8 = [], z: n8 = [] } = e8, s = r8.length, a = t8.length + o8.length + n8.length;
    if (a !== s)
      return "";
    if (t8.length === s)
      return `fn getOutputCoords() -> ${ht(s)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
    let i10 = "", p = [t8, o8, n8];
    for (let m = 0; m < p.length; m++) {
      let d = p[m];
      if (d.length !== 0)
        if (d.length === 1)
          i10 += `let d${d[0]} = i32(globalId[${m}]);`;
        else {
          let f = LB(d, "uniforms.outShape");
          i10 += `var index${m} = i32(globalId[${m}]);`;
          for (let h = 0; h < f.length; h++)
            i10 += `let d${d[h]} = index${m} / ${f[h]};`, h === f.length - 1 ? i10 += `let d${d[h + 1]} = index${m} - d${d[h]} * ${f[h]};` : i10 += `index${m} = index${m} - d${d[h]} * ${f[h]};`;
        }
    }
    let u = [];
    for (let m = 0; m < a; m++)
      u.push(`d${m}`);
    let c = ht(a), l = `fn getOutputCoords() -> ${c} {
  ${i10}
`;
    return u.length === 0 ? l += `return ${c}(0); }` : l += `return ${c}(${u.join(",")}); }`, l;
  }
  function jse(r8) {
    let e8 = "";
    switch (r8) {
      case 0:
      case 1:
        e8 += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
        break;
      case 2:
        e8 += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
        break;
      case 3:
        e8 += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
        break;
      case 4:
        e8 += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
        break;
      case 5:
        e8 += `
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;
        break;
      case 6:
        e8 += `
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;
        break;
      default:
        y.assert(false, () => `Unsupported ${r8}D shape`);
        break;
    }
    return e8;
  }
  function GB(r8) {
    return r8.dispatch[1] === 1 && r8.dispatch[2] === 1;
  }
  function $p(r8, e8 = 1) {
    if (r8 === "float32")
      return Ae(e8, "f32");
    if (r8 === "int32" || r8 === "bool")
      return Ae(e8, "i32");
    throw new Error(`type ${r8} is not supported.`);
  }
  function Xse(r8, e8, t8) {
    let o8 = r8.length, n8 = $p(e8, t8), s = `fn setOutputAtIndex(flatIndex : i32, value : ${Ae(t8)}) {
      result[flatIndex] = ${n8}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Ae(t8, "i32")}) {
      result[flatIndex] = ${n8}(value);
    }
    `;
    if (o8 >= 2) {
      let a = ["d0", "d1", "d2", "d3", "d4", "d5"].slice(0, o8), i10 = ht(o8);
      s += `
      fn setOutputAtCoords(${a.map((p) => `${p} : i32`).join(", ")}, value : ${Ae(t8)}) {
        let flatIndex = getOutputIndexFromCoords(${i10}(${a.join(", ")}));
        setOutputAtIndex(flatIndex${t8 === 1 ? "" : ` / ${t8}`}, value);
      }
      fn setOutputAtCoordsI32(${a.map((p) => `${p} : i32`).join(", ")}, value : ${Ae(t8, "i32")}) {
        let flatIndex = getOutputIndexFromCoords(${i10}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex${t8 === 1 ? "" : ` / ${t8}`}, value);
      }
    `;
    }
    return s;
  }
  function Yse(r8) {
    let e8 = /(\w+)\s*:\s*vec(5|6)/g;
    r8 = r8.replace(e8, (o8) => "@align(16) " + o8);
    let t8 = /vec(5|6)\s*,\s*(\w+)/g;
    return r8 = r8.replace(t8, (o8, n8, s) => `vec${n8}, @align(16) ${s}`), r8;
  }
  function VB(r8) {
    return !(r8.dispatchLayout.hasOwnProperty("y") && r8.dispatchLayout.y.length !== 0 || r8.dispatchLayout.hasOwnProperty("z") && r8.dispatchLayout.z.length !== 0);
  }
  var Wv = {};
  Ke(Wv, { GPUBytesPerElement: () => Kg, MatMulProgramType: () => Mo, assertNotComplex: () => lm, computeDispatch: () => K, computeWorkPerThreadForConv2d: () => pm, computeWorkgroupInfoForMatMul: () => Vv, computeWorkgroupSizeForConv2d: () => um, flatDispatchLayout: () => X, isWebGPUSupported: () => cm, tilesFitEvenlyIntoShape: () => Zse });
  var Ep = (r8) => {
    let e8 = 1;
    for (let t8 = 0; t8 < r8.length; t8++)
      e8 *= r8[t8];
    return e8;
  };
  function Zse(r8, e8) {
    if (r8.length !== e8.length)
      throw new Error(`Cannot compute whether rank ${r8.length} tiles fit evenly into rank ${e8.length} shape - ranks must match.`);
    return e8.every((t8, o8) => t8 % r8[o8] === 0);
  }
  function K(r8, e8, t8 = [1, 1, 1], o8 = [1, 1, 1]) {
    let [n8, s, a] = [Math.ceil(Ep(r8.x.map((i10) => e8[i10])) / (t8[0] * o8[0])), r8.y ? Math.ceil(Ep(r8.y.map((i10) => e8[i10])) / (t8[1] * o8[1])) : 1, r8.z ? Math.ceil(Ep(r8.z.map((i10) => e8[i10])) / (t8[2] * o8[2])) : 1];
    return [n8, s, a];
  }
  function Vv(r8, e8, t8, o8 = false) {
    let n8 = [8, 8, 1], s = [4, 4, 1];
    return o8 || (r8 <= 8 && (s[1] = 1), e8 <= 16 && t8 <= 16 && (n8[0] = 4)), { workgroupSize: n8, elementsPerThread: s };
  }
  function um(r8, e8, t8 = false) {
    if (t8)
      return [8, 8, 1];
    let o8 = Ep(r8.x.map((s) => e8[s])), n8 = Ep(r8.y.map((s) => e8[s]));
    return o8 <= 4 ? [4, 16, 1] : n8 <= 4 ? [16, 4, 1] : [16, 16, 1];
  }
  function pm(r8, e8, t8 = false) {
    if (t8)
      return [4, 4, 1];
    let o8 = Ep(r8.x.map((s) => e8[s])), n8 = Ep(r8.y.map((s) => e8[s]));
    return o8 <= 4 ? [1, 2, 1] : n8 <= 4 ? [2, 1, 1] : [2, 2, 1];
  }
  function X(r8) {
    return { x: r8.map((e8, t8) => t8) };
  }
  function Kg(r8) {
    if (r8 === "float32" || r8 === "int32" || r8 === "bool" || r8 === "string")
      return 4;
    if (r8 === "complex64")
      return 8;
    throw new Error(`Unknown dtype ${r8}`);
  }
  function cm() {
    return (typeof window != "undefined" || typeof WorkerGlobalScope != "undefined") && !!navigator.gpu;
  }
  function lm(r8, e8) {
    Array.isArray(r8) || (r8 = [r8]), r8.forEach((t8) => {
      t8 != null && y.assert(t8.dtype !== "complex64", () => `${e8} does not support complex64 tensors in the WebGPU backend.`);
    });
  }
  var Mo;
  (function(r8) {
    r8[r8.MatMulReduceProgram = 0] = "MatMulReduceProgram", r8[r8.MatMulSplitKProgram = 1] = "MatMulSplitKProgram", r8[r8.MatMulSmallOutputSizeProgram = 2] = "MatMulSmallOutputSizeProgram", r8[r8.MatMulPackedProgram = 3] = "MatMulPackedProgram", r8[r8.MatMulMax = 4] = "MatMulMax";
  })(Mo || (Mo = {}));
  var Jse = A().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");
  var eae = (r8, e8) => {
    let t8 = r8.limits.maxComputeWorkgroupsPerDimension, o8 = e8.dispatchLayout, n8 = e8.dispatch;
    if (n8.every((a) => a <= t8))
      return n8;
    y.assert(n8[0] > t8 && o8.y === void 0 && o8.z === void 0, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
    let s = Math.ceil(Math.sqrt(n8[0]));
    return s > t8 ? (s = Math.ceil(Math.cbrt(n8[0])), y.assert(s <= t8, () => "Total dispatch size exceeds WebGPU maximum."), [s, s, s]) : [s, s, 1];
  };
  var vu = class extends so {
    nextDataId() {
      return vu.nextDataId++;
    }
    constructor(e8, t8) {
      if (super(), this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.dispatchCountInPass = 0, this.disposed = false, this.downloadWaitMs = 0, this.tensorDataPendingDisposal = [], this.queryResolveBuffer = null, this.querySet = null, this.querySetCount = 2, this.stagingPendingDisposal = [], this.uniformPendingDisposal = [], this.uploadWaitMs = 0, this.hasReadSyncWarned = false, this.hasTimestampQueryWarned = false, !cm())
        throw new Error("WebGPU is not supported on this device");
      this.pipelineCache = {}, this.device = e8, this.queue = e8.queue, this.commandEncoder = null, this.computePassEncoder = null, this.adapterInfo = new Ug(t8), this.supportTimestampQuery = this.device.features.has("timestamp-query"), this.thresholdToIncreaseWorkgroups = this.adapterInfo.intelGPUGeneration >= 12 ? 16 : 8, this.bufferManager = new Gg(this.device), this.textureManager = new Hg(this.device), this.tensorMap = new Bo(this, ur()), A().getBool("WEBGPU_USE_PROFILE_TOOL") && (this.dummyCanvas = document.createElement("canvas"), this.dummyCanvas.width = 1, this.dummyCanvas.height = 1, this.dummyContext = this.dummyCanvas.getContext("webgpu"), this.dummyContext.configure({ device: e8, format: "bgra8unorm" }), document.body.appendChild(this.dummyCanvas));
    }
    floatPrecision() {
      return 32;
    }
    disposeData(e8, t8 = false) {
      if (!this.tensorMap.has(e8))
        return true;
      let o8 = this.tensorMap.get(e8);
      return t8 ? o8.refCount = 0 : o8.refCount--, o8.refCount > 0 ? false : (o8.complexTensorInfos != null && (this.disposeData(o8.complexTensorInfos.real.dataId), this.disposeData(o8.complexTensorInfos.imag.dataId)), this.commandQueueOwnedIds.has(e8) ? (this.tensorDataPendingDisposal.push(e8), true) : (this.releaseResource(e8), this.tensorMap.delete(e8), true));
    }
    memory() {
      return { numBytesInGPU: this.bufferManager.numBytesUsed, numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated, unreliable: false };
    }
    releaseResource(e8) {
      let t8 = this.tensorMap.get(e8);
      if (!(!t8 || !t8.resource)) {
        if (t8.external) {
          t8.resource = null;
          return;
        }
        t8.resource instanceof GPUBuffer ? this.bufferManager.releaseBuffer(t8.resource) : t8.resource instanceof GPUTexture && this.textureManager.releaseTexture(t8.resource), t8.resource = null;
      }
    }
    refCount(e8) {
      return this.tensorMap.has(e8) ? this.tensorMap.get(e8).refCount : 0;
    }
    incRef(e8) {
      let t8 = this.tensorMap.get(e8);
      t8.refCount++;
    }
    decRef(e8) {
      if (this.tensorMap.has(e8)) {
        let t8 = this.tensorMap.get(e8);
        t8.refCount--;
      }
    }
    write(e8, t8, o8) {
      if (o8 === "complex64" && e8 != null)
        throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      let n8 = { id: this.nextDataId() };
      return this.tensorMap.set(n8, { dtype: o8, shape: t8, values: e8, refCount: 1 }), n8;
    }
    move(e8, t8, o8, n8, s) {
      if (n8 === "complex64")
        throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.tensorMap.set(e8, { dtype: n8, shape: o8, values: t8, refCount: s });
    }
    submitQueue() {
      this.queue.submit([this.commandEncoder.finish()]), this.commandEncoder = null, this.dispatchCountInPass = 0, this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.tensorDataPendingDisposal.forEach((e8) => {
        this.releaseResource(e8), this.tensorMap.delete(e8);
      }), this.uniformPendingDisposal.forEach((e8) => this.bufferManager.releaseBuffer(e8)), this.stagingPendingDisposal.forEach((e8) => this.bufferManager.releaseBuffer(e8, false)), this.tensorDataPendingDisposal = [], this.uniformPendingDisposal = [], this.stagingPendingDisposal = [];
    }
    ensureCommandEncoderReady() {
      this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder());
    }
    endComputePassEncoder() {
      this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
    }
    async checkCompileCompletionAsync() {
      let e8;
      try {
        e8 = await Promise.all(Object.values(this.pipelineCache));
      } catch (t8) {
        throw new Error(t8.message);
      }
      Object.keys(this.pipelineCache).map((t8, o8) => {
        this.pipelineCache[t8] = e8[o8];
      });
    }
    async getBufferData(e8) {
      if (A().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))
        return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"), null;
      let t8 = e8.size, o8 = this.bufferManager.acquireBuffer(t8, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
      this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e8, 0, o8, 0, t8), this.submitQueue(), await o8.mapAsync(GPUMapMode.READ);
      let n8 = o8.getMappedRange().slice(0);
      return o8.unmap(), o8 != null && this.bufferManager.releaseBuffer(o8), A().getBool("WEBGPU_USE_PROFILE_TOOL") && (y.assert(this.dummyContext !== void 0, () => "Fail to get context for profiling tool"), this.dummyContext.getCurrentTexture()), n8;
    }
    convertAndCacheOnCPU(e8, t8) {
      let o8 = this.tensorMap.get(e8);
      return o8.values = t8, o8.values;
    }
    readSync(e8) {
      let t8 = this.tensorMap.get(e8), { values: o8, complexTensorInfos: n8 } = t8;
      if (o8 != null || t8.dtype === "string")
        return o8;
      if (t8.dtype === "complex64") {
        let h = this.readSync(n8.real.dataId), g = this.readSync(n8.imag.dataId), x = y.convertBackendValuesAndArrayBuffer(w.mergeRealAndImagArrays(h, g).buffer, "float32");
        return this.convertAndCacheOnCPU(e8, x), x;
      }
      this.hasReadSyncWarned || (this.hasReadSyncWarned = true, console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));
      let s = ["opaque", "premultiplied"], a = t8.resource, i10 = a.size;
      y.assert(i10 % 4 === 0, () => "Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");
      let p = i10 / 4, u = new ArrayBuffer(i10), c = 256, l = 256, m = s.map((h) => new OffscreenCanvas(c, l)), d = new OffscreenCanvas(c, l);
      this.endComputePassEncoder(), m.map((h, g) => {
        let x = h.getContext("webgpu");
        return x.configure({ device: this.device, format: "bgra8unorm", usage: GPUTextureUsage.COPY_DST, alphaMode: s[g] }), x.getCurrentTexture();
      }).map((h, g) => {
        let x = c * 4, b = (R, D, P) => {
          this.ensureCommandEncoderReady(), this.commandEncoder.copyBufferToTexture({ buffer: a, bytesPerRow: x, offset: P }, { texture: h }, { width: R, height: D }), this.submitQueue();
          let O = d.getContext("2d", { willReadFrequently: true });
          O.clearRect(0, 0, R, D), O.drawImage(m[g], 0, 0);
          let M = O.getImageData(0, 0, R, D).data, L = s[g], B = new Uint8ClampedArray(u, P, R * D * 4);
          for (let z = 0; z < B.length; z += 4)
            if (L === "premultiplied")
              B[z + 3] = M[z + 3];
            else {
              let U = M[z];
              B[z] = M[z + 2], B[z + 1] = M[z + 1], B[z + 2] = U;
            }
        }, C = Math.floor(p / (c * l)), S = c, k = l, _ = 0;
        for (let R = 0; R < C; R++)
          b(S, k, _), _ += c * l * 4;
        let E = p % (c * l);
        k = Math.floor(E / c), k > 0 && (b(S, k, _), _ += k * (c * 4)), S = E % c, S > 0 && b(S, 1, _);
      });
      let f = y.convertBackendValuesAndArrayBuffer(u, t8.dtype);
      return this.convertAndCacheOnCPU(e8, f), f;
    }
    async read(e8) {
      if (!this.tensorMap.has(e8))
        throw new Error(`Tensor ${e8} was not registered!`);
      let t8 = this.tensorMap.get(e8), { values: o8 } = t8;
      if (o8 != null)
        return o8;
      let n8;
      if (t8.dtype === "complex64") {
        let s = await Promise.all([this.read(t8.complexTensorInfos.real.dataId), this.read(t8.complexTensorInfos.imag.dataId)]), a = s[0], i10 = s[1];
        n8 = w.mergeRealAndImagArrays(a, i10);
      } else {
        let s = await this.getBufferData(t8.resource);
        n8 = y.convertBackendValuesAndArrayBuffer(s, t8.dtype);
      }
      return this.convertAndCacheOnCPU(e8, n8), n8;
    }
    copyBuffer(e8) {
      let t8 = e8.size, o8 = e8.usage, n8 = this.bufferManager.acquireBuffer(t8, o8);
      return this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e8, 0, n8, 0, t8), this.submitQueue(), n8;
    }
    createTensorFromGPUData(e8, t8, o8) {
      let n8 = e8.buffer;
      if (o8 === "complex64")
        throw new Error("Cannot write to a complex64 dtype. ");
      let s = { id: this.nextDataId() };
      this.tensorMap.set(s, { dtype: o8, shape: t8, values: null, refCount: 1, external: e8.zeroCopy });
      let a = this.tensorMap.get(s), i10 = Kg(a.dtype) * y.sizeFromShape(a.shape);
      if (e8.buffer.size < i10)
        throw new Error(`GPUBuffer size(${e8.buffer.size}) is smaller than tensor size(${i10})!`);
      if ((e8.buffer.usage & (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) !== (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC))
        throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");
      return e8.zeroCopy !== true && (n8 = this.copyBuffer(n8)), a.resource = n8, ur().makeTensorFromDataId(s, t8, o8, this);
    }
    readToGPU(e8) {
      let t8 = this.tensorMap.get(e8), { values: o8, dtype: n8, shape: s, resource: a } = t8;
      if (n8 === "complex64")
        throw new Error("Does not support reading buffer for complex64 dtype.");
      if (a == null)
        throw o8 != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
      let i10 = a, p = i10.size, u = i10.usage, c = this.bufferManager.acquireBuffer(p, u);
      this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(a, 0, c, 0, p), this.submitQueue();
      let l = this.makeTensorInfo(s, n8), m = ur().makeTensorFromTensorInfo(l), d = this.tensorMap.get(l.dataId);
      return d.resource = c, { tensorRef: m, buffer: c };
    }
    bufferSync(e8) {
      let t8 = this.readSync(e8.dataId);
      if (e8.dtype === "string")
        try {
          let o8 = t8.map((n8) => y.decodeString(n8));
          return me(e8.shape, e8.dtype, o8);
        } catch (o8) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      return me(e8.shape, e8.dtype, t8);
    }
    async time(e8) {
      !this.supportTimestampQuery && !this.hasTimestampQueryWarned && (console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."), this.hasTimestampQueryWarned = true);
      let t8 = this.activeTimers, o8 = [], n8 = false;
      this.programTimersStack == null ? (this.programTimersStack = o8, n8 = true) : this.activeTimers.push(o8), this.activeTimers = o8, e8();
      let s = y.flatten(this.activeTimers.map((u) => u.query)).filter((u) => u != null), a = y.flatten(this.activeTimers.map((u) => u.name)).filter((u) => u != null);
      this.activeTimers = t8, n8 && (this.programTimersStack = null);
      let i10 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null }, p = await Promise.all(s);
      return i10.kernelMs = y.sum(p), i10.getExtraProfileInfo = () => p.map((u, c) => ({ name: a[c], ms: u })).map((u) => `${u.name}: ${u.ms}`).join(", "), this.uploadWaitMs = 0, this.downloadWaitMs = 0, i10;
    }
    makeTensorInfo(e8, t8, o8) {
      return t8 === "string" && o8 != null && o8.length > 0 && y.isString(o8[0]) && (o8 = o8.map((s) => y.encodeString(s))), { dataId: this.write(o8, e8, t8), shape: e8, dtype: t8 };
    }
    tensorToBinding(e8) {
      if (!e8)
        return null;
      let o8 = this.tensorMap.get(e8.dataId).resource;
      return o8 instanceof GPUBuffer ? { buffer: o8 } : o8 instanceof GPUTexture ? o8.createView() : o8;
    }
    uploadToGPU(e8) {
      let t8 = this.tensorMap.get(e8);
      if (t8.resource != null)
        return;
      let o8 = Kg(t8.dtype) * y.sizeFromShape(t8.shape), n8, s = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
      if (t8.values) {
        if (n8 = this.bufferManager.acquireBuffer(o8, s, true), n8.mapState === "unmapped") {
          let a = this.bufferManager.acquireBuffer(o8, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, true, false), i10 = a.getMappedRange();
          t8.dtype === "int32" || t8.dtype === "bool" ? new Int32Array(i10).set(t8.values) : new Float32Array(i10).set(t8.values), a.unmap(), this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(a, 0, n8, 0, o8), this.stagingPendingDisposal.push(a);
        } else {
          let a = n8.getMappedRange();
          t8.dtype === "int32" || t8.dtype === "bool" ? new Int32Array(a).set(t8.values) : new Float32Array(a).set(t8.values), n8.unmap();
        }
        t8.values = null;
      } else
        n8 = this.bufferManager.acquireBuffer(o8, s);
      t8.resource = n8;
    }
    makeUniforms(e8) {
      let t8 = 0, o8 = 0, n8 = [], s = 1;
      e8.forEach((p) => {
        p.data.length === 0 && (p.data = [1]);
        let u;
        switch (p.data.length) {
          case 1:
            u = 4;
            break;
          case 2:
            u = 8;
            break;
          case 3:
            u = 16;
            break;
          case 4:
            u = 16;
            break;
          case 5:
            u = 16;
            break;
          case 6:
            u = 16;
            break;
          default:
            y.assert(false, () => `Unsupported ${p.data.length}D shape`);
        }
        (o8 === 5 || o8 === 6) && (u = 16), u > s && (s = u), t8 = Math.ceil(t8 / u) * u, o8 = p.data.length, n8.push(t8), t8 += p.data.length * 4;
      }), t8 = Math.ceil(t8 / s) * s;
      let a = new ArrayBuffer(t8);
      e8.forEach((p, u) => {
        let c = n8[u];
        p.type === "int32" ? new Int32Array(a, c, p.data.length).set(p.data) : p.type === "uint32" ? new Uint32Array(a, c, p.data.length).set(p.data) : new Float32Array(a, c, p.data.length).set(p.data);
      });
      let i10 = this.bufferManager.acquireBuffer(t8, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
      return this.queue.writeBuffer(i10, 0, a, 0, t8), this.uniformPendingDisposal.push(i10), { offset: 0, size: t8, buffer: i10 };
    }
    runWebGPUProgram(e8, t8, o8, n8, s) {
      if (s || (s = this.makeTensorInfo(e8.outputShape, o8)), y.sizeFromShape(s.shape) === 0)
        return this.tensorMap.get(s.dataId).values = y.getTypedArrayFromDType(s.dtype, 0), s;
      this.uploadToGPU(s.dataId), e8.dispatch = eae(this.device, e8);
      let a = t8.map((p, u) => {
        if (p.dtype === "complex64")
          throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        return this.uploadToGPU(p.dataId), { dtype: this.tensorMap.get(p.dataId).dtype, shape: p.shape, name: e8.variableNames[u] };
      });
      e8.shaderKey = UB(e8, a, s);
      let i10 = A().getBool("WEBGPU_ENGINE_COMPILE_ONLY");
      return e8.shaderKey in this.pipelineCache || (this.pipelineCache[e8.shaderKey] = WB(this.device, e8, a, s, i10)), e8.pipeline = this.pipelineCache[e8.shaderKey], i10 || this.recordAndSubmit(e8, s, t8, n8), s;
    }
    recordAndSubmit(e8, t8, o8, n8) {
      if (e8.pipeline instanceof Promise)
        throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");
      let s = [], a = [];
      if (!e8.isFromPixels) {
        s.push({ type: "float32", data: [NaN] }, { type: "float32", data: [1 / 0] }), a = o8.concat(t8).map((m) => m.shape);
        let l = "int32";
        if (a.map((m) => {
          s.push({ type: l, data: m });
          let d = y.computeStrides(m);
          s.push({ type: l, data: d });
        }), e8.size) {
          let m = y.sizeFromShape(e8.outputShape);
          s.push({ type: l, data: [e8.outputComponent ? m / e8.outputComponent : m] });
        }
      }
      n8 && (s = [...s, ...n8]);
      let i10 = [this.tensorToBinding(t8), ...o8.map((l) => this.tensorToBinding(l)), this.makeUniforms(s)];
      o8.forEach((l) => {
        this.commandQueueOwnedIds.add(l.dataId);
      }), this.commandQueueOwnedIds.add(t8.dataId);
      let p = this.device.createBindGroup({ layout: e8.pipeline.getBindGroupLayout(0), entries: i10.map((l, m) => ({ binding: m, resource: l })) }), u = this.activeTimers != null;
      this.ensureCommandEncoderReady();
      let c = {};
      u && this.supportTimestampQuery ? (this.endComputePassEncoder(), this.querySet == null && (this.querySet = this.device.createQuerySet({ type: "timestamp", count: this.querySetCount })), c.timestampWrites = [{ querySet: this.querySet, queryIndex: 0, location: "beginning" }, { querySet: this.querySet, queryIndex: 1, location: "end" }], this.computePassEncoder = this.commandEncoder.beginComputePass(c)) : this.computePassEncoder || (this.computePassEncoder = this.commandEncoder.beginComputePass(c)), this.computePassEncoder.setPipeline(e8.pipeline), this.computePassEncoder.setBindGroup(0, p), this.computePassEncoder.dispatchWorkgroups(e8.dispatch[0], e8.dispatch[1], e8.dispatch[2]), this.dispatchCountInPass++, (u || A().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchCountInPass) && (this.endComputePassEncoder(), u ? this.activeTimers.push({ name: e8.constructor.name, query: this.getQueryTime() }) : this.submitQueue());
    }
    async getQueryTime() {
      if (!this.supportTimestampQuery)
        return 0;
      this.queryResolveBuffer == null && (this.queryResolveBuffer = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.QUERY_RESOLVE)), this.commandEncoder.resolveQuerySet(this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);
      let e8 = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, e8, 0, this.querySetCount * 8), this.submitQueue(), await e8.mapAsync(GPUMapMode.READ);
      let t8 = new BigUint64Array(e8.getMappedRange()), o8 = Number(t8[1] - t8[0]) / 1e6;
      return e8.unmap(), this.bufferManager.releaseBuffer(e8), o8;
    }
    shouldExecuteOnCPU(e8, t8 = Jse) {
      return A().getBool("WEBGPU_CPU_FORWARD") && e8.every((o8) => this.tensorMap.get(o8.dataId).resource == null && y.sizeFromShape(o8.shape) < t8);
    }
    numDataIds() {
      return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;
    }
    dispose() {
      this.disposed || (this.querySet != null && this.querySet.destroy(), this.bufferManager.dispose(), this.textureManager.dispose(), this.disposed = true);
    }
  };
  vu.nextDataId = 0;
  cm() && nu("webgpu", async () => {
    let r8 = { powerPreference: A().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance" }, e8 = await navigator.gpu.requestAdapter(r8), t8 = {};
    e8.features.has("timestamp-query") && (t8.requiredFeatures = ["timestamp-query"]);
    let o8 = e8.limits;
    t8.requiredLimits = { maxComputeWorkgroupStorageSize: o8.maxComputeWorkgroupStorageSize, maxComputeWorkgroupsPerDimension: o8.maxComputeWorkgroupsPerDimension, maxStorageBufferBindingSize: o8.maxStorageBufferBindingSize, maxBufferSize: o8.maxBufferSize, maxComputeWorkgroupSizeX: o8.maxComputeWorkgroupSizeX, maxComputeInvocationsPerWorkgroup: o8.maxComputeInvocationsPerWorkgroup };
    let n8 = await e8.requestDevice(t8), s = await e8.requestAdapterInfo();
    return new vu(n8, s);
  }, 3);
  var fe;
  (function(r8) {
    r8[r8.ADD = 0] = "ADD", r8[r8.ATAN2 = 1] = "ATAN2", r8[r8.COMPLEX_MULTIPLY_IMAG = 2] = "COMPLEX_MULTIPLY_IMAG", r8[r8.COMPLEX_MULTIPLY_REAL = 3] = "COMPLEX_MULTIPLY_REAL", r8[r8.DIV = 4] = "DIV", r8[r8.ELU_DER = 5] = "ELU_DER", r8[r8.EQUAL = 6] = "EQUAL", r8[r8.GREATER = 7] = "GREATER", r8[r8.GREATER_EQUAL = 8] = "GREATER_EQUAL", r8[r8.INT_DIV = 9] = "INT_DIV", r8[r8.LESS = 10] = "LESS", r8[r8.LESS_EQUAL = 11] = "LESS_EQUAL", r8[r8.LOGICAL_AND = 12] = "LOGICAL_AND", r8[r8.LOGICAL_OR = 13] = "LOGICAL_OR", r8[r8.MAX = 14] = "MAX", r8[r8.MIN = 15] = "MIN", r8[r8.MOD = 16] = "MOD", r8[r8.MUL = 17] = "MUL", r8[r8.NOT_EQUAL = 18] = "NOT_EQUAL", r8[r8.POW = 19] = "POW", r8[r8.PRELU = 20] = "PRELU", r8[r8.SQUARED_DIFFERENCE = 21] = "SQUARED_DIFFERENCE", r8[r8.SUB = 22] = "SUB";
  })(fe || (fe = {}));
  var tae = "return a + b;";
  var rae = "var resultTemp = atan2(a, b);";
  var oae = "return areal * breal - aimag * bimag;";
  var nae = "return areal * bimag + aimag * breal;";
  var sae = "return a / b;";
  var aae = "return select(a * (b + 1.0), a, b >= 0.);";
  var iae = "return select(a * (b + vec4<f32>(1.0)), a, b >= vec4<f32>(0.));";
  var uae = "return f32(a == b);";
  var pae = "return vec4<f32>(a == b);";
  var cae = "return f32(a > b);";
  var lae = "return vec4<f32>(a > b);";
  var mae = "return f32(a >= b);";
  var dae = "return vec4<f32>(a >= b);";
  var fae = `
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
`;
  var hae = `
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
`;
  var gae = "return f32(a < b);";
  var xae = "return vec4<f32>(a < b);";
  var yae = "return f32(a <= b);";
  var bae = "return vec4<f32>(a <= b);";
  var Cae = "return f32(a >= 1.0 && b >= 1.0);";
  var wae = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`;
  var Sae = "return f32(a >= 1.0 || b >= 1.0);";
  var Iae = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`;
  var vae = "var resultTemp = max(a, b);";
  var kae = "var resultTemp = min(a, b);";
  var Nae = `
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`;
  var Tae = `
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`;
  var _ae = "return a * b;";
  var $ae = `
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`;
  var Eae = `
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`;
  var Rae = `
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`;
  var Dae = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`;
  var Aae = "if (a < 0.0) { return b * a; }  return a;";
  var Fae = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`;
  var Pae = "return (a - b) * (a - b);";
  var Oae = "return a - b;";
  function qc(r8, e8) {
    let t8;
    do {
      switch (r8) {
        case fe.ATAN2:
          t8 = rae;
          break;
        case fe.MAX:
          t8 = vae;
          break;
        case fe.MIN:
          t8 = kae;
          break;
        case fe.MOD:
          t8 = e8 ? Tae : Nae;
          break;
        case fe.NOT_EQUAL:
          t8 = e8 ? Eae : $ae;
          break;
        case fe.POW:
          t8 = e8 ? Dae : Rae;
          break;
        default:
          continue;
      }
      let o8, n8, s;
      return e8 ? (o8 = "isnanVec4", n8 = "vec4<f32>", s = "vec4<bool>") : (o8 = "isnan", n8 = "f32", s = "bool"), `
      let aIsNaN = ${o8}(a);
      let aPostLegalization = select(a, ${n8}(42), aIsNaN);
      let bIsNaN = ${o8}(b);
      let bPostLegalization = select(b, ${n8}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t8}
        return select(
            resultTemp, ${n8}(valueForNaN),
            ${s}(isNaN) | aIsNaN | bIsNaN);
      }
    `;
    } while (false);
    switch (r8) {
      case fe.ADD:
        return tae;
      case fe.COMPLEX_MULTIPLY_IMAG:
        return nae;
      case fe.COMPLEX_MULTIPLY_REAL:
        return oae;
      case fe.DIV:
        return sae;
      case fe.ELU_DER:
        return e8 ? iae : aae;
      case fe.EQUAL:
        return e8 ? pae : uae;
      case fe.GREATER:
        return e8 ? lae : cae;
      case fe.GREATER_EQUAL:
        return e8 ? dae : mae;
      case fe.INT_DIV:
        return e8 ? hae : fae;
      case fe.LESS:
        return e8 ? xae : gae;
      case fe.LESS_EQUAL:
        return e8 ? bae : yae;
      case fe.LOGICAL_AND:
        return e8 ? wae : Cae;
      case fe.LOGICAL_OR:
        return e8 ? Iae : Sae;
      case fe.MUL:
        return _ae;
      case fe.PRELU:
        return e8 ? Fae : Aae;
      case fe.SQUARED_DIFFERENCE:
        return Pae;
      case fe.SUB:
        return Oae;
    }
    return `
    ${t8}
    return resultTemp;
  `;
  }
  var Z;
  (function(r8) {
    r8[r8.ABS = 0] = "ABS", r8[r8.ACOS = 1] = "ACOS", r8[r8.ACOSH = 2] = "ACOSH", r8[r8.ASIN = 3] = "ASIN", r8[r8.ASINH = 4] = "ASINH", r8[r8.ATAN = 5] = "ATAN", r8[r8.ATANH = 6] = "ATANH", r8[r8.CEIL = 7] = "CEIL", r8[r8.COS = 8] = "COS", r8[r8.COSH = 9] = "COSH", r8[r8.ELU = 10] = "ELU", r8[r8.ERF = 11] = "ERF", r8[r8.EXP = 12] = "EXP", r8[r8.EXPM1 = 13] = "EXPM1", r8[r8.FLOOR = 14] = "FLOOR", r8[r8.IS_FINITE = 15] = "IS_FINITE", r8[r8.IS_INF = 16] = "IS_INF", r8[r8.IS_NAN = 17] = "IS_NAN", r8[r8.LINEAR = 18] = "LINEAR", r8[r8.LOG = 19] = "LOG", r8[r8.LOG1P = 20] = "LOG1P", r8[r8.LOGICAL_NOT = 21] = "LOGICAL_NOT", r8[r8.NEG = 22] = "NEG", r8[r8.RELU = 23] = "RELU", r8[r8.RELU6 = 24] = "RELU6", r8[r8.LEAKYRELU = 25] = "LEAKYRELU", r8[r8.RECIPROCAL = 26] = "RECIPROCAL", r8[r8.ROUND = 27] = "ROUND", r8[r8.RSQRT = 28] = "RSQRT", r8[r8.SELU = 29] = "SELU", r8[r8.SIGMOID = 30] = "SIGMOID", r8[r8.SIGN = 31] = "SIGN", r8[r8.SIN = 32] = "SIN", r8[r8.SINH = 33] = "SINH", r8[r8.SOFTPLUS = 34] = "SOFTPLUS", r8[r8.SQRT = 35] = "SQRT", r8[r8.SQUARE = 36] = "SQUARE", r8[r8.STEP = 37] = "STEP", r8[r8.TAN = 38] = "TAN", r8[r8.TANH = 39] = "TANH", r8[r8.TO_INT = 40] = "TO_INT";
  })(Z || (Z = {}));
  var Mae = "return abs(a);";
  var Lae = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`;
  var Bae = `
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`;
  var zae = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`;
  var Vae = "return asinh(a);";
  var Wae = `
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`;
  var Uae = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`;
  var Gae = "return ceil(a);";
  var Hae = "return cos(a);";
  var Kae = `
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`;
  var qae = "return exp(a) - 1.0;";
  var jae = "if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";
  var Xae = `
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`;
  var Yae = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${w.ERF_P};
  let a1 = ${w.ERF_A1};
  let a2 = ${w.ERF_A2};
  let a3 = ${w.ERF_A3};
  let a4 = ${w.ERF_A4};
  let a5 = ${w.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`;
  var Qae = "return exp(a);";
  var Zae = "return floor(a);";
  var Jae = "return f32(!isnan(a) && !isinf(a));";
  var eie = "return f32(isinf(a));";
  var tie = "return f32(isnan(a));";
  var rie = "return a;";
  var oie = `if (a < 0.0) { return uniforms.NAN; }
  return log(a);`;
  var nie = `
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`;
  var sie = "return f32(!(a >= 1.0));";
  var aie = "return -a;";
  var iie = "if (a < 0.0) { return uniforms.alpha * a; } return a;";
  var uie = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`;
  var pie = "return 1.0 / a;";
  var cie = "return select(a, 0.0, a < 0.0);";
  var lie = "return clamp(a, 0.0, 6.0);";
  var mie = "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));";
  var die = `
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`;
  var fie = "return round(a);";
  var hie = "return inverseSqrt(a);";
  var gie = `
  if (a >= 0.0) {
    return ${w.SELU_SCALE} * a;
  } else {
    return ${w.SELU_SCALEALPHA} * (exp(a) - 1.0);
  }
`;
  var xie = "return 1.0 / (1.0 + exp(-1.0 * a));";
  var yie = "return sign(a);";
  var bie = "return sin(a);";
  var Cie = `
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`;
  var wie = `
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`;
  var Sie = "return sqrt(a);";
  var Iie = "return a * a;";
  var vie = `
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`;
  var kie = "return tan(a);";
  var Nie = `
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;
  var Tie = "return f32(i32((a)));";
  function wi(r8, e8) {
    switch (r8) {
      case Z.ABS:
        return Mae;
      case Z.ACOS:
        return Lae;
      case Z.ACOSH:
        return Bae;
      case Z.ASIN:
        return zae;
      case Z.ASINH:
        return Vae;
      case Z.ATAN:
        return Wae;
      case Z.ATANH:
        return Uae;
      case Z.COS:
        return Hae;
      case Z.COSH:
        return Kae;
      case Z.CEIL:
        return Gae;
      case Z.ELU:
        return e8 ? Xae : jae;
      case Z.ERF:
        return Yae;
      case Z.EXP:
        return Qae;
      case Z.EXPM1:
        return qae;
      case Z.FLOOR:
        return Zae;
      case Z.IS_FINITE:
        return Jae;
      case Z.IS_INF:
        return eie;
      case Z.IS_NAN:
        return tie;
      case Z.LINEAR:
        return rie;
      case Z.LOG:
        return oie;
      case Z.LOG1P:
        return nie;
      case Z.LOGICAL_NOT:
        return sie;
      case Z.NEG:
        return aie;
      case Z.LEAKYRELU:
        return e8 ? uie : iie;
      case Z.RECIPROCAL:
        return pie;
      case Z.RELU:
        return e8 ? die : cie;
      case Z.RELU6:
        return e8 ? mie : lie;
      case Z.ROUND:
        return fie;
      case Z.RSQRT:
        return hie;
      case Z.SELU:
        return gie;
      case Z.SIGMOID:
        return xie;
      case Z.SIGN:
        return yie;
      case Z.SIN:
        return bie;
      case Z.SINH:
        return Cie;
      case Z.SOFTPLUS:
        return wie;
      case Z.SQRT:
        return Sie;
      case Z.SQUARE:
        return Iie;
      case Z.STEP:
        return vie;
      case Z.TAN:
        return kie;
      case Z.TANH:
        return Nie;
      case Z.TO_INT:
        return Tie;
      default:
        throw new Error(`BinaryType ${r8} is not implemented!`);
    }
  }
  function dr(r8, e8 = false, t8 = false, o8 = 3) {
    if (r8 === null)
      return "";
    let n8 = "";
    if (r8 === "linear")
      n8 = wi(Z.LINEAR);
    else if (r8 === "relu")
      n8 = wi(Z.RELU, t8);
    else if (r8 === "elu")
      n8 = wi(Z.ELU, t8);
    else if (r8 === "relu6")
      n8 = wi(Z.RELU6, t8);
    else if (r8 === "prelu")
      n8 = qc(fe.PRELU, t8);
    else if (r8 === "sigmoid")
      n8 = wi(Z.SIGMOID, t8);
    else if (r8 === "leakyrelu")
      n8 = wi(Z.LEAKYRELU, t8);
    else
      throw new Error(`Activation ${r8} has not been implemented for the WebGPU backend.`);
    let a = Ae(t8 ? 4 : 1), i10 = "";
    return e8 ? i10 = `
      fn activation(a : ${a}, coords : vec${o8}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${n8}
      }` : i10 = `
      fn activation(a : ${a}, coords : vec${o8}<i32>) -> ${a} {
        ${n8}
      }`, i10;
  }
  function Qr(r8, e8) {
    return `
      ${r8 ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${e8 ? "value = activation(value, coords);" : ""}
      `;
  }
  function Uv(r8, e8, t8 = false, o8 = false, n8 = false, s = 1) {
    y.assert(r8 && s === 1 || !r8, () => `transposeA ${r8} is not compatible with component size ${s}`);
    let a = `
      ${r8 ? "value = getA(batch, col, row);" : "value = getA(batch, row, col);"}

    `, i10 = e8 ? "value = getB(batch, col, row);" : "value = getB(batch, row, col);";
    return `
  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ${Ae(s)} {
    var value = ${Ae(s)}(0.0);
    let col = colIn * ${s};
    ${t8 && n8 ? a : `
    ${r8 ? "if(row < uniforms.dimAOuter && col < uniforms.dimInner)" : "if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${a}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ${Ae(s)} {
    let col = colIn * ${s};
    var value = ${Ae(s)}(0.0);
    ${i10}
    return value;
  }
  `;
  }
  function mm(r8, e8, t8, o8, n8 = false, s = false, a = false, i10 = 1) {
    return `
  ${Uv(t8, o8, n8, s, a, i10)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ae(i10)}) {
    let col = colIn * ${i10};
    ${n8 && s ? "" : "if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Qr(r8, e8)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `;
  }
  var _ie = (r8, e8) => r8 ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart / ${e8} + inputCol);
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart / ${e8} + inputCol);
        `;
  var $ie = (r8, e8, t8) => r8 ? `
        let ACached0 = mm_Asub[k * ${e8}][localRow];
        let ACached1 = mm_Asub[k * ${e8} + 1][localRow];
        let ACached2 = mm_Asub[k * ${e8} + 2][localRow];
        ${e8 === 3 ? "" : `let ACached3 = mm_Asub[k * ${e8} + 3][localRow];`}
        for (var i = 0; i < ${t8}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
          acc[i] = fma(BCached1, vec4<f32>(ACached1[i]), acc[i]);
          acc[i] = fma(BCached2, vec4<f32>(ACached2[i]), acc[i]);
          ${e8 === 3 ? "" : "acc[i] = fma(BCached3, vec4<f32>(ACached3[i]), acc[i]);"}
        }` : `
        for (var i = 0; i < ${t8}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = fma(BCached0, vec4<f32>(ACached.x), acc[i]);
          acc[i] = fma(BCached1, vec4<f32>(ACached.y), acc[i]);
          acc[i] = fma(BCached2, vec4<f32>(ACached.z), acc[i]);
          ${e8 === 3 ? "" : "acc[i] = fma(BCached3, vec4<f32>(ACached.w), acc[i]);"}
        }`;
  function Rp(r8, e8, t8 = false, o8 = 32, n8 = false, s = 32, a = false) {
    let i10 = e8[1] * r8[1], p = e8[0] * r8[0], u = t8 ? i10 : o8, c = t8 ? o8 : i10, l = u / e8[0], m = o8 / e8[1], d = r8[1];
    return y.assert((t8 && l === 4 && r8[1] === 4 || !t8 && (l === 3 || l === 4)) && u % e8[0] === 0 && o8 % e8[1] === 0 && r8[0] === 4, () => `If transposeA ${t8} is true, innerElementSize ${l} and workPerThread[1] ${r8[1]} must be 4.
          Otherwise, innerElementSize ${l} must be 3 or 4.
      tileAWidth ${u} must be divisible by workgroupSize[0]${e8[0]}. tileInner ${o8} must be divisible by workgroupSize[1] ${e8[1]}. colPerThread ${r8[0]} must be 4.`), `
  var<workgroup> mm_Asub : array<array<vec${l}<f32>, ${u / l}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${p / r8[0]}>, ${o8}>;

  ${H()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${d};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${d};
    let globalCol = i32(globalId.x);
    let batch = ${n8 ? "0" : "i32(globalId.z)"};
    let batchA = ${n8 || !a ? "batch" : "batch % uniforms.aShape[0]"};
    let batchB = ${n8 || !a ? "batch" : "batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${i10};

    let numTiles = ${n8 ? `${Math.ceil(s / o8)}` : `(uniforms.dimInner - 1) / ${o8} + 1`};
    var kStart = ${n8 ? `i32(globalId.z) * ${s}` : "0"};

    var acc: array<vec4<f32>, ${d}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${m};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${_ie(t8, l)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${o8};
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${o8 / l}; k++) {
            let BCached0 = mm_Bsub[k * ${l}][tileCol];
            let BCached1 = mm_Bsub[k * ${l} + 1][tileCol];
            let BCached2 = mm_Bsub[k * ${l} + 2][tileCol];
            ${l === 3 ? "" : `let BCached3 = mm_Bsub[k * ${l} + 3][tileCol];`}

            ${$ie(t8, l, d)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`;
  }
  var HB = (r8) => r8 ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `;
  var Eie = (r8) => r8 ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
  function Dp(r8, e8, t8 = false, o8 = 32, n8 = false, s = 32, a = false, i10 = false) {
    let p = r8[1] * e8[1], u = r8[0] * e8[0], c = t8 ? p : o8, l = t8 ? o8 : p;
    y.assert(l % e8[1] === 0 && c % e8[0] === 0 && o8 % e8[1] === 0, () => `tileAHight ${l} must be divisible by workgroupSize[1]${e8[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e8[0]}, tileInner ${o8} must be divisible by workgroupSize[1]${e8[1]}`);
    let m = l / e8[1], d = c / e8[0], f = o8 / e8[1], h = r8[1], g = r8[0], x = a ? `
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${p};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${l}; inputRow = inputRow + ${e8[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e8[0]}) {
            ${HB(t8)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${o8}; inputRow = inputRow + ${e8[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e8[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${o8};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${o8}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e8[0]}];
          }
          for (var innerRow = 0; innerRow < ${h}; innerRow++) {
            let ACached = ${t8 ? `mm_Asub[k][localRow + innerRow * ${e8[1]}];` : `mm_Asub[localRow + innerRow * ${e8[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${h}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e8[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e8[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      ` : `
  let tileRow = i32(localId.y) * ${h};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${h};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${p};

  let tileRowA = i32(localId.y) * ${m};
  let tileColA = i32(localId.x) * ${d};
  let tileRowB = i32(localId.y) * ${f};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${d}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${HB(t8)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${o8};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${o8}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${h}; innerRow++) {
        ${Eie(t8)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${h}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;
    return `
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${l}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${o8}>;

    ${H()} {
      let batch = ${n8 ? "0" : "i32(globalId.z)"};
      let batchA = ${n8 || !i10 ? "batch" : "batch % uniforms.aShape[0]"};
      let batchB = ${n8 || !i10 ? "batch" : "batch % uniforms.bShape[0]"};
      let numTiles = ${n8 ? `${Math.ceil(s / o8)}` : `(uniforms.dimInner - 1) / ${o8} + 1`};
      var kStart = ${n8 ? `i32(globalId.z) * ${s}` : "0"};

      var acc : array<array<f32, ${g}>, ${h}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${h}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${x}
    }
  `;
  }
  var Rie = (r8) => r8 ? `
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  ` : `
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;
  function Die(r8, e8 = false) {
    y.assert(r8[1] === 1 && r8[2] === 1, () => `A linear work group size is required. But got ${r8}.`);
    let t8 = r8[0] * 4;
    return `
    var<workgroup> mm_Asub : array<vec4<f32>, ${r8[0]}>;

    ${H()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t8} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t8} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Rie(e8)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t8 / 4}; k++) {
          let rowB = t * ${t8} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `;
  }
  var qg = class {
    constructor(e8, t8, o8 = false, n8 = false, s = null, a = null, i10 = null, p = false) {
      this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = t8, this.dispatchLayout = { x: [2], y: [1], z: [0] };
      let u = o8 ? e8[1] : e8[2];
      if (this.isVec4 = (u % 4 === 0 && !o8 || t8[1] % 4 === 0 && o8) && t8[2] % 4 === 0 && !n8, this.outputComponent = this.isVec4 ? 4 : 1, this.isVectorA = t8[1] === 1 && !o8, !this.isVec4 && this.isVectorA)
        this.elementsPerThread = [1, 1, 1], this.workgroupSize = [32, 1, 1];
      else {
        let m = Vv(t8[1], u, t8[2], o8);
        this.workgroupSize = m.workgroupSize, this.elementsPerThread = m.elementsPerThread;
      }
      this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
      let c = s != null, l = i10 != null;
      c && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), this.sequentialAccessByThreads = p, this.transposeA = o8, this.transposeB = n8, this.addBias = c, this.activation = a, this.hasPreluActivationWeights = l, [this.fitAOuter, this.fitBOuter, this.fitInner] = this.getShapeFit(t8[1], t8[2], u), this.shaderKey = `matMulPacked_${this.elementsPerThread}_${o8}_${n8}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`;
    }
    getShapeFit(e8, t8, o8) {
      let n8 = this.workgroupSize[1] * this.elementsPerThread[1], s = this.workgroupSize[0] * this.elementsPerThread[0];
      !this.isVec4 && this.isVectorA ? this.tileInner = this.workgroupSize[0] * 4 : this.tileInner = s;
      let a = e8 % n8 === 0, i10 = t8 % s === 0, p = o8 % this.tileInner === 0;
      return [a, i10, p];
    }
    getUserCode() {
      return `
      ${dr(this.activation, this.hasPreluActivationWeights, this.isVec4)}
      ${mm(this.addBias, this.activation, false, this.transposeB, this.fitAOuter, this.fitBOuter, this.fitInner, this.isVec4 ? 4 : 1)}
      ${this.isVec4 ? Rp(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, true) : this.isVectorA ? Die(this.workgroupSize, this.transposeA) : Dp(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, this.sequentialAccessByThreads, true)}
    `;
    }
  };
  function Aie(r8) {
    return `
    var<workgroup> sumValues : array<f32, ${r8}>;
    ${H()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${r8}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${r8 / 2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `;
  }
  var jg = class {
    constructor(e8, t8 = false, o8 = false, n8 = null, s = null, a = null) {
      this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [256, 1, 1], this.outputShape = e8, this.dispatchLayout = { x: [], y: [1, 2], z: [0] }, this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize);
      let i10 = n8 != null, p = a != null;
      i10 && this.variableNames.push("bias"), p && this.variableNames.push("preluActivationWeights"), this.transposeA = t8, this.transposeB = o8, this.addBias = i10, this.activation = s, this.hasPreluActivationWeights = p, this.shaderKey = `matMulReduce_${this.activation}_${t8}_${o8}`;
    }
    getUserCode() {
      return `
      ${dr(this.activation, this.hasPreluActivationWeights)}
      ${mm(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${Aie(this.workgroupSize[0])}
    `;
    }
  };
  function Fie(r8) {
    let e8 = r8[1], t8 = r8[0], o8 = e8 > t8 ? e8 : t8;
    return `
  var<workgroup> mm_Asub : array<array<f32, ${o8}>, ${e8}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t8}>, ${o8}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${H()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${o8} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${o8};
    globalRowB = globalRowB + ${o8};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${o8};
      globalRowB = globalRowB + ${o8};

      for (var k = 0; k < ${o8}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `;
  }
  var Xg = class {
    constructor(e8, t8, o8, n8 = false, s = false, a = null, i10 = null, p = null) {
      this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [16, 8, 1], this.outputShape = o8, this.dispatchLayout = { x: [2], y: [1], z: [0] }, this.dispatch = [Math.ceil(o8[2] / this.workgroupSize[0]), Math.ceil(o8[1] / this.workgroupSize[1]), o8[0]];
      let u = a != null;
      u && this.variableNames.push("bias");
      let c = p != null;
      c && this.variableNames.push("preluActivationWeights"), this.transposeA = n8, this.transposeB = s, this.addBias = u, this.activation = i10, this.hasPreluActivationWeights = c, this.shaderKey = `matMulSmallOutputSize_${this.activation}_${n8}_${s}`;
    }
    getUserCode() {
      return `
      ${dr(this.activation, this.hasPreluActivationWeights)}
      ${mm(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${Fie(this.workgroupSize)}
    `;
    }
  };
  var Yg = class {
    constructor(e8, t8, o8 = false, n8 = false) {
      this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [8, 8, 1], this.atomic = true, this.splitedDimInner = 128, y.assert(e8[0] === 1, () => "MatMulSplitKProgram only supports batch = 1."), this.outputShape = e8, this.dispatchLayout = { x: [2], y: [1], z: [0, 3] };
      let s = (o8 && this.outputShape[1] % 4 === 0 || !o8 && t8 % 4 === 0) && this.outputShape[2] % 4 === 0;
      this.elementsPerThread = [4, 4, this.splitedDimInner], this.outputComponent = s ? 4 : 1, s || (this.outputShape[1] < 16 && (this.elementsPerThread[1] = 1), this.outputShape[2] < 16 && (this.elementsPerThread[0] = 1)), this.dispatch = K(this.dispatchLayout, [this.outputShape[0], this.outputShape[1], this.outputShape[2], t8], this.workgroupSize, this.elementsPerThread), this.transposeA = o8, this.transposeB = n8, this.shaderKey = `matMulSplitK_${o8}_${n8}_${this.elementsPerThread}_${this.outputComponent}`;
    }
    getUserCode() {
      let e8 = this.outputComponent;
      return `
      ${Uv(false, this.transposeB, false, false, false, e8)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${Ae(e8)}) {
        let col = colIn * ${e8};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e8}; i = i + 1) {
            ${Us("&result[flatIndex + i]", `${e8 > 1 ? "value[i]" : "value"}`, "float32")}
          }
        }
      }
      ${e8 === 4 ? Rp(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) : Dp(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
    }
  };
  var Qg = class {
    constructor(e8, t8 = null, o8 = null, n8 = null) {
      this.uniforms = "", this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = t8 != null, this.hasPreluActivationWeights = n8 != null, this.activation = o8, this.addBias && this.variableNames.push("bias"), this.hasPreluActivationWeights && this.variableNames.push("preluActivationWeights"), this.shaderKey = `biasActivation_${o8}`;
    }
    getUserCode() {
      return `
    ${dr(this.activation, this.hasPreluActivationWeights)}
    ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Qr(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
    }
  };
  var Zg = class {
    constructor(e8) {
      this.variableNames = [], this.outputShape = [], this.uniforms = "value : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "fill";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;
    }
  };
  function Vt(r8) {
    let { backend: e8, attrs: t8 } = r8, { shape: o8, value: n8 } = t8, { dtype: s } = t8;
    if (s = s || y.inferDtype(n8), s === "string") {
      let a = y.getArrayFromDType(s, y.sizeFromShape(o8));
      return a.fill(n8), e8.makeTensorInfo(o8, s, a);
    } else {
      let a = new Zg(o8), i10 = [{ type: "float32", data: [n8] }];
      return e8.runWebGPUProgram(a, [], s, i10);
    }
  }
  var KB = { kernelName: na, backendName: "webgpu", kernelFunc: Vt };
  function pe(r8) {
    let { inputs: e8, attrs: t8 } = r8, { x: o8 } = e8, { shape: n8 } = t8, s = y.sizeFromShape(o8.shape), a = y.inferFromImplicitShape(n8, s), i10 = y.sizeFromShape(a);
    return y.assert(s === i10, () => `The new shape (${a}) has ${i10} elements and the old shape (${o8.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`), r8.backend.incRef(o8.dataId), { dataId: o8.dataId, shape: a, dtype: o8.dtype };
  }
  var qB = { kernelName: ma, backendName: "webgpu", kernelFunc: pe };
  function Ap({ a: r8, b: e8, transposeA: t8, transposeB: o8, backend: n8, bias: s = null, preluActivationWeights: a = null, leakyreluAlpha: i10 = 0, activation: p = null }) {
    let u = r8.shape.length, c = e8.shape.length, l = t8 ? r8.shape[u - 2] : r8.shape[u - 1], m = o8 ? e8.shape[c - 1] : e8.shape[c - 2], d = t8 ? r8.shape[u - 1] : r8.shape[u - 2], f = o8 ? e8.shape[c - 2] : e8.shape[c - 1], h = r8.shape.slice(0, -2), g = e8.shape.slice(0, -2), x = y.sizeFromShape(h), b = y.sizeFromShape(g), S = Ir.assertAndGetBroadcastShape(r8.shape.slice(0, -2), e8.shape.slice(0, -2)).concat([d, f]);
    y.assert(l === m, () => `Error in matMul: inner shapes (${l}) and (${m}) of Tensors with shapes ${r8.shape} and ${e8.shape} and transposeA=${t8} and transposeB=${o8} must match.`);
    let k = t8 ? [x, l, d] : [x, d, l], _ = o8 ? [b, f, m] : [b, m, f], E = pe({ inputs: { x: r8 }, backend: n8, attrs: { shape: k } }), R = pe({ inputs: { x: e8 }, backend: n8, attrs: { shape: _ } }), D = [E, R], P = Math.max(x, b), O = [E, R], M = [{ type: "int32", data: [d] }, { type: "int32", data: [f] }, { type: "int32", data: [l] }], L, B, z = [P, d, f], U = A().get("WEBGPU_MATMUL_PROGRAM_TYPE");
    if (U < 0) {
      let q = A().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), Y = q > 0 ? q : n8.thresholdToIncreaseWorkgroups, J = P * Math.ceil(d / 32) * Math.ceil(f / 32);
      J <= Y || d <= 8 && J <= Y * 2 ? P * d * f <= 128 ? U = Mo.MatMulReduceProgram : P === 1 && m >= 2e3 ? U = Mo.MatMulSplitKProgram : U = Mo.MatMulSmallOutputSizeProgram : U = Mo.MatMulPackedProgram;
    }
    switch (U) {
      case Mo.MatMulReduceProgram:
        L = new jg(z, t8, o8, s, p, a);
        break;
      case Mo.MatMulSplitKProgram: {
        if (B = Vt({ backend: n8, attrs: { shape: z, value: 0, dtype: r8.dtype } }), L = new Yg(z, m, t8, o8), s || p) {
          B = n8.runWebGPUProgram(L, O, r8.dtype, M, B);
          let Y = new Qg(B.shape, s, p, a), J = null, re = [B];
          s && re.push(s), a && re.push(a), p === "leakyrelu" && (J = [{ type: "float32", data: [i10] }], Y.uniforms += " alpha : f32,");
          let ne = n8.runWebGPUProgram(Y, re, B.dtype, J);
          D.push(B);
          let ee = pe({ inputs: { x: ne }, backend: n8, attrs: { shape: S } });
          D.push(ne);
          for (let oe of D)
            n8.disposeData(oe.dataId);
          return ee;
        }
        break;
      }
      case Mo.MatMulSmallOutputSizeProgram:
        L = new Xg(k, _, z, t8, o8, s, p, a);
        break;
      case Mo.MatMulPackedProgram:
        let q = n8.adapterInfo.isIntel();
        L = new qg(k, z, t8, o8, s, p, a, q);
        break;
      default:
        throw new Error(`Unsupported MatMulProgramType ${U}.`);
    }
    s && O.push(s), a && O.push(a), p === "leakyrelu" && (M.push({ type: "float32", data: [i10] }), L.uniforms += " alpha : f32,"), B = n8.runWebGPUProgram(L, O, r8.dtype, M, B);
    let j = pe({ inputs: { x: B }, backend: n8, attrs: { shape: S } });
    D.push(B);
    for (let q of D)
      n8.disposeData(q.dataId);
    return j;
  }
  function Pie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s, bias: a, preluActivationWeights: i10 } = e8, { transposeA: p, transposeB: u, activation: c, leakyreluAlpha: l } = o8;
    return Ap({ a: n8, b: s, transposeA: p, transposeB: u, backend: t8, bias: a, preluActivationWeights: i10, leakyreluAlpha: l, activation: c });
  }
  var jB = { kernelName: So, backendName: "webgpu", kernelFunc: Pie };
  var dm = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.workgroupSize = [128, 1, 1], this.size = true, this.outputShape = w.assertAndGetBroadcastShape(t8, o8), this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `binaryOpComplex_${e8}`, this.op = e8;
    }
    getUserCode() {
      return `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${qc(this.op, false)}
      }

      ${H("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
    }
  };
  var Si = class {
    constructor(e8, t8, o8) {
      if (this.size = true, this.variableNames = ["A", "B"], this.outputShape = w.assertAndGetBroadcastShape(t8, o8), this.dispatchLayout = X(this.outputShape), this.op = e8, this.useSharedMemoryWithA = t8.length <= 1 && o8.length > 1 && t8[0] < 128, this.useSharedMemoryWithB = o8.length <= 1 && t8.length > 1 && o8[0] < 128, this.useSharedMemoryWithA || this.useSharedMemoryWithB)
        this.outputComponent = 1, this.variableComponents = [1, 1], this.lastDimensionSize = this.useSharedMemoryWithB ? o8[0] : t8[0], this.shaderKey = `binary_${e8}_${this.lastDimensionSize}`, this.type = "shared", this.workgroupSize = [256, 1, 1];
      else {
        let n8 = t8.length > 0 && t8[t8.length - 1] % 4 === 0, s = o8.length > 0 && o8[o8.length - 1] % 4 === 0;
        n8 && s ? (this.outputComponent = 4, this.variableComponents = [4, 4]) : n8 && (y.isScalarShape(o8) || o8[o8.length - 1] === 1) || s && (y.isScalarShape(t8) || t8[t8.length - 1] === 1) ? (this.outputComponent = 4, this.variableComponents = n8 ? [4, 1] : [1, 4]) : (this.outputComponent = 1, this.variableComponents = [1, 1]), this.type = "nonshared", this.shaderKey = `binary_${e8}_${this.variableComponents}`, this.workgroupSize = [128, 1, 1];
      }
      this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.outputComponent, 1, 1]);
    }
    getUserCode() {
      let e8, t8 = this.outputComponent === 4 ? "vec4<f32>" : "f32", o8 = `
    fn binaryOperation(a : ${t8}, b : ${t8}) -> ${t8} {
      ${qc(this.op, this.outputComponent === 4)}
    };
    `;
      if (this.type === "shared") {
        let n8 = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0", s = this.useSharedMemoryWithB ? `let a = getAByOutputIndex(index);
          let b = sharedBuf[${n8}];` : `let a = sharedBuf[${n8}];
          let b = getBByOutputIndex(index);`;
        e8 = `
        ${o8}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${H("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `;
      } else
        e8 = `
       ${o8}
       ${H("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t8}(getAByOutputCoords(coords));
           let b = ${t8}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;
      return e8;
    }
  };
  function At(r8) {
    let { inputs: e8 } = r8, { x: t8 } = e8;
    return r8.backend.incRef(t8.dataId), { dataId: t8.dataId, shape: t8.shape, dtype: t8.dtype };
  }
  var XB = { kernelName: Co, backendName: "webgpu", kernelFunc: At };
  function xo(r8) {
    let { inputs: e8, backend: t8 } = r8, { real: o8, imag: n8 } = e8, s = t8.makeTensorInfo(o8.shape, "complex64"), a = t8.tensorMap.get(s.dataId), i10 = At({ inputs: { x: o8 }, backend: t8 }), p = At({ inputs: { x: n8 }, backend: t8 });
    return a.complexTensorInfos = { real: i10, imag: p }, s;
  }
  var YB = { kernelName: Ri, backendName: "webgpu", kernelFunc: xo };
  var Zr = class {
    constructor(e8, t8, o8 = "") {
      this.variableNames = ["A"], this.size = true;
      let n8 = 128;
      this.workgroupSize = [n8, 1, 1], this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.op = t8, o8 !== "" && (this.uniforms = o8), this.shaderKey = `unary_${t8}`;
    }
    getUserCode() {
      return `
      fn unaryOperation(a : f32) -> f32 {
        ${wi(this.op, false)}
      }
      ${H("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `;
    }
  };
  function ye({ opType: r8, cpuKernelImpl: e8, dtype: t8 }) {
    return ({ inputs: o8, backend: n8 }) => {
      let { x: s } = o8, a = n8, i10 = t8 || s.dtype;
      if (a.shouldExecuteOnCPU([s]) && e8 != null) {
        let u = a.tensorMap.get(s.dataId), c = e8(u.values, i10);
        return a.makeTensorInfo(s.shape, i10, c);
      }
      let p = new Zr(s.shape, r8);
      return a.runWebGPUProgram(p, [s], i10);
    };
  }
  function et({ opType: r8, cpuKernelImpl: e8, supportsComplex: t8 = false, dtype: o8 }) {
    return ({ inputs: n8, backend: s }) => {
      let { a, b: i10 } = n8, p = s;
      if (t8 && a.dtype === "complex64") {
        let l = p.tensorMap.get(a.dataId), m = p.tensorMap.get(i10.dataId), d, f;
        if (r8 !== fe.MUL)
          [d, f] = [[l.complexTensorInfos.real, m.complexTensorInfos.real], [l.complexTensorInfos.imag, m.complexTensorInfos.imag]].map((g) => {
            let [x, b] = g, C = { dataId: x.dataId, dtype: x.dtype, shape: a.shape }, S = { dataId: b.dataId, dtype: b.dtype, shape: i10.shape }, k = new Si(r8, a.shape, i10.shape);
            return p.runWebGPUProgram(k, [C, S], dt(x.dtype, b.dtype));
          });
        else {
          let g = new dm(fe.COMPLEX_MULTIPLY_REAL, a.shape, i10.shape), x = new dm(fe.COMPLEX_MULTIPLY_IMAG, a.shape, i10.shape), b = [{ dataId: l.complexTensorInfos.real.dataId, dtype: l.complexTensorInfos.real.dtype, shape: a.shape }, { dataId: l.complexTensorInfos.imag.dataId, dtype: l.complexTensorInfos.imag.dtype, shape: a.shape }, { dataId: m.complexTensorInfos.real.dataId, dtype: m.complexTensorInfos.real.dtype, shape: i10.shape }, { dataId: m.complexTensorInfos.imag.dataId, dtype: m.complexTensorInfos.imag.dtype, shape: i10.shape }];
          d = p.runWebGPUProgram(g, b, "float32"), f = p.runWebGPUProgram(x, b, "float32");
        }
        let h = xo({ inputs: { real: d, imag: f }, backend: p });
        return p.disposeData(d.dataId), p.disposeData(f.dataId), h;
      }
      let u = o8 || dt(a.dtype, i10.dtype);
      if ((a.dtype === "string" || i10.dtype === "string" || p.shouldExecuteOnCPU([a, i10])) && e8 != null) {
        let l = p.tensorMap.get(a.dataId).values, m = p.tensorMap.get(i10.dataId).values, d = a.dtype === "string" ? w.fromUint8ToStringArray(l) : l, f = a.dtype === "string" ? w.fromUint8ToStringArray(m) : m, [h, g] = e8(a.shape, i10.shape, d, f, u);
        return p.makeTensorInfo(g, u, h);
      }
      let c = new Si(r8, a.shape, i10.shape);
      return p.runWebGPUProgram(c, [a, i10], u);
    };
  }
  var { addImpl: QB, castImpl: ZB, ceilImpl: JB, concatImpl: ez, equalImpl: tz, expImpl: rz, expm1Impl: oz, floorImpl: nz, floorDivImpl: sz, gatherNdImpl: az, gatherV2Impl: iz, greaterEqualImpl: uz, greaterImpl: pz, lessEqualImpl: cz, lessImpl: lz, logImpl: mz, maxImpl: dz, maximumImpl: fz, minimumImpl: hz, multiplyImpl: gz, negImpl: xz, notEqualImpl: yz, prodImpl: bz, rangeImpl: Cz, rsqrtImpl: wz, scatterImpl: Sz, simpleAbsImpl: Iz, sliceImpl: vz, stridedSliceImpl: kz, stringNGramsImpl: Nz, subImpl: Tz, tileImpl: _z, topKImpl: $z, transposeImpl: Ez, uniqueImpl: NPt } = Ic;
  var Oie = ye({ opType: Z.ABS, cpuKernelImpl: Iz });
  var Rz = { kernelName: js, backendName: "webgpu", kernelFunc: Oie };
  var Mie = ye({ opType: Z.ACOS });
  var Dz = { kernelName: Vo, backendName: "webgpu", kernelFunc: Mie };
  var Lie = ye({ opType: Z.ACOSH });
  var Az = { kernelName: Wo, backendName: "webgpu", kernelFunc: Lie };
  var Bie = et({ opType: fe.ADD, cpuKernelImpl: QB, supportsComplex: true });
  var Fz = { kernelName: io, backendName: "webgpu", kernelFunc: Bie };
  var Jg = class {
    constructor(e8) {
      this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8[0], this.variableNames = e8.map((t8, o8) => `T${o8}`), this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.shaderKey = "addN";
    }
    getUserCode() {
      let e8 = [];
      this.variableNames.forEach((n8) => {
        e8.push(`let v${n8} = get${n8}ByOutputCoords(coords);`);
      });
      let t8 = this.variableNames.map((n8) => `v${n8}`).join(" + ");
      return `
      ${H("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e8.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t8});
          }
        }
      }
    `;
    }
  };
  function zie(r8) {
    let { inputs: e8, backend: t8 } = r8, o8 = e8;
    if (o8.length === 1)
      return At({ inputs: { x: o8[0] }, backend: t8 });
    let n8 = o8.map((i10) => i10.dtype).reduce((i10, p) => dt(i10, p)), s = o8.map((i10) => i10.shape), a = new Jg(s);
    return t8.runWebGPUProgram(a, o8, n8);
  }
  var Pz = { kernelName: Uo, backendName: "webgpu", kernelFunc: zie };
  var ex = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.workgroupSize = [16, 16, 1];
      let o8 = new Array(e8.length);
      for (let n8 = 0; n8 < o8.length; n8++)
        o8[n8] = e8[t8[n8]];
      this.outputShape = o8, this.dispatchLayout = { x: [0], y: [1] }, this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [1, 1, 1]), this.shaderKey = "transposeShared";
    }
    getUserCode() {
      y.assert(this.workgroupSize[0] === this.workgroupSize[1], () => `Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);
      let e8 = this.workgroupSize[0];
      return `
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0] + 1}>, ${this.workgroupSize[0]}>;
      ${H()} {
        var x = i32(workgroupId.x) * ${e8} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e8} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e8} + i32(localId.x);
        y = i32(workgroupId.x) * ${e8} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
    }
  };
  var tx = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true;
      let o8 = new Array(e8.length);
      for (let n8 = 0; n8 < o8.length; n8++)
        o8[n8] = e8[t8[n8]];
      this.outputShape = o8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.newDim = t8, this.shaderKey = `transpose_${t8}`;
    }
    getUserCode() {
      let e8 = ht(this.outputShape.length), t8 = Gv(this.newDim);
      return `
      ${H("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e8}(${t8}), uniforms.aShape)]);
          }
        }
      }
    `;
    }
  };
  function Gv(r8) {
    let e8 = r8.length;
    if (e8 > 6)
      throw Error(`Transpose for rank ${e8} is not yet supported`);
    let t8 = new Array(e8);
    for (let o8 = 0; o8 < r8.length; o8++)
      t8[r8[o8]] = `coords.${Oo(o8)}`;
    return t8.join();
  }
  function yr(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { perm: s } = o8, a = t8, i10 = n8.shape.length, p = new Array(i10);
    for (let c = 0; c < p.length; c++)
      p[c] = n8.shape[s[c]];
    if (t8.shouldExecuteOnCPU([n8])) {
      let l = a.tensorMap.get(n8.dataId).values, m = Ez(l, n8.shape, n8.dtype, s, p);
      return t8.makeTensorInfo(p, n8.dtype, m);
    }
    if (n8.shape.length === 2 && y.arraysEqual(s, [1, 0])) {
      let c = new ex(n8.shape, s);
      return a.runWebGPUProgram(c, [n8], n8.dtype);
    }
    let u = new tx(n8.shape, s);
    return a.runWebGPUProgram(u, [n8], n8.dtype);
  }
  var Oz = { kernelName: po, backendName: "webgpu", kernelFunc: yr };
  var rx = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.uniforms = "reduceSize : i32,", this.size = true, this.inputShape = [e8.batchSize, e8.inSize];
      let [n8] = w.computeOutAndReduceShapes(this.inputShape, [1]);
      this.outputShape = n8.length === 0 ? [1] : n8, e8.inSize >= 32768 && o8 >= 512 ? this.workgroupSize = [512, 1, 1] : e8.inSize >= 4096 ? this.workgroupSize = [256, 1, 1] : this.workgroupSize = [64, 1, 1], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, [1, 1, 1]), this.reduceType = t8, this.shaderKey = `reduce_${t8}`;
    }
    getUserCode() {
      let e8 = "", t8 = "0.0", o8 = this.workgroupSize[0];
      this.reduceType === "min" || this.reduceType === "max" ? (e8 = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType === "min" ? "<" : ">"} bestValue)
           {  bestValue = candidate; }`, t8 = "f32(x[offset])") : this.reduceType === "sum" || this.reduceType === "mean" ? e8 = " bestValue = bestValue + candidate; " : this.reduceType === "prod" ? (e8 = " bestValue = bestValue * candidate; ", t8 = "1.0") : this.reduceType === "all" ? (e8 = " bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ", t8 = "1.0") : this.reduceType === "any" && (e8 = " bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ", t8 = "0.0");
      let n8 = this.reduceType === "mean" ? "setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));" : "setOutputAtIndex(outputIndex, bestValue);";
      return `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${o8}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length === 1 ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${H("index")} {
         let outputIndex = index / ${o8};
         let offset = getOffset(outputIndex);
         var bestValue = ${t8};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${o8}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${o8}) {
           let candidate = f32(x[offset + k]);
           ${e8}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${o8}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e8}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n8}
        }
       }
     `;
    }
  };
  function Jr(r8, e8, t8, o8, n8) {
    let s = r8.shape.length, a = [], i10 = y.parseAxisParam(e8, r8.shape), p = i10, u = w.getAxesPermutation(p, s), c = r8;
    u != null && (c = yr({ inputs: { x: r8 }, attrs: { perm: u }, backend: n8 }), p = w.getInnerMostAxes(p.length, s), a.push(c)), w.assertAxesAreInnerMostDims(o8, p, s);
    let [l, m] = w.computeOutAndReduceShapes(c.shape, p), d = l;
    t8 && (d = w.expandShapeToKeepDim(l, i10));
    let f;
    if ((o8 === "max" || o8 === "prod") && n8.shouldExecuteOnCPU([c])) {
      let h = n8.tensorMap.get(c.dataId).values;
      switch (o8) {
        case "max":
          let g = dz(h, y.sizeFromShape(m), d, r8.dtype);
          f = n8.makeTensorInfo(d, r8.dtype, g);
          break;
        case "prod":
          let { outVals: x, outShape: b, outDtype: C } = bz(c.shape, c.dtype, h, p);
          f = n8.makeTensorInfo(b, C, x);
          break;
        default:
          throw new Error(`${o8} CPU implementation is not yet supported.`);
      }
    } else {
      let h = y.sizeFromShape(m), x = y.sizeFromShape(c.shape) / h, b = { windowSize: h, inSize: h, batchSize: x, outSize: 1 }, C = o8 === "mean" ? "float32" : ti(r8.dtype), S = [{ type: "int32", data: [h] }], k = new rx(b, o8, n8.device.limits.maxComputeWorkgroupSizeX), _ = n8.runWebGPUProgram(k, [c], C, S);
      a.push(_), f = pe({ inputs: { x: _ }, attrs: { shape: d }, backend: n8 });
    }
    return a.forEach((h) => n8.disposeData(h.dataId)), f;
  }
  function Vie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { keepDims: s, axis: a } = o8;
    return Jr(n8, a, s, "all", t8);
  }
  var Mz = { kernelName: Go, backendName: "webgpu", kernelFunc: Vie };
  function Wie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { keepDims: s, axis: a } = o8;
    return Jr(n8, a, s, "any", t8);
  }
  var Lz = { kernelName: Ho, backendName: "webgpu", kernelFunc: Wie };
  var jc = class {
    constructor(e8, t8, o8) {
      this.workgroupSize = [64, 1, 1], this.variableNames = ["x"], this.uniforms = "infinityValue : f32,", this.size = true;
      let n8 = [t8];
      this.op = o8 === "min" ? "<" : ">";
      let [s, a] = w.computeOutAndReduceShapes(e8, n8);
      this.outputShape = s.length === 0 ? [1] : s, this.dispatchLayout = X(this.outputShape), y.sizeFromShape(a) < 32 || y.sizeFromShape(s) > 1e3 ? (this.type = "plain", this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize)) : (this.type = "shared", this.dispatch = K(this.dispatchLayout, this.outputShape, [1, 1, 1])), this.inputShape = e8, this.shaderKey = `argMinMax_${this.op}_${this.type}`;
    }
    getUserCode() {
      let e8 = this.workgroupSize[0], t8 = () => this.inputShape.length === 1 ? "uniforms.xShape" : `uniforms.xShape.${Oo(this.inputShape.length - 1)}`, o8 = () => {
        let n8 = "";
        if (this.outputShape.length === 1)
          this.inputShape.length !== 1 && (n8 += "outputCoords,");
        else
          for (let s = 0; s < this.outputShape.length; s++)
            n8 += `outputCoords.${Oo(s)},`;
        return n8;
      };
      return this.type === "shared" ? `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e8}>;
      var<workgroup> xBestValues : array<f32, ${e8}>;
    `}

      ${H("index")} {
        let outputIndex = index / ${e8};
        let reduceLength = ${t8()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e8}) {
          let candidate = getX(${o8()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e8}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    ` : `
      ${H("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${o8()} 0);
          let reduceLength = ${t8()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${o8()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
    }
  };
  function Uie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s } = o8, a = y.parseAxisParam(s, n8.shape), i10 = w.getAxesPermutation(a, n8.shape.length), p = n8, u = [];
    i10 != null && (p = yr({ inputs: { x: n8 }, backend: t8, attrs: { perm: i10 } }), u.push(p), a = w.getInnerMostAxes(a.length, p.shape.length)), w.assertAxesAreInnerMostDims("argMax", [a[0]], p.shape.length);
    let c = new jc(p.shape, a[0], "max"), l = [{ type: "float32", data: [Number.NEGATIVE_INFINITY] }], m = t8.runWebGPUProgram(c, [p], "int32", l);
    return u.forEach((d) => t8.disposeData(d.dataId)), m;
  }
  var Bz = { kernelName: Xs, backendName: "webgpu", kernelFunc: Uie };
  function Gie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s } = o8, a = y.parseAxisParam(s, n8.shape), i10 = w.getAxesPermutation(a, n8.shape.length), p = n8, u = [];
    i10 != null && (p = yr({ inputs: { x: n8 }, backend: t8, attrs: { perm: i10 } }), u.push(p), a = w.getInnerMostAxes(a.length, p.shape.length)), w.assertAxesAreInnerMostDims("argMin", [a[0]], p.shape.length);
    let c = new jc(p.shape, a[0], "min"), l = [{ type: "float32", data: [Number.POSITIVE_INFINITY] }], m = t8.runWebGPUProgram(c, [p], "int32", l);
    return u.forEach((d) => t8.disposeData(d.dataId)), m;
  }
  var zz = { kernelName: Ys, backendName: "webgpu", kernelFunc: Gie };
  var Hie = ye({ opType: Z.ASIN });
  var Vz = { kernelName: Ko, backendName: "webgpu", kernelFunc: Hie };
  var Kie = ye({ opType: Z.ASINH });
  var Wz = { kernelName: qo, backendName: "webgpu", kernelFunc: Kie };
  var qie = ye({ opType: Z.ATAN });
  var Uz = { kernelName: jo, backendName: "webgpu", kernelFunc: qie };
  var jie = et({ opType: fe.ATAN2 });
  var Gz = { kernelName: Yo, backendName: "webgpu", kernelFunc: jie };
  var Xie = ye({ opType: Z.ATANH });
  var Hz = { kernelName: Xo, backendName: "webgpu", kernelFunc: Xie };
  var ox = class {
    constructor(e8) {
      this.variableNames = ["x"], this.uniforms = "strides : vec2<i32>,", this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e8.outShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "poolWithFilterSizeEqualsOne";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
  };
  var Ma = class {
    constructor(e8, t8, o8 = false, n8 = false, s = false) {
      if (this.variableNames = ["x"], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,", this.workgroupSize = [128, 1, 1], this.size = true, t8 === "avg" && o8)
        throw new Error("Cannot compute positions for average pool.");
      this.outputShape = e8.outShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t8, this.computePositions = o8, this.flattenPositions = n8, this.includeBatchIndex = s, this.shaderKey = `pool2D_${t8}_${o8}_${n8}_${s}`;
    }
    getUserCode() {
      let e8;
      this.poolType === "avg" ? e8 = "resultValue = resultValue + value; count = count + 1.0;" : this.computePositions ? e8 = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "wR * uniforms.filterDims.y + wC"};
      }` : e8 = "resultValue = max(value, resultValue);";
      let t8 = "resultValue";
      return this.poolType === "avg" && (t8 = "resultValue / max(count, 1.0)"), `
      ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e8}
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t8});`}
        }
      }
    `;
    }
  };
  var ku = class {
    constructor(e8, t8, o8 = false, n8 = false, s = false) {
      if (this.variableNames = ["x"], this.uniforms = "strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,", this.workgroupSize = [128, 1, 1], this.size = true, t8 === "avg" && o8)
        throw new Error("Cannot compute positions for average pool.");
      this.outputShape = e8.outShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t8, this.computePositions = o8, this.flattenPositions = n8, this.includeBatchIndex = s, this.shaderKey = `pool3D_${t8}_${o8}_${n8}_${s}`;
    }
    getUserCode() {
      let e8;
      this.poolType === "avg" ? e8 = "resultValue += value; count += 1.0;" : this.computePositions ? e8 = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }` : e8 = "resultValue = max(value, resultValue);";
      let t8 = "resultValue";
      return this.poolType === "avg" && (t8 = "resultValue / max(count, 1.0)"), `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e8}
              }
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t8});`}
        }
      }
    `;
    }
  };
  function Hv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { reductionIndices: s, keepDims: a } = o8;
    return Jr(n8, s, a, "max", t8);
  }
  var Kz = { kernelName: zn, backendName: "webgpu", kernelFunc: Hv };
  function Kv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { keepDims: s, axis: a } = o8;
    return Jr(n8, a, s, "mean", t8);
  }
  var qz = { kernelName: Un, backendName: "webgpu", kernelFunc: Kv };
  function nx(r8, e8, t8, o8) {
    if (e8.filterWidth === 1 && e8.filterHeight === 1 && y.arraysEqual(e8.inShape, e8.outShape))
      return At({ inputs: { x: r8 }, backend: o8 });
    if (e8.filterWidth === e8.inWidth && e8.filterHeight === e8.inHeight && e8.batchSize === 1 && e8.padInfo.type === "VALID") {
      let a = r8.shape.length, i10 = pe({ inputs: { x: r8 }, backend: o8, attrs: { shape: [r8.shape[a - 3] * r8.shape[a - 2], r8.shape[a - 1]] } }), p;
      t8 === "avg" ? p = Kv({ inputs: { x: i10 }, backend: o8, attrs: { axis: 0, keepDims: false } }) : (y.assert(t8 === "max", () => `Invalid pool type ${t8}`), p = Hv({ inputs: { x: i10 }, backend: o8, attrs: { reductionIndices: 0, keepDims: false } }));
      let u = pe({ inputs: { x: p }, backend: o8, attrs: { shape: e8.outShape } });
      return o8.disposeData(i10.dataId), o8.disposeData(p.dataId), u;
    }
    let n8, s = [{ type: "int32", data: [e8.strideHeight, e8.strideWidth] }];
    return e8.filterHeight === 1 && e8.filterWidth === 1 ? n8 = new ox(e8) : (t8 === "avg" ? n8 = new Ma(e8, "avg") : (y.assert(t8 === "max", () => `Invalid pool type ${t8}`), n8 = new Ma(e8, "max")), s.push({ type: "int32", data: [e8.padInfo.top, e8.padInfo.left] }, { type: "int32", data: [e8.dilationHeight, e8.dilationWidth] }, { type: "int32", data: [e8.inHeight, e8.inWidth] }, { type: "int32", data: [e8.effectiveFilterHeight, e8.effectiveFilterWidth] })), o8.runWebGPUProgram(n8, [r8], r8.dtype, s);
  }
  function Yie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dimRoundingMode: p } = o8, u = 1, c = w.computePool2DInfo(n8.shape, s, a, u, i10, p);
    return nx(n8, c, "avg", t8);
  }
  var jz = { kernelName: Qo, backendName: "webgpu", kernelFunc: Yie };
  function Qie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dataFormat: p, dimRoundingMode: u } = o8, c = [1, 1, 1], l = w.computePool3DInfo(n8.shape, s, a, c, i10, u, p), m = new ku(l, "avg"), d = [{ type: "int32", data: [l.strideDepth, l.strideHeight, l.strideWidth] }, { type: "int32", data: [l.padInfo.front, l.padInfo.top, l.padInfo.left] }, { type: "int32", data: [l.inDepth, l.inHeight, l.inWidth] }, { type: "int32", data: [l.effectiveFilterDepth, l.effectiveFilterHeight, l.effectiveFilterWidth] }];
    return t8.runWebGPUProgram(m, [n8], n8.dtype, d);
  }
  var Xz = { kernelName: Qs, backendName: "webgpu", kernelFunc: Qie };
  var sx = class {
    constructor(e8) {
      this.variableNames = ["dy"], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.inShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool2DBackprop";
    }
    getUserCode() {
      return `
      ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  };
  var ax = class {
    constructor(e8) {
      this.variableNames = ["dy"], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.inShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool3DBackprop";
    }
    getUserCode() {
      return `
      ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  };
  function Zie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, a = s, { filterSize: i10, strides: p, pad: u, dimRoundingMode: c } = o8, l = w.computePool3DInfo(a.shape, i10, p, 1, u, c), m = new ax(l), d = 1 / (l.filterDepth * l.filterHeight * l.filterWidth), f = [{ type: "int32", data: [l.strideDepth, l.strideHeight, l.strideWidth] }, { type: "int32", data: [l.effectiveFilterDepth - 1 - l.padInfo.front, l.effectiveFilterHeight - 1 - l.padInfo.top, l.effectiveFilterWidth - 1 - l.padInfo.left] }, { type: "int32", data: [l.effectiveFilterDepth, l.effectiveFilterHeight, l.effectiveFilterWidth] }, { type: "int32", data: [l.outDepth] }, { type: "int32", data: [l.outHeight] }, { type: "int32", data: [l.outWidth] }, { type: "float32", data: [d] }];
    return t8.runWebGPUProgram(m, [n8], a.dtype, f);
  }
  var Yz = { kernelName: Ei, backendName: "webgpu", kernelFunc: Zie };
  function Jie(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, a = s;
    lm([n8, s], "avgPoolGrad");
    let { filterSize: i10, strides: p, pad: u } = o8, c = w.computePool2DInfo(a.shape, i10, p, 1, u), l = new sx(c), m = 1 / (c.filterHeight * c.filterWidth), d = [{ type: "int32", data: [c.strideHeight, c.strideWidth] }, { type: "int32", data: [c.effectiveFilterHeight - 1 - c.padInfo.top, c.effectiveFilterWidth - 1 - c.padInfo.left] }, { type: "int32", data: [c.dilationHeight, c.dilationWidth] }, { type: "int32", data: [c.effectiveFilterHeight, c.effectiveFilterWidth] }, { type: "int32", data: [c.outHeight] }, { type: "int32", data: [c.outWidth] }, { type: "float32", data: [m] }];
    return t8.runWebGPUProgram(l, [n8], a.dtype, d);
  }
  var Qz = { kernelName: $i, backendName: "webgpu", kernelFunc: Jie };
  function eue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { a: n8, b: s } = e8, { transposeA: a, transposeB: i10 } = o8;
    return Ap({ a: n8, b: s, transposeA: a, transposeB: i10, backend: t8 });
  }
  var Zz = { kernelName: Zo, backendName: "webgpu", kernelFunc: eue };
  var ix = class {
    constructor(e8, t8) {
      this.variableNames = ["source"], this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t8, this.rank = t8.length, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.start = e8, this.uniforms = `start : ${ht(e8.length)}, `, this.shaderKey = "slice";
    }
    getUserCode() {
      let e8 = ht(this.rank), t8 = tue(this.rank), o8;
      return this.start.length === 1 ? o8 = this.outputShape.map((s, a) => "sourceLoc = uniforms.start + coords;") : o8 = this.outputShape.map((s, a) => `sourceLoc.${qv[a]} = uniforms.start.${Oo(a)} + coords.${qv[a]};`), `
      ${H("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e8};
          let coords = getCoordsFromIndex(index);
          ${o8.join(`
`)}
          setOutputAtIndex(index, getSource(${t8}));
        }
      }
    `;
    }
  };
  var qv = ["x", "y", "z", "w", "u", "v"];
  function tue(r8) {
    if (r8 === 1)
      return "sourceLoc";
    if (r8 <= 6)
      return qv.slice(0, r8).map((e8) => `sourceLoc.${e8}`).join(",");
    throw Error(`Slicing for rank ${r8} is not yet supported`);
  }
  function Gs(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { begin: s, size: a } = o8, [i10, p] = ct.parseSliceParams(n8, s, a);
    if (ct.assertParamsValid(n8, i10, p), t8.shouldExecuteOnCPU([n8]) || n8.dtype === "string") {
      let l = t8.tensorMap.get(n8.dataId), m = vz(l.values, i10, p, n8.shape, n8.dtype);
      return t8.makeTensorInfo(p, n8.dtype, m);
    }
    if (y.sizeFromShape(p) === 0)
      return t8.makeTensorInfo(p, n8.dtype, []);
    let u = new ix(i10, p), c = [{ type: "int32", data: i10 }];
    return t8.runWebGPUProgram(u, [n8], n8.dtype, c);
  }
  var Jz = { kernelName: fa, backendName: "webgpu", kernelFunc: Gs };
  var rue = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, crops: a } = o8;
    y.assert(n8.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");
    let i10 = s.reduce((b, C) => b * C), p = w.getReshaped(n8.shape, s, i10), u = w.getPermuted(p.length, s.length), c = w.getReshapedPermuted(n8.shape, s, i10), l = w.getSliceBeginCoords(a, s.length), m = w.getSliceSize(c, a, s.length), d = [], f = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: p } }), h = yr({ inputs: { x: f }, backend: t8, attrs: { perm: u } }), g = pe({ inputs: { x: h }, backend: t8, attrs: { shape: c } }), x = Gs({ inputs: { x: g }, backend: t8, attrs: { begin: l, size: m } });
    return d.push(f), d.push(h), d.push(g), d.forEach((b) => t8.disposeData(b.dataId)), x;
  };
  var eV = { kernelName: Zs, backendName: "webgpu", kernelFunc: rue };
  var oue = `
  fn bincount_write(index: i32, value: f32) {
    ${Us("&result[index]", "value", "float32")}
  }
`;
  var nue = `
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;
  var Xc = class {
    constructor(e8, t8, o8 = false) {
      this.outputShape = [], this.variableNames = ["x"], this.uniforms = "binCountSize : i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.hasWeights = true, this.binaryOutput = false, this.outputShape = e8, this.rank = e8.length, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.binaryOutput = o8, o8 && (this.atomic = false), this.hasWeights = t8, this.hasWeights && this.variableNames.push("w"), this.shaderKey = `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;
    }
    getUserCode() {
      return `
    ${this.binaryOutput ? nue : oue}
  ${H("index")} {
    ${this.rank === 1 ? `if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(index)" : "1."};
        bincount_write(indexVal, value);
      }
    }` : `let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(coord[0], coord[1])" : "1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `;
    }
  };
  function sue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, weights: s } = e8, { size: a } = o8, i10 = y.sizeFromShape(n8.shape), u = y.sizeFromShape(s.shape) > 0, c = [a], l = s.dtype, m = Vt({ backend: t8, attrs: { shape: c, value: 0, dtype: l } }), d = new Xc([i10], u), f = [{ type: "int32", data: [a] }], h = u ? [n8, s] : [n8];
    return t8.runWebGPUProgram(d, h, l, f, m);
  }
  var tV = { kernelName: Jo, backendName: "webgpu", kernelFunc: sue };
  var ux = class {
    constructor(e8) {
      this.outputShape = [], this.variableNames = ["s0", "s1"], this.uniforms = "s0Size : i32, s1Size : i32, ", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e8], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "broadcastArgs";
    }
    getUserCode() {
      return `
  ${H("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `;
    }
  };
  function aue(r8) {
    let { inputs: e8, backend: t8 } = r8, { s0: o8, s1: n8 } = e8;
    if (t8.shouldExecuteOnCPU([o8, n8])) {
      let c = t8.tensorMap.get(o8.dataId), l = t8.tensorMap.get(n8.dataId), m = c.values, d = l.values, f = w.assertAndGetBroadcastShape(Array.from(m), Array.from(d));
      return t8.makeTensorInfo([f.length], "int32", Int32Array.from(f));
    }
    let s = y.sizeFromShape(o8.shape), a = y.sizeFromShape(n8.shape), i10 = Math.max(s, a), p = new ux(i10), u = [{ type: "int32", data: [s] }, { type: "int32", data: [a] }];
    return t8.runWebGPUProgram(p, [o8, n8], "int32", u);
  }
  var rV = { kernelName: Js, backendName: "webgpu", kernelFunc: aue };
  var jv = et({ opType: fe.NOT_EQUAL, dtype: "bool", cpuKernelImpl: yz });
  var oV = { kernelName: Yn, backendName: "webgpu", kernelFunc: jv };
  function Ii(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = t8.tensorMap.get(o8.dataId);
    return At({ inputs: { x: n8.complexTensorInfos.real }, backend: t8 });
  }
  var nV = { kernelName: Gi, backendName: "webgpu", kernelFunc: Ii };
  function sV(r8, e8) {
    let t8 = new Zr(r8.shape, Z.TO_INT), o8 = e8.runWebGPUProgram(t8, [r8], "int32");
    return { dataId: o8.dataId, shape: o8.shape, dtype: o8.dtype };
  }
  function Xv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { dtype: s } = o8;
    if (s === "complex64") {
      if (n8.dtype === "complex64")
        return At({ inputs: { x: n8 }, backend: t8 });
      let a = Gr(n8.shape), i10 = Xv({ inputs: { x: n8 }, backend: t8, attrs: { dtype: "float32" } }), p = xo({ inputs: { real: i10, imag: a }, backend: t8 });
      return a.dispose(), t8.disposeData(i10.dataId), p;
    }
    if (n8.dtype === "complex64") {
      let a = Ii({ inputs: { input: n8 }, backend: t8 }), i10 = Xv({ inputs: { x: a }, backend: t8, attrs: { dtype: s } });
      return t8.disposeData(a.dataId), i10;
    }
    if (!y.hasEncodingLoss(n8.dtype, s)) {
      let a = At({ inputs: { x: n8 }, backend: t8 });
      return { dataId: a.dataId, shape: a.shape, dtype: s };
    }
    if (t8.shouldExecuteOnCPU([n8])) {
      let a = t8.tensorMap.get(n8.dataId).values, [i10, p, u] = ZB(a, n8.shape, n8.dtype, s);
      return t8.makeTensorInfo(i10, p, u);
    }
    if (s === "int32")
      return sV(n8, t8);
    if (s === "bool") {
      let a = t8.makeTensorInfo([], "bool", y.getTypedArrayFromDType("bool", 1)), p = jv({ inputs: { a: n8, b: a }, backend: t8 });
      return t8.disposeData(a.dataId), p;
    }
    throw new Error(`Error in Cast: failed to cast ${n8.dtype} to ${s}`);
  }
  var aV = { kernelName: yo, backendName: "webgpu", kernelFunc: Xv };
  var iue = ye({ opType: Z.CEIL, cpuKernelImpl: JB });
  var iV = { kernelName: en, backendName: "webgpu", kernelFunc: iue };
  var px = class {
    constructor(e8) {
      this.variableNames = ["A"], this.uniforms = "minVal : f32, maxVal : f32,", this.workPerThread = 4, this.workgroupSize = [64, 1, 1], this.outputComponent = 4, this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.shaderKey = "clipVec4";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `;
    }
  };
  var cx = class {
    constructor(e8) {
      this.variableNames = ["A"], this.uniforms = "minVal : f32, maxVal : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "clip";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
    }
  };
  function uue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { clipValueMin: s, clipValueMax: a } = o8, i10, p = [{ type: "float32", data: [s] }, { type: "float32", data: [a] }];
    return y.sizeFromShape(n8.shape) % 4 === 0 ? i10 = new px(n8.shape) : i10 = new cx(n8.shape), t8.runWebGPUProgram(i10, [n8], n8.dtype, p);
  }
  var uV = { kernelName: bo, backendName: "webgpu", kernelFunc: uue };
  var lx = class {
    constructor(e8) {
      this.outputShape = [], this.variableNames = ["real", "imag"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "complexAbs";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `;
    }
  };
  function pV(r8, e8) {
    return { dataId: e8.dataId, dtype: e8.dtype, shape: r8.shape };
  }
  function pue(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8, n8 = t8.tensorMap.get(o8.dataId), s = new lx(o8.shape), a = [pV(o8, n8.complexTensorInfos.real), pV(o8, n8.complexTensorInfos.imag)];
    return t8.runWebGPUProgram(s, a, a[0].dtype);
  }
  var cV = { kernelName: Di, backendName: "webgpu", kernelFunc: pue };
  var mx = class {
    constructor(e8) {
      this.uniforms = "", this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = w.computeOutShape(e8, 1), this.variableNames = e8.map((t8, o8) => `T${o8}`), this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.offsetLength = e8.length - 1;
      for (let t8 = 0; t8 < this.offsetLength; t8++)
        this.uniforms += `offset${t8} : i32,`;
      this.shaderKey = "concat";
    }
    getUserCode() {
      let e8 = [];
      if (this.offsetLength > 0) {
        e8.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");
        for (let s = 1; s < this.offsetLength; s++)
          e8.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s - 1})); }`);
        let o8 = this.offsetLength, n8 = this.offsetLength - 1;
        e8.push(`else { setOutputAtCoords(coords.x, coords.y, getT${o8}(yR, yC - uniforms.offset${n8})); }`);
      } else
        e8.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");
      return `
      ${H("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e8.join(`
        `)}
          }
        }
      }
    `;
    }
  };
  function Fp(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8, n8 = t8.tensorMap.get(o8.dataId);
    return At({ inputs: { x: n8.complexTensorInfos.imag }, backend: t8 });
  }
  var lV = { kernelName: Vi, backendName: "webgpu", kernelFunc: Fp };
  function Yc(r8, e8, t8) {
    let o8 = r8[0].dtype;
    if (o8 === "complex64") {
      let f = r8.map((C) => Ii({ inputs: { input: C }, backend: t8 })), h = r8.map((C) => Fp({ inputs: { input: C }, backend: t8 })), g = Yc(f, e8, t8), x = Yc(h, e8, t8), b = xo({ inputs: { real: g, imag: x }, backend: t8 });
      return f.forEach((C) => t8.disposeData(C.dataId)), h.forEach((C) => t8.disposeData(C.dataId)), t8.disposeData(g.dataId), t8.disposeData(x.dataId), b;
    }
    let n8 = t8.shouldExecuteOnCPU(r8);
    if (o8 === "string" && (n8 = true), n8) {
      let f = r8.map((k) => {
        let E = [-1, y.sizeFromShape(k.shape.slice(e8))];
        return pe({ inputs: { x: k }, backend: t8, attrs: { shape: E } });
      }), h = f.map((k) => ({ vals: t8.readSync(k.dataId), shape: k.shape })), g = w.computeOutShape(f.map((k) => k.shape), 1), x = f[0].shape[0] === 1, b = ez(h, g, o8, x), C = w.computeOutShape(r8.map((k) => k.shape), e8), S = t8.makeTensorInfo(C, o8, b);
      return f.forEach((k) => t8.disposeData(k.dataId)), S;
    }
    let s = t8.device.limits.maxStorageBuffersPerShaderStage - 1;
    if (r8.length > s) {
      let f = [];
      for (let g = 0; g < r8.length; g += s) {
        let x = r8.slice(g, g + s);
        f.push(Yc(x, e8, t8));
      }
      let h = Yc(f, e8, t8);
      for (let g of f)
        t8.disposeData(g.dataId);
      return h;
    }
    let { tensors2D: a, outShape: i10 } = cue(r8, e8, t8), p = a.map((f) => f.shape), u = new mx(p), c = [], l = new Array(p.length - 1);
    if (l.length > 0) {
      l[0] = p[0][1], c.push({ type: "int32", data: [l[0]] });
      for (let f = 1; f < l.length; f++)
        l[f] = l[f - 1] + p[f][1], c.push({ type: "int32", data: [l[f]] });
    }
    let m = t8.runWebGPUProgram(u, a, a[0].dtype, c);
    a.forEach((f) => t8.disposeData(f.dataId));
    let d = pe({ inputs: { x: m }, backend: t8, attrs: { shape: i10 } });
    return t8.disposeData(m.dataId), d;
  }
  function cue(r8, e8, t8) {
    let o8 = w.computeOutShape(r8.map((s) => s.shape), e8);
    return { tensors2D: r8.map((s) => pe({ inputs: { x: s }, backend: t8, attrs: { shape: [y.sizeFromShape(s.shape.slice(0, e8)), y.sizeFromShape(s.shape.slice(e8))] } })), outShape: o8 };
  }
  function Yv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { axis: n8 } = o8, s = y.parseAxisParam(n8, e8[0].shape)[0], a = e8.map((u) => u.shape);
    w.assertParamsConsistent(a, s);
    let i10 = w.computeOutShape(e8.map((u) => u.shape), s);
    if (y.sizeFromShape(i10) === 0)
      return t8.makeTensorInfo(i10, e8[0].dtype, []);
    let p = e8.filter((u) => y.sizeFromShape(u.shape) > 0);
    return p.length === 1 ? At({ inputs: { x: p[0] }, backend: t8 }) : Yc(p, s, t8);
  }
  var mV = { kernelName: ea, backendName: "webgpu", kernelFunc: Yv };
  function lue(r8, e8, t8, o8, n8 = false, s = null, a = false, i10 = 4, p = 4, u = 4) {
    let c = (D) => {
      switch (D) {
        case 1:
          return "resData = x[xIndex];";
        case 3:
          return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";
        case 4:
          return "resData = x[xIndex / 4];";
        default:
          throw new Error(`innerElementSize ${D} is not supported.`);
      }
    }, l = (D) => {
      switch (D) {
        case 1:
          return "return W[row * uniforms.wShape[3] + colIn];";
        case 4:
          return "return W[row * uniforms.wShape[3] / 4 + colIn];";
        default:
          throw new Error(`innerElementSize ${D} is not supported.`);
      }
    }, m = r8 ? `
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `, d = r8 ? `
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      ` : `
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `, f = r8 ? "uniforms.xShape[1]" : "uniforms.xShape[2]", h = r8 ? "uniforms.xShape[2]" : "uniforms.xShape[3]", g = r8 ? "row" : "col", x = r8 ? "col" : "row", b = `
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r8 ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${x} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${x} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${x} % inChannels;
      var resData = ${Ae(i10)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {
        ${m}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(i10)}
      }
      return resData;`, C = r8 ? e8 && o8 ? `
      let col = colIn * ${i10};
      ${b}` : `
      let col = colIn * ${i10};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${Ae(i10)}(0.0);` : o8 && t8 ? `
      let col = colIn * ${i10};
      ${b}` : `
      let col = colIn * ${i10};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${Ae(i10)}(0.0);`, S = `${l(p)}`, k = Ae(u), _ = r8 ? Ae(i10) : Ae(p), E = r8 ? Ae(p) : Ae(i10);
    return `
      ${dr(s, a, u === 4, 4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${_} {
        ${r8 ? C : S}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${E} {
        ${r8 ? S : C}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${k}) {
        let col = colIn * ${u};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r8 ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
        ${d}
        ${Qr(n8, s)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`;
  }
  var dx = class {
    constructor(e8, t8, o8, n8, s = false, a = null, i10 = false, p = false) {
      this.variableNames = ["x", "W"], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e8.outShape, this.isChannelsLast = e8.dataFormat === "channelsLast", this.isVec4 = ((e8.inChannels % 4 === 0 || e8.inChannels % 3 === 0) && this.isChannelsLast || e8.outWidth % 4 === 0 && !this.isChannelsLast) && e8.outChannels % 4 === 0, this.dispatchLayout = this.isChannelsLast ? { x: [3], y: [1, 2], z: [0] } : { x: [2, 3], y: [1], z: [0] }, this.workgroupSize = um(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = pm(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 ? (this.outputComponent = 4, this.isChannelsLast && e8.inChannels % 4 !== 0 ? (this.innerElementSize = 3, this.variableComponents = [1, 4]) : (this.innerElementSize = 4, this.variableComponents = [4, 4]), s && (this.variableNames.push("bias"), this.variableComponents.push(4)), i10 && (this.variableNames.push("preluActivationWeights"), this.variableComponents.push(4))) : (this.innerElementSize = this.elementsPerThread[0], s && this.variableNames.push("bias"), i10 && this.variableNames.push("preluActivationWeights")), this.sequentialAccessByThreads = p, this.addBias = s, this.activation = a, this.hasPreluActivationWeights = i10, this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1], this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0], this.tileInner = Math.max(this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]), this.fitAOuter = t8 % this.tileAOuter === 0, this.fitBOuter = o8 % this.tileBOuter === 0, this.fitInner = n8 % this.tileInner === 0, this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`;
    }
    getUserCode() {
      let e8 = this.isVec4 ? Rp(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner) : Dp(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner, false, null, this.sequentialAccessByThreads), t8 = this.isVec4 ? [this.innerElementSize, 4, 4] : [1, 1, 1];
      return `
    ${lue(this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner, this.addBias, this.activation, this.hasPreluActivationWeights, t8[0], t8[1], t8[2])}
    ${e8}
  `;
    }
  };
  var fx = class {
    constructor(e8, t8 = false, o8 = null, n8 = false) {
      this.variableNames = ["x", "W"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,", this.workgroupSize = [4, 4, 8], this.outputShape = e8.outShape, this.isChannelsLast = e8.dataFormat === "channelsLast", this.dispatchLayout = this.isChannelsLast ? { x: [2], y: [1], z: [0, 3] } : { x: [3], y: [2], z: [0, 1] }, this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = t8, this.activation = o8, this.hasPreluActivationWeights = n8, t8 && this.variableNames.push("bias"), n8 && this.variableNames.push("preluActivationWeights"), this.shaderKey = `conv2dnaive_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
      return `
       ${dr(this.activation, this.hasPreluActivationWeights, false, 4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast ? "vec4<i32>(batch, row, col, chan);" : "vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Qr(this.addBias, this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${H("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast ? "coords[3];" : "coords[1];"}
         let outRow = ${this.isChannelsLast ? "coords[1];" : "coords[2];"}
         let outCol = ${this.isChannelsLast ? "coords[2];" : "coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast ? "uniforms.xShape[3];" : "uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast ? "let v = readInp(batch, xRow, xCol, xChannel);" : "let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `;
    }
  };
  var hx = class {
    constructor(e8, t8) {
      this.variableNames = ["x"], this.uniforms = `pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = t8, this.shaderKey = `im2col_${this.isChannelsLast}`;
    }
    getUserCode() {
      let e8 = this.isChannelsLast ? 1 : 2, t8 = this.isChannelsLast ? 2 : 3, o8 = this.isChannelsLast ? "coords[1]" : "coords[2]", n8 = this.isChannelsLast ? "coords[2]" : "coords[1]", s = this.isChannelsLast ? "getX(batch, xRow, xCol, ch)" : "getX(batch, ch, xRow, xCol)";
      return `
    ${H("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${o8};
        let col = ${n8};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e8}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t8}] && xCol >= 0) {
            value = ${s};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `;
    }
  };
  function gx(r8, e8) {
    let t8 = r8.length;
    return t8 >= 3 ? e8 ? [...r8.slice(0, -3), r8[t8 - 3] * r8[t8 - 2], r8[t8 - 1]] : [...r8.slice(0, -3), r8[t8 - 3], r8[t8 - 2] * r8[t8 - 1]] : !e8 && t8 === 1 && r8[0] > 1 ? [r8[0], 1] : null;
  }
  function mue({ x: r8, filter: e8, convInfo: t8, backend: o8, bias: n8 = null, preluActivationWeights: s = null, leakyreluAlpha: a = 0, activation: i10 = null }) {
    let p = t8.dataFormat === "channelsLast", u = !p, c = false, l = p && t8.filterHeight === t8.inHeight && t8.filterWidth === t8.inWidth && t8.padInfo.type === "VALID", m = [], d, f;
    if (l) {
      let x = t8.inHeight * t8.inWidth * t8.inChannels;
      d = pe({ inputs: { x: r8 }, backend: o8, attrs: { shape: [1, t8.batchSize, x] } }), f = pe({ inputs: { x: e8 }, backend: o8, attrs: { shape: [1, x, t8.outChannels] } });
    } else
      d = pe({ inputs: { x: r8 }, backend: o8, attrs: { shape: p ? [t8.batchSize, t8.inHeight * t8.inWidth, t8.inChannels] : [t8.batchSize, t8.inChannels, t8.inHeight * t8.inWidth] } }), f = pe({ inputs: { x: e8 }, backend: o8, attrs: { shape: [1, t8.inChannels, t8.outChannels] } });
    if (m.push(d), m.push(f), s != null) {
      let x = gx(s.shape, p);
      x != null && (s = pe({ inputs: { x: s }, backend: o8, attrs: { shape: x } }), m.push(s));
    }
    if (n8 != null) {
      let x = gx(n8.shape, p);
      x != null && (n8 = pe({ inputs: { x: n8 }, backend: o8, attrs: { shape: x } }), m.push(n8));
    }
    let h = Ap({ a: p ? d : f, b: p ? f : d, transposeA: u, transposeB: c, backend: o8, bias: n8, activation: i10, preluActivationWeights: s, leakyreluAlpha: a }), g = pe({ inputs: { x: h }, backend: o8, attrs: { shape: t8.outShape } });
    m.push(h);
    for (let x of m)
      o8.disposeData(x.dataId);
    return g;
  }
  function due({ x: r8, filter: e8, convInfo: t8, backend: o8, bias: n8 = null, preluActivationWeights: s = null, leakyreluAlpha: a = 0, activation: i10 = null }) {
    let { filterWidth: p, filterHeight: u, inChannels: c, strideWidth: l, strideHeight: m, padInfo: d, outWidth: f, outHeight: h, dilationWidth: g, dilationHeight: x, dataFormat: b } = t8, C = b === "channelsLast", S = p * u * c, k = h * f, _ = C ? [t8.batchSize, k, S] : [t8.batchSize, S, k], E = new hx(_, C), R = [{ type: "int32", data: [d.top, d.left] }, { type: "int32", data: [m, l] }, { type: "int32", data: [x, g] }, { type: "int32", data: [f] }, { type: "int32", data: [c * p] }, { type: "int32", data: [c] }], D = o8.runWebGPUProgram(E, [r8], r8.dtype, R), P = [];
    P.push(D);
    let O = pe({ inputs: { x: e8 }, backend: o8, attrs: { shape: [1, S, -1] } });
    if (P.push(O), s != null) {
      let U = gx(s.shape, C);
      U != null && (s = pe({ inputs: { x: s }, backend: o8, attrs: { shape: U } }), P.push(s));
    }
    if (n8 != null) {
      let U = gx(n8.shape, C);
      U != null && (n8 = pe({ inputs: { x: n8 }, backend: o8, attrs: { shape: U } }), P.push(n8));
    }
    let B = Ap({ a: C ? D : O, b: C ? O : D, transposeA: !C, transposeB: false, backend: o8, bias: n8, activation: i10, preluActivationWeights: s, leakyreluAlpha: a }), z = pe({ inputs: { x: B }, backend: o8, attrs: { shape: t8.outShape } });
    P.push(B);
    for (let U of P)
      o8.disposeData(U.dataId);
    return z;
  }
  function xx({ x: r8, filter: e8, convInfo: t8, backend: o8, bias: n8 = null, preluActivationWeights: s = null, leakyreluAlpha: a = 0, activation: i10 = null }) {
    let p = n8 != null, u = s != null, c = t8.dataFormat === "channelsLast", l = c && t8.filterHeight === t8.inHeight && t8.filterWidth === t8.inWidth && t8.padInfo.type === "VALID", m = A().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");
    if (!m && (l || t8.filterHeight === 1 && t8.filterWidth === 1 && t8.dilationHeight === 1 && t8.dilationWidth === 1 && t8.strideHeight === 1 && t8.strideWidth === 1 && (t8.padInfo.type === "SAME" || t8.padInfo.type === "VALID")))
      return mue({ x: r8, filter: e8, convInfo: t8, backend: o8, bias: n8, activation: i10, preluActivationWeights: s, leakyreluAlpha: a });
    let d = A().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), f = d > 0 ? d : o8.thresholdToIncreaseWorkgroups, h = t8.batchSize * Math.ceil(t8.outHeight * t8.outWidth / 32) * Math.ceil(t8.outChannels / 32);
    if (A().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") || h <= f)
      return due({ x: r8, filter: e8, convInfo: t8, backend: o8, bias: n8, preluActivationWeights: s, leakyreluAlpha: a, activation: i10 });
    let g, x = [t8.padInfo.top, t8.padInfo.left], b = [{ type: "int32", data: [t8.filterHeight, t8.filterWidth] }, { type: "int32", data: [...x] }, { type: "int32", data: [t8.strideHeight, t8.strideWidth] }, { type: "int32", data: [t8.dilationHeight, t8.dilationWidth] }];
    if (m)
      g = new fx(t8, p, i10, u);
    else {
      let _ = c ? t8.outHeight * t8.outWidth : t8.outChannels, E = c ? t8.outChannels : t8.outHeight * t8.outWidth, R = t8.filterHeight * t8.filterWidth * t8.inChannels;
      b.push({ type: "int32", data: [_] }, { type: "int32", data: [E] }, { type: "int32", data: [R] });
      let D = o8.adapterInfo.isIntel();
      g = new dx(t8, _, E, R, p, i10, u, D);
    }
    let C = [], S = [r8, e8];
    p && (!c && n8.shape.length === 1 && (n8 = pe({ inputs: { x: n8 }, backend: o8, attrs: { shape: [n8.shape[0], 1, 1] } }), C.push(n8)), S.push(n8)), u && (!c && s.shape.length === 1 && (s = pe({ inputs: { x: s }, backend: o8, attrs: { shape: [s.shape[0], 1, 1] } }), C.push(s)), S.push(s)), i10 === "leakyrelu" && (b.push({ type: "float32", data: [a] }), g.uniforms += " alpha : f32,");
    let k = o8.runWebGPUProgram(g, S, r8.dtype, b);
    for (let _ of C)
      o8.disposeData(_.dataId);
    return k;
  }
  function fue(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dataFormat: p, dilations: u, dimRoundingMode: c } = t8, l = w.convertConv2DDataFormat(p), m = w.computeConv2DInfo(n8.shape, s.shape, a, u, i10, c, false, l);
    return xx({ x: n8, filter: s, convInfo: m, backend: o8 });
  }
  var dV = { kernelName: tn, backendName: "webgpu", kernelFunc: fue };
  var yx = class {
    constructor(e8) {
      this.variableNames = ["dy", "W"], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,", this.workgroupSize = [64, 1, 1], this.size = false, this.isVec4 = false, this.workPerThread = 1, this.outputShape = e8.inShape, this.isChannelsLast = e8.dataFormat === "channelsLast", this.isVec4 = this.isChannelsLast && e8.outChannels % 4 === 0 && e8.inChannels % 4 === 0, this.isVec4 ? (this.workPerThread = 2, this.outputComponent = 4, this.workgroupSize = [4, 4, 4], this.dispatchLayout = { x: [3], y: [2], z: [0, 1] }, this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [4, this.workPerThread, 1])) : (this.size = true, this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize)), this.shaderKey = `conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`;
    }
    getUserCode() {
      let e8 = this.isChannelsLast ? 1 : 2, t8 = this.isChannelsLast ? 2 : 3, o8 = this.isChannelsLast ? 3 : 1, n8 = `
    ${H()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;
      return this.isVec4 ? `
    ${n8}
    ` : `
    ${H("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${o8}];

        let dyCorner = vec2<i32>(coords[${e8}], coords[${t8}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast ? "getDy(batch, idyR, idyC, d2)" : "getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  };
  var bx = class {
    constructor(e8) {
      this.variableNames = ["x", "dy"], this.uniforms = "pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.filterShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = e8.dataFormat === "channelsLast", this.shaderKey = `conv2DDerFilter_${this.isChannelsLast}`;
    }
    getUserCode() {
      return `
    ${H("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  };
  var Cx = class {
    constructor(e8) {
      this.variableNames = ["x", "dy"], this.uniforms = `pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.filterShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerFilter";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  };
  var wx = class {
    constructor(e8) {
      this.variableNames = ["dy", "W"], this.uniforms = `filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.inShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerInput";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  };
  function hue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, pad: i10, dataFormat: p, dimRoundingMode: u, filterShape: c } = o8, l = w.convertConv2DDataFormat(p), m = w.computeConv2DInfo(n8.shape, c, a, 1, i10, u, false, l), d = new bx(m), f = [{ type: "int32", data: [m.padInfo.top, m.padInfo.left] }, { type: "int32", data: [m.strideHeight, m.strideWidth] }, { type: "int32", data: [m.batchSize] }, { type: "int32", data: [m.outHeight] }, { type: "int32", data: [m.outWidth] }, { type: "int32", data: [m.inHeight] }, { type: "int32", data: [m.inWidth] }];
    return t8.runWebGPUProgram(d, [n8, s], n8.dtype, f);
  }
  var fV = { kernelName: Ai, backendName: "webgpu", kernelFunc: hue };
  function gue(r8 = 4) {
    let e8 = (s) => {
      switch (s) {
        case 1:
          return "return W[getIndexFromCoords4D(coord, uniforms.wShape)];";
        case 4:
          return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;
        default:
          throw new Error(`innerElementSize ${s} is not supported.`);
      }
    }, o8 = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Ae(r8)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Ae(r8)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r8}];`}
      }
      return ${Ae(r8)}(0.0);`;
    return `
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Ae(r8)} {
    let col = colIn * ${r8};
    ${o8}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Ae(r8)} {
    let col = colIn * ${r8};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e8(r8)}
    }
    return ${Ae(r8)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${Ae(r8)}) {
    let col = colIn * ${r8};
    if (row < uniforms.dimAOuter && (col + ${r8 - 1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r8}] = value;
    }
  }`;
  }
  var Sx = class {
    constructor(e8) {
      this.variableNames = ["x", "W"], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e8.inShape, y.assert(e8.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), this.isVec4 = e8.inChannels % 4 === 0 && e8.outChannels % 4 === 0, this.dispatchLayout = { x: [3], y: [1, 2], z: [0] }, this.workgroupSize = um(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = pm(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 && (this.outputComponent = 4, this.variableComponents = [4, 1]), this.shaderKey = `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;
    }
    getUserCode() {
      let e8 = this.isVec4 ? Rp(this.elementsPerThread, this.workgroupSize) : Dp(this.elementsPerThread, this.workgroupSize);
      return `
    ${gue(this.isVec4 ? 4 : 1)}
    ${e8}
    `;
    }
  };
  function xue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { inputShape: a, strides: i10, pad: p, dataFormat: u, dimRoundingMode: c } = o8, l = w.convertConv2DDataFormat(u), m = w.computeConv2DInfo(a, s.shape, i10, 1, p, c, false, l), d = [{ type: "int32", data: [m.filterHeight, m.filterWidth] }, { type: "int32", data: [m.filterHeight - 1 - m.padInfo.top, m.filterWidth - 1 - m.padInfo.left] }, { type: "int32", data: [m.strideHeight, m.strideWidth] }, { type: "int32", data: [m.batchSize, m.outHeight, m.outWidth, m.outChannels] }], f;
    if (A().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE") || m.dataFormat !== "channelsLast")
      f = new yx(m);
    else {
      f = new Sx(m);
      let h = m.inHeight * m.inWidth, g = m.inChannels, x = m.filterHeight * m.filterWidth * m.outChannels;
      d.push({ type: "uint32", data: [h] }, { type: "uint32", data: [g] }, { type: "uint32", data: [x] });
    }
    return t8.runWebGPUProgram(f, [n8, s], "float32", d);
  }
  var hV = { kernelName: rn, backendName: "webgpu", kernelFunc: xue };
  var Ix = class {
    constructor(e8) {
      this.variableNames = ["x", "W"], this.uniforms = "filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.outShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3dnaive";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`;
    }
  };
  function yue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p } = o8, u = w.computeConv3DInfo(n8.shape, s.shape, a, p, i10), c = [u.padInfo.front, u.padInfo.top, u.padInfo.left], l = [{ type: "int32", data: [u.filterDepth, u.filterHeight, u.filterWidth] }, { type: "int32", data: [...c] }, { type: "int32", data: [u.strideDepth, u.strideHeight, u.strideWidth] }, { type: "int32", data: [u.dilationDepth, u.dilationHeight, u.dilationWidth] }], m = new Ix(u), d = dt(n8.dtype, s.dtype);
    return t8.runWebGPUProgram(m, [n8, s], d, l);
  }
  var gV = { kernelName: on, backendName: "webgpu", kernelFunc: yue };
  function bue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, pad: i10, filterShape: p } = o8, u = w.computeConv3DInfo(n8.shape, p, a, 1, i10), c = new Cx(u), l = [{ type: "int32", data: [u.padInfo.front, u.padInfo.top, u.padInfo.left] }, { type: "int32", data: [u.strideDepth, u.strideHeight, u.strideWidth] }, { type: "int32", data: [u.batchSize] }, { type: "int32", data: [u.outDepth] }, { type: "int32", data: [u.outHeight] }, { type: "int32", data: [u.outWidth] }, { type: "int32", data: [u.inDepth] }, { type: "int32", data: [u.inHeight] }, { type: "int32", data: [u.inWidth] }];
    return t8.runWebGPUProgram(c, [n8, s], s.dtype, l);
  }
  var xV = { kernelName: Ka, backendName: "webgpu", kernelFunc: bue };
  function Cue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { strides: a, pad: i10, inputShape: p } = o8, u = w.computeConv3DInfo(p, s.shape, a, 1, i10), c = new wx(u), l = [{ type: "int32", data: [u.filterDepth, u.filterHeight, u.filterWidth] }, { type: "int32", data: [u.filterDepth - 1 - u.padInfo.front, u.filterHeight - 1 - u.padInfo.top, u.filterWidth - 1 - u.padInfo.left] }, { type: "int32", data: [u.strideDepth, u.strideHeight, u.strideWidth] }, { type: "int32", data: [u.outDepth] }, { type: "int32", data: [u.outHeight] }, { type: "int32", data: [u.outWidth] }, { type: "int32", data: [u.outChannels] }];
    return t8.runWebGPUProgram(c, [n8, s], n8.dtype, l);
  }
  var yV = { kernelName: nn, backendName: "webgpu", kernelFunc: Cue };
  var wue = ye({ opType: Z.COS });
  var bV = { kernelName: sn, backendName: "webgpu", kernelFunc: wue };
  var Sue = ye({ opType: Z.COSH });
  var CV = { kernelName: an, backendName: "webgpu", kernelFunc: Sue };
  var vx = class {
    constructor(e8, t8, o8, n8) {
      this.variableNames = ["Image", "Boxes", "BoxInd"], this.uniforms = "extrapolationValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true;
      let [s] = t8;
      this.outputShape = [s, o8[0], o8[1], e8], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.methodId = n8 === "bilinear" ? 1 : 0, this.cropHeightBiggerThan1 = this.outputShape[1] > 1, this.cropWidthBiggerThan1 = this.outputShape[2] > 1, this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
    }
    getUserCode() {
      let [e8, t8] = ["f32(uniforms.imageShape[1] - 1)", "f32(uniforms.imageShape[2] - 1)"], [o8, n8, s] = this.cropHeightBiggerThan1 ? [`(${e8} / f32(uniforms.outShape[1] - 1))`, "(y2-y1) * height_ratio", `y1*${e8} + f32(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${e8}`], [a, i10, p] = this.cropWidthBiggerThan1 ? [`(${t8} / f32(uniforms.outShape[2] - 1))`, "(x2-x1) * width_ratio", `x1*${t8} + f32(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${t8}`];
      return `
    ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${o8});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${n8};
        let width_scale = ${i10};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e8} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${p};
        if( in_x < 0.0 || in_x > ${t8} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;
    }
  };
  var Iue = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { image: n8, boxes: s, boxInd: a } = e8, { cropSize: i10, method: p, extrapolationValue: u } = o8, c = new vx(n8.shape[3], s.shape, i10, p), l = [{ type: "float32", data: [u] }];
    return t8.runWebGPUProgram(c, [n8, s, a], "float32", l);
  };
  var wV = { kernelName: cn, backendName: "webgpu", kernelFunc: Iue };
  var Pp;
  (function(r8) {
    r8.Prod = "*", r8.Sum = "+";
  })(Pp || (Pp = {}));
  var fm = class {
    constructor(e8, t8, o8, n8) {
      this.variableNames = ["x"], this.uniforms = "index : f32,", this.size = true, this.workgroupSize = [128, 1, 1], this.outputShape = t8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.exclusive = o8, this.reverse = n8, this.op = e8, this.shaderKey = `cum_${this.op}_${this.exclusive}_${this.reverse}`;
    }
    getUserCode() {
      let e8 = this.outputShape.length, t8 = this.op === Pp.Prod ? "1.0" : "0.0", o8 = this.exclusive ? t8 : `getX(${SV(e8, "coords", this.op)})`, n8 = this.outputShape[this.outputShape.length - 1], s = "", a = "";
      return this.exclusive ? (s = this.reverse ? `end != ${n8 - 1}` : "end != 0", a = this.reverse ? "end + 1" : "end - 1") : (s = this.reverse ? `end + pow2 < ${n8}` : "end >= pow2", a = this.reverse ? "end + pow2" : "end - pow2"), `
      ${H("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${IV(e8, "coords", this.op)};
         var val = ${o8};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${a};
           ${IV(e8, "coords", this.op)} = idx;
           val ${this.op}= getX(${SV(e8, "coords", this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `;
    }
  };
  function SV(r8, e8, t8) {
    if (r8 === 1)
      return `${e8}`;
    if (r8 === 2)
      return `${e8}.x, ${e8}.y`;
    if (r8 === 3)
      return `${e8}.x, ${e8}.y, ${e8}.z`;
    if (r8 === 4)
      return `${e8}.x, ${e8}.y, ${e8}.z, ${e8}.w`;
    throw Error(`Cumulative ${t8} for rank ${r8} is not yet supported`);
  }
  function IV(r8, e8, t8) {
    if (r8 === 1)
      return `${e8}`;
    if (r8 === 2)
      return `${e8}.y`;
    if (r8 === 3)
      return `${e8}.z`;
    if (r8 === 4)
      return `${e8}.w`;
    throw Error(`Cumulative ${t8} for rank ${r8} is not yet supported`);
  }
  function kx(r8, e8, t8, o8, n8, s) {
    let a = e8.shape.length, i10 = w.getAxesPermutation([o8], a), p = e8;
    i10 != null && (p = yr({ inputs: { x: e8 }, backend: t8, attrs: { perm: i10 } }));
    let u = w.getInnerMostAxes(1, a)[0];
    if (u !== a - 1)
      throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e8.shape.length - 1} but got axis=${o8}`);
    let c = p.shape[u], l = At({ inputs: { x: p }, backend: t8 });
    for (let m = 0; m <= Math.ceil(Math.log2(c)) - 1; m++) {
      let d = new fm(r8, p.shape, false, s), f = l, h = [{ type: "float32", data: [m] }];
      l = t8.runWebGPUProgram(d, [l], l.dtype, h), t8.disposeData(f.dataId);
    }
    if (n8) {
      let m = new fm(r8, p.shape, n8, s), d = l, f = [{ type: "float32", data: [0] }];
      l = t8.runWebGPUProgram(m, [l], l.dtype, f), t8.disposeData(d.dataId);
    }
    if (i10 != null) {
      let m = w.getUndoAxesPermutation(i10), d = yr({ inputs: { x: l }, backend: t8, attrs: { perm: m } });
      return t8.disposeData(l.dataId), t8.disposeData(p.dataId), d;
    }
    return l;
  }
  function vue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8;
    return kx(Pp.Prod, n8, t8, s, a, i10);
  }
  var vV = { kernelName: un, backendName: "webgpu", kernelFunc: vue };
  function kue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, exclusive: a, reverse: i10 } = o8;
    return kx(Pp.Sum, n8, t8, s, a, i10);
  }
  var kV = { kernelName: pn, backendName: "webgpu", kernelFunc: kue };
  function Nue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, weights: s } = e8, { size: a, binaryOutput: i10 } = o8, p = n8.shape.length === 1, c = y.sizeFromShape(s.shape) > 0, l = s.dtype, m = p ? [n8.shape[0]] : [n8.shape[0], n8.shape[1]], d = p ? [a] : [n8.shape[0], a], f = Vt({ backend: t8, attrs: { shape: d, value: 0, dtype: l } }), h = new Xc(m, c, i10), g = [{ type: "int32", data: [a] }], x = c ? [n8, s] : [n8];
    return t8.runWebGPUProgram(h, x, l, g, f);
  }
  var NV = { kernelName: ta, backendName: "webgpu", kernelFunc: Nue };
  var Nx = class {
    constructor(e8, t8) {
      this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.uniforms = "blockSize : i32,", this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `depthToSpace_${t8}`, this.dataFormat = t8;
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;
    }
    getHeightCoordString() {
      return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
      return this.dataFormat === "NHWC" ? "uniforms.outShape[3]" : "uniforms.outShape[1]";
    }
    getInputSamplingString() {
      return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  };
  function Tue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockSize: s, dataFormat: a } = o8, i10 = n8.shape[0], p = a === "NHWC" ? n8.shape[1] : n8.shape[2], u = a === "NHWC" ? n8.shape[2] : n8.shape[3], c = a === "NHWC" ? n8.shape[3] : n8.shape[1], l = p * s, m = u * s, d = c / (s * s), f = a === "NHWC" ? [i10, l, m, d] : [i10, d, l, m], h = [{ type: "int32", data: [s] }], g = new Nx(f, a);
    return t8.runWebGPUProgram(g, [n8], n8.dtype, h);
  }
  var TV = { kernelName: ln, backendName: "webgpu", kernelFunc: Tue };
  var Tx = class {
    constructor(e8, t8, o8, n8 = false, s = null, a = false) {
      this.variableNames = ["x", "W"], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>,", this.workgroupSize = [16, 16, 1], this.outputShape = e8, this.dispatchLayout = { x: [3], y: [2], z: [0, 1] }, this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), n8 && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), this.addBias = n8, this.activation = s, this.hasPreluActivation = a, this.filterHeight = t8, this.filterWidth = o8, this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
    }
    getUserCode() {
      let e8 = this.filterWidth * this.filterHeight, t8 = this.workgroupSize[0] * this.workgroupSize[1] * this.workgroupSize[2], o8 = this.workgroupSize[1] + this.filterHeight - 1, n8 = this.workgroupSize[0] + this.filterWidth - 1;
      return `
      ${dr(this.activation, this.hasPreluActivation, false, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${n8}>, ${o8}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${H()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${o8}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${n8}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e8 < t8 ? `if (wIndex < ${e8})` : `for(; wIndex < ${e8}; wIndex = wIndex + ${t8})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Qr(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
  };
  var Qc = class {
    constructor(e8, t8 = false, o8 = null, n8 = false) {
      this.variableNames = ["x", "W"], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,", this.workgroupSize = [64, 1, 1], this.workPerThread = 4, this.outputComponent = 4, this.outputShape = e8.outShape, this.virtualWidth = Math.ceil(this.outputShape[2] / this.workPerThread) * this.workPerThread;
      let s = [this.outputShape[0], this.outputShape[1], this.virtualWidth, this.outputShape[3]];
      this.dispatchLayout = X(s), this.dispatch = K(this.dispatchLayout, s, this.workgroupSize, [this.outputComponent * this.workPerThread, 1, 1]), y.assert(e8.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), t8 && this.variableNames.push("bias"), n8 && this.variableNames.push("preluActivationWeights"), this.convInfo = e8, this.addBias = t8, this.activation = o8, this.hasPreluActivation = n8, this.shaderKey = `depthwiseVec4_${o8}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`;
    }
    getUserCode() {
      let e8 = (this.workPerThread - 1) * this.convInfo.strideWidth + this.convInfo.filterWidth, t8 = this.convInfo.strideHeight, o8 = this.convInfo.strideWidth;
      return `
      ${dr(this.activation, this.hasPreluActivation, true, 4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${H("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t8}, ${o8}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e8}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e8}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${o8} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Qr(this.addBias, this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;
    }
  };
  var Zc = class {
    constructor(e8, t8 = false, o8 = null, n8 = false) {
      this.variableNames = ["x", "W"], this.uniforms = `pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`, this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e8.outShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = e8.dataFormat === "channelsLast", t8 && this.variableNames.push("bias"), n8 && this.variableNames.push("preluActivationWeights"), this.convInfo = e8, this.addBias = t8, this.activation = o8, this.hasPreluActivation = n8, this.shaderKey = `depthwise_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
      let e8 = this.isChannelsLast ? "getX(batch, xR, xC, d1);" : "getX(batch, d1, xR, xC);";
      return `
      ${dr(this.activation, this.hasPreluActivation, false, 4)}

      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast ? "yz" : "zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast ? 3 : 1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e8};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e8};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Qr(this.addBias, this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
  };
  function _ue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dataFormat: p, dilations: u, dimRoundingMode: c } = o8, l = w.convertConv2DDataFormat(p), m = u;
    m == null && (m = [1, 1]);
    let d = w.computeConv2DInfo(n8.shape, s.shape, a, m, i10, c, true, l), f = [{ type: "int32", data: [d.padInfo.top, d.padInfo.left] }, { type: "int32", data: [d.inHeight, d.inWidth] }], h = d.dataFormat === "channelsLast", g;
    return !h && d.inHeight > 16 && d.inWidth > 16 && d.strideHeight === 1 && d.strideWidth === 1 && d.dilationWidth === 1 && d.dilationHeight === 1 && d.inChannels === d.outChannels ? g = new Tx(d.outShape, d.filterHeight, d.filterWidth) : h && d.outHeight > 4 && d.outWidth > 4 && d.strideWidth <= 2 && d.inChannels === d.outChannels && d.dilationHeight === 1 && d.dilationWidth === 1 && d.inChannels % 4 === 0 ? (g = new Qc(d), f.push({ type: "int32", data: [g.virtualWidth] })) : (g = new Zc(d), f.push({ type: "int32", data: [d.filterHeight] }, { type: "int32", data: [d.filterWidth] }, { type: "int32", data: [d.strideHeight, d.strideWidth] }, { type: "int32", data: [d.dilationHeight, d.dilationWidth] })), t8.runWebGPUProgram(g, [n8, s], n8.dtype, f);
  }
  var _V = { kernelName: mn, backendName: "webgpu", kernelFunc: _ue };
  var _x = class {
    constructor(e8) {
      this.variableNames = ["x", "dy"], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.filterShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_filter";
    }
    getUserCode() {
      return `
      ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  };
  var $x = class {
    constructor(e8) {
      this.variableNames = ["dy", "W"], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.inShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_input";
    }
    getUserCode() {
      return `
      ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  };
  function $ue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, dy: s } = e8, { strides: a, dilations: i10, pad: p, dimRoundingMode: u, filterShape: c } = o8, l = w.computeConv2DInfo(n8.shape, c, a, i10, p, u, true), m = new _x(l), d = [{ type: "int32", data: [l.strideHeight, l.strideWidth] }, { type: "int32", data: [l.padInfo.top, l.padInfo.left] }, { type: "int32", data: [l.filterHeight, l.filterWidth] }, { type: "int32", data: [l.outHeight] }, { type: "int32", data: [l.outWidth] }, { type: "int32", data: [l.inHeight] }, { type: "int32", data: [l.inWidth] }, { type: "int32", data: [l.batchSize] }, { type: "int32", data: [l.outChannels / l.inChannels] }];
    return t8.runWebGPUProgram(m, [n8, s], "float32", d);
  }
  var $V = { kernelName: Fi, backendName: "webgpu", kernelFunc: $ue };
  function Eue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, filter: s } = e8, { strides: a, dilations: i10, pad: p, dimRoundingMode: u, inputShape: c } = o8, l = w.computeConv2DInfo(c, s.shape, a, i10, p, u, true), m = new $x(l), d = [{ type: "int32", data: [l.strideHeight, l.strideWidth] }, { type: "int32", data: [l.filterHeight - 1 - l.padInfo.top, l.filterWidth - 1 - l.padInfo.left] }, { type: "int32", data: [l.filterHeight, l.filterWidth] }, { type: "int32", data: [l.outHeight] }, { type: "int32", data: [l.outWidth] }, { type: "int32", data: [l.outChannels / l.inChannels] }];
    return t8.runWebGPUProgram(m, [n8, s], n8.dtype, d);
  }
  var EV = { kernelName: Pi, backendName: "webgpu", kernelFunc: Eue };
  var Ex = class {
    constructor(e8) {
      this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e8, e8], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "diag";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
  };
  function Rue(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8, n8 = [...o8.shape, ...o8.shape], s = y.sizeFromShape(o8.shape), a = pe({ inputs: { x: o8 }, backend: t8, attrs: { shape: [s] } }), i10 = new Ex(s), p = t8.runWebGPUProgram(i10, [a], a.dtype), u = pe({ inputs: { x: p }, backend: t8, attrs: { shape: n8 } });
    return t8.disposeData(a.dataId), t8.disposeData(p.dataId), u;
  }
  var RV = { kernelName: ra, backendName: "webgpu", kernelFunc: Rue };
  var Rx = class {
    constructor(e8) {
      this.variableNames = ["x", "w"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.outShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "dilation2d";
    }
    getUserCode() {
      return `
       ${H("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `;
    }
  };
  function Due(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s } = e8, { strides: a, pad: i10, dilations: p } = o8, u = w.computeDilation2DInfo(n8.shape, s.shape, a, i10, "NHWC", p), c = [u.padInfo.top, u.padInfo.left], l = [{ type: "int32", data: [u.filterHeight, u.filterWidth] }, { type: "int32", data: [...c] }, { type: "int32", data: [u.strideHeight, u.strideWidth] }, { type: "int32", data: [u.dilationHeight, u.dilationWidth] }], m = new Rx(u);
    return t8.runWebGPUProgram(m, [n8, s], n8.dtype, l);
  }
  var DV = { kernelName: dn, backendName: "webgpu", kernelFunc: Due };
  var Dx = class {
    constructor(e8, t8) {
      if (this.variableNames = ["x", "w", "dy"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = e8.inShape, this.dispatchLayout = X(e8.outShape), this.dispatch = K(this.dispatchLayout, e8.outShape, this.workgroupSize), t8 !== "float32" && t8 !== "int32")
        throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t8} type.`);
      this.type = t8, this.shaderKey = "dilation2DBackpropInput";
    }
    getUserCode() {
      return `
       ${H("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Us("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
  };
  var Ax = class {
    constructor(e8, t8, o8) {
      if (this.variableNames = ["x", "w", "dy"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = e8.filterShape, this.dispatchLayout = X(e8.outShape), this.dispatch = K(this.dispatchLayout, e8.outShape, this.workgroupSize), o8 !== "float32" && o8 !== "int32")
        throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${o8} type.`);
      this.type = o8, this.shaderKey = "dilation2DBackpropFilter";
    }
    getUserCode() {
      return `
       ${H("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Us("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
  };
  function Aue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, dy: a } = e8, { strides: i10, pad: p, dilations: u } = o8, c = w.computeDilation2DInfo(n8.shape, s.shape, i10, p, "NHWC", u), l = s.dtype, m = new Ax(c, s.shape, l), d = [{ type: "int32", data: [c.filterHeight, c.filterWidth] }, { type: "int32", data: [c.padInfo.top, c.padInfo.left] }, { type: "int32", data: [c.strideHeight, c.strideWidth] }, { type: "int32", data: [c.dilationHeight, c.dilationWidth] }, { type: "int32", data: [y.sizeFromShape(c.outShape)] }], f = Vt({ backend: t8, attrs: { shape: s.shape, value: 0, dtype: l } });
    return t8.runWebGPUProgram(m, [n8, s, a], l, d, f);
  }
  var AV = { kernelName: Mi, backendName: "webgpu", kernelFunc: Aue };
  function Fue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, dy: a } = e8, { strides: i10, pad: p, dilations: u } = o8, c = w.computeDilation2DInfo(n8.shape, s.shape, i10, p, "NHWC", u), l = n8.dtype, m = new Dx(c, l), d = [{ type: "int32", data: [c.filterHeight, c.filterWidth] }, { type: "int32", data: [c.padInfo.top, c.padInfo.left] }, { type: "int32", data: [c.strideHeight, c.strideWidth] }, { type: "int32", data: [c.dilationHeight, c.dilationWidth] }, { type: "int32", data: [y.sizeFromShape(c.outShape)] }], f = Vt({ backend: t8, attrs: { shape: c.inShape, value: 0, dtype: l } });
    return t8.runWebGPUProgram(m, [n8, s, a], l, d, f);
  }
  var FV = { kernelName: Oi, backendName: "webgpu", kernelFunc: Fue };
  var Qv = et({ opType: fe.MUL, cpuKernelImpl: gz, supportsComplex: true });
  var PV = { kernelName: Xn, backendName: "webgpu", kernelFunc: Qv };
  function Zv(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    return Jr(n8, s, a, "sum", t8);
  }
  var OV = { kernelName: Ss, backendName: "webgpu", kernelFunc: Zv };
  function Pue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { equation: n8 } = o8, s = e8, { allDims: a, summedDims: i10, idDims: p } = w.decodeEinsumEquation(n8, s.length);
    w.checkEinsumDimSizes(a.length, p, s);
    let { path: u, steps: c } = w.getEinsumComputePath(i10, p), l = c.length, m = null, d = a.length, f = [];
    for (let h = 0; h < l; ++h) {
      for (let g of c[h]) {
        let { permutationIndices: x, expandDims: b } = w.getEinsumPermutation(d, p[g]), C;
        w.isIdentityPermutation(x) ? C = s[g] : (C = yr({ inputs: { x: s[g] }, backend: t8, attrs: { perm: x } }), f.push(C));
        let S = C.shape.slice();
        for (let k = 0; k < b.length; ++k)
          S.splice(b[k], 0, 1);
        y.arraysEqual(C.shape, S) || (C = pe({ inputs: { x: C }, backend: t8, attrs: { shape: S } }), f.push(C)), m === null ? m = C : (m = Qv({ inputs: { a: C, b: m }, backend: t8 }), f.push(m));
      }
      h < l - 1 && (u[h] >= 0 && (m = Zv({ inputs: { x: m }, backend: t8, attrs: { axis: u[h] - (a.length - d), keepDims: false } }), f.push(m)), d--);
    }
    for (let h of f)
      h !== m && t8.disposeData(h.dataId);
    return m;
  }
  var MV = { kernelName: Li, backendName: "webgpu", kernelFunc: Pue };
  var Oue = ye({ opType: Z.ELU });
  var LV = { kernelName: hn, backendName: "webgpu", kernelFunc: Oue };
  var Mue = (r8) => {
    let { inputs: e8, backend: t8 } = r8, { dy: o8, y: n8 } = e8, s = new Si(fe.ELU_DER, o8.shape, n8.shape);
    return t8.runWebGPUProgram(s, [o8, n8], o8.dtype);
  };
  var BV = { kernelName: qa, backendName: "webgpu", kernelFunc: Mue };
  var Lue = et({ opType: fe.EQUAL, dtype: "bool", cpuKernelImpl: tz });
  var zV = { kernelName: xn, backendName: "webgpu", kernelFunc: Lue };
  var Bue = ye({ opType: Z.ERF });
  var VV = { kernelName: gn, backendName: "webgpu", kernelFunc: Bue };
  var zue = ye({ opType: Z.EXP, cpuKernelImpl: rz, dtype: "float32" });
  var WV = { kernelName: yn, backendName: "webgpu", kernelFunc: zue };
  function Fx(r8) {
    let { inputs: e8, attrs: t8, backend: o8 } = r8, { dim: n8 } = t8, { input: s } = e8, a = s.shape.length, i10 = s.shape.slice(), p = n8;
    return n8 < 0 && (y.assert(-(a + 1) <= n8, () => `Axis must be in the interval [${-(a + 1)}, ${a}]`), p = a + n8 + 1), i10.splice(p, 0, 1), pe({ inputs: { x: s }, backend: o8, attrs: { shape: i10 } });
  }
  var UV = { kernelName: oa, backendName: "webgpu", kernelFunc: Fx };
  var Vue = ye({ opType: Z.EXPM1, cpuKernelImpl: oz });
  var GV = { kernelName: bn, backendName: "webgpu", kernelFunc: Vue };
  var hm = class {
    constructor(e8, t8) {
      this.variableNames = ["real", "imag"], this.outputShape = [], this.uniforms = "exponentMultiplier : f32, denominator: f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.component = e8, this.shaderKey = `fft_${e8}`;
    }
    getUserCode() {
      return `
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component === "real" ? "return real * expR - imag * expI;" : "return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${H("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `;
    }
  };
  function Px(r8, e8, t8) {
    let o8 = t8.tensorMap.get(r8.dataId), n8 = y.sizeFromShape(r8.shape), s = r8.shape[r8.shape.length - 1], a = n8 / s, i10 = [], p = pe({ inputs: { x: r8 }, backend: t8, attrs: { shape: [a, s] } });
    i10.push(p);
    let u = p.shape, c = new hm("real", u), l = new hm("imag", u), m = [{ dataId: o8.complexTensorInfos.real.dataId, dtype: o8.complexTensorInfos.real.dtype, shape: u }, { dataId: o8.complexTensorInfos.imag.dataId, dtype: o8.complexTensorInfos.imag.dtype, shape: u }], d = e8 ? 2 * Math.PI : -2 * Math.PI, f = e8 ? u[1] : 1, h = [{ type: "float32", data: [d] }, { type: "float32", data: [f] }], g = t8.runWebGPUProgram(c, m, "float32", h);
    i10.push(g);
    let x = t8.runWebGPUProgram(l, m, "float32", h);
    i10.push(x);
    let b = xo({ inputs: { real: g, imag: x }, backend: t8 });
    i10.push(b);
    let C = pe({ inputs: { x: b }, backend: t8, attrs: { shape: r8.shape } });
    return i10.forEach((S) => t8.disposeData(S.dataId)), C;
  }
  function Wue(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8;
    return Px(o8, false, t8);
  }
  var HV = { kernelName: Bi, backendName: "webgpu", kernelFunc: Wue };
  var Ox = class {
    constructor(e8) {
      this.outputShape = [], this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "flipLeftRight";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;
    }
  };
  var KV = { kernelName: Cn, backendName: "webgpu", kernelFunc: ({ inputs: r8, backend: e8 }) => {
    let { image: t8 } = r8, o8 = e8, n8 = new Ox(t8.shape);
    return o8.runWebGPUProgram(n8, [t8], t8.dtype);
  } };
  var Uue = ye({ opType: Z.FLOOR, cpuKernelImpl: nz });
  var qV = { kernelName: wn, backendName: "webgpu", kernelFunc: Uue };
  var Gue = et({ opType: fe.INT_DIV, cpuKernelImpl: sz, dtype: "int32" });
  var jV = { kernelName: Sn, backendName: "webgpu", kernelFunc: Gue };
  var Mx = class {
    constructor(e8, t8, o8 = false) {
      this.isFromPixels = true, this.outputShape = [0], this.variableNames = [], this.workgroupSize = [256, 1, 1], this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [t8, 1, 1]), this.importVideo = o8, this.shaderKey = `fromPixels_${this.importVideo}`;
    }
    getUserCode() {
      let e8 = this.importVideo ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
      return `
      @binding(1) @group(0) var src: ${this.importVideo ? "texture_external" : "texture_2d<f32>"};
      ${H("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e8};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
    }
  };
  var XV = { kernelName: Au, backendName: "webgpu", kernelFunc: Hue };
  var Jc;
  var Jv = A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function Hue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { pixels: n8 } = e8, { numChannels: s } = o8;
    if (n8 == null)
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    let a = typeof HTMLVideoElement != "undefined" && n8 instanceof HTMLVideoElement, i10 = typeof HTMLImageElement != "undefined" && n8 instanceof HTMLImageElement, p = typeof HTMLCanvasElement != "undefined" && n8 instanceof HTMLCanvasElement || typeof OffscreenCanvas != "undefined" && n8 instanceof OffscreenCanvas, u = typeof ImageBitmap != "undefined" && n8 instanceof ImageBitmap, [c, l] = a ? [n8.videoWidth, n8.videoHeight] : [n8.width, n8.height], m = [l, c, s], d = false, f = a || i10;
    if (u || p || f) {
      let b;
      {
        if (f) {
          let L = A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
          (Jc == null || L !== Jv) && (Jv = L, Jc = document.createElement("canvas").getContext("2d", { willReadFrequently: Jv })), Jc.canvas.width = c, Jc.canvas.height = l, Jc.drawImage(n8, 0, 0, c, l), n8 = Jc.canvas;
        }
        let P = GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, O = "rgba8unorm", M = t8.textureManager.acquireTexture(m[1], m[0], O, P);
        t8.queue.copyExternalImageToTexture({ source: n8 }, { texture: M }, [m[1], m[0]]), b = M;
      }
      let C = y.sizeFromShape(m), S = y.computeStrides(m), k = new Mx(m, s, d), _ = [{ type: "uint32", data: [C] }, { type: "uint32", data: [s] }, { type: "uint32", data: [...S] }], E = t8.makeTensorInfo([l, c], "int32"), R = t8.tensorMap.get(E.dataId);
      R.resource = b;
      let D = t8.runWebGPUProgram(k, [E], "int32", _);
      return t8.disposeData(E.dataId), D;
    }
    let h = n8.data, g = h;
    if (s != null && s !== 4) {
      g = new Uint8Array(n8.width * n8.height * s);
      let b = h.length, C = 0;
      for (let S = 0; S < b; S++)
        S % 4 < s && (g[C++] = h[S]);
    }
    let x = t8.makeTensorInfo(m, "int32", new Int32Array(g));
    return t8.uploadToGPU(x.dataId), x;
  }
  var Lx = class {
    constructor(e8, t8, o8, n8, s) {
      this.uniforms = "varianceEpsilon : f32,", this.workgroupSize = [128, 1, 1], this.size = true, this.variableNames = ["x", "mean", "variance"], w.assertAndGetBroadcastShape(e8, t8), w.assertAndGetBroadcastShape(e8, o8), this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), n8 != null && (w.assertAndGetBroadcastShape(e8, n8), this.variableNames.push("offset")), s != null && (w.assertAndGetBroadcastShape(e8, s), this.variableNames.push("scale")), this.offsetShape = n8, this.scaleShape = s, this.shaderKey = "batchNorm";
    }
    getUserCode() {
      let e8 = "0.0";
      this.offsetShape != null && (e8 = "getOffsetByOutputIndex(index)");
      let t8 = "1.0";
      return this.scaleShape != null && (t8 = "getScaleByOutputIndex(index)"), `
      ${H("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e8};
          let scaleValue = ${t8};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;
    }
  };
  var YV = { kernelName: In, backendName: "webgpu", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { x: o8, scale: n8, offset: s, mean: a, variance: i10 } = r8, { varianceEpsilon: p } = e8, u = t8, c = [o8, a, i10], l = null;
    s != null && (l = s.shape, c.push(s));
    let m = null;
    n8 != null && (m = n8.shape, c.push(n8));
    let d = new Lx(o8.shape, a.shape, i10.shape, l, m), f = [{ type: "float32", data: [p] }];
    return u.runWebGPUProgram(d, c, o8.dtype, f);
  } };
  function Kue(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dataFormat: c, dilations: l, dimRoundingMode: m, activation: d, leakyreluAlpha: f } = o8, h = w.convertConv2DDataFormat(c), g = w.computeConv2DInfo(n8.shape, s.shape, p, l, u, m, false, h);
    return xx({ x: n8, filter: s, convInfo: g, backend: t8, bias: a, preluActivationWeights: i10, leakyreluAlpha: f, activation: d });
  }
  var QV = { kernelName: Io, backendName: "webgpu", kernelFunc: Kue };
  function que(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, filter: s, bias: a, preluActivationWeights: i10 } = e8, { strides: p, pad: u, dilations: c, dimRoundingMode: l, activation: m, leakyreluAlpha: d } = o8, f = c;
    f == null && (f = [1, 1]), y.assert(w.eitherStridesOrDilationsAreOne(p, f), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${p} and dilations '${f}'`);
    let h = w.computeConv2DInfo(n8.shape, s.shape, p, f, u, l, true), g = [n8, s], x = a != null, b = i10 != null;
    x && g.push(a), b && g.push(i10);
    let C = [{ type: "int32", data: [h.padInfo.top, h.padInfo.left] }, { type: "int32", data: [h.inHeight, h.inWidth] }], S;
    return h.outHeight > 4 && h.outWidth > 4 && h.strideWidth <= 2 && h.inChannels === h.outChannels && h.dilationHeight === 1 && h.dilationWidth === 1 && h.inChannels % 4 === 0 ? (S = new Qc(h, x, m, b), C.push({ type: "int32", data: [S.virtualWidth] })) : (S = new Zc(h, x, m, b), C.push({ type: "int32", data: [h.filterHeight] }, { type: "int32", data: [h.filterWidth] }, { type: "int32", data: [h.strideHeight, h.strideWidth] }, { type: "int32", data: [h.dilationHeight, h.dilationWidth] })), m === "leakyrelu" && (C.push({ type: "float32", data: [d] }), S.uniforms += " alpha : f32,"), t8.runWebGPUProgram(S, g, "float32", C);
  }
  var ZV = { kernelName: vo, backendName: "webgpu", kernelFunc: que };
  var Bx = class {
    constructor(e8, t8) {
      this.variableNames = ["A", "indices"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `gathernd_${e8}`, this.sliceDim = e8, this.uniforms = `sliceDim : i32, strides : ${ht(e8)},`;
    }
    getUserCode() {
      let e8;
      return this.sliceDim > 1 ? e8 = "uniforms.strides[j]" : e8 = "uniforms.strides", `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e8};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;
    }
  };
  function jue(r8) {
    let { inputs: e8, backend: t8 } = r8, { params: o8, indices: n8 } = e8, s = n8.shape, a = s[s.length - 1], i10 = y.sizeFromShape(o8.shape), [p, u, c, l] = w.prepareAndValidate(o8, n8), m = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: [u, a] } }), d = pe({ inputs: { x: o8 }, backend: t8, attrs: { shape: [y.sizeFromShape(o8.shape) / c, c] } });
    if (t8.shouldExecuteOnCPU([o8, n8]) || o8.dtype === "string") {
      let b = t8.readSync(n8.dataId), C = t8.bufferSync(o8), S = az(b, C, o8.dtype, u, a, c, l, o8.shape, i10);
      return t8.makeTensorInfo(p, o8.dtype, S.values);
    }
    let f = new Bx(a, [u, c]), h = [{ type: "int32", data: [a] }, { type: "int32", data: l }], g = t8.runWebGPUProgram(f, [d, m], d.dtype, h), x = pe({ inputs: { x: g }, backend: t8, attrs: { shape: p } });
    return t8.disposeData(m.dataId), t8.disposeData(d.dataId), t8.disposeData(g.dataId), x;
  }
  var JV = { kernelName: vn, backendName: "webgpu", kernelFunc: jue };
  var zx = class {
    constructor(e8, t8) {
      this.variableNames = ["A", "indices"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.slice(), this.aShape = e8, this.outputShape = t8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "gather";
    }
    getUserCode() {
      let e8 = Xue(this.aShape);
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e8}));
        }
      }
    `;
    }
  };
  function Xue(r8) {
    let e8 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], t8 = [];
    for (let o8 = 0; o8 < r8.length; o8++)
      o8 === 2 ? t8.push("indexZ") : t8.push(`${e8[o8]}`);
    return t8.join();
  }
  function e0(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, indices: s } = e8, { axis: a, batchDims: i10 } = o8, p = y.parseAxisParam(a, n8.shape)[0], u = w.segment_util.collectGatherOpShapeInfo(n8, s, p, i10), c = y.sizeFromShape(s.shape), l = [], m = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: [u.batchSize, u.outerSize, u.dimSize, u.sliceSize] } }), d = pe({ inputs: { x: s }, backend: t8, attrs: { shape: [u.batchSize, c / u.batchSize] } });
    l.push(m), l.push(d);
    let f = [u.batchSize, u.outerSize, c / u.batchSize, u.sliceSize];
    if (t8.shouldExecuteOnCPU([n8, s])) {
      let C = t8.tensorMap.get(d.dataId).values, S = me(d.shape, d.dtype, C), _ = t8.tensorMap.get(m.dataId).values, E = me(m.shape, m.dtype, _), R = iz(E, S, f);
      return l.forEach((D) => t8.disposeData(D.dataId)), t8.makeTensorInfo(u.outputShape, R.dtype, R.values);
    }
    let h = new zx(m.shape, f), g = t8.runWebGPUProgram(h, [m, d], m.dtype);
    l.push(g);
    let x = pe({ inputs: { x: g }, backend: t8, attrs: { shape: u.outputShape } });
    return l.forEach((b) => t8.disposeData(b.dataId)), x;
  }
  var eW = { kernelName: sa, backendName: "webgpu", kernelFunc: e0 };
  var Yue = et({ opType: fe.GREATER, cpuKernelImpl: pz, dtype: "bool" });
  var tW = { kernelName: kn, backendName: "webgpu", kernelFunc: Yue };
  var Que = et({ opType: fe.GREATER_EQUAL, dtype: "bool", cpuKernelImpl: uz });
  var rW = { kernelName: Nn, backendName: "webgpu", kernelFunc: Que };
  function Zue(r8) {
    let { inputs: e8, backend: t8 } = r8, { input: o8 } = e8;
    return Px(o8, true, t8);
  }
  var oW = { kernelName: zi, backendName: "webgpu", kernelFunc: Zue };
  var Jue = ye({ opType: Z.IS_FINITE, dtype: "bool" });
  var nW = { kernelName: Tn, backendName: "webgpu", kernelFunc: Jue };
  var epe = ye({ opType: Z.IS_INF, dtype: "bool" });
  var sW = { kernelName: _n, backendName: "webgpu", kernelFunc: epe };
  var tpe = ye({ opType: Z.IS_NAN, dtype: "bool" });
  var aW = { kernelName: $n, backendName: "webgpu", kernelFunc: tpe };
  function rpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { alpha: s } = o8, a = [{ type: "float32", data: [s] }], i10 = new Zr(n8.shape, Z.LEAKYRELU, "alpha : f32,");
    return t8.runWebGPUProgram(i10, [n8], "float32", a);
  }
  var iW = { kernelName: En, backendName: "webgpu", kernelFunc: rpe };
  var ope = et({ opType: fe.LESS, dtype: "bool", cpuKernelImpl: lz });
  var uW = { kernelName: Rn, backendName: "webgpu", kernelFunc: ope };
  var npe = et({ opType: fe.LESS_EQUAL, dtype: "bool", cpuKernelImpl: cz });
  var pW = { kernelName: Dn, backendName: "webgpu", kernelFunc: npe };
  var Vx = class {
    constructor(e8) {
      this.variableNames = [], this.outputShape = [], this.uniforms = "start : f32, step : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e8], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "linSpace";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `;
    }
  };
  function spe(r8) {
    let { backend: e8, attrs: t8 } = r8, { start: o8, stop: n8, num: s } = t8, a = (n8 - o8) / (s - 1), i10 = new Vx(s), p = [{ type: "float32", data: [o8] }, { type: "float32", data: [a] }];
    return e8.runWebGPUProgram(i10, [], "float32", p);
  }
  var cW = { kernelName: An, backendName: "webgpu", kernelFunc: spe };
  var ape = ye({ opType: Z.LOG, cpuKernelImpl: mz });
  var lW = { kernelName: Fn, backendName: "webgpu", kernelFunc: ape };
  var ipe = ye({ opType: Z.LOG1P });
  var mW = { kernelName: Pn, backendName: "webgpu", kernelFunc: ipe };
  var upe = et({ opType: fe.LOGICAL_AND, dtype: "bool" });
  var dW = { kernelName: On, backendName: "webgpu", kernelFunc: upe };
  var ppe = ye({ opType: Z.LOGICAL_NOT });
  var fW = { kernelName: Mn, backendName: "webgpu", kernelFunc: ppe };
  var cpe = et({ opType: fe.LOGICAL_OR });
  var hW = { kernelName: Ln, backendName: "webgpu", kernelFunc: cpe };
  var gW = `
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;
  var Wx = class {
    constructor(e8) {
      this.outputShape = [], this.variableNames = ["x"], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${gW}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `;
    }
  };
  var Ux = class {
    constructor(e8, t8) {
      this.outputShape = [], this.variableNames = ["x"], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [256, 1, 1], this.maxAllowRadius = 16, y.assert(t8 <= this.maxAllowRadius, () => `Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t8}`), this.outputShape = e8, this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius, this.dispatchLayout = { x: [3], y: [2], z: [0, 1] }, this.dispatch = K(this.dispatchLayout, this.outputShape, [this.elementsPerWorkgroup, this.workgroupSize[1], this.workgroupSize[2]]), this.shaderKey = "lrn_shared";
    }
    getUserCode() {
      return `
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${H()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${gW}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `;
    }
  };
  function lpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { depthRadius: s, bias: a, alpha: i10, beta: p } = o8, u;
    s > 16 ? u = new Wx(n8.shape) : u = new Ux(n8.shape, s);
    let c = [{ type: "int32", data: [s] }, { type: "float32", data: [a] }, { type: "float32", data: [i10] }, { type: "float32", data: [p] }];
    return t8.runWebGPUProgram(u, [n8], n8.dtype, c);
  }
  var xW = { kernelName: Bn, backendName: "webgpu", kernelFunc: lpe };
  var Gx = class {
    constructor(e8) {
      this.outputShape = [], this.variableNames = ["inputImage", "outputImage", "dy"], this.uniforms = "depthRadius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn_grad";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `;
    }
  };
  function mpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, y: s, dy: a } = e8, { depthRadius: i10, bias: p, alpha: u, beta: c } = o8, l = new Gx(n8.shape), m = [{ type: "int32", data: [i10] }, { type: "float32", data: [p] }, { type: "float32", data: [u] }, { type: "float32", data: [c] }];
    return t8.runWebGPUProgram(l, [n8, s, a], n8.dtype, m);
  }
  var yW = { kernelName: ja, backendName: "webgpu", kernelFunc: mpe };
  var dpe = et({ opType: fe.MAX, cpuKernelImpl: fz });
  var bW = { kernelName: Vn, backendName: "webgpu", kernelFunc: dpe };
  function fpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dimRoundingMode: p } = o8, u = 1, c = w.computePool2DInfo(n8.shape, s, a, u, i10, p);
    return nx(n8, c, "max", t8);
  }
  var CW = { kernelName: Wn, backendName: "webgpu", kernelFunc: fpe };
  function hpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { filterSize: s, strides: a, pad: i10, dataFormat: p, dimRoundingMode: u } = o8, c = [1, 1, 1], l = w.computePool3DInfo(n8.shape, s, a, c, i10, u, p), m = new ku(l, "max"), d = [{ type: "int32", data: [l.strideDepth, l.strideHeight, l.strideWidth] }, { type: "int32", data: [l.padInfo.front, l.padInfo.top, l.padInfo.left] }, { type: "int32", data: [l.inDepth, l.inHeight, l.inWidth] }, { type: "int32", data: [l.effectiveFilterDepth, l.effectiveFilterHeight, l.effectiveFilterWidth] }];
    return t8.runWebGPUProgram(m, [n8], n8.dtype, d);
  }
  var wW = { kernelName: aa, backendName: "webgpu", kernelFunc: hpe };
  var Hx = class {
    constructor(e8) {
      this.variableNames = ["dy", "maxPos"], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.inShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool2DBackprop";
    }
    getUserCode() {
      return `
      ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  };
  var Kx = class {
    constructor(e8) {
      this.variableNames = ["dy", "maxPos"], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8.inShape, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool3DBackprop";
    }
    getUserCode() {
      return `
      ${H("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  };
  function gpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s } = e8, a = s, { filterSize: i10, strides: p, pad: u, dimRoundingMode: c } = o8, l = [1, 1, 1], m = w.computePool3DInfo(a.shape, i10, p, l, u, c), d = new ku(m, "max", true), f = [{ type: "int32", data: [m.strideDepth, m.strideHeight, m.strideWidth] }, { type: "int32", data: [m.padInfo.front, m.padInfo.top, m.padInfo.left] }, { type: "int32", data: [m.inDepth, m.inHeight, m.inWidth] }, { type: "int32", data: [m.effectiveFilterDepth, m.effectiveFilterHeight, m.effectiveFilterWidth] }], h = t8.runWebGPUProgram(d, [a], "int32", f), g = new Kx(m);
    f = [{ type: "int32", data: [m.strideDepth, m.strideHeight, m.strideWidth] }, { type: "int32", data: [m.effectiveFilterDepth - 1 - m.padInfo.front, m.effectiveFilterHeight - 1 - m.padInfo.top, m.effectiveFilterWidth - 1 - m.padInfo.left] }, { type: "int32", data: [m.effectiveFilterDepth, m.effectiveFilterHeight, m.effectiveFilterWidth] }, { type: "int32", data: [m.outDepth] }, { type: "int32", data: [m.outHeight] }, { type: "int32", data: [m.outWidth] }];
    let x = t8.runWebGPUProgram(g, [n8, h], a.dtype, f);
    return t8.disposeData(h.dataId), x;
  }
  var SW = { kernelName: Ui, backendName: "webgpu", kernelFunc: gpe };
  function xpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { dy: n8, input: s, output: a } = e8, i10 = s;
    lm([s, a], "maxPoolGrad");
    let { filterSize: p, strides: u, pad: c, dimRoundingMode: l } = o8, m = w.computePool2DInfo(i10.shape, p, u, 1, c, l), d = new Ma(m, "max", true), f = [{ type: "int32", data: [m.strideHeight, m.strideWidth] }, { type: "int32", data: [m.padInfo.top, m.padInfo.left] }, { type: "int32", data: [m.dilationHeight, m.dilationWidth] }, { type: "int32", data: [m.inHeight, m.inWidth] }, { type: "int32", data: [m.effectiveFilterHeight, m.effectiveFilterWidth] }], h = t8.runWebGPUProgram(d, [i10], "int32", f), g = new Hx(m);
    f = [{ type: "int32", data: [m.strideHeight, m.strideWidth] }, { type: "int32", data: [m.effectiveFilterHeight - 1 - m.padInfo.top, m.effectiveFilterWidth - 1 - m.padInfo.left] }, { type: "int32", data: [m.dilationHeight, m.dilationWidth] }, { type: "int32", data: [m.effectiveFilterHeight, m.effectiveFilterWidth] }, { type: "int32", data: [m.outHeight] }, { type: "int32", data: [m.outWidth] }];
    let x = t8.runWebGPUProgram(g, [n8, h], i10.dtype, f);
    return t8.disposeData(h.dataId), x;
  }
  var IW = { kernelName: Wi, backendName: "webgpu", kernelFunc: xpe };
  function ype(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { filterSize: n8, strides: s, pad: a, includeBatchInIndex: i10 } = o8, { x: p } = e8;
    y.assert(p.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${p.shape.length}.`);
    let u = [1, 1];
    y.assert(w.eitherStridesOrDilationsAreOne(s, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    let c = w.computePool2DInfo(p.shape, n8, s, u, a), l = [{ type: "int32", data: [c.strideHeight, c.strideWidth] }, { type: "int32", data: [c.padInfo.top, c.padInfo.left] }, { type: "int32", data: [c.dilationHeight, c.dilationWidth] }, { type: "int32", data: [c.inHeight, c.inWidth] }, { type: "int32", data: [c.effectiveFilterHeight, c.effectiveFilterWidth] }], m = new Ma(c, "max", false), d = t8.runWebGPUProgram(m, [p], p.dtype, l);
    m = new Ma(c, "max", true, true, i10);
    let f = t8.runWebGPUProgram(m, [p], "int32", l);
    return [d, f];
  }
  var vW = { kernelName: ia, backendName: "webgpu", kernelFunc: ype };
  function bpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    return Jr(n8, s, a, "min", t8);
  }
  var kW = { kernelName: Gn, backendName: "webgpu", kernelFunc: bpe };
  var Cpe = et({ opType: fe.MIN, cpuKernelImpl: hz });
  var NW = { kernelName: Hn, backendName: "webgpu", kernelFunc: Cpe };
  var qx = class {
    constructor(e8, t8, o8) {
      this.uniforms = "", this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t8.map((n8, s) => n8[0] + e8[s] + n8[1]), this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e8, t8.map((n8, s) => {
        this.uniforms += ` pad${s} : vec2<i32>,`;
      }), this.offset = o8 === "reflect" ? 0 : 1, this.shaderKey = `mirrorPad_${o8}`;
    }
    getUserCode() {
      let e8 = this.xShape.length, t8 = this.xShape.map((u, c) => `uniforms.pad${c}[0]`).join(","), o8 = this.xShape.map((u, c) => `uniforms.pad${c}[0] + uniforms.xShape${e8 > 1 ? `[${c}]` : ""}`).join(","), n8 = e8 === 1 ? "start" : "start[i]", s = e8 === 1 ? "end" : "end[i]", a = e8 === 1 ? "outC" : "outC[i]", i10 = ht(e8), p = e8 > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, e8) : "coords";
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let start = ${i10}(${t8});
          let end = ${i10}(${o8});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e8}; i = i + 1) {
            if (${a} < ${n8}) {
              ${a} = ${n8} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${s}) {
              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${p}));
        }
      }
    `;
    }
  };
  var TW = { kernelName: Kn, backendName: "webgpu", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { x: o8 } = r8, { paddings: n8, mode: s } = e8, a = t8, i10 = n8.map((c) => ({ type: "int32", data: [c[0], c[1]] })), p = new qx(o8.shape, n8, s);
    return a.runWebGPUProgram(p, [o8], o8.dtype, i10);
  } };
  var wpe = et({ opType: fe.MOD });
  var _W = { kernelName: qn, backendName: "webgpu", kernelFunc: wpe };
  var jx = class {
    constructor(e8, t8) {
      this.variableNames = ["probs"], this.outputShape = [], this.uniforms = "seed : f32, numOutcomes: i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e8, t8], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "multinomial";
    }
    getUserCode() {
      return `
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${H("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `;
    }
  };
  var Xx = class {
    constructor(e8) {
      this.variableNames = ["logits"], this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = [this.outputShape[0], 1, 1], this.outputShape[1] >= 4096 ? this.workgroupSize = [256, 1, 1] : this.workgroupSize = [64, 1, 1], this.shaderKey = "softmax";
    }
    getUserCode() {
      return `
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${H("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `;
    }
  };
  function t0(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { logits: n8 } = e8, { dim: s } = o8, a = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: [y.sizeFromShape(n8.shape) / n8.shape[s], n8.shape[s]] } }), i10 = new Xx(a.shape), p = t8.runWebGPUProgram(i10, [a], n8.dtype), u = pe({ inputs: { x: p }, backend: t8, attrs: { shape: n8.shape } });
    return t8.disposeData(a.dataId), t8.disposeData(p.dataId), u;
  }
  var $W = { kernelName: Is, backendName: "webgpu", kernelFunc: t0 };
  function Spe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { logits: n8 } = e8, { numSamples: s, seed: a, normalized: i10 } = o8, p = i10 ? n8 : t0({ inputs: { logits: n8 }, backend: t8, attrs: { dim: n8.shape.length - 1 } }), u = p.shape[0], c = p.shape[1], l = new jx(u, s), m = [{ type: "float32", data: [a] }, { type: "int32", data: [c] }], d = t8.runWebGPUProgram(l, [p], "int32", m);
    return i10 || t8.disposeData(p.dataId), d;
  }
  var EW = { kernelName: jn, backendName: "webgpu", kernelFunc: Spe };
  function Ipe(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (t8.shouldExecuteOnCPU([o8])) {
      let s = t8.tensorMap.get(o8.dataId), [a, i10] = xz(s.values, o8.shape, o8.dtype);
      return t8.makeTensorInfo(i10, o8.dtype, a);
    }
    let n8 = new Zr(o8.shape, Z.NEG);
    return t8.runWebGPUProgram(n8, [o8], o8.dtype);
  }
  var RW = { kernelName: ua, backendName: "webgpu", kernelFunc: Ipe };
  function vpe(r8) {
    console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p } = o8, u = t8.readSync(n8.dataId), c = t8.readSync(s.dataId), { selectedIndices: l } = Wt.nonMaxSuppressionV3Impl(u, c, a, i10, p);
    return t8.makeTensorInfo([l.length], "int32", new Int32Array(l));
  }
  var DW = { kernelName: Qn, backendName: "webgpu", kernelFunc: vpe };
  function kpe(r8) {
    console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { boxes: n8, scores: s } = e8, { maxOutputSize: a, iouThreshold: i10, scoreThreshold: p, softNmsSigma: u } = o8, c = t8.readSync(n8.dataId), l = t8.readSync(s.dataId), m = a, d = i10, f = p, h = u, { selectedIndices: g, selectedScores: x } = Wt.nonMaxSuppressionV5Impl(c, l, m, d, f, h);
    return [t8.makeTensorInfo([g.length], "int32", new Int32Array(g)), t8.makeTensorInfo([x.length], "float32", new Float32Array(x))];
  }
  var AW = { kernelName: Zn, backendName: "webgpu", kernelFunc: kpe };
  var Yx = class {
    constructor(e8, t8) {
      this.variableNames = ["x"], this.uniforms = "onValue : f32, offValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e8, t8], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "onehot";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `;
    }
  };
  function Npe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { indices: n8 } = e8, { dtype: s, depth: a, onValue: i10, offValue: p } = o8, u = y.sizeFromShape(n8.shape), c = new Yx(u, a), l = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: [u] } }), m = [{ type: "float32", data: [i10] }, { type: "float32", data: [p] }], d = t8.runWebGPUProgram(c, [l], s, m);
    t8.disposeData(l.dataId);
    let f = [...n8.shape, a], h = pe({ inputs: { x: d }, backend: t8, attrs: { shape: f } });
    return t8.disposeData(d.dataId), h;
  }
  var FW = { kernelName: Jn, backendName: "webgpu", kernelFunc: Npe };
  function gm(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (o8.dtype === "complex64") {
      let n8 = Ii({ inputs: { input: o8 }, backend: t8 }), s = gm({ inputs: { x: n8 }, backend: t8 }), a = Fp({ inputs: { input: o8 }, backend: t8 }), i10 = gm({ inputs: { x: a }, backend: t8 }), p = xo({ inputs: { real: s, imag: i10 }, backend: t8 });
      return t8.disposeData(n8.dataId), t8.disposeData(s.dataId), t8.disposeData(a.dataId), t8.disposeData(i10.dataId), p;
    } else
      return Vt({ attrs: { shape: o8.shape, dtype: o8.dtype, value: o8.dtype === "string" ? "" : 0 }, backend: t8 });
  }
  var PW = { kernelName: ba, backendName: "webgpu", kernelFunc: gm };
  function OW(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8 } = e8;
    if (o8.dtype === "string")
      throw new Error("onesLike is not supported under string dtype");
    if (o8.dtype === "complex64") {
      let n8 = Ii({ inputs: { input: o8 }, backend: t8 }), s = OW({ inputs: { x: n8 }, backend: t8 }), a = Fp({ inputs: { input: o8 }, backend: t8 }), i10 = gm({ inputs: { x: a }, backend: t8 }), p = xo({ inputs: { real: s, imag: i10 }, backend: t8 });
      return t8.disposeData(n8.dataId), t8.disposeData(s.dataId), t8.disposeData(a.dataId), t8.disposeData(i10.dataId), p;
    } else
      return Vt({ attrs: { shape: o8.shape, dtype: o8.dtype, value: 1 }, backend: t8 });
  }
  var MW = { kernelName: pa, backendName: "webgpu", kernelFunc: OW };
  function Tpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { axis: n8 } = o8;
    if (e8.length === 1)
      return Fx({ inputs: { input: e8[0] }, backend: t8, attrs: { dim: n8 } });
    let s = e8[0].shape, a = e8[0].dtype;
    e8.forEach((c) => {
      y.assertShapesMatch(s, c.shape, "All tensors passed to stack must have matching shapes"), y.assert(a === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    let i10 = [], p = e8.map((c) => {
      let l = Fx({ inputs: { input: c }, backend: t8, attrs: { dim: n8 } });
      return i10.push(l), l;
    }), u = Yv({ inputs: p, backend: t8, attrs: { axis: n8 } });
    return i10.forEach((c) => t8.disposeData(c.dataId)), u;
  }
  var LW = { kernelName: ca, backendName: "webgpu", kernelFunc: Tpe };
  function r0(r8, e8 = false) {
    let t8 = r8.length, o8 = ht(t8), n8 = r8.map((l, m) => `uniforms.pad${m}[0]`).join(","), s = r8.map((l, m) => `uniforms.pad${m}[0] + uniforms.xShape${t8 > 1 ? `[${m}]` : ""}`).join(","), a = t8 > 1 ? `${o8}(${n8})` : `${n8}`, i10 = t8 > 1 ? `${o8}(${s})` : `${s}`, p = t8 > 1 ? "any(paddedCoords < start)" : "paddedCoords < start", u = t8 > 1 ? "any(paddedCoords >= end)" : "paddedCoords >= end", c = t8 > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, t8) : "coords";
    return `
        let start = ${a};
        let end = ${i10};
        if (${p} || ${u}) {
          setOutputAtIndex(index, ${e8 ? 0 : "uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `;
  }
  var Qx = class {
    constructor(e8, t8) {
      this.variableNames = ["x"], this.uniforms = "constantValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t8.map((o8, n8) => o8[0] + e8[n8] + o8[1]), this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), t8.map((o8, n8) => {
        this.uniforms += ` pad${n8} : vec2<i32>,`;
      }), this.xShape = e8, this.shaderKey = "pad";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${r0(this.xShape)}
        }
      }
    `;
    }
  };
  var _pe = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { paddings: s, constantValue: a } = o8;
    if (s.every((u) => y.arraysEqual(u, [0, 0])))
      return At({ inputs: { x: n8 }, backend: t8 });
    if (y.sizeFromShape(n8.shape) === 0) {
      let u = s.map((c, l) => c[0] + n8.shape[l] + c[1]);
      return Vt({ backend: t8, attrs: { shape: u, value: a, dtype: n8.dtype } });
    }
    let i10 = [{ type: "float32", data: [a] }];
    s.map((u) => i10.push({ type: "int32", data: [u[0], u[1]] }));
    let p = new Qx(n8.shape, s);
    return t8.runWebGPUProgram(p, [n8], n8.dtype, i10);
  };
  var BW = { kernelName: es, backendName: "webgpu", kernelFunc: _pe };
  var $pe = et({ opType: fe.POW });
  var zW = { kernelName: ts, backendName: "webgpu", kernelFunc: $pe };
  function Epe(r8) {
    let { inputs: e8, backend: t8 } = r8, { x: o8, alpha: n8 } = e8, s = new Si(fe.PRELU, o8.shape, n8.shape);
    return t8.runWebGPUProgram(s, [o8, n8], "float32");
  }
  var VW = { kernelName: rs, backendName: "webgpu", kernelFunc: Epe };
  function Rpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { axis: s, keepDims: a } = o8;
    return Jr(n8, s, a, "prod", t8);
  }
  var WW = { kernelName: os, backendName: "webgpu", kernelFunc: Rpe };
  var Dpe = (r8) => {
    let { backend: e8, attrs: t8 } = r8, { start: o8, stop: n8, step: s, dtype: a } = t8, i10 = Cz(o8, n8, s, a);
    return e8.makeTensorInfo([i10.length], a, i10);
  };
  var UW = { kernelName: la, backendName: "webgpu", kernelFunc: Dpe };
  var Ape = et({ opType: fe.DIV });
  var GW = { kernelName: fn, backendName: "webgpu", kernelFunc: Ape };
  var Fpe = ye({ opType: Z.RECIPROCAL });
  var HW = { kernelName: ns, backendName: "webgpu", kernelFunc: Fpe };
  var Ppe = ye({ opType: Z.RELU });
  var KW = { kernelName: ss, backendName: "webgpu", kernelFunc: Ppe };
  var Ope = ye({ opType: Z.RELU6 });
  var qW = { kernelName: us, backendName: "webgpu", kernelFunc: Ope };
  var Zx = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["x"], this.uniforms = "adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e8[0], t8, o8, e8[3]], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "resizeBilinear";
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
  };
  function Mpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8 } = e8, { alignCorners: s, size: a, halfPixelCenters: i10 } = o8, [p, u] = a, c = s && p > 1 ? 1 : 0, l = s && u > 1 ? 1 : 0, d = [{ type: "float32", data: [c, l] }, { type: "float32", data: [i10 ? 0.5 : 0] }], f = new Zx(n8.shape, p, u);
    return t8.runWebGPUProgram(f, [n8], "float32", d);
  }
  var jW = { kernelName: is, backendName: "webgpu", kernelFunc: Mpe };
  var Jx = class {
    constructor(e8, t8) {
      this.variableNames = ["dy"], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t8, this.shaderKey = `resizeBilinearBackprop_${t8}`;
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
  };
  function Lpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8, [, i10, p] = n8.shape, [, u, c] = s.shape, l = [a && u > 1 ? i10 - 1 : i10, a && c > 1 ? p - 1 : p], m = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c], d = l[0] / m[0], f = l[1] / m[1], h = 1 / d, g = 1 / f, x = Math.ceil(h) * 2 + 2, b = Math.ceil(g) * 2 + 2, C = new Jx(n8.shape, a), S = [{ type: "int32", data: l }, { type: "int32", data: m }, { type: "float32", data: [d] }, { type: "float32", data: [f] }, { type: "float32", data: [h] }, { type: "float32", data: [g] }, { type: "int32", data: [x] }, { type: "int32", data: [b] }];
    return t8.runWebGPUProgram(C, [s], s.dtype, S);
  }
  var XW = { kernelName: Qa, backendName: "webgpu", kernelFunc: Lpe };
  var ey = class {
    constructor(e8, t8, o8, n8) {
      this.variableNames = ["x"], this.uniforms = "adjustHeightWidth : vec2<f32>, roundBase : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e8[0], t8, o8, e8[3]], this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.halfPixelCenters = n8, this.shaderKey = `resizeNearest_${n8}`;
    }
    getUserCode() {
      let e8;
      return this.halfPixelCenters ? e8 = "max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))" : e8 = "vec2<f32>(rc) * effectiveInputOverOutputRatioRC", `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e8};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
  };
  function Bpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8 } = e8, { alignCorners: s, halfPixelCenters: a, size: i10 } = o8, [p, u] = i10, c = s && p > 1 ? 1 : 0, l = s && u > 1 ? 1 : 0, d = [{ type: "float32", data: [c, l] }, { type: "float32", data: [s ? 0.5 : 0] }], f = new ey(n8.shape, p, u, a);
    return t8.runWebGPUProgram(f, [n8], n8.dtype, d);
  }
  var YW = { kernelName: as, backendName: "webgpu", kernelFunc: Bpe };
  var ty = class {
    constructor(e8, t8) {
      this.variableNames = ["dy"], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t8, this.shaderKey = `resizeNearestNeigborBackprop_${t8}`;
    }
    getUserCode() {
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners ? "floor(sourceFracRow + 0.5)" : "floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners ? "floor(sourceFracCol + 0.5)" : "floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
  };
  function zpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { images: n8, dy: s } = e8, { alignCorners: a } = o8, [, i10, p] = n8.shape, [, u, c] = s.shape, l = [a && u > 1 ? i10 - 1 : i10, a && c > 1 ? p - 1 : p], m = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c], d = l[0] / m[0], f = l[1] / m[1], h = 1 / d, g = 1 / f, x = Math.ceil(h) * 2 + 2, b = Math.ceil(g) * 2 + 2, C = new ty(n8.shape, a), S = [{ type: "int32", data: l }, { type: "int32", data: m }, { type: "float32", data: [h] }, { type: "float32", data: [g] }, { type: "int32", data: [x] }, { type: "int32", data: [b] }];
    return t8.runWebGPUProgram(C, [s], s.dtype, S);
  }
  var QW = { kernelName: Ya, backendName: "webgpu", kernelFunc: zpe };
  var ry = class {
    constructor(e8) {
      this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = " axis : vec4<i32>,", this.shaderKey = "reverse";
    }
    getUserCode() {
      return `
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `;
    }
  };
  function Vpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { dims: s } = o8, a = n8.shape.length;
    if (a === 0)
      return At({ inputs: { x: n8 }, backend: t8 });
    let i10 = n8.shape, p = [1, 1, 1, 1];
    i10.forEach((g, x) => {
      let b = x + 4 - a;
      p[b] = g;
    });
    let u = y.parseAxisParam(s, n8.shape), c = [0, 0, 0, 0];
    u.forEach((g) => {
      let x = g + 4 - a;
      c[x] = 1;
    });
    let l = [{ type: "int32", data: c }], m = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: p } }), d = new ry(p), f = t8.runWebGPUProgram(d, [m], m.dtype, l);
    t8.disposeData(m.dataId);
    let h = pe({ inputs: { x: f }, backend: t8, attrs: { shape: i10 } });
    return t8.disposeData(f.dataId), h;
  }
  var ZW = { kernelName: ps, backendName: "webgpu", kernelFunc: Vpe };
  var oy = class {
    constructor(e8, t8) {
      this.outputShape = [], this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = `centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`, this.shaderKey = "rotate", this.outputShape = e8, typeof t8 == "number" ? (this.uniforms += " fillValue : f32,", this.fillSnippet = "var outputValue = uniforms.fillValue;", this.shaderKey += "_float") : (this.uniforms += " fillValue : vec3<f32>,", this.fillSnippet = "var outputValue = uniforms.fillValue[coords[3]];", this.shaderKey += "_vec3");
    }
    getUserCode() {
      return `
        ${H("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;
    }
  };
  var JW = { kernelName: Ds, backendName: "webgpu", kernelFunc: ({ inputs: r8, attrs: e8, backend: t8 }) => {
    let { image: o8 } = r8, { radians: n8, fillValue: s, center: a } = e8, i10 = t8, p = new oy(o8.shape, s), [u, c] = w.getImageCenter(a, o8.shape[1], o8.shape[2]), l = [{ type: "float32", data: [u] }, { type: "float32", data: [c] }, { type: "float32", data: [Math.sin(n8)] }, { type: "float32", data: [Math.cos(n8)] }];
    return typeof s == "number" ? l.push({ type: "float32", data: [Number.parseFloat(s.toFixed(2))] }) : l.push({ type: "float32", data: s }), i10.runWebGPUProgram(p, [o8], o8.dtype, l);
  } };
  var Wpe = ye({ opType: Z.ROUND });
  var eU = { kernelName: cs, backendName: "webgpu", kernelFunc: Wpe };
  var Upe = ye({ opType: Z.RSQRT, cpuKernelImpl: wz });
  var tU = { kernelName: ls, backendName: "webgpu", kernelFunc: Upe };
  var La = class {
    constructor(e8, t8, o8, n8, s, a, i10, p = true) {
      this.variableNames = ["updates", "indices"], this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = a, this.type = i10, this.sumDupeIndices = p, this.dispatchLayout = X(e8), this.dispatch = K(this.dispatchLayout, e8, this.workgroupSize), this.sliceDimGreaterThanOne = t8 > 1, this.shaderKey = `scatter_${o8}_${n8}_${this.sliceDimGreaterThanOne}_${i10}_${p}`;
      let u = ht(s.length);
      this.uniforms = `sliceDim : i32, strides: ${u}, updatesSize: i32,`, this.updatesRank = n8, this.indicesRank = o8;
    }
    getUserCode() {
      let e8 = "";
      this.indicesRank === 1 ? e8 = "coords[0]" : this.indicesRank === 2 && (e8 = "coords[0], j");
      let t8 = `getIndices(${e8})`, o8 = this.sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides", n8 = "", s = "";
      this.dispatchLayout.x.length === 1 ? (n8 = "flattenedIndex", s = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `) : this.dispatchLayout.x.length === 2 && (n8 = "vec2<i32>(flattenedIndex, coords[1])", s = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);
      let i10 = `getUpdates(${Array.from({ length: this.updatesRank }, (u, c) => `coords[${c}]`).join(", ")})`;
      return `
    ${s}
      ${H("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t8}));
            flattenedIndex = flattenedIndex + indexInside * ${o8};
          }
          let updateValue =
              ${$p(this.type)}(${i10});
          let flatIndex = getOutputIndexFromCoords(${n8});

          ${this.sumDupeIndices ? Us("&result[flatIndex]", "updateValue", this.type) : "atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`;
    }
  };
  function Gpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { indices: n8, updates: s } = e8, { shape: a } = o8, { sliceRank: i10, numUpdates: p, sliceSize: u, strides: c, outputSize: l } = w.calculateShapes(s, n8, a), m = [l / u, u];
    if (l === 0)
      return t8.makeTensorInfo(a, n8.dtype);
    let d = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: [p, i10] } }), f = pe({ inputs: { x: s }, backend: t8, attrs: { shape: [p, u] } }), h = f.dtype, g = Vt({ backend: t8, attrs: { shape: m, value: 0, dtype: h } }), x = y.sizeFromShape(f.shape), b = [{ type: "int32", data: [i10] }, { type: "int32", data: c }, { type: "int32", data: [x] }], C = new La(f.shape, i10, d.shape.length, f.shape.length, c, m, h), S = t8.runWebGPUProgram(C, [f, d], h, b, g), k = pe({ inputs: { x: S }, backend: t8, attrs: { shape: a } });
    return t8.disposeData(d.dataId), t8.disposeData(f.dataId), t8.disposeData(S.dataId), k;
  }
  var rU = { kernelName: ms, backendName: "webgpu", kernelFunc: Gpe };
  var ny = class {
    constructor(e8, t8) {
      this.outputShape = [], this.variableNames = ["sortedSequence", "values"], this.uniforms = "numInputs : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.side = t8, this.shaderKey = `search_sorted_${t8}`;
    }
    getUserCode() {
      return `
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side === "left" ? "<" : "<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${H("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `;
    }
  };
  function Hpe(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { sortedSequence: n8, values: s } = e8, { side: a } = o8, i10 = new ny([s.shape[0], s.shape[1]], a), p = [{ type: "int32", data: [n8.shape[1]] }];
    return t8.runWebGPUProgram(i10, [n8, s], "int32", p);
  }
  var oU = { kernelName: fs, backendName: "webgpu", kernelFunc: Hpe };
  var sy = class {
    constructor(e8, t8, o8) {
      this.variableNames = ["c", "a", "b"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.cRank = e8, this.rank = o8, this.shaderKey = "select";
    }
    getUserCode() {
      let e8, t8;
      if (this.rank > 4)
        throw Error(`Where for rank ${this.rank} is not yet supported`);
      if (this.rank === 1)
        t8 = "resRC", e8 = "resRC";
      else {
        let n8 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s = [], a = [];
        for (let i10 = 0; i10 < this.outputShape.length; i10++)
          a.push(`${n8[i10]}`), i10 < this.cRank && s.push(`${n8[i10]}`);
        e8 = s.join(), t8 = a.join();
      }
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e8});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t8}));
          } else {
            setOutputAtIndex(index, getB(${t8}));
          }
        }
      }
    `;
    }
  };
  function Kpe(r8) {
    let { inputs: e8, backend: t8 } = r8, { condition: o8, t: n8, e: s } = e8, a = new sy(o8.shape.length, n8.shape, n8.shape.length);
    return t8.runWebGPUProgram(a, [o8, n8, s], dt(n8.dtype, s.dtype));
  }
  var nU = { kernelName: da, backendName: "webgpu", kernelFunc: Kpe };
  var qpe = ye({ opType: Z.SELU });
  var sU = { kernelName: hs, backendName: "webgpu", kernelFunc: qpe };
  var jpe = ye({ opType: Z.SIGMOID });
  var aU = { kernelName: bs, backendName: "webgpu", kernelFunc: jpe };
  var Xpe = ye({ opType: Z.SIGN });
  var iU = { kernelName: ys, backendName: "webgpu", kernelFunc: Xpe };
  var Ype = ye({ opType: Z.SIN });
  var uU = { kernelName: gs, backendName: "webgpu", kernelFunc: Ype };
  var Qpe = ye({ opType: Z.SINH });
  var pU = { kernelName: xs, backendName: "webgpu", kernelFunc: Qpe };
  var Zpe = ye({ opType: Z.SOFTPLUS });
  var cU = { kernelName: Cs, backendName: "webgpu", kernelFunc: Zpe };
  var ay = class {
    constructor(e8, t8, o8, n8, s, a) {
      this.variableNames = ["x"], this.outputShape = [], this.uniforms = "", this.workgroupSize = [64, 1, 1], this.size = true;
      let i10 = new Array(n8.length);
      for (let p = 0; p < i10.length; p++)
        i10[p] = n8[s[p]];
      this.outputShape = i10, this.newDim = s, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e8, this.paddedXShape = t8, this.uniforms += `reshapedPaddedXShape : ${ht(n8.length)}, paddedXShapeStrides : ${ht(a)}, `, o8.map((p, u) => {
        this.uniforms += ` pad${u} : vec2<i32>,`;
      }), this.shaderKey = `spaceToBatchND_${s}`;
    }
    getUserCode() {
      let e8 = ht(this.outputShape.length), t8 = Gv(this.newDim);
      return `
      ${im(this.paddedXShape, "PaddedX")}
      ${H("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e8}(${t8}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${r0(this.xShape, true)}
        }
      }
    `;
    }
  };
  var Jpe = (r8) => {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { blockShape: s, paddings: a } = o8;
    y.assert(n8.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");
    let i10 = s.reduce((b, C) => b * C), p = [[0, 0]];
    p.push(...a);
    for (let b = 1 + s.length; b < n8.shape.length; ++b)
      p.push([0, 0]);
    let u = p.map((b, C) => b[0] + n8.shape[C] + b[1]), c = w.getReshaped(u, s, i10, false), l = w.getPermuted(c.length, s.length, false), m = w.getReshapedPermuted(u, s, i10, false), d = y.computeStrides(u), f = new ay(n8.shape, u, p, c, l, d.length), h = [{ type: "int32", data: c }, { type: "int32", data: d }];
    p.map((b) => h.push({ type: "int32", data: [b[0], b[1]] }));
    let g = t8.runWebGPUProgram(f, [n8], n8.dtype, h), x = pe({ inputs: { x: g }, backend: t8, attrs: { shape: m } });
    return t8.disposeData(g.dataId), x;
  };
  var lU = { kernelName: ha, backendName: "webgpu", kernelFunc: Jpe };
  var iy = class {
    constructor(e8, t8) {
      this.variableNames = ["A"], this.workgroupSize = [64, 1, 1], this.size = true;
      let o8 = new Array(e8.length);
      for (let n8 = 0; n8 < o8.length; n8++)
        o8[n8] = e8[n8] * t8[n8];
      this.outputShape = o8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.rank = this.outputShape.length, this.shaderKey = "tile";
    }
    getUserCode() {
      let e8 = ece(this.rank, "uniforms.");
      return `
      ${H("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e8}));
        }
      }
    `;
    }
  };
  function ece(r8, e8 = "") {
    if (r8 >= 5)
      throw Error(`Tile for rank ${r8} is not yet supported`);
    if (r8 === 1)
      return `(resRC % ${e8}aShape)`;
    let t8 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o8 = [];
    for (let n8 = 0; n8 < r8; n8++)
      o8.push(`(${t8[n8]} % ${e8}aShape[${n8}])`);
    return o8.join();
  }
  function xm(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { reps: s } = o8;
    if (t8.shouldExecuteOnCPU([n8]) || n8.dtype === "string" || n8.shape.length >= 5) {
      let p = t8.readSync(n8.dataId), u = n8.dtype === "string" ? p.map((m) => y.decodeString(m)) : p, c = me(n8.shape, n8.dtype, u), l = _z(c, s);
      return t8.makeTensorInfo(l.shape, l.dtype, l.values);
    }
    let a = new iy(n8.shape, s);
    return t8.runWebGPUProgram(a, [n8], n8.dtype);
  }
  var mU = { kernelName: uo, backendName: "webgpu", kernelFunc: xm };
  function tce(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { sparseIndices: n8, sparseValues: s, defaultValue: a } = e8, { outputShape: i10 } = o8, { sliceRank: p, numUpdates: u, sliceSize: c, strides: l, outputSize: m } = w.calculateShapes(s, n8, i10), d = false;
    if (s.dtype === "string") {
      let R = t8.bufferSync(n8), D = t8.bufferSync(s), P = y.decodeString(t8.readSync(a.dataId)[0]), O = Sz(R, D, i10, m, c, u, p, l, P, d);
      return t8.makeTensorInfo(i10, O.dtype, O.values);
    }
    let f = [m / c, c], h = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: [u, p] } }), g = s.shape.length ? pe({ inputs: { x: s }, backend: t8, attrs: { shape: [u, c] } }) : At({ inputs: { x: s }, backend: t8 }), x = g.dtype, b = t8.makeTensorInfo([], x, y.makeZerosTypedArray(1, x)), C = pe({ inputs: { x: a }, backend: t8, attrs: { shape: Array(f.length).fill(1) } }), S = xm({ inputs: { x: C }, backend: t8, attrs: { reps: f } }), k = y.sizeFromShape([u, c]), _ = [{ type: "int32", data: [p] }, { type: "int32", data: l }, { type: "int32", data: [k] }];
    switch (u) {
      case 0:
        break;
      case 1:
        {
          let R = new La([u, c], p, h.shape.length, g.shape.length, l, f, x, d);
          t8.runWebGPUProgram(R, [g, h], x, _, S);
        }
        break;
      default:
        {
          let R = new La([u, c], p, h.shape.length, b.shape.length, l, f, x, d);
          t8.runWebGPUProgram(R, [b, h], x, _, S);
        }
        {
          let R = new La([u, c], p, h.shape.length, g.shape.length, l, f, x);
          t8.runWebGPUProgram(R, [g, h], x, _, S);
        }
    }
    let E = pe({ inputs: { x: S }, backend: t8, attrs: { shape: i10 } });
    return t8.disposeData(h.dataId), t8.disposeData(g.dataId), t8.disposeData(C.dataId), t8.disposeData(b.dataId), t8.disposeData(S.dataId), E;
  }
  var dU = { kernelName: vs, backendName: "webgpu", kernelFunc: tce };
  function rce(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { numOrSizeSplits: s, axis: a } = o8, i10 = y.parseAxisParam(a, n8.shape)[0], p = w.prepareSplitSize(n8, s, i10), u = n8.shape.length, c = new Array(u).fill(0), l = n8.shape.slice();
    return p.map((m) => {
      let d = [...l];
      d[i10] = m;
      let f = Gs({ inputs: { x: n8 }, backend: t8, attrs: { begin: c, size: d } });
      return c[i10] += m, f;
    });
  }
  var fU = { kernelName: ga, backendName: "webgpu", kernelFunc: rce };
  var oce = ye({ opType: Z.SQRT });
  var hU = { kernelName: ws, backendName: "webgpu", kernelFunc: oce };
  var gU = { kernelName: ji, backendName: "webgpu", kernelFunc: ({ inputs: r8, backend: e8 }) => {
    let { x: t8 } = r8, o8 = e8, n8 = new Zr(t8.shape, Z.SQUARE);
    return o8.runWebGPUProgram(n8, [t8], t8.dtype);
  } };
  var nce = et({ opType: fe.SQUARED_DIFFERENCE });
  var xU = { kernelName: ks, backendName: "webgpu", kernelFunc: nce };
  function sce({ inputs: r8, attrs: e8, backend: t8 }) {
    let { x: o8 } = r8, n8 = new Zr(o8.shape, Z.STEP, "stepAlpha : f32,"), s = [{ type: "float32", data: [e8.alpha] }];
    return t8.runWebGPUProgram(n8, [o8], o8.dtype, s);
  }
  var yU = { kernelName: wo, backendName: "webgpu", kernelFunc: sce };
  var uy = class {
    constructor(e8) {
      this.variableNames = ["x"], this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
      let t8 = ht(this.outputShape.length);
      this.uniforms = `begin : ${t8},  strides : ${t8}, `, this.shaderKey = "stridedSlice";
    }
    getUserCode() {
      let e8 = this.outputShape.length, t8 = "";
      if (e8 === 1)
        t8 = "coords * uniforms.strides + uniforms.begin";
      else {
        let n8 = 0;
        t8 = this.outputShape.map((s, a) => (n8++, this.outputShape.length === 1 ? `coords * uniforms.strides[${a}] + uniforms.begin[${a}]` : `coords[${n8 - 1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",");
      }
      return `
       ${H("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t8}));
         }
       }
     `;
    }
  };
  function ace(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { begin: s, end: a, strides: i10, beginMask: p, endMask: u, ellipsisMask: c, newAxisMask: l, shrinkAxisMask: m } = o8, { finalShapeSparse: d, finalShape: f, isIdentity: h, sliceDim0: g, isSimpleSlice: x, begin: b, end: C, strides: S } = ct.sliceInfo(n8.shape, s, a, i10, p, u, c, l, m), k;
    if (h)
      k = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: f } });
    else if (g || x) {
      y.assert(n8.shape.length >= 1, () => `Input must have rank at least 1, got: ${n8.shape.length}`);
      let _ = ct.computeOutShape(b, C, S), E = Gs({ inputs: { x: n8 }, backend: t8, attrs: { begin: b, size: _ } });
      k = pe({ inputs: { x: E }, backend: t8, attrs: { shape: f } }), t8.disposeData(E.dataId);
    } else if (t8.shouldExecuteOnCPU([n8])) {
      let E = t8.readSync(n8.dataId), R = me(n8.shape, n8.dtype, E), D = kz(d, R, S, b);
      k = t8.makeTensorInfo(f, n8.dtype, D.values);
    } else {
      let E = new uy(d), R = [{ type: "int32", data: b }, { type: "int32", data: S }], D = t8.runWebGPUProgram(E, [n8], n8.dtype, R);
      k = pe({ inputs: { x: D }, backend: t8, attrs: { shape: f } }), t8.disposeData(D.dataId);
    }
    return k;
  }
  var bU = { kernelName: Ns, backendName: "webgpu", kernelFunc: ace };
  function ice(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { separator: n8, nGramWidths: s, leftPad: a, rightPad: i10, padWidth: p, preserveShortSequences: u } = o8, { data: c, dataSplits: l } = e8, m = t8.readSync(c.dataId), d = t8.readSync(l.dataId), [f, h] = Nz(m, d, n8, s, a, i10, p, u);
    return [t8.makeTensorInfo([f.length], "string", f), t8.makeTensorInfo(l.shape, "int32", h)];
  }
  var CU = { kernelName: xa, backendName: "webgpu", kernelFunc: ice };
  var uce = et({ opType: fe.SUB, cpuKernelImpl: Tz, supportsComplex: true });
  var wU = { kernelName: Ts, backendName: "webgpu", kernelFunc: uce };
  var pce = ye({ opType: Z.TAN });
  var SU = { kernelName: _s, backendName: "webgpu", kernelFunc: pce };
  var cce = ye({ opType: Z.TANH });
  var IU = { kernelName: $s, backendName: "webgpu", kernelFunc: cce };
  function lce(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { tensor: n8, indices: s, updates: a } = e8, { sliceRank: i10, numUpdates: p, sliceSize: u, strides: c, outputSize: l } = w.calculateShapes(a, s, n8.shape), m = [l / u, u];
    if (l === 0)
      return t8.makeTensorInfo(n8.shape, s.dtype);
    let d = [], f = pe({ inputs: { x: s }, backend: t8, attrs: { shape: [p, i10] } });
    d.push(f);
    let h = pe({ inputs: { x: a }, backend: t8, attrs: { shape: [p, u] } });
    d.push(h);
    let g = pe({ inputs: { x: n8 }, backend: t8, attrs: { shape: m } });
    d.push(g);
    let x = xm({ inputs: { x: g }, backend: t8, attrs: { reps: Array(m.length).fill(1) } }), b = new La([p, u], i10, f.shape.length, h.shape.length, c, m, n8.dtype, false), C = y.sizeFromShape([p, u]), S = [{ type: "int32", data: [i10] }, { type: "int32", data: c }, { type: "int32", data: [C] }], k = t8.runWebGPUProgram(b, [h, f], g.dtype, S, x);
    d.push(k);
    let _ = pe({ inputs: { x: k }, backend: t8, attrs: { shape: n8.shape } });
    return d.forEach((E) => t8.disposeData(E.dataId)), _;
  }
  var vU = { kernelName: ds, backendName: "webgpu", kernelFunc: lce };
  var py = class {
    constructor(e8) {
      this.variableNames = ["x", "indices"], this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = `inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`, this.shaderKey = "swap";
    }
    getUserCode() {
      return `
        ${H("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
  };
  var cy = class {
    constructor(e8) {
      this.variableNames = ["x", "indices"], this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = "inputSize : i32, firstPass : i32, k : i32,", this.shaderKey = "merge";
    }
    getUserCode() {
      return `
        ${H("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
  };
  function el(r8, e8) {
    e8 !== null && r8.disposeData(e8.dataId);
  }
  function kU(r8) {
    let e8 = 1;
    for (; e8 < r8; )
      e8 *= 2;
    return e8;
  }
  function mce(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8 } = e8, { k: s, sorted: a } = o8, i10 = n8.shape, p = i10[i10.length - 1];
    if (t8.shouldExecuteOnCPU([n8])) {
      let k = t8.readSync(n8.dataId), [_, E] = $z(k, i10, n8.dtype, s, a);
      return [t8.makeTensorInfo(_.shape, _.dtype, _.values), t8.makeTensorInfo(E.shape, E.dtype, E.values)];
    }
    if (s === 0)
      return i10[i10.length - 1] = 0, [t8.makeTensorInfo(i10, n8.dtype, []), t8.makeTensorInfo(i10, "int32", [])];
    if (p === 1)
      return [n8, Vt({ attrs: { shape: i10, dtype: "int32", value: 0 }, backend: t8 })];
    let c = y.sizeFromShape(i10) / p, l = pe({ inputs: { x: n8 }, attrs: { shape: [c, p] }, backend: t8 }), m = kU(s), d = kU(p), f = null, h = () => f === null ? [l, l] : [l, f], g = (k, _, E) => {
      let R = h(), D = new py(E), O = [{ type: "int32", data: [p] }, { type: "int32", data: [f === null ? 1 : 0] }, { type: "float32", data: [Number.NEGATIVE_INFINITY] }, { type: "int32", data: [k] }, { type: "int32", data: [_] }], M = f;
      f = t8.runWebGPUProgram(D, R, "int32", O), el(t8, M);
    };
    for (let k = 1; k < m; k *= 2) {
      let _ = k * 2;
      for (let E = k; E >= 1; E /= 2)
        g(_, E, [c, d]);
    }
    for (let k = d; k > m; k /= 2) {
      let _ = h(), E = new cy([c, k / 2]), D = [{ type: "int32", data: [p] }, { type: "int32", data: [f === null ? 1 : 0] }, { type: "int32", data: [m] }], P = f;
      f = t8.runWebGPUProgram(E, _, "int32", D), el(t8, P);
      let O = m / 2, M = O * 2;
      for (let L = O; L >= 1; L /= 2)
        g(M, L, f.shape);
    }
    let x = f;
    f = Gs({ inputs: { x: f }, backend: t8, attrs: { begin: 0, size: [c, s] } }), el(t8, x);
    let b = e0({ inputs: { x: l, indices: f }, backend: t8, attrs: { axis: 1, batchDims: 1 } });
    el(t8, l);
    let C = i10.slice(0, -1);
    C.push(s), x = f, f = pe({ inputs: { x: f }, attrs: { shape: C }, backend: t8 }), el(t8, x);
    let S = b;
    return b = pe({ inputs: { x: b }, attrs: { shape: C }, backend: t8 }), el(t8, S), [b, f];
  }
  var NU = { kernelName: Es, backendName: "webgpu", kernelFunc: mce };
  var ly = class {
    constructor(e8) {
      this.variableNames = ["Image", "Transforms"], this.uniforms = "interpolationModeId : i32, fillModeId : i32, fillValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e8, this.dispatchLayout = X(this.outputShape), this.dispatch = K(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "transform";
    }
    getUserCode() {
      return `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${H("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;
    }
  };
  function dce(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { image: n8, transforms: s } = e8, { interpolation: a, fillMode: i10, fillValue: p, outputShape: u } = o8, [c, l, m, d] = n8.shape, [f, h] = u != null ? u : [l, m], g = [c, f, h, d], x = new ly(g), b = a === "nearest" ? 1 : 2, C;
    switch (i10) {
      case "constant":
        C = 1;
        break;
      case "reflect":
        C = 2;
        break;
      case "wrap":
        C = 3;
        break;
      case "nearest":
        C = 4;
        break;
      default:
        C = 1;
        break;
    }
    let S = [{ type: "int32", data: [b] }, { type: "int32", data: [C] }, { type: "float32", data: [p] }];
    return t8.runWebGPUProgram(x, [n8, s], "float32", S);
  }
  var TU = { kernelName: Rs, backendName: "webgpu", kernelFunc: dce };
  function fce(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { value: n8 } = e8, { axis: s } = o8;
    s < 0 && (s += n8.shape.length);
    let a = n8, i10 = a.shape.length, p = n8.shape[s], u = new Array(i10 - 1), c = 0;
    for (let h = 0; h < i10; h++)
      h !== s && (u[c++] = a.shape[h]);
    let l = [], m = new Array(i10).fill(0), d = a.shape.slice();
    d[s] = 1;
    let f = new Array(p);
    for (let h = 0; h < f.length; h++) {
      m[s] = h;
      let g = Gs({ inputs: { x: a }, backend: t8, attrs: { begin: m, size: d } }), x = pe({ inputs: { x: g }, backend: t8, attrs: { shape: u } });
      f[h] = x, l.push(g);
    }
    return l.forEach((h) => t8.disposeData(h.dataId)), f;
  }
  var _U = { kernelName: ya, backendName: "webgpu", kernelFunc: fce };
  var my = class {
    constructor(e8, t8, o8) {
      if (this.outputShape = [], this.variableNames = ["x", "segmentIds"], this.uniforms = "numSegments : i32, xSize: i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = t8, this.dispatchLayout = X(e8), this.dispatch = K(this.dispatchLayout, e8, this.workgroupSize), o8 !== "float32" && o8 !== "int32")
        throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${o8} type.`);
      this.type = o8, this.shaderKey = "unsortedSegmentSum";
    }
    getUserCode() {
      return `
    ${H("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Us("&result[flatIndex]", "value", this.type)}
        }
      }
    }
  `;
    }
  };
  function hce(r8) {
    let { inputs: e8, backend: t8, attrs: o8 } = r8, { x: n8, segmentIds: s } = e8, { numSegments: a } = o8, i10 = n8.shape.length, p = [], u = 0, c = w.getAxesPermutation([u], i10), l = n8;
    c != null && (l = yr({ inputs: { x: n8 }, backend: t8, attrs: { perm: c } }), p.push(l), u = w.getInnerMostAxes(1, i10)[0]);
    let m = w.segment_util.computeOutShape(l.shape, u, a), d = y.sizeFromShape([l.shape[u]]), f = pe({ inputs: { x: l }, backend: t8, attrs: { shape: [-1, d] } });
    p.push(f);
    let h = n8.dtype, g = [f.shape[0], a], x = Vt({ backend: t8, attrs: { shape: g, value: 0, dtype: h } }), b = new my(f.shape, g, h), C = [{ type: "int32", data: [a] }, { type: "int32", data: [y.sizeFromShape(f.shape)] }], S = t8.runWebGPUProgram(b, [f, s], h, C, x), k = pe({ inputs: { x: S }, backend: t8, attrs: { shape: m } });
    p.push(S);
    let _ = k;
    if (c != null) {
      p.push(k);
      let E = w.getUndoAxesPermutation(c);
      _ = yr({ inputs: { x: _ }, backend: t8, attrs: { perm: E } });
    }
    return p.forEach((E) => t8.disposeData(E.dataId)), _;
  }
  var $U = { kernelName: Zi, backendName: "webgpu", kernelFunc: hce };
  var gce = [jB, Rz, Dz, Az, Fz, Pz, Mz, Lz, Bz, zz, Vz, Wz, Uz, Gz, Hz, jz, Xz, Yz, Qz, Zz, eV, tV, rV, aV, iV, uV, YB, cV, mV, dV, fV, hV, gV, xV, yV, bV, CV, wV, vV, kV, NV, TV, $V, EV, _V, RV, DV, AV, FV, MV, LV, BV, zV, VV, WV, UV, GV, HV, KB, KV, XV, qV, jV, YV, QV, ZV, JV, eW, tW, rW, XB, oW, lV, nW, sW, aW, iW, uW, pW, cW, mW, lW, dW, fW, hW, xW, yW, Kz, bW, CW, IW, wW, SW, vW, qz, kW, NW, TW, _W, EW, PV, RW, DW, AW, oV, FW, MW, LW, BW, zW, VW, WW, UW, nV, GW, HW, KW, qW, qB, jW, XW, YW, QW, ZW, JW, eU, tU, rU, oU, nU, sU, aU, iU, uU, pU, Jz, yU, bU, CU, $W, cU, lU, dU, fU, hU, gU, xU, wU, OV, SU, IU, vU, mU, NU, TU, Oz, _U, $U, PW];
  for (let r8 of gce)
    Ja(r8);
  var EU = "4.7.0";
  var xce = "4.7.0";
  var yce = "4.7.0";
  var bce = "4.7.0";
  var Cce = "4.7.0";
  var wce = "4.7.0";
  var Sce = { tfjs: EU, "tfjs-core": EU, "tfjs-converter": xce, "tfjs-backend-cpu": yce, "tfjs-backend-webgl": bce, "tfjs-backend-wasm": Cce, "tfjs-backend-webgpu": wce };
  function log$1(...msg) {
    const dt2 = /* @__PURE__ */ new Date();
    const ts2 = `${dt2.getHours().toString().padStart(2, "0")}:${dt2.getMinutes().toString().padStart(2, "0")}:${dt2.getSeconds().toString().padStart(2, "0")}.${dt2.getMilliseconds().toString().padStart(3, "0")}`;
    if (msg)
      console.log(ts2, "Human:", ...msg);
  }
  function join(folder, file) {
    const separator = folder.endsWith("/") ? "" : "/";
    const skipJoin = file.startsWith(".") || file.startsWith("/") || file.startsWith("http:") || file.startsWith("https:") || file.startsWith("file:");
    const path = skipJoin ? `${file}` : `${folder}${separator}${file}`;
    if (!path.toLocaleLowerCase().includes(".json"))
      throw new Error(`modelpath error: expecting json file: ${path}`);
    return path;
  }
  var now = () => {
    if (typeof performance !== "undefined")
      return performance.now();
    return parseInt((Number(process$1.hrtime.bigint()) / 1e3 / 1e3).toString());
  };
  function validate(defaults, config3, parent = "config", msgs = []) {
    for (const key2 of Object.keys(config3)) {
      if (typeof config3[key2] === "object") {
        validate(defaults[key2], config3[key2], key2, msgs);
      } else {
        const defined = defaults && typeof defaults[key2] !== "undefined";
        if (!defined)
          msgs.push({ reason: "unknown property", where: `${parent}.${key2} = ${config3[key2]}` });
        const same = defaults && typeof defaults[key2] === typeof config3[key2];
        if (defined && !same)
          msgs.push({ reason: "property type mismatch", where: `${parent}.${key2} = ${config3[key2]}`, expected: typeof defaults[key2] });
      }
    }
    if (config3.debug && parent === "config" && msgs.length > 0)
      log$1("invalid configuration", msgs);
    return msgs;
  }
  function mergeDeep(...objects) {
    const isObject = (obj) => obj && typeof obj === "object";
    return objects.reduce((prev, obj) => {
      Object.keys(obj || {}).forEach((key2) => {
        const pVal = prev[key2];
        const oVal = obj[key2];
        if (Array.isArray(pVal) && Array.isArray(oVal))
          prev[key2] = pVal.concat(...oVal);
        else if (isObject(pVal) && isObject(oVal))
          prev[key2] = mergeDeep(pVal, oVal);
        else
          prev[key2] = oVal;
      });
      return prev;
    }, {});
  }
  var config = {
    backend: "",
    modelBasePath: "",
    cacheModels: true,
    validateModels: true,
    wasmPath: "",
    wasmPlatformFetch: false,
    debug: false,
    async: true,
    warmup: "full",
    cacheSensitivity: 0.7,
    skipAllowed: false,
    deallocate: false,
    flags: {},
    softwareKernels: false,
    filter: {
      enabled: true,
      equalization: false,
      width: 0,
      height: 0,
      flip: false,
      return: true,
      autoBrightness: true,
      brightness: 0,
      contrast: 0,
      sharpness: 0,
      blur: 0,
      saturation: 0,
      hue: 0,
      negative: false,
      sepia: false,
      vintage: false,
      kodachrome: false,
      technicolor: false,
      polaroid: false,
      pixelate: 0
    },
    gesture: {
      enabled: true
    },
    face: {
      enabled: true,
      detector: {
        modelPath: "blazeface.json",
        rotation: false,
        maxDetected: 1,
        skipFrames: 99,
        skipTime: 2500,
        minConfidence: 0.2,
        minSize: 0,
        iouThreshold: 0.1,
        mask: false,
        return: false
      },
      mesh: {
        enabled: true,
        modelPath: "facemesh.json",
        keepInvalid: false
      },
      attention: {
        enabled: false,
        modelPath: "facemesh-attention.json"
      },
      iris: {
        enabled: true,
        modelPath: "iris.json"
      },
      emotion: {
        enabled: true,
        minConfidence: 0.1,
        skipFrames: 99,
        skipTime: 1500,
        modelPath: "emotion.json"
      },
      description: {
        enabled: true,
        modelPath: "faceres.json",
        skipFrames: 99,
        skipTime: 3e3,
        minConfidence: 0.1
      },
      antispoof: {
        enabled: false,
        skipFrames: 99,
        skipTime: 4e3,
        modelPath: "antispoof.json"
      },
      liveness: {
        enabled: false,
        skipFrames: 99,
        skipTime: 4e3,
        modelPath: "liveness.json"
      }
    },
    body: {
      enabled: true,
      modelPath: "movenet-lightning.json",
      maxDetected: -1,
      minConfidence: 0.3,
      skipFrames: 1,
      skipTime: 200
    },
    hand: {
      enabled: true,
      rotation: true,
      skipFrames: 99,
      skipTime: 1e3,
      minConfidence: 0.5,
      iouThreshold: 0.2,
      maxDetected: -1,
      landmarks: true,
      detector: {
        modelPath: "handtrack.json"
      },
      skeleton: {
        modelPath: "handlandmark-lite.json"
      }
    },
    object: {
      enabled: false,
      modelPath: "centernet.json",
      minConfidence: 0.2,
      iouThreshold: 0.4,
      maxDetected: 10,
      skipFrames: 99,
      skipTime: 2e3
    },
    segmentation: {
      enabled: false,
      modelPath: "rvm.json",
      ratio: 0.5,
      mode: "default"
    }
  };
  var vertexIdentity = `
  precision highp float;
  attribute vec2 pos;
  attribute vec2 uv;
  varying vec2 vUv;
  uniform float flipY;
  void main(void) {
    vUv = uv;
    gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);
  }
`;
  var colorMatrixWithAlpha = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];
    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];
  }
`;
  var colorMatrixWithoutAlpha = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];
    gl_FragColor.a = c.a;
  }
`;
  var pixelate = `
  precision highp float;
  varying vec2 vUv;
  uniform vec2 size;
  uniform sampler2D texture;
  vec2 pixelate(vec2 coord, vec2 size) {
    return floor( coord / size ) * size;
  }
  void main(void) {
    gl_FragColor = vec4(0.0);
    vec2 coord = pixelate(vUv, size);
    gl_FragColor += texture2D(texture, coord);
  }
`;
  var blur = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  void main(void) {
    gl_FragColor = vec4(0.0);
    gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;
    gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;
    gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;
  }
`;
  var convolution = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  uniform float m[9];
  void main(void) {
    vec4 c11 = texture2D(texture, vUv - px); // top left
    vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y)); // top center
    vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y)); // top right
    vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) ); // mid left
    vec4 c22 = texture2D(texture, vUv); // mid center
    vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) ); // mid right
    vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) ); // bottom left
    vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) ); // bottom center
    vec4 c33 = texture2D(texture, vUv + px ); // bottom right
    gl_FragColor = 
    c11 * m[0] + c12 * m[1] + c22 * m[2] +
    c21 * m[3] + c22 * m[4] + c23 * m[5] +
    c31 * m[6] + c32 * m[7] + c33 * m[8];
    gl_FragColor.a = c22.a;
  }
`;
  var collect = (source, prefix, collection) => {
    const r8 = new RegExp("\\b" + prefix + " \\w+ (\\w+)", "ig");
    source.replace(r8, (match2, name2) => {
      collection[name2] = 0;
      return match2;
    });
  };
  var GLProgram = class {
    constructor(gl2, vertexSource, fragmentSource) {
      __publicField2(this, "uniform", {});
      __publicField2(this, "attribute", {});
      __publicField2(this, "gl");
      __publicField2(this, "id");
      __publicField2(this, "compile", (source, type) => {
        const shader = this.gl.createShader(type);
        if (!shader) {
          log$1("filter: could not create shader");
          return null;
        }
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          log$1(`filter: gl compile failed: ${this.gl.getShaderInfoLog(shader) || "unknown"}`);
          return null;
        }
        return shader;
      });
      this.gl = gl2;
      const vertexShader = this.compile(vertexSource, this.gl.VERTEX_SHADER);
      const fragmentShader = this.compile(fragmentSource, this.gl.FRAGMENT_SHADER);
      this.id = this.gl.createProgram();
      if (!vertexShader || !fragmentShader)
        return;
      if (!this.id) {
        log$1("filter: could not create webgl program");
        return;
      }
      this.gl.attachShader(this.id, vertexShader);
      this.gl.attachShader(this.id, fragmentShader);
      this.gl.linkProgram(this.id);
      if (!this.gl.getProgramParameter(this.id, this.gl.LINK_STATUS)) {
        log$1(`filter: gl link failed: ${this.gl.getProgramInfoLog(this.id) || "unknown"}`);
        return;
      }
      this.gl.useProgram(this.id);
      collect(vertexSource, "attribute", this.attribute);
      for (const a in this.attribute)
        this.attribute[a] = this.gl.getAttribLocation(this.id, a);
      collect(vertexSource, "uniform", this.uniform);
      collect(fragmentSource, "uniform", this.uniform);
      for (const u in this.uniform)
        this.uniform[u] = this.gl.getUniformLocation(this.id, u);
    }
  };
  function GLImageFilter() {
    let drawCount = 0;
    let sourceTexture = null;
    let lastInChain = false;
    let currentFramebufferIndex = -1;
    let tempFramebuffers = [null, null];
    let filterChain = [];
    let vertexBuffer = null;
    let currentProgram = null;
    const fxcanvas = canvas(100, 100);
    const shaderProgramCache = {};
    const DRAW = { INTERMEDIATE: 1 };
    const gl2 = fxcanvas.getContext("webgl");
    if (!gl2) {
      log$1("filter: cannot get webgl context");
      return;
    }
    this.gl = gl2;
    function resize(width, height) {
      if (width === fxcanvas.width && height === fxcanvas.height)
        return;
      fxcanvas.width = width;
      fxcanvas.height = height;
      if (!vertexBuffer) {
        const vertices = new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 1, 1, 1, 1, 1, 0]);
        vertexBuffer = gl2.createBuffer();
        gl2.bindBuffer(gl2.ARRAY_BUFFER, vertexBuffer);
        gl2.bufferData(gl2.ARRAY_BUFFER, vertices, gl2.STATIC_DRAW);
        gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      }
      gl2.viewport(0, 0, fxcanvas.width, fxcanvas.height);
      tempFramebuffers = [null, null];
    }
    function createFramebufferTexture(width, height) {
      const fbo = gl2.createFramebuffer();
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, fbo);
      const renderbuffer = gl2.createRenderbuffer();
      gl2.bindRenderbuffer(gl2.RENDERBUFFER, renderbuffer);
      const texture = gl2.createTexture();
      gl2.bindTexture(gl2.TEXTURE_2D, texture);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, width, height, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, null);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.LINEAR);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.LINEAR);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
      gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, texture, 0);
      gl2.bindTexture(gl2.TEXTURE_2D, null);
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
      return { fbo, texture };
    }
    function getTempFramebuffer(index2) {
      tempFramebuffers[index2] = tempFramebuffers[index2] || createFramebufferTexture(fxcanvas.width, fxcanvas.height);
      return tempFramebuffers[index2];
    }
    function draw(flags = 0) {
      if (!currentProgram)
        return;
      let source = null;
      let target = null;
      let flipY = false;
      if (drawCount === 0)
        source = sourceTexture;
      else
        source = getTempFramebuffer(currentFramebufferIndex).texture || null;
      drawCount++;
      if (lastInChain && !(flags & DRAW.INTERMEDIATE)) {
        target = null;
        flipY = drawCount % 2 === 0;
      } else {
        currentFramebufferIndex = (currentFramebufferIndex + 1) % 2;
        target = getTempFramebuffer(currentFramebufferIndex).fbo || null;
      }
      gl2.bindTexture(gl2.TEXTURE_2D, source);
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, target);
      gl2.uniform1f(currentProgram.uniform["flipY"], flipY ? -1 : 1);
      gl2.drawArrays(gl2.TRIANGLES, 0, 6);
    }
    function compileShader(fragmentSource) {
      if (shaderProgramCache[fragmentSource]) {
        currentProgram = shaderProgramCache[fragmentSource];
        gl2.useProgram((currentProgram ? currentProgram.id : null) || null);
        return currentProgram;
      }
      currentProgram = new GLProgram(gl2, vertexIdentity, fragmentSource);
      if (!currentProgram) {
        log$1("filter: could not get webgl program");
        return null;
      }
      const floatSize = Float32Array.BYTES_PER_ELEMENT;
      const vertSize = 4 * floatSize;
      gl2.enableVertexAttribArray(currentProgram.attribute["pos"]);
      gl2.vertexAttribPointer(currentProgram.attribute["pos"], 2, gl2.FLOAT, false, vertSize, 0 * floatSize);
      gl2.enableVertexAttribArray(currentProgram.attribute["uv"]);
      gl2.vertexAttribPointer(currentProgram.attribute["uv"], 2, gl2.FLOAT, false, vertSize, 2 * floatSize);
      shaderProgramCache[fragmentSource] = currentProgram;
      return currentProgram;
    }
    const filter = {
      colorMatrix: (matrix) => {
        const m = new Float32Array(matrix);
        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;
        const shader = m[18] === 1 && m[3] === 0 && m[8] === 0 && m[13] === 0 && m[15] === 0 && m[16] === 0 && m[17] === 0 && m[19] === 0 ? colorMatrixWithoutAlpha : colorMatrixWithAlpha;
        const program = compileShader(shader);
        if (!program)
          return;
        gl2.uniform1fv(program.uniform["m"], m);
        draw();
      },
      brightness: (brightness) => {
        const b = (brightness || 0) + 1;
        filter.colorMatrix([
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      saturation: (amount) => {
        const x = (amount || 0) * 2 / 3 + 1;
        const y10 = (x - 1) * -0.5;
        filter.colorMatrix([
          x,
          y10,
          y10,
          0,
          0,
          y10,
          x,
          y10,
          0,
          0,
          y10,
          y10,
          x,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      desaturate: () => {
        filter.saturation(-1);
      },
      contrast: (amount) => {
        const v10 = (amount || 0) + 1;
        const o8 = -128 * (v10 - 1);
        filter.colorMatrix([
          v10,
          0,
          0,
          0,
          o8,
          0,
          v10,
          0,
          0,
          o8,
          0,
          0,
          v10,
          0,
          o8,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      negative: () => {
        filter.contrast(-2);
      },
      hue: (rotation) => {
        rotation = (rotation || 0) / 180 * Math.PI;
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        const lumR = 0.213;
        const lumG = 0.715;
        const lumB = 0.072;
        filter.colorMatrix([
          lumR + cos * (1 - lumR) + sin * -lumR,
          lumG + cos * -lumG + sin * -lumG,
          lumB + cos * -lumB + sin * (1 - lumB),
          0,
          0,
          lumR + cos * -lumR + sin * 0.143,
          lumG + cos * (1 - lumG) + sin * 0.14,
          lumB + cos * -lumB + sin * -0.283,
          0,
          0,
          lumR + cos * -lumR + sin * -(1 - lumR),
          lumG + cos * -lumG + sin * lumG,
          lumB + cos * (1 - lumB) + sin * lumB,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      desaturateLuminance: () => {
        filter.colorMatrix([
          0.2764723,
          0.929708,
          0.0938197,
          0,
          -37.1,
          0.2764723,
          0.929708,
          0.0938197,
          0,
          -37.1,
          0.2764723,
          0.929708,
          0.0938197,
          0,
          -37.1,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      sepia: () => {
        filter.colorMatrix([
          0.393,
          0.7689999,
          0.18899999,
          0,
          0,
          0.349,
          0.6859999,
          0.16799999,
          0,
          0,
          0.272,
          0.5339999,
          0.13099999,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      brownie: () => {
        filter.colorMatrix([
          0.5997023498159715,
          0.34553243048391263,
          -0.2708298674538042,
          0,
          47.43192855600873,
          -0.037703249837783157,
          0.8609577587992641,
          0.15059552388459913,
          0,
          -36.96841498319127,
          0.24113635128153335,
          -0.07441037908422492,
          0.44972182064877153,
          0,
          -7.562075277591283,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      vintagePinhole: () => {
        filter.colorMatrix([
          0.6279345635605994,
          0.3202183420819367,
          -0.03965408211312453,
          0,
          9.651285835294123,
          0.02578397704808868,
          0.6441188644374771,
          0.03259127616149294,
          0,
          7.462829176470591,
          0.0466055556782719,
          -0.0851232987247891,
          0.5241648018700465,
          0,
          5.159190588235296,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      kodachrome: () => {
        filter.colorMatrix([
          1.1285582396593525,
          -0.3967382283601348,
          -0.03992559172921793,
          0,
          63.72958762196502,
          -0.16404339962244616,
          1.0835251566291304,
          -0.05498805115633132,
          0,
          24.732407896706203,
          -0.16786010706155763,
          -0.5603416277695248,
          1.6014850761964943,
          0,
          35.62982807460946,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      technicolor: () => {
        filter.colorMatrix([
          1.9125277891456083,
          -0.8545344976951645,
          -0.09155508482755585,
          0,
          11.793603434377337,
          -0.3087833385928097,
          1.7658908555458428,
          -0.10601743074722245,
          0,
          -70.35205161461398,
          -0.231103377548616,
          -0.7501899197440212,
          1.847597816108189,
          0,
          30.950940869491138,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      polaroid: () => {
        filter.colorMatrix([
          1.438,
          -0.062,
          -0.062,
          0,
          0,
          -0.122,
          1.378,
          -0.122,
          0,
          0,
          -0.016,
          -0.016,
          1.483,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      shiftToBGR: () => {
        filter.colorMatrix([
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]);
      },
      convolution: (matrix) => {
        const m = new Float32Array(matrix);
        const pixelSizeX = 1 / fxcanvas.width;
        const pixelSizeY = 1 / fxcanvas.height;
        const program = compileShader(convolution);
        if (!program)
          return;
        gl2.uniform1fv(program.uniform["m"], m);
        gl2.uniform2f(program.uniform["px"], pixelSizeX, pixelSizeY);
        draw();
      },
      detectEdges: () => {
        filter.convolution.call(this, [
          0,
          1,
          0,
          1,
          -4,
          1,
          0,
          1,
          0
        ]);
      },
      sobelX: () => {
        filter.convolution.call(this, [
          -1,
          0,
          1,
          -2,
          0,
          2,
          -1,
          0,
          1
        ]);
      },
      sobelY: () => {
        filter.convolution.call(this, [
          -1,
          -2,
          -1,
          0,
          0,
          0,
          1,
          2,
          1
        ]);
      },
      sharpen: (amount) => {
        const a = amount || 1;
        filter.convolution.call(this, [
          0,
          -1 * a,
          0,
          -1 * a,
          1 + 4 * a,
          -1 * a,
          0,
          -1 * a,
          0
        ]);
      },
      emboss: (size2) => {
        const s = size2 || 1;
        filter.convolution.call(this, [
          -2 * s,
          -1 * s,
          0,
          -1 * s,
          1,
          1 * s,
          0,
          1 * s,
          2 * s
        ]);
      },
      blur: (size2) => {
        const blurSizeX = size2 / 7 / fxcanvas.width;
        const blurSizeY = size2 / 7 / fxcanvas.height;
        const program = compileShader(blur);
        if (!program)
          return;
        gl2.uniform2f(program.uniform["px"], 0, blurSizeY);
        draw(DRAW.INTERMEDIATE);
        gl2.uniform2f(program.uniform["px"], blurSizeX, 0);
        draw();
      },
      pixelate: (size2) => {
        const blurSizeX = size2 / fxcanvas.width;
        const blurSizeY = size2 / fxcanvas.height;
        const program = compileShader(pixelate);
        if (!program)
          return;
        gl2.uniform2f(program.uniform["size"], blurSizeX, blurSizeY);
        draw();
      }
    };
    this.add = function(name2) {
      const args = Array.prototype.slice.call(arguments, 1);
      const func = filter[name2];
      filterChain.push({ func, args });
    };
    this.reset = function() {
      filterChain = [];
    };
    this.get = function() {
      return filterChain;
    };
    this.apply = function(image) {
      resize(image.width, image.height);
      drawCount = 0;
      if (!sourceTexture)
        sourceTexture = gl2.createTexture();
      gl2.bindTexture(gl2.TEXTURE_2D, sourceTexture);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, image);
      for (let i10 = 0; i10 < filterChain.length; i10++) {
        lastInChain = i10 === filterChain.length - 1;
        const f = filterChain[i10];
        f.func.apply(this, f.args || []);
      }
      return fxcanvas;
    };
    this.draw = function(image) {
      this.add("brightness", 0);
      return this.apply(image);
    };
  }
  async function histogramEqualization(inputImage) {
    const squeeze = inputImage.shape.length === 4 ? mc(inputImage) : inputImage;
    const rgb3 = pi(squeeze, 3, 2);
    const min = [vl(rgb3[0]), vl(rgb3[1]), vl(rgb3[2])];
    const max = [_a(rgb3[0]), _a(rgb3[1]), _a(rgb3[2])];
    const absMax = await Promise.all(max.map((channel) => channel.data()));
    const maxValue = Math.max(absMax[0][0], absMax[1][0], absMax[2][0]);
    const maxRange = maxValue > 1 ? 255 : 1;
    const factor = maxRange / maxValue;
    let final;
    if (factor > 1) {
      const sub = [Te(rgb3[0], min[0]), Te(rgb3[1], min[1]), Te(rgb3[2], min[2])];
      const range = [Te(max[0], min[0]), Te(max[1], min[1]), Te(max[2], min[2])];
      const enh = [se(sub[0], factor), se(sub[1], factor), se(sub[2], factor)];
      const stack = kr([enh[0], enh[1], enh[2]], 2);
      final = W(stack, [1, squeeze.shape[0] || 0, squeeze.shape[1] || 0, 3]);
      Ot([...sub, ...range, ...enh, stack]);
    } else {
      final = ai(squeeze, 0);
    }
    Ot([...rgb3, ...min, ...max, rgb3, squeeze, inputImage]);
    return final;
  }
  var maxSize = 3840;
  var inCanvas = null;
  var outCanvas = null;
  var tmpCanvas = null;
  var fx2;
  var last = {
    inputSum: 0,
    cacheDiff: 1,
    sumMethod: 0,
    inputTensor: void 0
  };
  function reset() {
    last.inputSum = 0;
    last.cacheDiff = 1;
    last.sumMethod = 0;
    last.inputTensor = void 0;
  }
  function canvas(width, height) {
    let c;
    if (env.browser) {
      if (env.worker) {
        if (typeof OffscreenCanvas === "undefined")
          throw new Error("canvas error: attempted to run in web worker but OffscreenCanvas is not supported");
        c = new OffscreenCanvas(width, height);
      } else {
        if (typeof document !== "undefined") {
          c = document.createElement("canvas");
          c.width = width;
          c.height = height;
        } else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
          if (typeof env.Canvas !== "undefined")
            c = new env.Canvas(width, height);
          else if (typeof globalThis.Canvas !== "undefined")
            c = new globalThis.Canvas(width, height);
          else
            throw new Error("canvas error: attempted to use canvas in react-native without canvas support installed");
        } else {
          throw new Error("canvas error: attempted to run in browser but DOM is not defined");
        }
      }
    } else {
      if (typeof env.Canvas !== "undefined")
        c = new env.Canvas(width, height);
      else if (typeof globalThis.Canvas !== "undefined")
        c = new globalThis.Canvas(width, height);
    }
    return c;
  }
  function copy(input, output) {
    const outputCanvas = output || canvas(input.width, input.height);
    const ctx = outputCanvas.getContext("2d");
    ctx.drawImage(input, 0, 0);
    return outputCanvas;
  }
  async function process2(input, config3, getTensor = true) {
    var _a22, _b2, _c22;
    if (!input) {
      if (config3.debug)
        log$1("input error: input is missing");
      return { tensor: null, canvas: null };
    }
    if (!(input instanceof ut) && !(typeof Image !== "undefined" && input instanceof Image) && !(typeof globalThis.Canvas !== "undefined" && input instanceof globalThis.Canvas) && !(typeof ImageData !== "undefined" && input instanceof ImageData) && !(typeof ImageBitmap !== "undefined" && input instanceof ImageBitmap) && !(typeof HTMLImageElement !== "undefined" && input instanceof HTMLImageElement) && !(typeof HTMLMediaElement !== "undefined" && input instanceof HTMLMediaElement) && !(typeof HTMLVideoElement !== "undefined" && input instanceof HTMLVideoElement) && !(typeof HTMLCanvasElement !== "undefined" && input instanceof HTMLCanvasElement) && !(typeof OffscreenCanvas !== "undefined" && input instanceof OffscreenCanvas)) {
      throw new Error("input error: type not recognized");
    }
    if (input instanceof ut) {
      let tensor2 = null;
      if (input["isDisposedInternal"])
        throw new Error("input error: attempted to use tensor but it is disposed");
      if (!input.shape)
        throw new Error("input error: attempted to use tensor without a shape");
      if (input.shape.length === 3) {
        if (input.shape[2] === 3) {
          tensor2 = ai(input, 0);
        } else if (input.shape[2] === 4) {
          const rgb3 = N1(input, [0, 0, 0], [-1, -1, 3]);
          tensor2 = ai(rgb3, 0);
          Ot(rgb3);
        }
      } else if (input.shape.length === 4) {
        if (input.shape[3] === 3) {
          tensor2 = Ur(input);
        } else if (input.shape[3] === 4) {
          tensor2 = T1(input, [0, 0, 0, 0], [-1, -1, -1, 3]);
        }
      }
      if (tensor2 == null || tensor2.shape.length !== 4 || tensor2.shape[0] !== 1 || tensor2.shape[3] !== 3)
        throw new Error(`input error: attempted to use tensor with unrecognized shape: ${input.shape.toString()}`);
      if (tensor2.dtype === "int32") {
        const cast = qe(tensor2, "float32");
        Ot(tensor2);
        tensor2 = cast;
      }
      return { tensor: tensor2, canvas: config3.filter.return ? outCanvas : null };
    }
    if (typeof input["readyState"] !== "undefined" && input.readyState <= 2) {
      if (config3.debug)
        log$1("input stream is not ready");
      return { tensor: null, canvas: inCanvas };
    }
    const originalWidth = input["naturalWidth"] || input["videoWidth"] || input["width"] || input["shape"] && input["shape"][1] > 0;
    const originalHeight = input["naturalHeight"] || input["videoHeight"] || input["height"] || input["shape"] && input["shape"][2] > 0;
    if (!originalWidth || !originalHeight) {
      if (config3.debug)
        log$1("cannot determine input dimensions");
      return { tensor: null, canvas: inCanvas };
    }
    let targetWidth = originalWidth;
    let targetHeight = originalHeight;
    if (targetWidth > maxSize) {
      targetWidth = maxSize;
      targetHeight = Math.trunc(targetWidth * originalHeight / originalWidth);
    }
    if (targetHeight > maxSize) {
      targetHeight = maxSize;
      targetWidth = Math.trunc(targetHeight * originalWidth / originalHeight);
    }
    if ((((_a22 = config3.filter) == null ? void 0 : _a22.width) || 0) > 0)
      targetWidth = config3.filter.width;
    else if ((((_b2 = config3.filter) == null ? void 0 : _b2.height) || 0) > 0)
      targetWidth = originalWidth * ((config3.filter.height || 0) / originalHeight);
    if ((config3.filter.height || 0) > 0)
      targetHeight = config3.filter.height;
    else if ((config3.filter.width || 0) > 0)
      targetHeight = originalHeight * ((config3.filter.width || 0) / originalWidth);
    if (!targetWidth || !targetHeight)
      throw new Error("input error: cannot determine dimension");
    if (!inCanvas || inCanvas.width !== targetWidth || inCanvas.height !== targetHeight)
      inCanvas = canvas(targetWidth, targetHeight);
    const inCtx = inCanvas.getContext("2d");
    if (typeof ImageData !== "undefined" && input instanceof ImageData) {
      inCtx.putImageData(input, 0, 0);
    } else {
      if (config3.filter.flip && typeof inCtx.translate !== "undefined") {
        inCtx.translate(originalWidth, 0);
        inCtx.scale(-1, 1);
        inCtx.drawImage(input, 0, 0, originalWidth, originalHeight, 0, 0, inCanvas.width, inCanvas.height);
        inCtx.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        inCtx.drawImage(input, 0, 0, originalWidth, originalHeight, 0, 0, inCanvas.width, inCanvas.height);
      }
    }
    if (!outCanvas || inCanvas.width !== outCanvas.width || inCanvas.height !== outCanvas.height)
      outCanvas = canvas(inCanvas.width, inCanvas.height);
    if (config3.filter.enabled && env.webgl.supported) {
      if (!fx2)
        fx2 = env.browser ? new GLImageFilter() : null;
      env.filter = !!fx2;
      if (!(fx2 == null ? void 0 : fx2.add)) {
        if (config3.debug)
          log$1("input process error: cannot initialize filters");
        env.webgl.supported = false;
        config3.filter.enabled = false;
        copy(inCanvas, outCanvas);
      } else {
        fx2.reset();
        if (config3.filter.brightness !== 0)
          fx2.add("brightness", config3.filter.brightness);
        if (config3.filter.contrast !== 0)
          fx2.add("contrast", config3.filter.contrast);
        if (config3.filter.sharpness !== 0)
          fx2.add("sharpen", config3.filter.sharpness);
        if (config3.filter.blur !== 0)
          fx2.add("blur", config3.filter.blur);
        if (config3.filter.saturation !== 0)
          fx2.add("saturation", config3.filter.saturation);
        if (config3.filter.hue !== 0)
          fx2.add("hue", config3.filter.hue);
        if (config3.filter.negative)
          fx2.add("negative");
        if (config3.filter.sepia)
          fx2.add("sepia");
        if (config3.filter.vintage)
          fx2.add("brownie");
        if (config3.filter.sepia)
          fx2.add("sepia");
        if (config3.filter.kodachrome)
          fx2.add("kodachrome");
        if (config3.filter.technicolor)
          fx2.add("technicolor");
        if (config3.filter.polaroid)
          fx2.add("polaroid");
        if (config3.filter.pixelate !== 0)
          fx2.add("pixelate", config3.filter.pixelate);
        if (((_c22 = fx2.get()) == null ? void 0 : _c22.length) > 1)
          outCanvas = fx2.apply(inCanvas);
        else
          outCanvas = fx2.draw(inCanvas);
      }
    } else {
      copy(inCanvas, outCanvas);
      if (fx2)
        fx2 = null;
      env.filter = !!fx2;
    }
    if (!getTensor)
      return { tensor: null, canvas: outCanvas };
    if (!outCanvas)
      throw new Error("canvas error: cannot create output");
    let pixels;
    let depth = 3;
    if (typeof ImageData !== "undefined" && input instanceof ImageData || input.data && input.width && input.height) {
      if (env.browser && XN) {
        pixels = XN ? XN.fromPixels(input) : null;
      } else {
        depth = input.data.length / input.height / input.width;
        const arr = new Uint8Array(input.data.buffer);
        pixels = ir(arr, [input.height, input.width, depth], "int32");
      }
    } else {
      if (!tmpCanvas || outCanvas.width !== tmpCanvas.width || outCanvas.height !== tmpCanvas.height)
        tmpCanvas = canvas(outCanvas.width, outCanvas.height);
      if (XN && env.browser) {
        if (config3.backend === "webgl" || config3.backend === "humangl" || config3.backend === "webgpu") {
          pixels = XN.fromPixels(outCanvas);
        } else {
          tmpCanvas = copy(outCanvas);
          pixels = XN.fromPixels(tmpCanvas);
        }
      } else {
        const tempCanvas = copy(outCanvas);
        const tempCtx = tempCanvas.getContext("2d");
        const tempData = tempCtx.getImageData(0, 0, targetWidth, targetHeight);
        depth = tempData.data.length / targetWidth / targetHeight;
        const arr = new Uint8Array(tempData.data.buffer);
        pixels = ir(arr, [targetWidth, targetHeight, depth]);
      }
    }
    if (depth === 4) {
      const rgb3 = N1(pixels, [0, 0, 0], [-1, -1, 3]);
      Ot(pixels);
      pixels = rgb3;
    }
    if (!pixels)
      throw new Error("input error: cannot create tensor");
    const casted = qe(pixels, "float32");
    const tensor = config3.filter.equalization ? await histogramEqualization(casted) : ai(casted, 0);
    Ot([pixels, casted]);
    if (config3.filter.autoBrightness) {
      const max = _a(tensor);
      const maxVal = await max.data();
      config3.filter.brightness = maxVal[0] > 1 ? 1 - maxVal[0] / 255 : 1 - maxVal[0];
      Ot(max);
    }
    return { tensor, canvas: config3.filter.return ? outCanvas : null };
  }
  async function skip(config3, input) {
    let skipFrame = false;
    if (config3.cacheSensitivity === 0 || !input.shape || input.shape.length !== 4 || input.shape[1] > 3840 || input.shape[2] > 2160)
      return skipFrame;
    if (!last.inputTensor) {
      last.inputTensor = Ur(input);
    } else if (last.inputTensor.shape[1] !== input.shape[1] || last.inputTensor.shape[2] !== input.shape[2]) {
      Ot(last.inputTensor);
      last.inputTensor = Ur(input);
    } else {
      const t8 = {};
      t8.diff = Te(input, last.inputTensor);
      t8.squared = se(t8.diff, t8.diff);
      t8.sum = ot(t8.squared);
      const diffSum = await t8.sum.data();
      const diffRelative = diffSum[0] / (input.shape[1] || 1) / (input.shape[2] || 1) / 255 / 3;
      Ot([last.inputTensor, t8.diff, t8.squared, t8.sum]);
      last.inputTensor = Ur(input);
      skipFrame = diffRelative <= (config3.cacheSensitivity || 0);
    }
    return skipFrame;
  }
  async function compare(config3, input1, input2) {
    const t8 = {};
    if (!input1 || !input2 || input1.shape.length !== 4 || input1.shape.length !== input2.shape.length) {
      if (!config3.debug)
        log$1("invalid input tensor or tensor shapes do not match:", input1.shape, input2.shape);
      return 0;
    }
    if (input1.shape[0] !== 1 || input2.shape[0] !== 1 || input1.shape[3] !== 3 || input2.shape[3] !== 3) {
      if (!config3.debug)
        log$1("input tensors must be of shape [1, height, width, 3]:", input1.shape, input2.shape);
      return 0;
    }
    t8.input1 = Ur(input1);
    t8.input2 = input1.shape[1] !== input2.shape[1] || input1.shape[2] !== input2.shape[2] ? Fj.resizeBilinear(input2, [input1.shape[1], input1.shape[2]]) : Ur(input2);
    t8.diff = Te(t8.input1, t8.input2);
    t8.squared = se(t8.diff, t8.diff);
    t8.sum = ot(t8.squared);
    const diffSum = await t8.sum.data();
    const diffRelative = diffSum[0] / (input1.shape[1] || 1) / (input1.shape[2] || 1) / 255 / 3;
    Ot([t8.input1, t8.input2, t8.diff, t8.squared, t8.sum]);
    return diffRelative;
  }
  var _canvas, _image, _imageData;
  var Env = class {
    constructor() {
      __publicField2(this, "browser");
      __publicField2(this, "node");
      __publicField2(this, "worker");
      __publicField2(this, "platform", "");
      __publicField2(this, "agent", "");
      __publicField2(this, "backends", []);
      __publicField2(this, "initial");
      __publicField2(this, "filter");
      __publicField2(this, "tfjs");
      __publicField2(this, "offscreen");
      __publicField2(this, "perfadd", false);
      __publicField2(this, "tensorflow", {
        version: void 0,
        gpu: void 0
      });
      __publicField2(this, "wasm", {
        supported: void 0,
        backend: void 0,
        simd: void 0,
        multithread: void 0
      });
      __publicField2(this, "webgl", {
        supported: void 0,
        backend: void 0,
        version: void 0,
        renderer: void 0,
        shader: void 0,
        vendor: void 0
      });
      __publicField2(this, "webgpu", {
        supported: void 0,
        backend: void 0,
        adapter: void 0
      });
      __publicField2(this, "cpu", {
        model: void 0,
        flags: []
      });
      __publicField2(this, "kernels", []);
      __privateAdd(this, _canvas, void 0);
      __privateAdd(this, _image, void 0);
      __privateAdd(this, _imageData, void 0);
      this.browser = typeof navigator !== "undefined";
      this.node = typeof process$1 !== "undefined" && typeof process$1.versions !== "undefined" && typeof process$1.versions.node !== "undefined";
      this.tfjs = { version: Sce["tfjs-core"] };
      this.offscreen = typeof OffscreenCanvas !== "undefined";
      this.initial = true;
      this.worker = this.browser && this.offscreen ? typeof WorkerGlobalScope !== "undefined" : void 0;
      if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
        const agent = navigator.userAgent || "";
        const raw = agent.match(/\(([^()]+)\)/g);
        if (raw == null ? void 0 : raw[0]) {
          const platformMatch = raw[0].match(/\(([^()]+)\)/g);
          this.platform = (platformMatch == null ? void 0 : platformMatch[0]) ? platformMatch[0].replace(/\(|\)/g, "") : "";
          this.agent = agent.replace(raw[0], "");
          if (this.platform[1])
            this.agent = this.agent.replace(raw[1], "");
          this.agent = this.agent.replace(/  /g, " ");
        }
      } else if (typeof process$1 !== "undefined") {
        this.platform = `${process$1.platform} ${process$1.arch}`;
        this.agent = `NodeJS ${process$1.version}`;
      }
    }
    get Canvas() {
      return __privateGet(this, _canvas);
    }
    set Canvas(val) {
      __privateSet(this, _canvas, val);
      globalThis.Canvas = val;
    }
    get Image() {
      return __privateGet(this, _image);
    }
    // @ts-ignore monkey-patch;
    set Image(val) {
      __privateSet(this, _image, val);
      globalThis.Image = val;
    }
    get ImageData() {
      return __privateGet(this, _imageData);
    }
    // @ts-ignore monkey-patch;
    set ImageData(val) {
      __privateSet(this, _imageData, val);
      globalThis.ImageData = val;
    }
    /** update backend information */
    async updateBackend() {
      this.backends = Object.keys(ur().registryFactory);
      try {
        this.tensorflow = {
          version: dde()["binding"] ? dde()["binding"].TF_Version : void 0,
          gpu: dde()["binding"] ? dde()["binding"].isUsingGpuDevice() : void 0
        };
      } catch (e8) {
      }
      this.wasm.supported = typeof WebAssembly !== "undefined";
      this.wasm.backend = this.backends.includes("wasm");
      if (this.wasm.supported && this.wasm.backend) {
        this.wasm.simd = await A().getAsync("WASM_HAS_SIMD_SUPPORT");
        this.wasm.multithread = await A().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");
      }
      const c = canvas(100, 100);
      const gl2 = c ? c.getContext("webgl2") : void 0;
      this.webgl.supported = typeof gl2 !== "undefined";
      this.webgl.backend = this.backends.includes("webgl");
      if (this.webgl.supported && this.webgl.backend && gl2) {
        this.webgl.version = gl2.getParameter(gl2.VERSION);
        this.webgl.vendor = gl2.getParameter(gl2.VENDOR);
        this.webgl.renderer = gl2.getParameter(gl2.RENDERER);
        this.webgl.shader = gl2.getParameter(gl2.SHADING_LANGUAGE_VERSION);
      }
      this.webgpu.supported = this.browser && typeof navigator !== "undefined" && typeof navigator.gpu !== "undefined";
      this.webgpu.backend = this.backends.includes("webgpu");
      try {
        if (this.webgpu.supported) {
          const adapter = await navigator.gpu.requestAdapter();
          this.webgpu.adapter = await (adapter == null ? void 0 : adapter.requestAdapterInfo());
        }
      } catch (e8) {
        this.webgpu.supported = false;
      }
      try {
        this.kernels = jm(pde()).map((kernel) => kernel.kernelName.toLowerCase());
      } catch (e8) {
      }
    }
    /** update cpu information */
    updateCPU() {
      const cpu = { model: "", flags: [] };
      if (this.node && this.platform.startsWith("linux"))
        ;
      if (!this.cpu)
        Object.defineProperty(this, "cpu", { value: cpu });
      else
        this.cpu = cpu;
    }
  };
  _canvas = /* @__PURE__ */ new WeakMap();
  _image = /* @__PURE__ */ new WeakMap();
  _imageData = /* @__PURE__ */ new WeakMap();
  var env = new Env();
  var WebCam = class {
    constructor() {
      __publicField2(this, "config");
      __publicField2(this, "element");
      __publicField2(this, "stream");
      __publicField2(this, "devices", []);
      __publicField2(this, "enumerate", async () => {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          this.devices = devices.filter((device) => device.kind === "videoinput");
        } catch (e8) {
          this.devices = [];
        }
        return this.devices;
      });
      __publicField2(this, "start", async (webcamConfig) => {
        var _a22, _b2;
        if (webcamConfig == null ? void 0 : webcamConfig.debug)
          this.config.debug = webcamConfig == null ? void 0 : webcamConfig.debug;
        if (webcamConfig == null ? void 0 : webcamConfig.crop)
          this.config.crop = webcamConfig == null ? void 0 : webcamConfig.crop;
        if (webcamConfig == null ? void 0 : webcamConfig.mode)
          this.config.mode = webcamConfig == null ? void 0 : webcamConfig.mode;
        if (webcamConfig == null ? void 0 : webcamConfig.width)
          this.config.width = webcamConfig == null ? void 0 : webcamConfig.width;
        if (webcamConfig == null ? void 0 : webcamConfig.height)
          this.config.height = webcamConfig == null ? void 0 : webcamConfig.height;
        if (webcamConfig == null ? void 0 : webcamConfig.id)
          this.config.id = webcamConfig == null ? void 0 : webcamConfig.id;
        if (webcamConfig == null ? void 0 : webcamConfig.element) {
          if (typeof webcamConfig.element === "string") {
            const el2 = document.getElementById(webcamConfig.element);
            if (el2 && el2 instanceof HTMLVideoElement) {
              this.element = el2;
            } else {
              if (this.config.debug)
                log$1("webcam", "cannot get dom element", webcamConfig.element);
              return `webcam error: cannot get dom element: ${webcamConfig.element}`;
            }
          } else if (webcamConfig.element instanceof HTMLVideoElement) {
            this.element = webcamConfig.element;
          } else {
            if (this.config.debug)
              log$1("webcam", "unknown dom element", webcamConfig.element);
            return `webcam error: unknown dom element: ${webcamConfig.element}`;
          }
        } else {
          this.element = document.createElement("video");
        }
        const requestedConstraints = {
          audio: false,
          video: {
            facingMode: this.config.mode === "front" ? "user" : "environment",
            // @ts-ignore // resizeMode is still not defined in tslib
            resizeMode: this.config.crop ? "crop-and-scale" : "none"
          }
        };
        if (((_a22 = this.config) == null ? void 0 : _a22.width) > 0)
          requestedConstraints.video.width = { ideal: this.config.width };
        if (((_b2 = this.config) == null ? void 0 : _b2.height) > 0)
          requestedConstraints.video.height = { ideal: this.config.height };
        if (this.config.id)
          requestedConstraints.video.deviceId = this.config.id;
        this.element.addEventListener("play", () => {
          if (this.config.debug)
            log$1("webcam", "play");
        });
        this.element.addEventListener("pause", () => {
          if (this.config.debug)
            log$1("webcam", "pause");
        });
        this.element.addEventListener("click", async () => {
          if (!this.element || !this.stream)
            return;
          if (this.element.paused)
            await this.element.play();
          else
            this.element.pause();
        });
        if (!(navigator == null ? void 0 : navigator.mediaDevices)) {
          if (this.config.debug)
            log$1("webcam error", "no devices");
          return "webcam error: no devices";
        }
        try {
          this.stream = await navigator.mediaDevices.getUserMedia(requestedConstraints);
        } catch (err) {
          log$1("webcam", err);
          return `webcam error: ${err}`;
        }
        if (!this.stream) {
          if (this.config.debug)
            log$1("webcam error", "no stream");
          return "webcam error no stream";
        }
        this.element.srcObject = this.stream;
        const ready = new Promise((resolve) => {
          if (!this.element)
            resolve(false);
          else
            this.element.onloadeddata = () => resolve(true);
        });
        await ready;
        await this.element.play();
        if (this.config.debug) {
          log$1("webcam", {
            width: this.width,
            height: this.height,
            label: this.label,
            stream: this.stream,
            track: this.track,
            settings: this.settings,
            constraints: this.constraints,
            capabilities: this.capabilities
          });
        }
        return `webcam: ${this.label}`;
      });
      __publicField2(this, "pause", () => {
        if (this.element)
          this.element.pause();
      });
      __publicField2(this, "play", async () => {
        if (this.element)
          await this.element.play();
      });
      __publicField2(this, "stop", () => {
        if (this.config.debug)
          log$1("webcam", "stop");
        if (this.track)
          this.track.stop();
      });
      this.config = {
        element: void 0,
        debug: true,
        mode: "front",
        crop: false,
        width: 0,
        height: 0
      };
    }
    /** get active webcam stream track */
    get track() {
      if (!this.stream)
        return void 0;
      return this.stream.getVideoTracks()[0];
    }
    /** get webcam capabilities */
    get capabilities() {
      if (!this.track)
        return void 0;
      return this.track.getCapabilities ? this.track.getCapabilities() : void 0;
    }
    /** get webcam constraints */
    get constraints() {
      if (!this.track)
        return void 0;
      return this.track.getConstraints ? this.track.getConstraints() : void 0;
    }
    /** get webcam settings */
    get settings() {
      if (!this.stream)
        return void 0;
      const track = this.stream.getVideoTracks()[0];
      return track.getSettings ? track.getSettings() : void 0;
    }
    /** get webcam label */
    get label() {
      if (!this.track)
        return "";
      return this.track.label;
    }
    /** is webcam paused */
    get paused() {
      var _a22;
      return ((_a22 = this.element) == null ? void 0 : _a22.paused) || false;
    }
    /** webcam current width */
    get width() {
      var _a22;
      return ((_a22 = this.element) == null ? void 0 : _a22.videoWidth) || 0;
    }
    /** webcam current height */
    get height() {
      var _a22;
      return ((_a22 = this.element) == null ? void 0 : _a22.videoHeight) || 0;
    }
  };
  var models_exports = {};
  __export(models_exports, {
    "affectnet-mobilenet": () => affectnet_mobilenet,
    age: () => age,
    "anti-spoofing": () => anti_spoofing,
    antispoof: () => antispoof,
    blazeface: () => blazeface,
    "blazeface-back": () => blazeface_back,
    "blazeface-front": () => blazeface_front,
    "blazepose-detector": () => blazepose_detector,
    "blazepose-full": () => blazepose_full,
    "blazepose-heavy": () => blazepose_heavy,
    "blazepose-lite": () => blazepose_lite,
    centernet: () => centernet,
    default: () => models_default,
    efficientpose: () => efficientpose,
    "efficientpose-i-lite": () => efficientpose_i_lite,
    "efficientpose-ii-lite": () => efficientpose_ii_lite,
    "efficientpose-iv": () => efficientpose_iv,
    emotion: () => emotion,
    faceboxes: () => faceboxes,
    facemesh: () => facemesh,
    "facemesh-attention": () => facemesh_attention,
    "facemesh-attention-pinto": () => facemesh_attention_pinto,
    "facemesh-detection-full": () => facemesh_detection_full,
    "facemesh-detection-short": () => facemesh_detection_short,
    faceres: () => faceres,
    "faceres-deep": () => faceres_deep,
    gear: () => gear,
    "gear-e1": () => gear_e1,
    "gear-e2": () => gear_e2,
    gender: () => gender,
    "gender-ssrnet-imdb": () => gender_ssrnet_imdb,
    handdetect: () => handdetect,
    "handlandmark-full": () => handlandmark_full,
    "handlandmark-lite": () => handlandmark_lite,
    "handlandmark-sparse": () => handlandmark_sparse,
    handskeleton: () => handskeleton,
    handtrack: () => handtrack,
    "insightface-efficientnet-b0": () => insightface_efficientnet_b0,
    "insightface-ghostnet-strides1": () => insightface_ghostnet_strides1,
    "insightface-ghostnet-strides2": () => insightface_ghostnet_strides2,
    "insightface-mobilenet-emore": () => insightface_mobilenet_emore,
    "insightface-mobilenet-swish": () => insightface_mobilenet_swish,
    iris: () => iris,
    liveness: () => liveness,
    meet: () => meet,
    mobileface: () => mobileface,
    mobilefacenet: () => mobilefacenet,
    models: () => models,
    "movenet-lightning": () => movenet_lightning,
    "movenet-multipose": () => movenet_multipose,
    "movenet-thunder": () => movenet_thunder,
    nanodet: () => nanodet,
    "nanodet-e": () => nanodet_e,
    "nanodet-g": () => nanodet_g,
    "nanodet-m": () => nanodet_m,
    "nanodet-t": () => nanodet_t,
    posenet: () => posenet,
    rvm: () => rvm,
    selfie: () => selfie
  });
  var antispoof = 853098;
  var blazeface = 538928;
  var centernet = 4030290;
  var emotion = 820516;
  var facemesh = 1477958;
  var faceres = 6978814;
  var handlandmark_lite = 2023432;
  var handtrack = 2964837;
  var iris = 2599092;
  var liveness = 592976;
  var models = 0;
  var movenet_lightning = 4650216;
  var affectnet_mobilenet = 6920630;
  var age = 161240;
  var blazeface_back = 538928;
  var blazeface_front = 402048;
  var blazepose_detector = 5928856;
  var blazepose_full = 6339202;
  var blazepose_heavy = 27502466;
  var blazepose_lite = 2726402;
  var efficientpose = 5651240;
  var faceboxes = 2013002;
  var facemesh_attention_pinto = 2387598;
  var facemesh_attention = 2382414;
  var facemesh_detection_full = 1026192;
  var facemesh_detection_short = 201268;
  var faceres_deep = 13957620;
  var gear_e1 = 112438;
  var gear_e2 = 112438;
  var gear = 1498916;
  var gender_ssrnet_imdb = 161236;
  var gender = 201808;
  var handdetect = 3515612;
  var handlandmark_full = 5431368;
  var handlandmark_sparse = 5286322;
  var handskeleton = 5502280;
  var meet = 372228;
  var mobileface = 2183192;
  var mobilefacenet = 5171976;
  var movenet_multipose = 9448838;
  var movenet_thunder = 12477112;
  var nanodet = 7574558;
  var posenet = 5032780;
  var rvm = 3739355;
  var selfie = 212886;
  var anti_spoofing = 853098;
  var efficientpose_i_lite = 2269064;
  var efficientpose_ii_lite = 5651240;
  var efficientpose_iv = 25643252;
  var insightface_efficientnet_b0 = 13013224;
  var insightface_ghostnet_strides1 = 8093408;
  var insightface_ghostnet_strides2 = 8049584;
  var insightface_mobilenet_emore = 6938536;
  var insightface_mobilenet_swish = 12168584;
  var nanodet_e = 12319156;
  var nanodet_g = 7574558;
  var nanodet_m = 1887474;
  var nanodet_t = 5294216;
  var models_default = {
    antispoof,
    blazeface,
    centernet,
    emotion,
    facemesh,
    faceres,
    "handlandmark-lite": handlandmark_lite,
    handtrack,
    iris,
    liveness,
    models,
    "movenet-lightning": movenet_lightning,
    "affectnet-mobilenet": affectnet_mobilenet,
    age,
    "blazeface-back": blazeface_back,
    "blazeface-front": blazeface_front,
    "blazepose-detector": blazepose_detector,
    "blazepose-full": blazepose_full,
    "blazepose-heavy": blazepose_heavy,
    "blazepose-lite": blazepose_lite,
    efficientpose,
    faceboxes,
    "facemesh-attention-pinto": facemesh_attention_pinto,
    "facemesh-attention": facemesh_attention,
    "facemesh-detection-full": facemesh_detection_full,
    "facemesh-detection-short": facemesh_detection_short,
    "faceres-deep": faceres_deep,
    "gear-e1": gear_e1,
    "gear-e2": gear_e2,
    gear,
    "gender-ssrnet-imdb": gender_ssrnet_imdb,
    gender,
    handdetect,
    "handlandmark-full": handlandmark_full,
    "handlandmark-sparse": handlandmark_sparse,
    handskeleton,
    meet,
    mobileface,
    mobilefacenet,
    "movenet-multipose": movenet_multipose,
    "movenet-thunder": movenet_thunder,
    nanodet,
    posenet,
    rvm,
    selfie,
    "anti-spoofing": anti_spoofing,
    "efficientpose-i-lite": efficientpose_i_lite,
    "efficientpose-ii-lite": efficientpose_ii_lite,
    "efficientpose-iv": efficientpose_iv,
    "insightface-efficientnet-b0": insightface_efficientnet_b0,
    "insightface-ghostnet-strides1": insightface_ghostnet_strides1,
    "insightface-ghostnet-strides2": insightface_ghostnet_strides2,
    "insightface-mobilenet-emore": insightface_mobilenet_emore,
    "insightface-mobilenet-swish": insightface_mobilenet_swish,
    "nanodet-e": nanodet_e,
    "nanodet-g": nanodet_g,
    "nanodet-m": nanodet_m,
    "nanodet-t": nanodet_t
  };
  var options = {
    cacheModels: true,
    cacheSupported: true,
    verbose: true,
    debug: false,
    modelBasePath: ""
  };
  var modelStats = {};
  async function httpHandler(url2, init4) {
    return fetch(url2, init4);
  }
  function setModelLoadOptions(config3) {
    options.cacheModels = config3.cacheModels;
    options.verbose = config3.debug;
    options.modelBasePath = config3.modelBasePath;
  }
  async function loadModel(modelPath) {
    var _a22, _b2, _c22, _d22;
    let modelUrl = join(options.modelBasePath, modelPath || "");
    if (!modelUrl.toLowerCase().endsWith(".json"))
      modelUrl += ".json";
    const modelPathSegments = modelUrl.includes("/") ? modelUrl.split("/") : modelUrl.split("\\");
    const shortModelName = modelPathSegments[modelPathSegments.length - 1].replace(".json", "");
    const cachedModelName = "indexeddb://" + shortModelName;
    modelStats[shortModelName] = {
      name: shortModelName,
      sizeFromManifest: 0,
      sizeLoadedWeights: 0,
      sizeDesired: models_exports[shortModelName],
      inCache: false,
      url: ""
    };
    options.cacheSupported = typeof indexedDB !== "undefined";
    let cachedModels = {};
    try {
      cachedModels = options.cacheSupported && options.cacheModels ? await mi.listModels() : {};
    } catch (e8) {
      options.cacheSupported = false;
    }
    modelStats[shortModelName].inCache = options.cacheSupported && options.cacheModels && Object.keys(cachedModels).includes(cachedModelName);
    modelStats[shortModelName].url = modelStats[shortModelName].inCache ? cachedModelName : modelUrl;
    const tfLoadOptions = typeof fetch === "undefined" ? {} : { fetchFunc: (url2, init4) => httpHandler(url2, init4) };
    let model23 = new Ol(modelStats[shortModelName].url, tfLoadOptions);
    let loaded = false;
    try {
      model23.findIOHandler();
      if (options.debug)
        ;
    } catch (err) {
      log$1("error finding model i/o handler:", modelUrl, err);
    }
    try {
      const artifacts = await ((_a22 = model23.handler) == null ? void 0 : _a22.load()) || null;
      modelStats[shortModelName].sizeFromManifest = ((_b2 = artifacts == null ? void 0 : artifacts.weightData) == null ? void 0 : _b2.byteLength) || 0;
      if (artifacts)
        model23.loadSync(artifacts);
      else
        model23 = await h8(modelStats[shortModelName].inCache ? cachedModelName : modelUrl, tfLoadOptions);
      modelStats[shortModelName].sizeLoadedWeights = ((_d22 = (_c22 = model23.artifacts) == null ? void 0 : _c22.weightData) == null ? void 0 : _d22.byteLength) || 0;
      if (options.verbose)
        log$1("load:", { model: shortModelName, url: model23["modelUrl"], bytes: modelStats[shortModelName].sizeLoadedWeights });
      loaded = true;
    } catch (err) {
      log$1("error loading model:", modelUrl, err);
    }
    if (loaded && options.cacheModels && options.cacheSupported && !modelStats[shortModelName].inCache) {
      try {
        const saveResult = await model23.save(cachedModelName);
        if (options.debug)
          ;
      } catch (err) {
        log$1("error saving model:", modelUrl, err);
      }
    }
    return model23;
  }
  var version = "3.0.7";
  var config2 = {
    name: "humangl",
    priority: 999,
    canvas: null,
    gl: null,
    extensions: [],
    webGLattr: {
      // https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
      alpha: false,
      antialias: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
      depth: false,
      stencil: false,
      failIfMajorPerformanceCaveat: false,
      // default=true
      desynchronized: true
      // default=undefined
    }
  };
  function extensions() {
    const gl2 = config2.gl;
    if (!gl2)
      return;
    config2.extensions = gl2.getSupportedExtensions();
  }
  function register(instance) {
    var _a22;
    if (instance.config.backend !== "humangl")
      return;
    if (config2.name in ur().registry && !((_a22 = config2 == null ? void 0 : config2.gl) == null ? void 0 : _a22.getParameter(config2.gl.VERSION))) {
      log$1("humangl error: backend invalid context");
      instance.models.reset();
    }
    if (!lde(config2.name)) {
      try {
        config2.canvas = canvas(100, 100);
      } catch (err) {
        log$1("humangl error: cannot create canvas:", err);
        return;
      }
      try {
        config2.gl = config2.canvas.getContext("webgl2", config2.webGLattr);
        if (!config2.gl) {
          log$1("humangl error: cannot get webgl context");
          return;
        }
        const glv2 = config2.gl.getParameter(config2.gl.VERSION).includes("2.0");
        if (!glv2) {
          log$1("backend override: using fallback webgl backend as webgl 2.0 is not detected");
          instance.config.backend = "webgl";
          return;
        }
        if (config2.canvas) {
          config2.canvas.addEventListener("webglcontextlost", (e8) => {
            log$1("humangl error:", e8.type);
            log$1("possible browser memory leak using webgl or conflict with multiple backend registrations");
            instance.emit("error");
            throw new Error("backend error: webgl context lost");
          });
          config2.canvas.addEventListener("webglcontextrestored", (e8) => {
            log$1("humangl error: context restored:", e8);
          });
          config2.canvas.addEventListener("webglcontextcreationerror", (e8) => {
            log$1("humangl error: context create:", e8);
          });
        }
      } catch (err) {
        log$1("humangl error: cannot get webgl context:", err);
        return;
      }
      try {
        gI(2, config2.gl);
      } catch (err) {
        log$1("humangl error: cannot set webgl context:", err);
        return;
      }
      try {
        const ctx = new wp(config2.gl);
        nu(config2.name, () => new bu(ctx), config2.priority);
      } catch (err) {
        log$1("humangl error: cannot register webgl backend:", err);
        return;
      }
      try {
        const kernels = jm("webgl");
        kernels.forEach((kernelConfig) => {
          const newKernelConfig = { ...kernelConfig, backendName: config2.name };
          Ja(newKernelConfig);
        });
      } catch (err) {
        log$1("humangl error: cannot update webgl backend registration:", err);
        return;
      }
      try {
        if (A().flagRegistry.WEBGL_VERSION)
          A().set("WEBGL_VERSION", 2);
      } catch (err) {
        log$1("humangl error: cannot set WebGL backend flags:", err);
        return;
      }
      extensions();
      const backend = dde();
      const current = typeof backend["gpgpu"] !== "undefined" ? backend["getGPGPUContext"]().gl : null;
      if (current) {
        if (instance.config.debug)
          log$1("humangl backend registered:", { webgl: current.getParameter(current.VERSION), renderer: current.getParameter(current.RENDERER) });
      } else {
        log$1("humangl error: no current gl context:", current, config2.gl);
      }
    }
  }
  var constants = {
    tf255: 255,
    tf1: 1,
    tf2: 2,
    tf05: 0.5,
    tf127: 127.5,
    rgb: [0.2989, 0.587, 0.114]
  };
  function init$1() {
    constants.tf255 = ke(255, "float32");
    constants.tf1 = ke(1, "float32");
    constants.tf2 = ke(2, "float32");
    constants.tf05 = ke(0.5, "float32");
    constants.tf127 = ke(127.5, "float32");
    constants.rgb = xr([0.2989, 0.587, 0.114], "float32");
  }
  async function getBestBackend() {
    var _a22;
    await env.updateBackend();
    if ((_a22 = env.tensorflow) == null ? void 0 : _a22.version)
      return "tensorflow";
    if (env.webgpu.supported && env.webgpu.backend)
      return "webgpu";
    if (env.webgl.supported && env.webgl.backend)
      return "webgl";
    if (env.wasm.supported && env.wasm.backend)
      return "wasm";
    return "cpu";
  }
  function registerCustomOps(config3) {
    const newKernels = [];
    if (!env.kernels.includes("mod")) {
      const kernelMod = {
        kernelName: "Mod",
        backendName: pde(),
        kernelFunc: (op2) => De(() => Te(op2.inputs.a, se(je(op2.inputs.a, op2.inputs.b), op2.inputs.b)))
      };
      Ja(kernelMod);
      env.kernels.push("mod");
      newKernels.push("mod");
    }
    if (!env.kernels.includes("floormod")) {
      const kernelFloorMod = {
        kernelName: "FloorMod",
        backendName: pde(),
        kernelFunc: (op2) => De(() => Ce(se(ld(op2.inputs.a, op2.inputs.b), op2.inputs.b), T2(op2.inputs.a, op2.inputs.b)))
      };
      Ja(kernelFloorMod);
      env.kernels.push("floormod");
      newKernels.push("floormod");
    }
    if (!env.kernels.includes("rotatewithoffset") && config3.softwareKernels) {
      const kernelRotateWithOffset = {
        kernelName: "RotateWithOffset",
        backendName: pde(),
        kernelFunc: (op2) => De(() => {
          const backend = pde();
          ide("cpu");
          const t8 = Fj.rotateWithOffset(op2.inputs.image, op2.attrs.radians, op2.attrs.fillValue, op2.attrs.center);
          ide(backend);
          return t8;
        })
      };
      Ja(kernelRotateWithOffset);
      env.kernels.push("rotatewithoffset");
      newKernels.push("rotatewithoffset");
    }
    if (newKernels.length > 0 && config3.debug)
      log$1("registered kernels:", newKernels);
  }
  var defaultFlags = {};
  async function check(instance, force = false) {
    var _a22, _b2;
    instance.state = "backend";
    if (((_a22 = instance.config.backend) == null ? void 0 : _a22.length) === 0)
      instance.config.backend = await getBestBackend();
    if (force || env.initial || instance.config.backend && instance.config.backend.length > 0 && pde() !== instance.config.backend) {
      const timeStamp = now();
      if (instance.config.backend && instance.config.backend.length > 0) {
        if (typeof window === "undefined" && typeof WorkerGlobalScope !== "undefined" && instance.config.debug) {
          if (instance.config.debug)
            log$1("running inside web worker");
        }
        if (typeof navigator !== "undefined" && ((_b2 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _b2.toLowerCase().includes("electron"))) {
          if (instance.config.debug)
            log$1("running inside electron");
        }
        let available = Object.keys(ur().registryFactory);
        if (instance.config.backend === "humangl" && !available.includes("humangl")) {
          register(instance);
          available = Object.keys(ur().registryFactory);
        }
        if (instance.config.debug)
          log$1("available backends:", available);
        if (env.browser && !env.node && instance.config.backend === "tensorflow" && available.includes("webgl")) {
          if (instance.config.debug)
            log$1("override: backend set to tensorflow while running in browser");
          instance.config.backend = "webgl";
        }
        if (env.node && !env.browser && (instance.config.backend === "webgl" || instance.config.backend === "humangl") && available.includes("tensorflow")) {
          if (instance.config.debug)
            log$1(`override: backend set to ${instance.config.backend} while running in nodejs`);
          instance.config.backend = "tensorflow";
        }
        if (env.browser && instance.config.backend === "webgpu") {
          if (typeof navigator === "undefined" || typeof navigator.gpu === "undefined") {
            log$1("override: backend set to webgpu but browser does not support webgpu");
            instance.config.backend = "webgl";
          } else {
            const adapter = await navigator.gpu.requestAdapter();
            if (instance.config.debug)
              log$1("enumerated webgpu adapter:", adapter);
            if (!adapter) {
              log$1("override: backend set to webgpu but browser reports no available gpu");
              instance.config.backend = "webgl";
            } else {
              const adapterInfo = "requestAdapterInfo" in adapter ? await adapter.requestAdapterInfo() : void 0;
              log$1("webgpu adapter info:", adapterInfo);
            }
          }
        }
        if (!available.includes(instance.config.backend)) {
          log$1(`error: backend ${instance.config.backend} not found in registry`);
          instance.config.backend = env.node ? "tensorflow" : "webgl";
          if (instance.config.debug)
            log$1(`override: setting backend ${instance.config.backend}`);
        }
        if (instance.config.debug)
          log$1("setting backend:", [instance.config.backend]);
        if (instance.config.backend === "wasm") {
          if (A().flagRegistry.CANVAS2D_WILL_READ_FREQUENTLY)
            A().set("CANVAS2D_WILL_READ_FREQUENTLY", true);
          if (instance.config.debug)
            log$1("wasm path:", instance.config.wasmPath);
          if (typeof Ose !== "undefined")
            Ose(instance.config.wasmPath, instance.config.wasmPlatformFetch);
          else
            throw new Error("backend error: attempting to use wasm backend but wasm path is not set");
          let mt = false;
          let simd = false;
          try {
            mt = await A().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");
            simd = await A().getAsync("WASM_HAS_SIMD_SUPPORT");
            if (instance.config.debug)
              log$1(`wasm execution: ${simd ? "simd" : "no simd"} ${mt ? "multithreaded" : "singlethreaded"}`);
            if (instance.config.debug && !simd)
              log$1("warning: wasm simd support is not enabled");
          } catch (e8) {
            log$1("wasm detection failed");
          }
        }
        try {
          await ide(instance.config.backend);
          await ude();
        } catch (err) {
          log$1("error: cannot set backend:", instance.config.backend, err);
          return false;
        }
        if (instance.config.debug)
          defaultFlags = JSON.parse(JSON.stringify(A().flags));
      }
      if (pde() === "humangl" || pde() === "webgl") {
        if (A().flagRegistry.WEBGL_USE_SHAPES_UNIFORMS)
          A().set("WEBGL_USE_SHAPES_UNIFORMS", true);
        if (A().flagRegistry.WEBGL_EXP_CONV)
          A().set("WEBGL_EXP_CONV", true);
        if (instance.config.debug && typeof instance.config.deallocate !== "undefined" && instance.config.deallocate) {
          log$1("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:", true);
          A().set("WEBGL_DELETE_TEXTURE_THRESHOLD", 0);
        }
      }
      if (pde() === "webgpu")
        ;
      if (instance.config.debug) {
        const newFlags = A().flags;
        const updatedFlags = {};
        for (const key2 of Object.keys(newFlags)) {
          if (defaultFlags[key2] === newFlags[key2])
            continue;
          updatedFlags[key2] = newFlags[key2];
        }
        if (instance.config.debug && Object.keys(updatedFlags).length > 0)
          log$1("backend:", pde(), "flags:", updatedFlags);
      }
      if (instance.config.flags && Object.keys(instance.config.flags).length > 0) {
        if (instance.config.debug)
          log$1("flags:", instance.config["flags"]);
        for (const [key2, val] of Object.entries(instance.config.flags)) {
          A().set(key2, val);
        }
      }
      ede();
      init$1();
      instance.performance.initBackend = Math.trunc(now() - timeStamp);
      instance.config.backend = pde();
      await env.updateBackend();
      registerCustomOps(instance.config);
    }
    return true;
  }
  function fakeOps(kernelNames, config3) {
    for (const kernelName of kernelNames) {
      const kernelConfig = {
        kernelName,
        backendName: config3.backend,
        kernelFunc: (param) => {
          var _a22;
          if (config3.debug)
            log$1("kernelFunc", kernelName, config3.backend, param);
          return (_a22 = param == null ? void 0 : param.inputs) == null ? void 0 : _a22.info;
        }
        // setupFunc: () => { if (config.debug) log('kernelFunc', kernelName, config.backend); },
        // disposeFunc: () => { if (config.debug) log('kernelFunc', kernelName, config.backend); },
      };
      Ja(kernelConfig);
    }
    env.kernels = jm(pde()).map((kernel) => kernel.kernelName.toLowerCase());
  }
  var draw_exports = {};
  __export(draw_exports, {
    all: () => all,
    body: () => body,
    canvas: () => canvas2,
    face: () => face,
    gesture: () => gesture,
    hand: () => hand,
    init: () => init2,
    object: () => object,
    options: () => options2,
    person: () => person
  });
  var getCanvasContext = (input) => {
    if (!input)
      log$1("draw error: invalid canvas");
    else if (!input.getContext)
      log$1("draw error: canvas context not defined");
    else {
      const ctx = input.getContext("2d", { willReadFrequently: true });
      if (!ctx)
        log$1("draw error: cannot get canvas context");
      else
        return ctx;
    }
    return null;
  };
  var rad2deg = (theta) => Math.round(theta * 180 / Math.PI);
  var replace = (str, source, target) => str.replace(source, typeof target === "number" ? target.toFixed(1) : target);
  var colorDepth = (z, opt) => {
    if (!opt.useDepth || typeof z === "undefined")
      return opt.color;
    const rgb3 = Uint8ClampedArray.from([127 + 2 * z, 127 - 2 * z, 255]);
    return `rgba(${rgb3[0]}, ${rgb3[1]}, ${rgb3[2]}, ${opt.alpha})`;
  };
  function labels(ctx, str, startX, startY, localOptions2) {
    const line = str.replace(/\[.*\]/g, "").split("\n").map((l) => l.trim());
    const x = Math.max(0, startX);
    for (let i10 = line.length - 1; i10 >= 0; i10--) {
      const y10 = i10 * localOptions2.lineHeight + startY;
      if (localOptions2.shadowColor && localOptions2.shadowColor !== "") {
        ctx.fillStyle = localOptions2.shadowColor;
        ctx.fillText(line[i10], x + 5, y10 + 16);
      }
      ctx.fillStyle = localOptions2.labelColor;
      ctx.fillText(line[i10], x + 4, y10 + 15);
    }
  }
  function point(ctx, x, y10, z, localOptions2) {
    ctx.fillStyle = colorDepth(z, localOptions2);
    ctx.beginPath();
    ctx.arc(x, y10, localOptions2.pointSize, 0, 2 * Math.PI);
    ctx.fill();
  }
  function rect(ctx, x, y10, width, height, localOptions2) {
    ctx.beginPath();
    ctx.lineWidth = localOptions2.lineWidth;
    if (localOptions2.useCurves) {
      const cx2 = (x + x + width) / 2;
      const cy2 = (y10 + y10 + height) / 2;
      ctx.ellipse(cx2, cy2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    } else {
      ctx.moveTo(x + localOptions2.roundRect, y10);
      ctx.lineTo(x + width - localOptions2.roundRect, y10);
      ctx.quadraticCurveTo(x + width, y10, x + width, y10 + localOptions2.roundRect);
      ctx.lineTo(x + width, y10 + height - localOptions2.roundRect);
      ctx.quadraticCurveTo(x + width, y10 + height, x + width - localOptions2.roundRect, y10 + height);
      ctx.lineTo(x + localOptions2.roundRect, y10 + height);
      ctx.quadraticCurveTo(x, y10 + height, x, y10 + height - localOptions2.roundRect);
      ctx.lineTo(x, y10 + localOptions2.roundRect);
      ctx.quadraticCurveTo(x, y10, x + localOptions2.roundRect, y10);
      ctx.closePath();
    }
    ctx.stroke();
  }
  function lines(ctx, points, localOptions2) {
    if (points.length < 2)
      return;
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);
    for (const pt2 of points) {
      ctx.strokeStyle = colorDepth(pt2[2] || 0, localOptions2);
      ctx.lineTo(Math.trunc(pt2[0]), Math.trunc(pt2[1]));
    }
    ctx.stroke();
    if (localOptions2.fillPolygons) {
      ctx.closePath();
      ctx.fill();
    }
  }
  function curves(ctx, points, localOptions2) {
    if (points.length < 2)
      return;
    ctx.lineWidth = localOptions2.lineWidth;
    if (!localOptions2.useCurves || points.length <= 2) {
      lines(ctx, points, localOptions2);
      return;
    }
    ctx.moveTo(points[0][0], points[0][1]);
    for (let i10 = 0; i10 < points.length - 2; i10++) {
      const xc2 = (points[i10][0] + points[i10 + 1][0]) / 2;
      const yc2 = (points[i10][1] + points[i10 + 1][1]) / 2;
      ctx.quadraticCurveTo(points[i10][0], points[i10][1], xc2, yc2);
    }
    ctx.quadraticCurveTo(points[points.length - 2][0], points[points.length - 2][1], points[points.length - 1][0], points[points.length - 1][1]);
    ctx.stroke();
    if (localOptions2.fillPolygons) {
      ctx.closePath();
      ctx.fill();
    }
  }
  function arrow(ctx, from, to, radius = 5) {
    let angle;
    let x;
    let y10;
    ctx.beginPath();
    ctx.moveTo(from[0], from[1]);
    ctx.lineTo(to[0], to[1]);
    angle = Math.atan2(to[1] - from[1], to[0] - from[0]);
    x = radius * Math.cos(angle) + to[0];
    y10 = radius * Math.sin(angle) + to[1];
    ctx.moveTo(x, y10);
    angle += 1 / 3 * (2 * Math.PI);
    x = radius * Math.cos(angle) + to[0];
    y10 = radius * Math.sin(angle) + to[1];
    ctx.lineTo(x, y10);
    angle += 1 / 3 * (2 * Math.PI);
    x = radius * Math.cos(angle) + to[0];
    y10 = radius * Math.sin(angle) + to[1];
    ctx.lineTo(x, y10);
    ctx.closePath();
    ctx.stroke();
    ctx.fill();
  }
  var options2 = {
    color: "rgba(173, 216, 230, 0.6)",
    // 'lightblue' with light alpha channel
    labelColor: "rgba(173, 216, 230, 1)",
    // 'lightblue' with dark alpha channel
    shadowColor: "black",
    alpha: 0.5,
    font: 'small-caps 16px "Segoe UI"',
    lineHeight: 18,
    lineWidth: 4,
    pointSize: 2,
    roundRect: 8,
    drawPoints: false,
    drawLabels: true,
    drawBoxes: true,
    drawAttention: true,
    drawGestures: true,
    drawPolygons: true,
    drawGaze: true,
    fillPolygons: false,
    useDepth: true,
    useCurves: false,
    faceLabels: "",
    bodyLabels: "",
    bodyPartLabels: "",
    objectLabels: "",
    handLabels: "",
    fingerLabels: "",
    gestureLabels: ""
  };
  var meshAnnotations = {
    silhouette: [
      10,
      338,
      297,
      332,
      284,
      251,
      389,
      356,
      454,
      323,
      361,
      288,
      397,
      365,
      379,
      378,
      400,
      377,
      152,
      148,
      176,
      149,
      150,
      136,
      172,
      58,
      132,
      93,
      234,
      127,
      162,
      21,
      54,
      103,
      67,
      109
    ],
    // lipsUpperOuter: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291], // 11
    // lipsLowerOuter: [146, 91, 181, 84, 17, 314, 405, 321, 375, 291], // 10
    // lipsUpperInner: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308], // 11
    // lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308], // 11
    lipsUpperOuter: [185, 40, 39, 37, 0, 267, 269, 270, 409],
    lipsLowerOuter: [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291],
    lipsUpperInner: [191, 80, 81, 82, 13, 312, 311, 310, 415],
    lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308],
    lipsLowerSemiOuter: [76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306],
    lipsUpperSemiOuter: [184, 74, 73, 72, 11, 302, 303, 304, 408],
    lipsLowerSemiInner: [62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292],
    lipsUpperSemiInner: [183, 42, 41, 38, 12, 268, 271, 272, 407],
    rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173],
    // 7
    rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133],
    // 9
    rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190],
    // 7
    rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243],
    // 9
    rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189],
    // 7
    rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244],
    // 9
    rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245],
    // 9
    rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193],
    // 8
    rightEyebrowLower: [35, 124, 46, 53, 52, 65],
    // 6
    rightEyeIris: [473, 474, 475, 476, 477],
    // 5
    leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398],
    leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362],
    leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414],
    leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463],
    leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413],
    leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464],
    leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465],
    leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417],
    leftEyebrowLower: [265, 353, 276, 283, 282, 295],
    leftEyeIris: [468, 469, 470, 471, 472],
    midwayBetweenEyes: [168],
    noseTip: [1],
    noseBottom: [2],
    noseRightCorner: [98],
    noseLeftCorner: [327],
    rightCheek: [205],
    leftCheek: [425]
  };
  var meshLandmarks = {
    count: 468,
    mouth: 13,
    symmetryLine: [13, meshAnnotations.midwayBetweenEyes[0]]
  };
  var blazeFaceLandmarks = {
    leftEye: 0,
    rightEye: 1,
    nose: 2,
    mouth: 3,
    leftEar: 4,
    rightEar: 5,
    symmetryLine: [3, 2]
  };
  var irisIndices = [
    // A mapping from facemesh model keypoints to iris model keypoints.
    { key: "EyeUpper0", indices: [9, 10, 11, 12, 13, 14, 15] },
    // 7 x 3d
    { key: "EyeUpper1", indices: [25, 26, 27, 28, 29, 30, 31] },
    // 7 x 3d
    { key: "EyeUpper2", indices: [41, 42, 43, 44, 45, 46, 47] },
    // 7 x 3d
    { key: "EyeLower0", indices: [0, 1, 2, 3, 4, 5, 6, 7, 8] },
    // 7 x 3d
    { key: "EyeLower1", indices: [16, 17, 18, 19, 20, 21, 22, 23, 24] },
    // 9 x 3d
    { key: "EyeLower2", indices: [32, 33, 34, 35, 36, 37, 38, 39, 40] },
    // 9 x 3d
    { key: "EyeLower3", indices: [54, 55, 56, 57, 58, 59, 60, 61, 62] },
    // 9 x 3d
    { key: "EyebrowUpper", indices: [63, 64, 65, 66, 67, 68, 69, 70] },
    // 8 x 3d
    { key: "EyebrowLower", indices: [48, 49, 50, 51, 52, 53] }
    // 6 x 3d
  ];
  var UV468 = [
    [0.499976992607117, 0.652534008026123],
    [0.500025987625122, 0.547487020492554],
    [0.499974012374878, 0.602371990680695],
    [0.482113003730774, 0.471979022026062],
    [0.500150978565216, 0.527155995368958],
    [0.499909996986389, 0.498252987861633],
    [0.499523013830185, 0.40106201171875],
    [0.289712011814117, 0.380764007568359],
    [0.499954998493195, 0.312398016452789],
    [0.499987006187439, 0.269918978214264],
    [0.500023007392883, 0.107050001621246],
    [0.500023007392883, 0.666234016418457],
    [0.5000159740448, 0.679224014282227],
    [0.500023007392883, 0.692348003387451],
    [0.499976992607117, 0.695277988910675],
    [0.499976992607117, 0.70593398809433],
    [0.499976992607117, 0.719385027885437],
    [0.499976992607117, 0.737019002437592],
    [0.499967992305756, 0.781370997428894],
    [0.499816000461578, 0.562981009483337],
    [0.473773002624512, 0.573909997940063],
    [0.104906998574734, 0.254140973091125],
    [0.365929991006851, 0.409575998783112],
    [0.338757991790771, 0.41302502155304],
    [0.311120003461838, 0.409460008144379],
    [0.274657994508743, 0.389131009578705],
    [0.393361985683441, 0.403706014156342],
    [0.345234006643295, 0.344011008739471],
    [0.370094001293182, 0.346076011657715],
    [0.319321990013123, 0.347265005111694],
    [0.297903001308441, 0.353591024875641],
    [0.24779200553894, 0.410809993743896],
    [0.396889001131058, 0.842755019664764],
    [0.280097991228104, 0.375599980354309],
    [0.106310002505779, 0.399955987930298],
    [0.2099249958992, 0.391353011131287],
    [0.355807989835739, 0.534406006336212],
    [0.471751004457474, 0.65040397644043],
    [0.474155008792877, 0.680191993713379],
    [0.439785003662109, 0.657229006290436],
    [0.414617002010345, 0.66654098033905],
    [0.450374007225037, 0.680860996246338],
    [0.428770989179611, 0.682690978050232],
    [0.374971002340317, 0.727805018424988],
    [0.486716985702515, 0.547628998756409],
    [0.485300987958908, 0.527395009994507],
    [0.257764995098114, 0.314490020275116],
    [0.401223003864288, 0.455172002315521],
    [0.429818987846375, 0.548614978790283],
    [0.421351999044418, 0.533740997314453],
    [0.276895999908447, 0.532056987285614],
    [0.483370006084442, 0.499586999416351],
    [0.33721199631691, 0.282882988452911],
    [0.296391993761063, 0.293242990970612],
    [0.169294998049736, 0.193813979625702],
    [0.447580009698868, 0.302609980106354],
    [0.392390012741089, 0.353887975215912],
    [0.354490011930466, 0.696784019470215],
    [0.067304998636246, 0.730105042457581],
    [0.442739009857178, 0.572826027870178],
    [0.457098007202148, 0.584792017936707],
    [0.381974011659622, 0.694710969924927],
    [0.392388999462128, 0.694203019142151],
    [0.277076005935669, 0.271932005882263],
    [0.422551989555359, 0.563233017921448],
    [0.385919004678726, 0.281364023685455],
    [0.383103013038635, 0.255840003490448],
    [0.331431001424789, 0.119714021682739],
    [0.229923993349075, 0.232002973556519],
    [0.364500999450684, 0.189113974571228],
    [0.229622006416321, 0.299540996551514],
    [0.173287004232407, 0.278747975826263],
    [0.472878992557526, 0.666198015213013],
    [0.446828007698059, 0.668527007102966],
    [0.422762006521225, 0.673889994621277],
    [0.445307999849319, 0.580065965652466],
    [0.388103008270264, 0.693961024284363],
    [0.403039008378983, 0.706539988517761],
    [0.403629004955292, 0.693953037261963],
    [0.460041999816895, 0.557139039039612],
    [0.431158006191254, 0.692366003990173],
    [0.452181994915009, 0.692366003990173],
    [0.475387006998062, 0.692366003990173],
    [0.465828001499176, 0.779190003871918],
    [0.472328990697861, 0.736225962638855],
    [0.473087012767792, 0.717857003211975],
    [0.473122000694275, 0.704625964164734],
    [0.473033010959625, 0.695277988910675],
    [0.427942007780075, 0.695277988910675],
    [0.426479011774063, 0.703539967536926],
    [0.423162013292313, 0.711845993995667],
    [0.4183090031147, 0.720062971115112],
    [0.390094995498657, 0.639572978019714],
    [0.013953999616206, 0.560034036636353],
    [0.499913990497589, 0.58014702796936],
    [0.413199990987778, 0.69539999961853],
    [0.409626007080078, 0.701822996139526],
    [0.468080013990402, 0.601534962654114],
    [0.422728985548019, 0.585985004901886],
    [0.463079988956451, 0.593783974647522],
    [0.37211999297142, 0.47341400384903],
    [0.334562003612518, 0.496073007583618],
    [0.411671012639999, 0.546965003013611],
    [0.242175996303558, 0.14767599105835],
    [0.290776997804642, 0.201445996761322],
    [0.327338010072708, 0.256527006626129],
    [0.399509996175766, 0.748921036720276],
    [0.441727995872498, 0.261676013469696],
    [0.429764986038208, 0.187834024429321],
    [0.412198007106781, 0.108901023864746],
    [0.288955003023148, 0.398952007293701],
    [0.218936994671822, 0.435410976409912],
    [0.41278201341629, 0.398970007896423],
    [0.257135003805161, 0.355440020561218],
    [0.427684992551804, 0.437960982322693],
    [0.448339998722076, 0.536936044692993],
    [0.178560003638268, 0.45755398273468],
    [0.247308000922203, 0.457193970680237],
    [0.286267012357712, 0.467674970626831],
    [0.332827985286713, 0.460712015628815],
    [0.368755996227264, 0.447206974029541],
    [0.398963987827301, 0.432654976844788],
    [0.476410001516342, 0.405806005001068],
    [0.189241006970406, 0.523923993110657],
    [0.228962004184723, 0.348950982093811],
    [0.490725994110107, 0.562400996685028],
    [0.404670000076294, 0.485132992267609],
    [0.019469000399113, 0.401564002037048],
    [0.426243007183075, 0.420431017875671],
    [0.396993011236191, 0.548797011375427],
    [0.266469985246658, 0.376977026462555],
    [0.439121007919312, 0.51895797252655],
    [0.032313998788595, 0.644356966018677],
    [0.419054001569748, 0.387154996395111],
    [0.462783008813858, 0.505746960639954],
    [0.238978996872902, 0.779744982719421],
    [0.198220998048782, 0.831938028335571],
    [0.107550002634525, 0.540755033493042],
    [0.183610007166862, 0.740257024765015],
    [0.134409993886948, 0.333683013916016],
    [0.385764002799988, 0.883153975009918],
    [0.490967005491257, 0.579378008842468],
    [0.382384985685349, 0.508572995662689],
    [0.174399003386497, 0.397670984268188],
    [0.318785011768341, 0.39623498916626],
    [0.343364000320435, 0.400596976280212],
    [0.396100014448166, 0.710216999053955],
    [0.187885001301765, 0.588537991046906],
    [0.430987000465393, 0.944064974784851],
    [0.318993002176285, 0.898285031318665],
    [0.266247987747192, 0.869701027870178],
    [0.500023007392883, 0.190576016902924],
    [0.499976992607117, 0.954452991485596],
    [0.366169989109039, 0.398822009563446],
    [0.393207013607025, 0.39553701877594],
    [0.410373002290726, 0.391080021858215],
    [0.194993004202843, 0.342101991176605],
    [0.388664990663528, 0.362284004688263],
    [0.365961998701096, 0.355970978736877],
    [0.343364000320435, 0.355356991291046],
    [0.318785011768341, 0.35834002494812],
    [0.301414996385574, 0.363156020641327],
    [0.058132998645306, 0.319076001644135],
    [0.301414996385574, 0.387449026107788],
    [0.499987989664078, 0.618434011936188],
    [0.415838003158569, 0.624195992946625],
    [0.445681989192963, 0.566076993942261],
    [0.465844005346298, 0.620640993118286],
    [0.49992299079895, 0.351523995399475],
    [0.288718998432159, 0.819945991039276],
    [0.335278987884521, 0.852819979190826],
    [0.440512001514435, 0.902418971061707],
    [0.128294005990028, 0.791940987110138],
    [0.408771991729736, 0.373893976211548],
    [0.455606997013092, 0.451801002025604],
    [0.499877005815506, 0.908990025520325],
    [0.375436991453171, 0.924192011356354],
    [0.11421000212431, 0.615022003650665],
    [0.448662012815475, 0.695277988910675],
    [0.4480200111866, 0.704632043838501],
    [0.447111994028091, 0.715808033943176],
    [0.444831997156143, 0.730794012546539],
    [0.430011987686157, 0.766808986663818],
    [0.406787008047104, 0.685672998428345],
    [0.400738000869751, 0.681069016456604],
    [0.392399996519089, 0.677703022956848],
    [0.367855995893478, 0.663918972015381],
    [0.247923001646996, 0.601333022117615],
    [0.452769994735718, 0.420849978923798],
    [0.43639200925827, 0.359887003898621],
    [0.416164010763168, 0.368713974952698],
    [0.413385987281799, 0.692366003990173],
    [0.228018000721931, 0.683571994304657],
    [0.468268007040024, 0.352671027183533],
    [0.411361992359161, 0.804327011108398],
    [0.499989002943039, 0.469825029373169],
    [0.479153990745544, 0.442654013633728],
    [0.499974012374878, 0.439637005329132],
    [0.432112008333206, 0.493588984012604],
    [0.499886006116867, 0.866917014122009],
    [0.49991300702095, 0.821729004383087],
    [0.456548988819122, 0.819200992584229],
    [0.344549000263214, 0.745438992977142],
    [0.37890899181366, 0.574010014533997],
    [0.374292999505997, 0.780184984207153],
    [0.319687992334366, 0.570737957954407],
    [0.357154995203018, 0.604269981384277],
    [0.295284003019333, 0.621580958366394],
    [0.447750002145767, 0.862477004528046],
    [0.410986006259918, 0.508723020553589],
    [0.31395098567009, 0.775308012962341],
    [0.354128003120422, 0.812552988529205],
    [0.324548006057739, 0.703992962837219],
    [0.189096003770828, 0.646299958229065],
    [0.279776990413666, 0.71465802192688],
    [0.1338230073452, 0.682700991630554],
    [0.336768001317978, 0.644733011722565],
    [0.429883986711502, 0.466521978378296],
    [0.455527991056442, 0.548622965812683],
    [0.437114000320435, 0.558896005153656],
    [0.467287987470627, 0.529924988746643],
    [0.414712011814117, 0.335219979286194],
    [0.37704598903656, 0.322777986526489],
    [0.344107985496521, 0.320150971412659],
    [0.312875986099243, 0.32233202457428],
    [0.283526003360748, 0.333190023899078],
    [0.241245999932289, 0.382785975933075],
    [0.102986000478268, 0.468762993812561],
    [0.267612010240555, 0.424560010433197],
    [0.297879010438919, 0.433175981044769],
    [0.333433985710144, 0.433878004550934],
    [0.366427004337311, 0.426115989685059],
    [0.396012008190155, 0.416696012020111],
    [0.420121014118195, 0.41022801399231],
    [0.007561000064015, 0.480777025222778],
    [0.432949006557465, 0.569517970085144],
    [0.458638995885849, 0.479089021682739],
    [0.473466008901596, 0.545744001865387],
    [0.476087987422943, 0.563830018043518],
    [0.468472003936768, 0.555056989192963],
    [0.433990985155106, 0.582361996173859],
    [0.483518004417419, 0.562983989715576],
    [0.482482999563217, 0.57784903049469],
    [0.42645001411438, 0.389798998832703],
    [0.438998997211456, 0.39649498462677],
    [0.450067013502121, 0.400434017181396],
    [0.289712011814117, 0.368252992630005],
    [0.276670008897781, 0.363372981548309],
    [0.517862021923065, 0.471948027610779],
    [0.710287988185883, 0.380764007568359],
    [0.526226997375488, 0.573909997940063],
    [0.895093023777008, 0.254140973091125],
    [0.634069979190826, 0.409575998783112],
    [0.661242008209229, 0.41302502155304],
    [0.688880026340485, 0.409460008144379],
    [0.725341975688934, 0.389131009578705],
    [0.606630027294159, 0.40370500087738],
    [0.654766023159027, 0.344011008739471],
    [0.629905998706818, 0.346076011657715],
    [0.680678009986877, 0.347265005111694],
    [0.702096998691559, 0.353591024875641],
    [0.75221198797226, 0.410804986953735],
    [0.602918028831482, 0.842862963676453],
    [0.719901978969574, 0.375599980354309],
    [0.893692970275879, 0.399959981441498],
    [0.790081977844238, 0.391354024410248],
    [0.643998026847839, 0.534487962722778],
    [0.528249025344849, 0.65040397644043],
    [0.525849997997284, 0.680191040039062],
    [0.560214996337891, 0.657229006290436],
    [0.585384011268616, 0.66654098033905],
    [0.549625992774963, 0.680860996246338],
    [0.57122802734375, 0.682691991329193],
    [0.624852001667023, 0.72809898853302],
    [0.513050019741058, 0.547281980514526],
    [0.51509702205658, 0.527251958847046],
    [0.742246985435486, 0.314507007598877],
    [0.598631024360657, 0.454979002475739],
    [0.570338010787964, 0.548575043678284],
    [0.578631997108459, 0.533622980117798],
    [0.723087012767792, 0.532054007053375],
    [0.516445994377136, 0.499638974666595],
    [0.662801027297974, 0.282917976379395],
    [0.70362401008606, 0.293271005153656],
    [0.830704987049103, 0.193813979625702],
    [0.552385985851288, 0.302568018436432],
    [0.607609987258911, 0.353887975215912],
    [0.645429015159607, 0.696707010269165],
    [0.932694971561432, 0.730105042457581],
    [0.557260990142822, 0.572826027870178],
    [0.542901992797852, 0.584792017936707],
    [0.6180260181427, 0.694710969924927],
    [0.607590973377228, 0.694203019142151],
    [0.722943007946014, 0.271963000297546],
    [0.577413976192474, 0.563166975975037],
    [0.614082992076874, 0.281386971473694],
    [0.616907000541687, 0.255886018276215],
    [0.668509006500244, 0.119913995265961],
    [0.770092010498047, 0.232020974159241],
    [0.635536015033722, 0.189248979091644],
    [0.77039098739624, 0.299556016921997],
    [0.826722025871277, 0.278755009174347],
    [0.527121007442474, 0.666198015213013],
    [0.553171992301941, 0.668527007102966],
    [0.577238023281097, 0.673889994621277],
    [0.554691970348358, 0.580065965652466],
    [0.611896991729736, 0.693961024284363],
    [0.59696102142334, 0.706539988517761],
    [0.596370995044708, 0.693953037261963],
    [0.539958000183105, 0.557139039039612],
    [0.568841993808746, 0.692366003990173],
    [0.547818005084991, 0.692366003990173],
    [0.52461302280426, 0.692366003990173],
    [0.534089982509613, 0.779141008853912],
    [0.527670979499817, 0.736225962638855],
    [0.526912987232208, 0.717857003211975],
    [0.526877999305725, 0.704625964164734],
    [0.526966989040375, 0.695277988910675],
    [0.572058022022247, 0.695277988910675],
    [0.573521018028259, 0.703539967536926],
    [0.57683801651001, 0.711845993995667],
    [0.581691026687622, 0.720062971115112],
    [0.609944999217987, 0.639909982681274],
    [0.986046016216278, 0.560034036636353],
    [0.5867999792099, 0.69539999961853],
    [0.590372025966644, 0.701822996139526],
    [0.531915009021759, 0.601536989212036],
    [0.577268004417419, 0.585934996604919],
    [0.536915004253387, 0.593786001205444],
    [0.627542972564697, 0.473352015018463],
    [0.665585994720459, 0.495950996875763],
    [0.588353991508484, 0.546862006187439],
    [0.757824003696442, 0.14767599105835],
    [0.709249973297119, 0.201507985591888],
    [0.672684013843536, 0.256581008434296],
    [0.600408971309662, 0.74900496006012],
    [0.55826598405838, 0.261672019958496],
    [0.570303976535797, 0.187870979309082],
    [0.588165998458862, 0.109044015407562],
    [0.711045026779175, 0.398952007293701],
    [0.781069993972778, 0.435405015945435],
    [0.587247014045715, 0.398931980133057],
    [0.742869973182678, 0.355445981025696],
    [0.572156012058258, 0.437651991844177],
    [0.55186802148819, 0.536570012569427],
    [0.821442008018494, 0.457556009292603],
    [0.752701997756958, 0.457181990146637],
    [0.71375697851181, 0.467626988887787],
    [0.66711300611496, 0.460672974586487],
    [0.631101012229919, 0.447153985500336],
    [0.6008620262146, 0.432473003864288],
    [0.523481011390686, 0.405627012252808],
    [0.810747981071472, 0.523926019668579],
    [0.771045982837677, 0.348959028720856],
    [0.509127020835876, 0.562718033790588],
    [0.595292985439301, 0.485023975372314],
    [0.980530977249146, 0.401564002037048],
    [0.573499977588654, 0.420000016689301],
    [0.602994978427887, 0.548687994480133],
    [0.733529984951019, 0.376977026462555],
    [0.560611009597778, 0.519016981124878],
    [0.967685997486115, 0.644356966018677],
    [0.580985009670258, 0.387160003185272],
    [0.537728011608124, 0.505385041236877],
    [0.760966002941132, 0.779752969741821],
    [0.801778972148895, 0.831938028335571],
    [0.892440974712372, 0.54076099395752],
    [0.816350996494293, 0.740260004997253],
    [0.865594983100891, 0.333687007427216],
    [0.614073991775513, 0.883246004581451],
    [0.508952975273132, 0.579437971115112],
    [0.617941975593567, 0.508316040039062],
    [0.825608015060425, 0.397674977779388],
    [0.681214988231659, 0.39623498916626],
    [0.656635999679565, 0.400596976280212],
    [0.603900015354156, 0.710216999053955],
    [0.81208598613739, 0.588539004325867],
    [0.56801301240921, 0.944564998149872],
    [0.681007981300354, 0.898285031318665],
    [0.733752012252808, 0.869701027870178],
    [0.633830010890961, 0.398822009563446],
    [0.606792986392975, 0.39553701877594],
    [0.589659988880157, 0.391062021255493],
    [0.805015981197357, 0.342108011245728],
    [0.611334979534149, 0.362284004688263],
    [0.634037971496582, 0.355970978736877],
    [0.656635999679565, 0.355356991291046],
    [0.681214988231659, 0.35834002494812],
    [0.698584973812103, 0.363156020641327],
    [0.941866993904114, 0.319076001644135],
    [0.698584973812103, 0.387449026107788],
    [0.584177017211914, 0.624107003211975],
    [0.554318010807037, 0.566076993942261],
    [0.534153997898102, 0.62064003944397],
    [0.711217999458313, 0.819975018501282],
    [0.664629995822906, 0.852871000766754],
    [0.559099972248077, 0.902631998062134],
    [0.871706008911133, 0.791940987110138],
    [0.591234028339386, 0.373893976211548],
    [0.544341027736664, 0.451583981513977],
    [0.624562978744507, 0.924192011356354],
    [0.88577002286911, 0.615028977394104],
    [0.551338016986847, 0.695277988910675],
    [0.551980018615723, 0.704632043838501],
    [0.552887976169586, 0.715808033943176],
    [0.555167973041534, 0.730794012546539],
    [0.569944024085999, 0.767035007476807],
    [0.593203008174896, 0.685675978660583],
    [0.599261999130249, 0.681069016456604],
    [0.607599973678589, 0.677703022956848],
    [0.631937980651855, 0.663500010967255],
    [0.752032995223999, 0.601315021514893],
    [0.547226011753082, 0.420395016670227],
    [0.563543975353241, 0.359827995300293],
    [0.583841025829315, 0.368713974952698],
    [0.586614012718201, 0.692366003990173],
    [0.771915018558502, 0.683578014373779],
    [0.531597018241882, 0.352482974529266],
    [0.588370978832245, 0.804440975189209],
    [0.52079701423645, 0.442565023899078],
    [0.567984998226166, 0.493479013442993],
    [0.543282985687256, 0.819254994392395],
    [0.655317008495331, 0.745514988899231],
    [0.621008992195129, 0.574018001556396],
    [0.625559985637665, 0.78031200170517],
    [0.680198013782501, 0.570719003677368],
    [0.64276397228241, 0.604337990283966],
    [0.704662978649139, 0.621529996395111],
    [0.552012026309967, 0.862591981887817],
    [0.589071989059448, 0.508637011051178],
    [0.685944974422455, 0.775357007980347],
    [0.645735025405884, 0.812640011310577],
    [0.675342977046967, 0.703978002071381],
    [0.810858011245728, 0.646304965019226],
    [0.72012197971344, 0.714666962623596],
    [0.866151988506317, 0.682704985141754],
    [0.663187026977539, 0.644596993923187],
    [0.570082008838654, 0.466325998306274],
    [0.544561982154846, 0.548375964164734],
    [0.562758982181549, 0.558784961700439],
    [0.531987011432648, 0.530140042304993],
    [0.585271000862122, 0.335177004337311],
    [0.622952997684479, 0.32277899980545],
    [0.655896008014679, 0.320163011550903],
    [0.687132000923157, 0.322345972061157],
    [0.716481983661652, 0.333200991153717],
    [0.758756995201111, 0.382786989212036],
    [0.897013008594513, 0.468769013881683],
    [0.732392013072968, 0.424547016620636],
    [0.70211398601532, 0.433162987232208],
    [0.66652500629425, 0.433866024017334],
    [0.633504986763, 0.426087975502014],
    [0.603875994682312, 0.416586995124817],
    [0.579657971858978, 0.409945011138916],
    [0.992439985275269, 0.480777025222778],
    [0.567192018032074, 0.569419980049133],
    [0.54136598110199, 0.478899002075195],
    [0.526564002037048, 0.546118021011353],
    [0.523913025856018, 0.563830018043518],
    [0.531529009342194, 0.555056989192963],
    [0.566035985946655, 0.582329034805298],
    [0.51631098985672, 0.563053965568542],
    [0.5174720287323, 0.577877044677734],
    [0.573594987392426, 0.389806985855103],
    [0.560697972774506, 0.395331978797913],
    [0.549755990505219, 0.399751007556915],
    [0.710287988185883, 0.368252992630005],
    [0.723330020904541, 0.363372981548309]
  ];
  var TRI468 = [
    127,
    34,
    139,
    11,
    0,
    37,
    232,
    231,
    120,
    72,
    37,
    39,
    128,
    121,
    47,
    232,
    121,
    128,
    104,
    69,
    67,
    175,
    171,
    148,
    157,
    154,
    155,
    118,
    50,
    101,
    73,
    39,
    40,
    9,
    151,
    108,
    48,
    115,
    131,
    194,
    204,
    211,
    74,
    40,
    185,
    80,
    42,
    183,
    40,
    92,
    186,
    230,
    229,
    118,
    202,
    212,
    214,
    83,
    18,
    17,
    76,
    61,
    146,
    160,
    29,
    30,
    56,
    157,
    173,
    106,
    204,
    194,
    135,
    214,
    192,
    203,
    165,
    98,
    21,
    71,
    68,
    51,
    45,
    4,
    144,
    24,
    23,
    77,
    146,
    91,
    205,
    50,
    187,
    201,
    200,
    18,
    91,
    106,
    182,
    90,
    91,
    181,
    85,
    84,
    17,
    206,
    203,
    36,
    148,
    171,
    140,
    92,
    40,
    39,
    193,
    189,
    244,
    159,
    158,
    28,
    247,
    246,
    161,
    236,
    3,
    196,
    54,
    68,
    104,
    193,
    168,
    8,
    117,
    228,
    31,
    189,
    193,
    55,
    98,
    97,
    99,
    126,
    47,
    100,
    166,
    79,
    218,
    155,
    154,
    26,
    209,
    49,
    131,
    135,
    136,
    150,
    47,
    126,
    217,
    223,
    52,
    53,
    45,
    51,
    134,
    211,
    170,
    140,
    67,
    69,
    108,
    43,
    106,
    91,
    230,
    119,
    120,
    226,
    130,
    247,
    63,
    53,
    52,
    238,
    20,
    242,
    46,
    70,
    156,
    78,
    62,
    96,
    46,
    53,
    63,
    143,
    34,
    227,
    173,
    155,
    133,
    123,
    117,
    111,
    44,
    125,
    19,
    236,
    134,
    51,
    216,
    206,
    205,
    154,
    153,
    22,
    39,
    37,
    167,
    200,
    201,
    208,
    36,
    142,
    100,
    57,
    212,
    202,
    20,
    60,
    99,
    28,
    158,
    157,
    35,
    226,
    113,
    160,
    159,
    27,
    204,
    202,
    210,
    113,
    225,
    46,
    43,
    202,
    204,
    62,
    76,
    77,
    137,
    123,
    116,
    41,
    38,
    72,
    203,
    129,
    142,
    64,
    98,
    240,
    49,
    102,
    64,
    41,
    73,
    74,
    212,
    216,
    207,
    42,
    74,
    184,
    169,
    170,
    211,
    170,
    149,
    176,
    105,
    66,
    69,
    122,
    6,
    168,
    123,
    147,
    187,
    96,
    77,
    90,
    65,
    55,
    107,
    89,
    90,
    180,
    101,
    100,
    120,
    63,
    105,
    104,
    93,
    137,
    227,
    15,
    86,
    85,
    129,
    102,
    49,
    14,
    87,
    86,
    55,
    8,
    9,
    100,
    47,
    121,
    145,
    23,
    22,
    88,
    89,
    179,
    6,
    122,
    196,
    88,
    95,
    96,
    138,
    172,
    136,
    215,
    58,
    172,
    115,
    48,
    219,
    42,
    80,
    81,
    195,
    3,
    51,
    43,
    146,
    61,
    171,
    175,
    199,
    81,
    82,
    38,
    53,
    46,
    225,
    144,
    163,
    110,
    246,
    33,
    7,
    52,
    65,
    66,
    229,
    228,
    117,
    34,
    127,
    234,
    107,
    108,
    69,
    109,
    108,
    151,
    48,
    64,
    235,
    62,
    78,
    191,
    129,
    209,
    126,
    111,
    35,
    143,
    163,
    161,
    246,
    117,
    123,
    50,
    222,
    65,
    52,
    19,
    125,
    141,
    221,
    55,
    65,
    3,
    195,
    197,
    25,
    7,
    33,
    220,
    237,
    44,
    70,
    71,
    139,
    122,
    193,
    245,
    247,
    130,
    33,
    71,
    21,
    162,
    153,
    158,
    159,
    170,
    169,
    150,
    188,
    174,
    196,
    216,
    186,
    92,
    144,
    160,
    161,
    2,
    97,
    167,
    141,
    125,
    241,
    164,
    167,
    37,
    72,
    38,
    12,
    145,
    159,
    160,
    38,
    82,
    13,
    63,
    68,
    71,
    226,
    35,
    111,
    158,
    153,
    154,
    101,
    50,
    205,
    206,
    92,
    165,
    209,
    198,
    217,
    165,
    167,
    97,
    220,
    115,
    218,
    133,
    112,
    243,
    239,
    238,
    241,
    214,
    135,
    169,
    190,
    173,
    133,
    171,
    208,
    32,
    125,
    44,
    237,
    86,
    87,
    178,
    85,
    86,
    179,
    84,
    85,
    180,
    83,
    84,
    181,
    201,
    83,
    182,
    137,
    93,
    132,
    76,
    62,
    183,
    61,
    76,
    184,
    57,
    61,
    185,
    212,
    57,
    186,
    214,
    207,
    187,
    34,
    143,
    156,
    79,
    239,
    237,
    123,
    137,
    177,
    44,
    1,
    4,
    201,
    194,
    32,
    64,
    102,
    129,
    213,
    215,
    138,
    59,
    166,
    219,
    242,
    99,
    97,
    2,
    94,
    141,
    75,
    59,
    235,
    24,
    110,
    228,
    25,
    130,
    226,
    23,
    24,
    229,
    22,
    23,
    230,
    26,
    22,
    231,
    112,
    26,
    232,
    189,
    190,
    243,
    221,
    56,
    190,
    28,
    56,
    221,
    27,
    28,
    222,
    29,
    27,
    223,
    30,
    29,
    224,
    247,
    30,
    225,
    238,
    79,
    20,
    166,
    59,
    75,
    60,
    75,
    240,
    147,
    177,
    215,
    20,
    79,
    166,
    187,
    147,
    213,
    112,
    233,
    244,
    233,
    128,
    245,
    128,
    114,
    188,
    114,
    217,
    174,
    131,
    115,
    220,
    217,
    198,
    236,
    198,
    131,
    134,
    177,
    132,
    58,
    143,
    35,
    124,
    110,
    163,
    7,
    228,
    110,
    25,
    356,
    389,
    368,
    11,
    302,
    267,
    452,
    350,
    349,
    302,
    303,
    269,
    357,
    343,
    277,
    452,
    453,
    357,
    333,
    332,
    297,
    175,
    152,
    377,
    384,
    398,
    382,
    347,
    348,
    330,
    303,
    304,
    270,
    9,
    336,
    337,
    278,
    279,
    360,
    418,
    262,
    431,
    304,
    408,
    409,
    310,
    415,
    407,
    270,
    409,
    410,
    450,
    348,
    347,
    422,
    430,
    434,
    313,
    314,
    17,
    306,
    307,
    375,
    387,
    388,
    260,
    286,
    414,
    398,
    335,
    406,
    418,
    364,
    367,
    416,
    423,
    358,
    327,
    251,
    284,
    298,
    281,
    5,
    4,
    373,
    374,
    253,
    307,
    320,
    321,
    425,
    427,
    411,
    421,
    313,
    18,
    321,
    405,
    406,
    320,
    404,
    405,
    315,
    16,
    17,
    426,
    425,
    266,
    377,
    400,
    369,
    322,
    391,
    269,
    417,
    465,
    464,
    386,
    257,
    258,
    466,
    260,
    388,
    456,
    399,
    419,
    284,
    332,
    333,
    417,
    285,
    8,
    346,
    340,
    261,
    413,
    441,
    285,
    327,
    460,
    328,
    355,
    371,
    329,
    392,
    439,
    438,
    382,
    341,
    256,
    429,
    420,
    360,
    364,
    394,
    379,
    277,
    343,
    437,
    443,
    444,
    283,
    275,
    440,
    363,
    431,
    262,
    369,
    297,
    338,
    337,
    273,
    375,
    321,
    450,
    451,
    349,
    446,
    342,
    467,
    293,
    334,
    282,
    458,
    461,
    462,
    276,
    353,
    383,
    308,
    324,
    325,
    276,
    300,
    293,
    372,
    345,
    447,
    382,
    398,
    362,
    352,
    345,
    340,
    274,
    1,
    19,
    456,
    248,
    281,
    436,
    427,
    425,
    381,
    256,
    252,
    269,
    391,
    393,
    200,
    199,
    428,
    266,
    330,
    329,
    287,
    273,
    422,
    250,
    462,
    328,
    258,
    286,
    384,
    265,
    353,
    342,
    387,
    259,
    257,
    424,
    431,
    430,
    342,
    353,
    276,
    273,
    335,
    424,
    292,
    325,
    307,
    366,
    447,
    345,
    271,
    303,
    302,
    423,
    266,
    371,
    294,
    455,
    460,
    279,
    278,
    294,
    271,
    272,
    304,
    432,
    434,
    427,
    272,
    407,
    408,
    394,
    430,
    431,
    395,
    369,
    400,
    334,
    333,
    299,
    351,
    417,
    168,
    352,
    280,
    411,
    325,
    319,
    320,
    295,
    296,
    336,
    319,
    403,
    404,
    330,
    348,
    349,
    293,
    298,
    333,
    323,
    454,
    447,
    15,
    16,
    315,
    358,
    429,
    279,
    14,
    15,
    316,
    285,
    336,
    9,
    329,
    349,
    350,
    374,
    380,
    252,
    318,
    402,
    403,
    6,
    197,
    419,
    318,
    319,
    325,
    367,
    364,
    365,
    435,
    367,
    397,
    344,
    438,
    439,
    272,
    271,
    311,
    195,
    5,
    281,
    273,
    287,
    291,
    396,
    428,
    199,
    311,
    271,
    268,
    283,
    444,
    445,
    373,
    254,
    339,
    263,
    466,
    249,
    282,
    334,
    296,
    449,
    347,
    346,
    264,
    447,
    454,
    336,
    296,
    299,
    338,
    10,
    151,
    278,
    439,
    455,
    292,
    407,
    415,
    358,
    371,
    355,
    340,
    345,
    372,
    390,
    249,
    466,
    346,
    347,
    280,
    442,
    443,
    282,
    19,
    94,
    370,
    441,
    442,
    295,
    248,
    419,
    197,
    263,
    255,
    359,
    440,
    275,
    274,
    300,
    383,
    368,
    351,
    412,
    465,
    263,
    467,
    466,
    301,
    368,
    389,
    380,
    374,
    386,
    395,
    378,
    379,
    412,
    351,
    419,
    436,
    426,
    322,
    373,
    390,
    388,
    2,
    164,
    393,
    370,
    462,
    461,
    164,
    0,
    267,
    302,
    11,
    12,
    374,
    373,
    387,
    268,
    12,
    13,
    293,
    300,
    301,
    446,
    261,
    340,
    385,
    384,
    381,
    330,
    266,
    425,
    426,
    423,
    391,
    429,
    355,
    437,
    391,
    327,
    326,
    440,
    457,
    438,
    341,
    382,
    362,
    459,
    457,
    461,
    434,
    430,
    394,
    414,
    463,
    362,
    396,
    369,
    262,
    354,
    461,
    457,
    316,
    403,
    402,
    315,
    404,
    403,
    314,
    405,
    404,
    313,
    406,
    405,
    421,
    418,
    406,
    366,
    401,
    361,
    306,
    408,
    407,
    291,
    409,
    408,
    287,
    410,
    409,
    432,
    436,
    410,
    434,
    416,
    411,
    264,
    368,
    383,
    309,
    438,
    457,
    352,
    376,
    401,
    274,
    275,
    4,
    421,
    428,
    262,
    294,
    327,
    358,
    433,
    416,
    367,
    289,
    455,
    439,
    462,
    370,
    326,
    2,
    326,
    370,
    305,
    460,
    455,
    254,
    449,
    448,
    255,
    261,
    446,
    253,
    450,
    449,
    252,
    451,
    450,
    256,
    452,
    451,
    341,
    453,
    452,
    413,
    464,
    463,
    441,
    413,
    414,
    258,
    442,
    441,
    257,
    443,
    442,
    259,
    444,
    443,
    260,
    445,
    444,
    467,
    342,
    445,
    459,
    458,
    250,
    289,
    392,
    290,
    290,
    328,
    460,
    376,
    433,
    435,
    250,
    290,
    392,
    411,
    416,
    433,
    341,
    463,
    464,
    453,
    464,
    465,
    357,
    465,
    412,
    343,
    412,
    399,
    360,
    363,
    440,
    437,
    399,
    456,
    420,
    456,
    363,
    401,
    435,
    288,
    372,
    383,
    353,
    339,
    255,
    249,
    448,
    261,
    255,
    133,
    243,
    190,
    133,
    155,
    112,
    33,
    246,
    247,
    33,
    130,
    25,
    398,
    384,
    286,
    362,
    398,
    414,
    362,
    463,
    341,
    263,
    359,
    467,
    263,
    249,
    255,
    466,
    467,
    260,
    75,
    60,
    166,
    238,
    239,
    79,
    162,
    127,
    139,
    72,
    11,
    37,
    121,
    232,
    120,
    73,
    72,
    39,
    114,
    128,
    47,
    233,
    232,
    128,
    103,
    104,
    67,
    152,
    175,
    148,
    173,
    157,
    155,
    119,
    118,
    101,
    74,
    73,
    40,
    107,
    9,
    108,
    49,
    48,
    131,
    32,
    194,
    211,
    184,
    74,
    185,
    191,
    80,
    183,
    185,
    40,
    186,
    119,
    230,
    118,
    210,
    202,
    214,
    84,
    83,
    17,
    77,
    76,
    146,
    161,
    160,
    30,
    190,
    56,
    173,
    182,
    106,
    194,
    138,
    135,
    192,
    129,
    203,
    98,
    54,
    21,
    68,
    5,
    51,
    4,
    145,
    144,
    23,
    90,
    77,
    91,
    207,
    205,
    187,
    83,
    201,
    18,
    181,
    91,
    182,
    180,
    90,
    181,
    16,
    85,
    17,
    205,
    206,
    36,
    176,
    148,
    140,
    165,
    92,
    39,
    245,
    193,
    244,
    27,
    159,
    28,
    30,
    247,
    161,
    174,
    236,
    196,
    103,
    54,
    104,
    55,
    193,
    8,
    111,
    117,
    31,
    221,
    189,
    55,
    240,
    98,
    99,
    142,
    126,
    100,
    219,
    166,
    218,
    112,
    155,
    26,
    198,
    209,
    131,
    169,
    135,
    150,
    114,
    47,
    217,
    224,
    223,
    53,
    220,
    45,
    134,
    32,
    211,
    140,
    109,
    67,
    108,
    146,
    43,
    91,
    231,
    230,
    120,
    113,
    226,
    247,
    105,
    63,
    52,
    241,
    238,
    242,
    124,
    46,
    156,
    95,
    78,
    96,
    70,
    46,
    63,
    116,
    143,
    227,
    116,
    123,
    111,
    1,
    44,
    19,
    3,
    236,
    51,
    207,
    216,
    205,
    26,
    154,
    22,
    165,
    39,
    167,
    199,
    200,
    208,
    101,
    36,
    100,
    43,
    57,
    202,
    242,
    20,
    99,
    56,
    28,
    157,
    124,
    35,
    113,
    29,
    160,
    27,
    211,
    204,
    210,
    124,
    113,
    46,
    106,
    43,
    204,
    96,
    62,
    77,
    227,
    137,
    116,
    73,
    41,
    72,
    36,
    203,
    142,
    235,
    64,
    240,
    48,
    49,
    64,
    42,
    41,
    74,
    214,
    212,
    207,
    183,
    42,
    184,
    210,
    169,
    211,
    140,
    170,
    176,
    104,
    105,
    69,
    193,
    122,
    168,
    50,
    123,
    187,
    89,
    96,
    90,
    66,
    65,
    107,
    179,
    89,
    180,
    119,
    101,
    120,
    68,
    63,
    104,
    234,
    93,
    227,
    16,
    15,
    85,
    209,
    129,
    49,
    15,
    14,
    86,
    107,
    55,
    9,
    120,
    100,
    121,
    153,
    145,
    22,
    178,
    88,
    179,
    197,
    6,
    196,
    89,
    88,
    96,
    135,
    138,
    136,
    138,
    215,
    172,
    218,
    115,
    219,
    41,
    42,
    81,
    5,
    195,
    51,
    57,
    43,
    61,
    208,
    171,
    199,
    41,
    81,
    38,
    224,
    53,
    225,
    24,
    144,
    110,
    105,
    52,
    66,
    118,
    229,
    117,
    227,
    34,
    234,
    66,
    107,
    69,
    10,
    109,
    151,
    219,
    48,
    235,
    183,
    62,
    191,
    142,
    129,
    126,
    116,
    111,
    143,
    7,
    163,
    246,
    118,
    117,
    50,
    223,
    222,
    52,
    94,
    19,
    141,
    222,
    221,
    65,
    196,
    3,
    197,
    45,
    220,
    44,
    156,
    70,
    139,
    188,
    122,
    245,
    139,
    71,
    162,
    145,
    153,
    159,
    149,
    170,
    150,
    122,
    188,
    196,
    206,
    216,
    92,
    163,
    144,
    161,
    164,
    2,
    167,
    242,
    141,
    241,
    0,
    164,
    37,
    11,
    72,
    12,
    144,
    145,
    160,
    12,
    38,
    13,
    70,
    63,
    71,
    31,
    226,
    111,
    157,
    158,
    154,
    36,
    101,
    205,
    203,
    206,
    165,
    126,
    209,
    217,
    98,
    165,
    97,
    237,
    220,
    218,
    237,
    239,
    241,
    210,
    214,
    169,
    140,
    171,
    32,
    241,
    125,
    237,
    179,
    86,
    178,
    180,
    85,
    179,
    181,
    84,
    180,
    182,
    83,
    181,
    194,
    201,
    182,
    177,
    137,
    132,
    184,
    76,
    183,
    185,
    61,
    184,
    186,
    57,
    185,
    216,
    212,
    186,
    192,
    214,
    187,
    139,
    34,
    156,
    218,
    79,
    237,
    147,
    123,
    177,
    45,
    44,
    4,
    208,
    201,
    32,
    98,
    64,
    129,
    192,
    213,
    138,
    235,
    59,
    219,
    141,
    242,
    97,
    97,
    2,
    141,
    240,
    75,
    235,
    229,
    24,
    228,
    31,
    25,
    226,
    230,
    23,
    229,
    231,
    22,
    230,
    232,
    26,
    231,
    233,
    112,
    232,
    244,
    189,
    243,
    189,
    221,
    190,
    222,
    28,
    221,
    223,
    27,
    222,
    224,
    29,
    223,
    225,
    30,
    224,
    113,
    247,
    225,
    99,
    60,
    240,
    213,
    147,
    215,
    60,
    20,
    166,
    192,
    187,
    213,
    243,
    112,
    244,
    244,
    233,
    245,
    245,
    128,
    188,
    188,
    114,
    174,
    134,
    131,
    220,
    174,
    217,
    236,
    236,
    198,
    134,
    215,
    177,
    58,
    156,
    143,
    124,
    25,
    110,
    7,
    31,
    228,
    25,
    264,
    356,
    368,
    0,
    11,
    267,
    451,
    452,
    349,
    267,
    302,
    269,
    350,
    357,
    277,
    350,
    452,
    357,
    299,
    333,
    297,
    396,
    175,
    377,
    381,
    384,
    382,
    280,
    347,
    330,
    269,
    303,
    270,
    151,
    9,
    337,
    344,
    278,
    360,
    424,
    418,
    431,
    270,
    304,
    409,
    272,
    310,
    407,
    322,
    270,
    410,
    449,
    450,
    347,
    432,
    422,
    434,
    18,
    313,
    17,
    291,
    306,
    375,
    259,
    387,
    260,
    424,
    335,
    418,
    434,
    364,
    416,
    391,
    423,
    327,
    301,
    251,
    298,
    275,
    281,
    4,
    254,
    373,
    253,
    375,
    307,
    321,
    280,
    425,
    411,
    200,
    421,
    18,
    335,
    321,
    406,
    321,
    320,
    405,
    314,
    315,
    17,
    423,
    426,
    266,
    396,
    377,
    369,
    270,
    322,
    269,
    413,
    417,
    464,
    385,
    386,
    258,
    248,
    456,
    419,
    298,
    284,
    333,
    168,
    417,
    8,
    448,
    346,
    261,
    417,
    413,
    285,
    326,
    327,
    328,
    277,
    355,
    329,
    309,
    392,
    438,
    381,
    382,
    256,
    279,
    429,
    360,
    365,
    364,
    379,
    355,
    277,
    437,
    282,
    443,
    283,
    281,
    275,
    363,
    395,
    431,
    369,
    299,
    297,
    337,
    335,
    273,
    321,
    348,
    450,
    349,
    359,
    446,
    467,
    283,
    293,
    282,
    250,
    458,
    462,
    300,
    276,
    383,
    292,
    308,
    325,
    283,
    276,
    293,
    264,
    372,
    447,
    346,
    352,
    340,
    354,
    274,
    19,
    363,
    456,
    281,
    426,
    436,
    425,
    380,
    381,
    252,
    267,
    269,
    393,
    421,
    200,
    428,
    371,
    266,
    329,
    432,
    287,
    422,
    290,
    250,
    328,
    385,
    258,
    384,
    446,
    265,
    342,
    386,
    387,
    257,
    422,
    424,
    430,
    445,
    342,
    276,
    422,
    273,
    424,
    306,
    292,
    307,
    352,
    366,
    345,
    268,
    271,
    302,
    358,
    423,
    371,
    327,
    294,
    460,
    331,
    279,
    294,
    303,
    271,
    304,
    436,
    432,
    427,
    304,
    272,
    408,
    395,
    394,
    431,
    378,
    395,
    400,
    296,
    334,
    299,
    6,
    351,
    168,
    376,
    352,
    411,
    307,
    325,
    320,
    285,
    295,
    336,
    320,
    319,
    404,
    329,
    330,
    349,
    334,
    293,
    333,
    366,
    323,
    447,
    316,
    15,
    315,
    331,
    358,
    279,
    317,
    14,
    316,
    8,
    285,
    9,
    277,
    329,
    350,
    253,
    374,
    252,
    319,
    318,
    403,
    351,
    6,
    419,
    324,
    318,
    325,
    397,
    367,
    365,
    288,
    435,
    397,
    278,
    344,
    439,
    310,
    272,
    311,
    248,
    195,
    281,
    375,
    273,
    291,
    175,
    396,
    199,
    312,
    311,
    268,
    276,
    283,
    445,
    390,
    373,
    339,
    295,
    282,
    296,
    448,
    449,
    346,
    356,
    264,
    454,
    337,
    336,
    299,
    337,
    338,
    151,
    294,
    278,
    455,
    308,
    292,
    415,
    429,
    358,
    355,
    265,
    340,
    372,
    388,
    390,
    466,
    352,
    346,
    280,
    295,
    442,
    282,
    354,
    19,
    370,
    285,
    441,
    295,
    195,
    248,
    197,
    457,
    440,
    274,
    301,
    300,
    368,
    417,
    351,
    465,
    251,
    301,
    389,
    385,
    380,
    386,
    394,
    395,
    379,
    399,
    412,
    419,
    410,
    436,
    322,
    387,
    373,
    388,
    326,
    2,
    393,
    354,
    370,
    461,
    393,
    164,
    267,
    268,
    302,
    12,
    386,
    374,
    387,
    312,
    268,
    13,
    298,
    293,
    301,
    265,
    446,
    340,
    380,
    385,
    381,
    280,
    330,
    425,
    322,
    426,
    391,
    420,
    429,
    437,
    393,
    391,
    326,
    344,
    440,
    438,
    458,
    459,
    461,
    364,
    434,
    394,
    428,
    396,
    262,
    274,
    354,
    457,
    317,
    316,
    402,
    316,
    315,
    403,
    315,
    314,
    404,
    314,
    313,
    405,
    313,
    421,
    406,
    323,
    366,
    361,
    292,
    306,
    407,
    306,
    291,
    408,
    291,
    287,
    409,
    287,
    432,
    410,
    427,
    434,
    411,
    372,
    264,
    383,
    459,
    309,
    457,
    366,
    352,
    401,
    1,
    274,
    4,
    418,
    421,
    262,
    331,
    294,
    358,
    435,
    433,
    367,
    392,
    289,
    439,
    328,
    462,
    326,
    94,
    2,
    370,
    289,
    305,
    455,
    339,
    254,
    448,
    359,
    255,
    446,
    254,
    253,
    449,
    253,
    252,
    450,
    252,
    256,
    451,
    256,
    341,
    452,
    414,
    413,
    463,
    286,
    441,
    414,
    286,
    258,
    441,
    258,
    257,
    442,
    257,
    259,
    443,
    259,
    260,
    444,
    260,
    467,
    445,
    309,
    459,
    250,
    305,
    289,
    290,
    305,
    290,
    460,
    401,
    376,
    435,
    309,
    250,
    392,
    376,
    411,
    433,
    453,
    341,
    464,
    357,
    453,
    465,
    343,
    357,
    412,
    437,
    343,
    399,
    344,
    360,
    440,
    420,
    437,
    456,
    360,
    420,
    363,
    361,
    401,
    288,
    265,
    372,
    353,
    390,
    339,
    249,
    339,
    448,
    255
  ];
  var VTX68 = [
    /* cont  */
    127,
    234,
    132,
    58,
    172,
    150,
    149,
    148,
    152,
    377,
    378,
    379,
    397,
    288,
    361,
    454,
    356,
    /* brows */
    70,
    63,
    105,
    66,
    107,
    336,
    296,
    334,
    293,
    300,
    /* nose  */
    168,
    6,
    195,
    4,
    98,
    97,
    2,
    326,
    327,
    /* eyes  */
    33,
    160,
    158,
    133,
    153,
    144,
    362,
    385,
    387,
    263,
    373,
    380,
    /* lip   */
    57,
    40,
    37,
    0,
    267,
    270,
    287,
    321,
    314,
    17,
    84,
    91,
    /* mouth */
    78,
    81,
    13,
    311,
    308,
    402,
    14,
    178
  ];
  var VTX33 = [33, 133, 362, 263, 1, 62, 308, 159, 145, 386, 374, 6, 102, 331, 2, 13, 14, 70, 105, 107, 336, 334, 300, 54, 10, 284, 50, 280, 234, 454, 58, 288, 152];
  var VTX7 = [33, 133, 362, 263, 1, 78, 308];
  VTX68.map((x) => UV468[x]);
  VTX33.map((x) => UV468[x]);
  VTX7.map((x) => UV468[x]);
  function connectionsToIndices(connections) {
    const indices = connections.map((connection) => connection[0]);
    indices.push(connections[connections.length - 1][1]);
    return indices;
  }
  var pairsLips = [
    [61, 146],
    [146, 91],
    [91, 181],
    [181, 84],
    [84, 17],
    [17, 314],
    [314, 405],
    [405, 321],
    [321, 375],
    [375, 291],
    [61, 185],
    [185, 40],
    [40, 39],
    [39, 37],
    [37, 0],
    [0, 267],
    [267, 269],
    [269, 270],
    [270, 409],
    [409, 291],
    [78, 95],
    [95, 88],
    [88, 178],
    [178, 87],
    [87, 14],
    [14, 317],
    [317, 402],
    [402, 318],
    [318, 324],
    [324, 308],
    [78, 191],
    [191, 80],
    [80, 81],
    [81, 82],
    [82, 13],
    [13, 312],
    [312, 311],
    [311, 310],
    [310, 415],
    [415, 308]
  ];
  var pairsLeftEye = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]];
  var pairsLeftEyebrow = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]];
  var pairsLeftIris = [[474, 475], [475, 476], [476, 477], [477, 474]];
  var pairsRightEye = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]];
  var pairsRightEyebrow = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]];
  var pairsRightIris = [[469, 470], [470, 471], [471, 472], [472, 469]];
  var pairsFaceContour = [
    [10, 338],
    [338, 297],
    [297, 332],
    [332, 284],
    [284, 251],
    [251, 389],
    [389, 356],
    [356, 454],
    [454, 323],
    [323, 361],
    [361, 288],
    [288, 397],
    [397, 365],
    [365, 379],
    [379, 378],
    [378, 400],
    [400, 377],
    [377, 152],
    [152, 148],
    [148, 176],
    [176, 149],
    [149, 150],
    [150, 136],
    [136, 172],
    [172, 58],
    [58, 132],
    [132, 93],
    [93, 234],
    [234, 127],
    [127, 162],
    [162, 21],
    [21, 54],
    [54, 103],
    [103, 67],
    [67, 109],
    [109, 10]
  ];
  ({
    lips: connectionsToIndices(pairsLips),
    leftEye: connectionsToIndices(pairsLeftEye),
    leftEyebrow: connectionsToIndices(pairsLeftEyebrow),
    leftIris: connectionsToIndices(pairsLeftIris),
    rightEye: connectionsToIndices(pairsRightEye),
    rightEyebrow: connectionsToIndices(pairsRightEyebrow),
    rightIris: connectionsToIndices(pairsRightIris),
    faceOval: connectionsToIndices(pairsFaceContour)
  });
  var LIPS_CONNECTIONS = [
    [61, 146],
    [146, 91],
    [91, 181],
    [181, 84],
    [84, 17],
    [17, 314],
    [314, 405],
    [405, 321],
    [321, 375],
    [375, 291],
    [61, 185],
    [185, 40],
    [40, 39],
    [39, 37],
    [37, 0],
    [0, 267],
    [267, 269],
    [269, 270],
    [270, 409],
    [409, 291],
    [78, 95],
    [95, 88],
    [88, 178],
    [178, 87],
    [87, 14],
    [14, 317],
    [317, 402],
    [402, 318],
    [318, 324],
    [324, 308],
    [78, 191],
    [191, 80],
    [80, 81],
    [81, 82],
    [82, 13],
    [13, 312],
    [312, 311],
    [311, 310],
    [310, 415],
    [415, 308]
  ];
  var LEFT_EYE_CONNECTIONS = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]];
  var LEFT_EYEBROW_CONNECTIONS = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]];
  var LEFT_IRIS_CONNECTIONS = [[474, 475], [475, 476], [476, 477], [477, 474]];
  var RIGHT_EYE_CONNECTIONS = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]];
  var RIGHT_EYEBROW_CONNECTIONS = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]];
  var RIGHT_IRIS_CONNECTIONS = [[469, 470], [470, 471], [471, 472], [472, 469]];
  var FACE_OVAL_CONNECTIONS = [
    [10, 338],
    [338, 297],
    [297, 332],
    [332, 284],
    [284, 251],
    [251, 389],
    [389, 356],
    [356, 454],
    [454, 323],
    [323, 361],
    [361, 288],
    [288, 397],
    [397, 365],
    [365, 379],
    [379, 378],
    [378, 400],
    [400, 377],
    [377, 152],
    [152, 148],
    [148, 176],
    [176, 149],
    [149, 150],
    [150, 136],
    [136, 172],
    [172, 58],
    [58, 132],
    [132, 93],
    [93, 234],
    [234, 127],
    [127, 162],
    [162, 21],
    [21, 54],
    [54, 103],
    [103, 67],
    [67, 109],
    [109, 10]
  ];
  function connectionsToIndices2(connections) {
    const indices = connections.map((connection) => connection[0]);
    indices.push(connections[connections.length - 1][1]);
    return indices;
  }
  var MEDIAPIPE_FACE_MESH_KEYPOINTS_BY_CONTOUR = {
    lips: connectionsToIndices2(LIPS_CONNECTIONS),
    leftEye: connectionsToIndices2(LEFT_EYE_CONNECTIONS),
    leftEyebrow: connectionsToIndices2(LEFT_EYEBROW_CONNECTIONS),
    leftIris: connectionsToIndices2(LEFT_IRIS_CONNECTIONS),
    rightEye: connectionsToIndices2(RIGHT_EYE_CONNECTIONS),
    rightEyebrow: connectionsToIndices2(RIGHT_EYEBROW_CONNECTIONS),
    rightIris: connectionsToIndices2(RIGHT_IRIS_CONNECTIONS),
    faceOval: connectionsToIndices2(FACE_OVAL_CONNECTIONS)
  };
  var indexLabelPairs = Object.entries(MEDIAPIPE_FACE_MESH_KEYPOINTS_BY_CONTOUR).map(([label, indices]) => indices.map((index2) => [index2, label])).flat();
  new Map(indexLabelPairs);
  var LANDMARKS_REFINEMENT_LIPS_CONFIG = [
    61,
    146,
    91,
    181,
    84,
    17,
    314,
    405,
    321,
    375,
    291,
    // Lower outer.
    185,
    40,
    39,
    37,
    0,
    267,
    269,
    270,
    409,
    // Upper outer(excluding corners).
    78,
    95,
    88,
    178,
    87,
    14,
    317,
    402,
    318,
    324,
    308,
    // Lower inner.
    191,
    80,
    81,
    82,
    13,
    312,
    311,
    310,
    415,
    // Upper inner(excluding corners).
    76,
    77,
    90,
    180,
    85,
    16,
    315,
    404,
    320,
    307,
    306,
    // Lower semi - outer.
    184,
    74,
    73,
    72,
    11,
    302,
    303,
    304,
    408,
    // Upper semi - outer(excluding corners).
    62,
    96,
    89,
    179,
    86,
    15,
    316,
    403,
    319,
    325,
    292,
    // Lower semi - inner.
    183,
    42,
    41,
    38,
    12,
    268,
    271,
    272,
    407
    // Upper semi - inner(excluding corners).
  ];
  var LANDMARKS_REFINEMENT_LEFT_EYE_CONFIG = [
    33,
    7,
    163,
    144,
    145,
    153,
    154,
    155,
    133,
    // Lower contour.
    246,
    161,
    160,
    159,
    158,
    157,
    173,
    // upper contour (excluding corners).
    130,
    25,
    110,
    24,
    23,
    22,
    26,
    112,
    243,
    // Halo x2 lower contour.
    247,
    30,
    29,
    27,
    28,
    56,
    190,
    // Halo x2 upper contour (excluding corners).
    226,
    31,
    228,
    229,
    230,
    231,
    232,
    233,
    244,
    // Halo x3 lower contour.
    113,
    225,
    224,
    223,
    222,
    221,
    189,
    // Halo x3 upper contour (excluding corners).
    35,
    124,
    46,
    53,
    52,
    65,
    // Halo x4 upper contour (no lower because of mesh structure) or eyebrow inner contour.
    143,
    111,
    117,
    118,
    119,
    120,
    121,
    128,
    245,
    // Halo x5 lower contour.
    156,
    70,
    63,
    105,
    66,
    107,
    55,
    193
    // Halo x5 upper contour (excluding corners) or eyebrow outer contour.
  ];
  var LANDMARKS_REFINEMENT_RIGHT_EYE_CONFIG = [
    263,
    249,
    390,
    373,
    374,
    380,
    381,
    382,
    362,
    // Lower contour.
    466,
    388,
    387,
    386,
    385,
    384,
    398,
    // Upper contour (excluding corners).
    359,
    255,
    339,
    254,
    253,
    252,
    256,
    341,
    463,
    // Halo x2 lower contour.
    467,
    260,
    259,
    257,
    258,
    286,
    414,
    // Halo x2 upper contour (excluding corners).
    446,
    261,
    448,
    449,
    450,
    451,
    452,
    453,
    464,
    // Halo x3 lower contour.
    342,
    445,
    444,
    443,
    442,
    441,
    413,
    // Halo x3 upper contour (excluding corners).
    265,
    353,
    276,
    283,
    282,
    295,
    // Halo x4 upper contour (no lower because of mesh structure) or/ eyebrow inner contour.
    372,
    340,
    346,
    347,
    348,
    349,
    350,
    357,
    465,
    // Halo x5 lower contour.
    383,
    300,
    293,
    334,
    296,
    336,
    285,
    417
    // Halo x5 upper contour (excluding corners) or eyebrow outer contour.
  ];
  var localOptions;
  function drawLabels(f, ctx) {
    var _a22, _b2, _c22, _d22, _e, _f2, _g2, _h2, _i2;
    if (!localOptions.drawLabels || ((_a22 = localOptions.faceLabels) == null ? void 0 : _a22.length) === 0)
      return;
    let l = localOptions.faceLabels.slice();
    l = replace(l, "[id]", f.id.toFixed(0));
    if (f.score)
      l = replace(l, "[score]", 100 * f.score);
    if (f.gender)
      l = replace(l, "[gender]", f.gender);
    if (f.genderScore)
      l = replace(l, "[genderScore]", 100 * f.genderScore);
    if (f.age)
      l = replace(l, "[age]", f.age);
    if (f.distance)
      l = replace(l, "[distance]", 100 * f.distance);
    if (f.real)
      l = replace(l, "[real]", 100 * f.real);
    if (f.live)
      l = replace(l, "[live]", 100 * f.live);
    if (f.emotion && f.emotion.length > 0) {
      const emotion2 = f.emotion.map((a) => `${Math.trunc(100 * a.score)}% ${a.emotion}`);
      if (emotion2.length > 3)
        emotion2.length = 3;
      l = replace(l, "[emotions]", emotion2.join(" "));
    }
    if ((_c22 = (_b2 = f.rotation) == null ? void 0 : _b2.angle) == null ? void 0 : _c22.roll)
      l = replace(l, "[roll]", rad2deg(f.rotation.angle.roll));
    if ((_e = (_d22 = f.rotation) == null ? void 0 : _d22.angle) == null ? void 0 : _e.yaw)
      l = replace(l, "[yaw]", rad2deg(f.rotation.angle.yaw));
    if ((_g2 = (_f2 = f.rotation) == null ? void 0 : _f2.angle) == null ? void 0 : _g2.pitch)
      l = replace(l, "[pitch]", rad2deg(f.rotation.angle.pitch));
    if ((_i2 = (_h2 = f.rotation) == null ? void 0 : _h2.gaze) == null ? void 0 : _i2.bearing)
      l = replace(l, "[gaze]", rad2deg(f.rotation.gaze.bearing));
    labels(ctx, l, f.box[0], f.box[1], localOptions);
  }
  function drawIrisElipse(f, ctx) {
    var _a22, _b2, _c22, _d22;
    if (((_a22 = f.annotations) == null ? void 0 : _a22.leftEyeIris) && ((_b2 = f.annotations) == null ? void 0 : _b2.leftEyeIris[0])) {
      ctx.strokeStyle = localOptions.useDepth ? "rgba(255, 200, 255, 0.3)" : localOptions.color;
      ctx.beginPath();
      const sizeX = Math.abs(f.annotations.leftEyeIris[3][0] - f.annotations.leftEyeIris[1][0]) / 2;
      const sizeY = Math.abs(f.annotations.leftEyeIris[4][1] - f.annotations.leftEyeIris[2][1]) / 2;
      ctx.ellipse(f.annotations.leftEyeIris[0][0], f.annotations.leftEyeIris[0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
      ctx.stroke();
      if (localOptions.fillPolygons) {
        ctx.fillStyle = localOptions.useDepth ? "rgba(255, 255, 200, 0.3)" : localOptions.color;
        ctx.fill();
      }
    }
    if (((_c22 = f.annotations) == null ? void 0 : _c22.rightEyeIris) && ((_d22 = f.annotations) == null ? void 0 : _d22.rightEyeIris[0])) {
      ctx.strokeStyle = localOptions.useDepth ? "rgba(255, 200, 255, 0.3)" : localOptions.color;
      ctx.beginPath();
      const sizeX = Math.abs(f.annotations.rightEyeIris[3][0] - f.annotations.rightEyeIris[1][0]) / 2;
      const sizeY = Math.abs(f.annotations.rightEyeIris[4][1] - f.annotations.rightEyeIris[2][1]) / 2;
      ctx.ellipse(f.annotations.rightEyeIris[0][0], f.annotations.rightEyeIris[0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
      ctx.stroke();
      if (localOptions.fillPolygons) {
        ctx.fillStyle = localOptions.useDepth ? "rgba(255, 255, 200, 0.3)" : localOptions.color;
        ctx.fill();
      }
    }
  }
  function drawGazeSpheres(f, ctx) {
    var _a22;
    if (localOptions.drawGaze && ((_a22 = f.rotation) == null ? void 0 : _a22.angle) && typeof Path2D !== "undefined") {
      ctx.strokeStyle = "pink";
      const valX = f.box[0] + f.box[2] / 2 - f.box[3] * rad2deg(f.rotation.angle.yaw) / 90;
      const valY = f.box[1] + f.box[3] / 2 + f.box[2] * rad2deg(f.rotation.angle.pitch) / 90;
      const pathV = new Path2D(`
      M ${f.box[0] + f.box[2] / 2} ${f.box[1]}
      C
        ${valX} ${f.box[1]},
        ${valX} ${f.box[1] + f.box[3]},
        ${f.box[0] + f.box[2] / 2} ${f.box[1] + f.box[3]}
    `);
      const pathH = new Path2D(`
      M ${f.box[0]} ${f.box[1] + f.box[3] / 2}
      C 
        ${f.box[0]} ${valY},
        ${f.box[0] + f.box[2]} ${valY},
        ${f.box[0] + f.box[2]} ${f.box[1] + f.box[3] / 2}
    `);
      ctx.stroke(pathH);
      ctx.stroke(pathV);
    }
  }
  function drawGazeArrows(f, ctx) {
    var _a22;
    if (localOptions.drawGaze && ((_a22 = f.rotation) == null ? void 0 : _a22.gaze.strength) && f.rotation.gaze.bearing && f.annotations.leftEyeIris && f.annotations.rightEyeIris && f.annotations.leftEyeIris[0] && f.annotations.rightEyeIris[0]) {
      ctx.strokeStyle = "pink";
      ctx.fillStyle = "pink";
      const leftGaze = [
        f.annotations.leftEyeIris[0][0] + Math.sin(f.rotation.gaze.bearing) * f.rotation.gaze.strength * f.box[3],
        f.annotations.leftEyeIris[0][1] + Math.cos(f.rotation.gaze.bearing) * f.rotation.gaze.strength * f.box[2]
      ];
      arrow(ctx, [f.annotations.leftEyeIris[0][0], f.annotations.leftEyeIris[0][1]], [leftGaze[0], leftGaze[1]], 4);
      const rightGaze = [
        f.annotations.rightEyeIris[0][0] + Math.sin(f.rotation.gaze.bearing) * f.rotation.gaze.strength * f.box[3],
        f.annotations.rightEyeIris[0][1] + Math.cos(f.rotation.gaze.bearing) * f.rotation.gaze.strength * f.box[2]
      ];
      arrow(ctx, [f.annotations.rightEyeIris[0][0], f.annotations.rightEyeIris[0][1]], [rightGaze[0], rightGaze[1]], 4);
    }
  }
  function drawFacePolygons(f, ctx) {
    if (localOptions.drawPolygons && f.mesh.length >= 468) {
      ctx.lineWidth = 1;
      for (let i10 = 0; i10 < TRI468.length / 3; i10++) {
        const points = [TRI468[i10 * 3 + 0], TRI468[i10 * 3 + 1], TRI468[i10 * 3 + 2]].map((index2) => f.mesh[index2]);
        lines(ctx, points, localOptions);
      }
      drawIrisElipse(f, ctx);
    }
  }
  function drawFacePoints(f, ctx) {
    if (localOptions.drawPoints) {
      if ((f == null ? void 0 : f.mesh.length) >= 468) {
        for (let i10 = 0; i10 < f.mesh.length; i10++) {
          point(ctx, f.mesh[i10][0], f.mesh[i10][1], f.mesh[i10][2], localOptions);
          if (localOptions.drawAttention) {
            if (LANDMARKS_REFINEMENT_LIPS_CONFIG.includes(i10))
              point(ctx, f.mesh[i10][0], f.mesh[i10][1], f.mesh[i10][2] + 127, localOptions);
            if (LANDMARKS_REFINEMENT_LEFT_EYE_CONFIG.includes(i10))
              point(ctx, f.mesh[i10][0], f.mesh[i10][1], f.mesh[i10][2] - 127, localOptions);
            if (LANDMARKS_REFINEMENT_RIGHT_EYE_CONFIG.includes(i10))
              point(ctx, f.mesh[i10][0], f.mesh[i10][1], f.mesh[i10][2] - 127, localOptions);
          }
        }
      } else {
        for (const [k, v10] of Object.entries((f == null ? void 0 : f.annotations) || {})) {
          if (!(v10 == null ? void 0 : v10[0]))
            continue;
          const pt2 = v10[0];
          point(ctx, pt2[0], pt2[1], 0, localOptions);
          if (localOptions.drawLabels)
            labels(ctx, k, pt2[0], pt2[1], localOptions);
        }
      }
    }
  }
  function drawFaceBoxes(f, ctx) {
    if (localOptions.drawBoxes) {
      rect(ctx, f.box[0], f.box[1], f.box[2], f.box[3], localOptions);
    }
  }
  function face(inCanvas2, result, drawOptions2) {
    localOptions = mergeDeep(options2, drawOptions2);
    if (!result || !inCanvas2)
      return;
    const ctx = getCanvasContext(inCanvas2);
    if (!ctx)
      return;
    ctx.font = localOptions.font;
    ctx.strokeStyle = localOptions.color;
    ctx.fillStyle = localOptions.color;
    for (const f of result) {
      drawFaceBoxes(f, ctx);
      drawLabels(f, ctx);
      if (f.mesh && f.mesh.length > 0) {
        drawFacePoints(f, ctx);
        drawFacePolygons(f, ctx);
        drawGazeSpheres(f, ctx);
        drawGazeArrows(f, ctx);
      }
    }
  }
  function body(inCanvas2, result, drawOptions2) {
    var _a22, _b2;
    const localOptions2 = mergeDeep(options2, drawOptions2);
    if (!result || !inCanvas2)
      return;
    const ctx = getCanvasContext(inCanvas2);
    if (!ctx)
      return;
    ctx.lineJoin = "round";
    for (let i10 = 0; i10 < result.length; i10++) {
      ctx.strokeStyle = localOptions2.color;
      ctx.fillStyle = localOptions2.color;
      ctx.lineWidth = localOptions2.lineWidth;
      ctx.font = localOptions2.font;
      if (localOptions2.drawBoxes && result[i10].box && result[i10].box.length === 4) {
        rect(ctx, result[i10].box[0], result[i10].box[1], result[i10].box[2], result[i10].box[3], localOptions2);
        if (localOptions2.drawLabels && ((_a22 = localOptions2.bodyLabels) == null ? void 0 : _a22.length) > 0) {
          let l = localOptions2.bodyLabels.slice();
          l = replace(l, "[id]", result[i10].id.toFixed(0));
          l = replace(l, "[score]", 100 * result[i10].score);
          labels(ctx, l, result[i10].box[0], result[i10].box[1], localOptions2);
        }
      }
      if (localOptions2.drawPoints && result[i10].keypoints) {
        for (let pt2 = 0; pt2 < result[i10].keypoints.length; pt2++) {
          if (!result[i10].keypoints[pt2].score || result[i10].keypoints[pt2].score === 0)
            continue;
          ctx.fillStyle = colorDepth(result[i10].keypoints[pt2].position[2], localOptions2);
          point(ctx, result[i10].keypoints[pt2].position[0], result[i10].keypoints[pt2].position[1], 0, localOptions2);
        }
      }
      if (localOptions2.drawLabels && ((_b2 = localOptions2.bodyPartLabels) == null ? void 0 : _b2.length) > 0 && result[i10].keypoints) {
        ctx.font = localOptions2.font;
        for (const pt2 of result[i10].keypoints) {
          if (!pt2.score || pt2.score === 0)
            continue;
          let l = localOptions2.bodyPartLabels.slice();
          l = replace(l, "[label]", pt2.part);
          l = replace(l, "[score]", 100 * pt2.score);
          labels(ctx, l, pt2.position[0], pt2.position[1], localOptions2);
        }
      }
      if (localOptions2.drawPolygons && result[i10].keypoints && result[i10].annotations) {
        for (const part of Object.values(result[i10].annotations)) {
          for (const connected4 of part)
            curves(ctx, connected4, localOptions2);
        }
      }
    }
  }
  function hand(inCanvas2, result, drawOptions2) {
    var _a22, _b2;
    const localOptions2 = mergeDeep(options2, drawOptions2);
    if (!result || !inCanvas2)
      return;
    const ctx = getCanvasContext(inCanvas2);
    if (!ctx)
      return;
    ctx.lineJoin = "round";
    ctx.font = localOptions2.font;
    for (const h of result) {
      if (localOptions2.drawBoxes) {
        ctx.strokeStyle = localOptions2.color;
        ctx.fillStyle = localOptions2.color;
        rect(ctx, h.box[0], h.box[1], h.box[2], h.box[3], localOptions2);
        if (localOptions2.drawLabels && ((_a22 = localOptions2.handLabels) == null ? void 0 : _a22.length) > 0) {
          let l = localOptions2.handLabels.slice();
          l = replace(l, "[id]", h.id.toFixed(0));
          l = replace(l, "[label]", h.label);
          l = replace(l, "[score]", 100 * h.score);
          labels(ctx, l, h.box[0], h.box[1], localOptions2);
        }
        ctx.stroke();
      }
      if (localOptions2.drawPoints) {
        if (h.keypoints && h.keypoints.length > 0) {
          for (const pt2 of h.keypoints) {
            ctx.fillStyle = colorDepth(pt2[2], localOptions2);
            point(ctx, pt2[0], pt2[1], 0, localOptions2);
          }
        }
      }
      if (localOptions2.drawLabels && h.annotations && ((_b2 = localOptions2.fingerLabels) == null ? void 0 : _b2.length) > 0) {
        for (const [part, pt2] of Object.entries(h.annotations)) {
          let l = localOptions2.fingerLabels.slice();
          l = replace(l, "[label]", part);
          labels(ctx, l, pt2[pt2.length - 1][0], pt2[pt2.length - 1][1], localOptions2);
        }
      }
      if (localOptions2.drawPolygons && h.annotations) {
        const addHandLine = (part) => {
          if (!part || part.length === 0 || !part[0])
            return;
          for (let i10 = 0; i10 < part.length; i10++) {
            ctx.beginPath();
            const z = part[i10][2] || 0;
            ctx.strokeStyle = colorDepth(i10 * z, localOptions2);
            ctx.moveTo(part[i10 > 0 ? i10 - 1 : 0][0], part[i10 > 0 ? i10 - 1 : 0][1]);
            ctx.lineTo(part[i10][0], part[i10][1]);
            ctx.stroke();
          }
        };
        ctx.lineWidth = localOptions2.lineWidth;
        addHandLine(h.annotations.index);
        addHandLine(h.annotations.middle);
        addHandLine(h.annotations.ring);
        addHandLine(h.annotations.pinky);
        addHandLine(h.annotations.thumb);
      }
    }
  }
  function object(inCanvas2, result, drawOptions2) {
    var _a22;
    const localOptions2 = mergeDeep(options2, drawOptions2);
    if (!result || !inCanvas2)
      return;
    const ctx = getCanvasContext(inCanvas2);
    if (!ctx)
      return;
    ctx.lineJoin = "round";
    ctx.font = localOptions2.font;
    for (const h of result) {
      if (localOptions2.drawBoxes) {
        ctx.strokeStyle = localOptions2.color;
        ctx.fillStyle = localOptions2.color;
        rect(ctx, h.box[0], h.box[1], h.box[2], h.box[3], localOptions2);
        if (localOptions2.drawLabels && ((_a22 = localOptions2.objectLabels) == null ? void 0 : _a22.length) > 0) {
          let l = localOptions2.objectLabels.slice();
          l = replace(l, "[id]", h.id.toFixed(0));
          l = replace(l, "[label]", h.label);
          l = replace(l, "[score]", 100 * h.score);
          labels(ctx, l, h.box[0], h.box[1], localOptions2);
        }
        ctx.stroke();
      }
    }
  }
  function gesture(inCanvas2, result, drawOptions2) {
    var _a22;
    const localOptions2 = mergeDeep(options2, drawOptions2);
    if (!result || !inCanvas2)
      return;
    if (localOptions2.drawGestures && ((_a22 = localOptions2.gestureLabels) == null ? void 0 : _a22.length) > 0) {
      const ctx = getCanvasContext(inCanvas2);
      if (!ctx)
        return;
      ctx.font = localOptions2.font;
      ctx.fillStyle = localOptions2.color;
      let i10 = 1;
      for (let j = 0; j < result.length; j++) {
        const [where, what] = Object.entries(result[j]);
        if (what.length > 1 && what[1].length > 0) {
          const who = where[1] > 0 ? `#${where[1]}` : "";
          let l = localOptions2.gestureLabels.slice();
          l = replace(l, "[where]", where[0]);
          l = replace(l, "[who]", who);
          l = replace(l, "[what]", what[1]);
          labels(ctx, l, 8, 2 + i10 * localOptions2.lineHeight, localOptions2);
          i10 += 1;
        }
      }
    }
  }
  var defaultLabels = {
    face: `face
    confidence: [score]%
    [gender] [genderScore]%
    age: [age] years
    distance: [distance]cm
    real: [real]%
    live: [live]%
    [emotions]
    roll: [roll]° yaw:[yaw]° pitch:[pitch]°
    gaze: [gaze]°`,
    body: "body [score]%",
    bodyPart: "[label] [score]%",
    object: "[label] [score]%",
    hand: "[label] [score]%",
    finger: "[label]",
    gesture: "[where] [who]: [what]"
  };
  var drawTime = 0;
  function person(inCanvas2, result, drawOptions2) {
    const localOptions2 = mergeDeep(options2, drawOptions2);
    if (!result || !inCanvas2)
      return;
    const ctx = getCanvasContext(inCanvas2);
    if (!ctx)
      return;
    ctx.lineJoin = "round";
    ctx.font = localOptions2.font;
    for (let i10 = 0; i10 < result.length; i10++) {
      if (localOptions2.drawBoxes) {
        ctx.strokeStyle = localOptions2.color;
        ctx.fillStyle = localOptions2.color;
        rect(ctx, result[i10].box[0], result[i10].box[1], result[i10].box[2], result[i10].box[3], localOptions2);
        if (localOptions2.drawLabels) {
          const label = `person #${i10}`;
          if (localOptions2.shadowColor && localOptions2.shadowColor !== "") {
            ctx.fillStyle = localOptions2.shadowColor;
            ctx.fillText(label, result[i10].box[0] + 3, 1 + result[i10].box[1] + localOptions2.lineHeight, result[i10].box[2]);
          }
          ctx.fillStyle = localOptions2.labelColor;
          ctx.fillText(label, result[i10].box[0] + 2, 0 + result[i10].box[1] + localOptions2.lineHeight, result[i10].box[2]);
        }
        ctx.stroke();
      }
    }
  }
  function canvas2(input, output) {
    if (!input || !output)
      return;
    const ctx = getCanvasContext(output);
    if (!ctx)
      return;
    ctx.drawImage(input, 0, 0);
  }
  async function all(inCanvas2, result, drawOptions2) {
    if (!(result == null ? void 0 : result.performance) || !inCanvas2)
      return null;
    const timeStamp = now();
    const localOptions2 = mergeDeep(options2, drawOptions2);
    const promise = Promise.all([
      face(inCanvas2, result.face, localOptions2),
      body(inCanvas2, result.body, localOptions2),
      hand(inCanvas2, result.hand, localOptions2),
      object(inCanvas2, result.object, localOptions2),
      gesture(inCanvas2, result.gesture, localOptions2)
      // gestures do not have buffering
      // person(inCanvas, result.persons, localOptions); // already included above
    ]);
    drawTime = env.perfadd ? drawTime + Math.round(now() - timeStamp) : Math.round(now() - timeStamp);
    result.performance.draw = drawTime;
    return promise;
  }
  function init2() {
    options2.faceLabels = defaultLabels.face;
    options2.bodyLabels = defaultLabels.body;
    options2.bodyPartLabels = defaultLabels.bodyPart;
    options2.handLabels = defaultLabels.hand;
    options2.fingerLabels = defaultLabels.finger;
    options2.objectLabels = defaultLabels.object;
    options2.gestureLabels = defaultLabels.gesture;
  }
  var blazeposecoords_exports = {};
  __export(blazeposecoords_exports, {
    connected: () => connected,
    kpt: () => kpt
  });
  var kpt = [
    "nose",
    //  0
    "leftEyeInside",
    //  1
    "leftEye",
    //  2
    "leftEyeOutside",
    //  3
    "rightEyeInside",
    //  4
    "rightEye",
    //  5
    "rightEyeOutside",
    //  6
    "leftEar",
    //  7
    "rightEar",
    //  8
    "leftMouth",
    //  9
    "rightMouth",
    // 10
    "leftShoulder",
    // 11
    "rightShoulder",
    // 12
    "leftElbow",
    // 13
    "rightElbow",
    // 14
    "leftWrist",
    // 15
    "rightWrist",
    // 16
    "leftPinky",
    // 17
    "rightPinky",
    // 18
    "leftIndex",
    // 19
    "rightIndex",
    // 20
    "leftThumb",
    // 21
    "rightThumb",
    // 22
    "leftHip",
    // 23
    "rightHip",
    // 24
    "leftKnee",
    // 25
    "rightKnee",
    // 26
    "leftAnkle",
    // 27
    "rightAnkle",
    // 28
    "leftHeel",
    // 29
    "rightHeel",
    // 30
    "leftFoot",
    // 31
    "rightFoot",
    // 32
    "bodyCenter",
    // 33
    "bodyTop",
    // 34
    "leftPalm",
    // 35 // z-coord not ok
    "leftHand",
    // 36 // similar to wrist but z-coord not ok
    "rightPalm",
    // 37 // z-coord not ok
    "rightHand"
    // 38 // similar to wrist but z-coord not ok
  ];
  var connected = {
    shoulders: ["leftShoulder", "rightShoulder"],
    hips: ["rightHip", "leftHip"],
    mouth: ["leftMouth", "rightMouth"],
    leftLegUpper: ["leftHip", "leftKnee"],
    leftLegLower: ["leftKnee", "leftAnkle"],
    leftFoot: ["leftAnkle", "leftHeel", "leftFoot"],
    leftTorso: ["leftShoulder", "leftHip"],
    leftArmUpper: ["leftShoulder", "leftElbow"],
    leftArmLower: ["leftElbow", "leftWrist"],
    leftHand: ["leftWrist", "leftPalm"],
    leftHandPinky: ["leftPalm", "leftPinky"],
    leftHandIndex: ["leftPalm", "leftIndex"],
    leftHandThumb: ["leftPalm", "leftThumb"],
    leftEyeOutline: ["leftEyeInside", "leftEyeOutside"],
    rightLegUpper: ["rightHip", "rightKnee"],
    rightLegLower: ["rightKnee", "rightAnkle"],
    rightFoot: ["rightAnkle", "rightHeel", "rightFoot"],
    rightTorso: ["rightShoulder", "rightHip"],
    rightArmUpper: ["rightShoulder", "rightElbow"],
    rightArmLower: ["rightElbow", "rightWrist"],
    rightHand: ["rightWrist", "rightPalm"],
    rightHandPinky: ["rightPalm", "rightPinky"],
    rightHandIndex: ["rightPalm", "rightIndex"],
    rightHandThumb: ["rightPalm", "rightThumb"],
    rightEyeOutline: ["rightEyeInside", "rightEyeOutside"]
  };
  var model;
  var inputSize = 224;
  var anchorTensor;
  var numLayers = 5;
  var strides = [8, 16, 32, 32, 32];
  function createAnchors() {
    const anchors3 = [];
    let layerId = 0;
    while (layerId < numLayers) {
      let anchorCount = 0;
      let lastSameStrideLayer = layerId;
      while (lastSameStrideLayer < strides.length && strides[lastSameStrideLayer] === strides[layerId]) {
        anchorCount += 2;
        lastSameStrideLayer++;
      }
      const stride = strides[layerId];
      const featureMapHeight = Math.ceil(inputSize / stride);
      const featureMapWidth = Math.ceil(inputSize / stride);
      for (let y10 = 0; y10 < featureMapHeight; ++y10) {
        for (let x = 0; x < featureMapWidth; ++x) {
          for (let anchorId = 0; anchorId < anchorCount; ++anchorId) {
            anchors3.push({ x: (x + 0.5) / featureMapWidth, y: (y10 + 0.5) / featureMapHeight });
          }
        }
      }
      layerId = lastSameStrideLayer;
    }
    anchorTensor = { x: xr(anchors3.map((a) => a.x)), y: xr(anchors3.map((a) => a.y)) };
  }
  async function loadDetector(config3) {
    if (env.initial)
      model = null;
    if (!model && config3.body["detector"] && config3.body["detector"].modelPath || "") {
      model = await loadModel(config3.body["detector"].modelPath);
      const inputs = (model == null ? void 0 : model["executor"]) ? Object.values(model.modelSignature["inputs"]) : void 0;
      inputSize = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    } else if (config3.debug && model)
      log$1("cached model:", model["modelUrl"]);
    createAnchors();
    return model;
  }
  var cropFactor = [5, 5];
  function decodeBoxes(boxesTensor, anchor) {
    return De(() => {
      const split = pi(boxesTensor, 12, 1);
      let xCenter = mc(split[0]);
      let yCenter = mc(split[1]);
      let width = mc(split[2]);
      let height = mc(split[3]);
      xCenter = Ce(je(xCenter, inputSize), anchor.x);
      yCenter = Ce(je(yCenter, inputSize), anchor.y);
      width = se(je(width, inputSize), cropFactor[0]);
      height = se(je(height, inputSize), cropFactor[1]);
      const xMin = Te(xCenter, je(width, 2));
      const yMin = Te(yCenter, je(height, 2));
      const xMax = Ce(xMin, width);
      const yMax = Ce(yMin, height);
      const boxes = kr([xMin, yMin, xMax, yMax], 1);
      return boxes;
    });
  }
  async function decodeResults(boxesTensor, logitsTensor, config3, outputSize2) {
    var _a22, _b2;
    const detectedBoxes = [];
    const t8 = {};
    t8.boxes = decodeBoxes(boxesTensor, anchorTensor);
    t8.scores = Na(logitsTensor);
    t8.nms = await Fj.nonMaxSuppressionAsync(t8.boxes, t8.scores, 1, ((_a22 = config3.body["detector"]) == null ? void 0 : _a22.minConfidence) || 0.1, ((_b2 = config3.body["detector"]) == null ? void 0 : _b2.iouThreshold) || 0.1);
    const nms = await t8.nms.data();
    const scores = await t8.scores.data();
    const boxes = await t8.boxes.array();
    for (const i10 of Array.from(nms)) {
      const score = scores[i10];
      const boxRaw = boxes[i10];
      const box = [Math.round(boxRaw[0] * outputSize2[0]), Math.round(boxRaw[1] * outputSize2[1]), Math.round(boxRaw[2] * outputSize2[0]), Math.round(boxRaw[3] * outputSize2[1])];
      const detectedBox = { score, boxRaw, box };
      detectedBoxes.push(detectedBox);
    }
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return detectedBoxes;
  }
  async function detectBoxes(input, config3, outputSize2) {
    const t8 = {};
    t8.res = model == null ? void 0 : model.execute(input, ["Identity"]);
    t8.logitsRaw = Xe(t8.res, [0, 0, 0], [1, -1, 1]);
    t8.boxesRaw = Xe(t8.res, [0, 0, 1], [1, -1, -1]);
    t8.logits = mc(t8.logitsRaw);
    t8.boxes = mc(t8.boxesRaw);
    const boxes = await decodeResults(t8.boxes, t8.logits, config3, outputSize2);
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return boxes;
  }
  function calc(keypoints, outputSize2 = [1, 1]) {
    const coords = [keypoints.map((pt2) => pt2[0]), keypoints.map((pt2) => pt2[1])];
    const min = [Math.min(...coords[0]), Math.min(...coords[1])];
    const max = [Math.max(...coords[0]), Math.max(...coords[1])];
    const box = [min[0], min[1], max[0] - min[0], max[1] - min[1]];
    const boxRaw = [box[0] / outputSize2[0], box[1] / outputSize2[1], box[2] / outputSize2[0], box[3] / outputSize2[1]];
    return { box, boxRaw };
  }
  function square(keypoints, outputSize2 = [1, 1]) {
    const coords = [keypoints.map((pt2) => pt2[0]), keypoints.map((pt2) => pt2[1])];
    const min = [Math.min(...coords[0]), Math.min(...coords[1])];
    const max = [Math.max(...coords[0]), Math.max(...coords[1])];
    const center = [(min[0] + max[0]) / 2, (min[1] + max[1]) / 2];
    const dist = Math.max(center[0] - min[0], center[1] - min[1], -center[0] + max[0], -center[1] + max[1]);
    const box = [Math.trunc(center[0] - dist), Math.trunc(center[1] - dist), Math.trunc(2 * dist), Math.trunc(2 * dist)];
    const boxRaw = [box[0] / outputSize2[0], box[1] / outputSize2[1], box[2] / outputSize2[0], box[3] / outputSize2[1]];
    return { box, boxRaw };
  }
  function scale(box, scaleFact) {
    const dist = [box[2] * scaleFact, box[3] * scaleFact];
    const newBox = [
      box[0] - (dist[0] - box[2]) / 2,
      box[1] - (dist[1] - box[3]) / 2,
      dist[0],
      dist[1]
    ];
    return newBox;
  }
  var model2;
  var inputSize2 = 256;
  var skipped = Number.MAX_SAFE_INTEGER;
  var outputNodes = {
    landmarks: ["ld_3d", "activation_segmentation", "activation_heatmap", "world_3d", "output_poseflag"],
    detector: []
  };
  var cache = [];
  var padding = [[0, 0], [0, 0], [0, 0], [0, 0]];
  var lastTime = 0;
  var sigmoid = (x) => 1 - 1 / (1 + Math.exp(x));
  var loadDetect = (config3) => loadDetector(config3);
  async function loadPose(config3) {
    if (env.initial)
      model2 = null;
    if (!model2) {
      model2 = await loadModel(config3.body.modelPath);
      const inputs = (model2 == null ? void 0 : model2["executor"]) ? Object.values(model2.modelSignature["inputs"]) : void 0;
      inputSize2 = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
    } else if (config3.debug)
      log$1("cached model:", model2["modelUrl"]);
    return model2;
  }
  function prepareImage(input, size2, cropBox) {
    var _a22, _b2;
    const t8 = {};
    if (!((_a22 = input == null ? void 0 : input.shape) == null ? void 0 : _a22[1]) || !((_b2 = input == null ? void 0 : input.shape) == null ? void 0 : _b2[2]))
      return input;
    let final;
    if (cropBox) {
      t8.cropped = Fj.cropAndResize(input, [cropBox], [0], [input.shape[1], input.shape[2]]);
    }
    if (input.shape[1] !== input.shape[2]) {
      const height = [
        input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0,
        input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0
      ];
      const width = [
        input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0,
        input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0
      ];
      padding = [
        [0, 0],
        // dont touch batch
        height,
        // height before&after
        width,
        // width before&after
        [0, 0]
        // dont touch rbg
      ];
      t8.pad = Ea(t8.cropped || input, padding);
      t8.resize = Fj.resizeBilinear(t8.pad, [size2, size2]);
      final = je(t8.resize, constants.tf255);
    } else if (input.shape[1] !== size2) {
      t8.resize = Fj.resizeBilinear(t8.cropped || input, [size2, size2]);
      final = je(t8.resize, constants.tf255);
    } else {
      final = je(t8.cropped || input, constants.tf255);
    }
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return final;
  }
  function rescaleKeypoints(keypoints, outputSize2, cropBox) {
    for (const kpt4 of keypoints) {
      kpt4.position = [
        Math.trunc(kpt4.position[0] * (outputSize2[0] + padding[2][0] + padding[2][1]) / outputSize2[0] - padding[2][0]),
        Math.trunc(kpt4.position[1] * (outputSize2[1] + padding[1][0] + padding[1][1]) / outputSize2[1] - padding[1][0]),
        kpt4.position[2]
      ];
      kpt4.positionRaw = [kpt4.position[0] / outputSize2[0], kpt4.position[1] / outputSize2[1], 2 * kpt4.position[2] / (outputSize2[0] + outputSize2[1])];
    }
    if (cropBox) {
      const width = cropBox[2] - cropBox[0];
      const height = cropBox[3] - cropBox[1];
      for (const kpt4 of keypoints) {
        kpt4.positionRaw = [
          kpt4.positionRaw[0] / height + cropBox[1],
          // correct offset due to crop
          kpt4.positionRaw[1] / width + cropBox[0],
          // correct offset due to crop
          kpt4.positionRaw[2]
        ];
        kpt4.position = [
          Math.trunc(kpt4.positionRaw[0] * outputSize2[0]),
          Math.trunc(kpt4.positionRaw[1] * outputSize2[1]),
          kpt4.positionRaw[2]
        ];
      }
    }
    return keypoints;
  }
  function fixKeypoints(keypoints) {
    const leftPalm = keypoints.find((k) => k.part === "leftPalm");
    const leftWrist = keypoints.find((k) => k.part === "leftWrist");
    const leftIndex = keypoints.find((k) => k.part === "leftIndex");
    leftPalm.position[2] = ((leftWrist.position[2] || 0) + (leftIndex.position[2] || 0)) / 2;
    const rightPalm = keypoints.find((k) => k.part === "rightPalm");
    const rightWrist = keypoints.find((k) => k.part === "rightWrist");
    const rightIndex = keypoints.find((k) => k.part === "rightIndex");
    rightPalm.position[2] = ((rightWrist.position[2] || 0) + (rightIndex.position[2] || 0)) / 2;
  }
  async function detectLandmarks(input, config3, outputSize2) {
    if (!(model2 == null ? void 0 : model2["executor"]))
      return null;
    const t8 = {};
    [
      t8.ld,
      t8.segmentation,
      t8.heatmap,
      t8.world,
      t8.poseflag
      /* 1,1 */
    ] = model2 == null ? void 0 : model2.execute(input, outputNodes.landmarks);
    const poseScore = (await t8.poseflag.data())[0];
    const points = await t8.ld.data();
    const distances = await t8.world.data();
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    const keypointsRelative = [];
    const depth = 5;
    for (let i10 = 0; i10 < points.length / depth; i10++) {
      const score = sigmoid(points[depth * i10 + 3]);
      const presence = sigmoid(points[depth * i10 + 4]);
      const adjScore = Math.trunc(100 * score * presence * poseScore) / 100;
      const positionRaw = [points[depth * i10 + 0] / inputSize2, points[depth * i10 + 1] / inputSize2, points[depth * i10 + 2] + 0];
      const position = [Math.trunc(outputSize2[0] * positionRaw[0]), Math.trunc(outputSize2[1] * positionRaw[1]), positionRaw[2]];
      const distance2 = [distances[depth * i10 + 0], distances[depth * i10 + 1], distances[depth * i10 + 2] + 0];
      keypointsRelative.push({ part: kpt[i10], positionRaw, position, distance: distance2, score: adjScore });
    }
    if (poseScore < (config3.body.minConfidence || 0))
      return null;
    fixKeypoints(keypointsRelative);
    const keypoints = rescaleKeypoints(keypointsRelative, outputSize2);
    const kpts = keypoints.map((k) => k.position);
    const boxes = calc(kpts, [outputSize2[0], outputSize2[1]]);
    const annotations2 = {};
    for (const [name2, indexes] of Object.entries(connected)) {
      const pt2 = [];
      for (let i10 = 0; i10 < indexes.length - 1; i10++) {
        const pt0 = keypoints.find((kpt4) => kpt4.part === indexes[i10]);
        const pt1 = keypoints.find((kpt4) => kpt4.part === indexes[i10 + 1]);
        if (pt0 && pt1)
          pt2.push([pt0.position, pt1.position]);
      }
      annotations2[name2] = pt2;
    }
    const body4 = { id: 0, score: Math.trunc(100 * poseScore) / 100, box: boxes.box, boxRaw: boxes.boxRaw, keypoints, annotations: annotations2 };
    return body4;
  }
  async function predict(input, config3) {
    var _a22, _b2, _c22;
    const outputSize2 = [input.shape[2] || 0, input.shape[1] || 0];
    const skipTime = (config3.body.skipTime || 0) > now() - lastTime;
    const skipFrame = skipped < (config3.body.skipFrames || 0);
    if (config3.skipAllowed && skipTime && skipFrame && cache !== null) {
      skipped++;
    } else {
      let boxes = [];
      if ((_b2 = (_a22 = config3.body) == null ? void 0 : _a22["detector"]) == null ? void 0 : _b2["enabled"]) {
        const preparedImage = prepareImage(input, 224);
        boxes = await detectBoxes(preparedImage, config3, outputSize2);
        Ot(preparedImage);
      } else {
        boxes = [{ box: [0, 0, 0, 0], boxRaw: [0, 0, 1, 1], score: 0 }];
      }
      for (let i10 = 0; i10 < boxes.length; i10++) {
        const preparedBox = prepareImage(input, 256, (_c22 = boxes[i10]) == null ? void 0 : _c22.boxRaw);
        cache.length = 0;
        const bodyResult = await detectLandmarks(preparedBox, config3, outputSize2);
        Ot(preparedBox);
        if (!bodyResult)
          continue;
        bodyResult.id = i10;
        cache.push(bodyResult);
      }
      lastTime = now();
      skipped = 0;
    }
    return cache;
  }
  var labels2 = [
    { class: 1, label: "person" },
    { class: 2, label: "bicycle" },
    { class: 3, label: "car" },
    { class: 4, label: "motorcycle" },
    { class: 5, label: "airplane" },
    { class: 6, label: "bus" },
    { class: 7, label: "train" },
    { class: 8, label: "truck" },
    { class: 9, label: "boat" },
    { class: 10, label: "traffic light" },
    { class: 11, label: "fire hydrant" },
    { class: 12, label: "stop sign" },
    { class: 13, label: "parking meter" },
    { class: 14, label: "bench" },
    { class: 15, label: "bird" },
    { class: 16, label: "cat" },
    { class: 17, label: "dog" },
    { class: 18, label: "horse" },
    { class: 19, label: "sheep" },
    { class: 20, label: "cow" },
    { class: 21, label: "elephant" },
    { class: 22, label: "bear" },
    { class: 23, label: "zebra" },
    { class: 24, label: "giraffe" },
    { class: 25, label: "backpack" },
    { class: 26, label: "umbrella" },
    { class: 27, label: "handbag" },
    { class: 28, label: "tie" },
    { class: 29, label: "suitcase" },
    { class: 30, label: "frisbee" },
    { class: 31, label: "skis" },
    { class: 32, label: "snowboard" },
    { class: 33, label: "sports ball" },
    { class: 34, label: "kite" },
    { class: 35, label: "baseball bat" },
    { class: 36, label: "baseball glove" },
    { class: 37, label: "skateboard" },
    { class: 38, label: "surfboard" },
    { class: 39, label: "tennis racket" },
    { class: 40, label: "bottle" },
    { class: 41, label: "wine glass" },
    { class: 42, label: "cup" },
    { class: 43, label: "fork" },
    { class: 44, label: "knife" },
    { class: 45, label: "spoon" },
    { class: 46, label: "bowl" },
    { class: 47, label: "banana" },
    { class: 48, label: "apple" },
    { class: 49, label: "sandwich" },
    { class: 50, label: "orange" },
    { class: 51, label: "broccoli" },
    { class: 52, label: "carrot" },
    { class: 53, label: "hot dog" },
    { class: 54, label: "pizza" },
    { class: 55, label: "donut" },
    { class: 56, label: "cake" },
    { class: 57, label: "chair" },
    { class: 58, label: "couch" },
    { class: 59, label: "potted plant" },
    { class: 60, label: "bed" },
    { class: 61, label: "dining table" },
    { class: 62, label: "toilet" },
    { class: 63, label: "tv" },
    { class: 64, label: "laptop" },
    { class: 65, label: "mouse" },
    { class: 66, label: "remote" },
    { class: 67, label: "keyboard" },
    { class: 68, label: "cell phone" },
    { class: 69, label: "microwave" },
    { class: 70, label: "oven" },
    { class: 71, label: "toaster" },
    { class: 72, label: "sink" },
    { class: 73, label: "refrigerator" },
    { class: 74, label: "book" },
    { class: 75, label: "clock" },
    { class: 76, label: "vase" },
    { class: 77, label: "scissors" },
    { class: 78, label: "teddy bear" },
    { class: 79, label: "hair drier" },
    { class: 80, label: "toothbrush" }
  ];
  var model3;
  var inputSize3 = 0;
  var last2 = [];
  var lastTime2 = 0;
  var skipped2 = Number.MAX_SAFE_INTEGER;
  async function load(config3) {
    if (env.initial)
      model3 = null;
    if (!model3) {
      model3 = await loadModel(config3.object.modelPath);
      const inputs = (model3 == null ? void 0 : model3["executor"]) ? Object.values(model3.modelSignature["inputs"]) : void 0;
      inputSize3 = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    } else if (config3.debug)
      log$1("cached model:", model3["modelUrl"]);
    return model3;
  }
  async function process3(res, outputShape, config3) {
    if (!res)
      return [];
    const t8 = {};
    const results = [];
    const detections = await res.array();
    t8.squeeze = mc(res);
    const arr = pi(t8.squeeze, 6, 1);
    t8.stack = kr([arr[1], arr[0], arr[3], arr[2]], 1);
    t8.boxes = mc(t8.stack);
    t8.scores = mc(arr[4]);
    t8.classes = mc(arr[5]);
    Ot([res, ...arr]);
    t8.nms = await Fj.nonMaxSuppressionAsync(t8.boxes, t8.scores, config3.object.maxDetected || 0, config3.object.iouThreshold, config3.object.minConfidence || 0);
    const nms = await t8.nms.data();
    let i10 = 0;
    for (const id2 of Array.from(nms)) {
      const score = Math.trunc(100 * detections[0][id2][4]) / 100;
      const classVal = detections[0][id2][5];
      if (Number.isNaN(classVal))
        continue;
      const label = labels2[classVal].label;
      const [x, y10] = [
        detections[0][id2][0] / inputSize3,
        detections[0][id2][1] / inputSize3
      ];
      const boxRaw = [
        x,
        y10,
        detections[0][id2][2] / inputSize3 - x,
        detections[0][id2][3] / inputSize3 - y10
      ];
      const box = [
        Math.trunc(boxRaw[0] * outputShape[0]),
        Math.trunc(boxRaw[1] * outputShape[1]),
        Math.trunc(boxRaw[2] * outputShape[0]),
        Math.trunc(boxRaw[3] * outputShape[1])
      ];
      results.push({ id: i10++, score, class: classVal, label, box, boxRaw });
    }
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return results;
  }
  async function predict2(input, config3) {
    if (!(model3 == null ? void 0 : model3["executor"]))
      return [];
    const skipTime = (config3.object.skipTime || 0) > now() - lastTime2;
    const skipFrame = skipped2 < (config3.object.skipFrames || 0);
    if (config3.skipAllowed && skipTime && skipFrame && last2.length > 0) {
      skipped2++;
      return last2;
    }
    skipped2 = 0;
    return new Promise(async (resolve) => {
      const outputSize2 = [input.shape[2] || 0, input.shape[1] || 0];
      const resize = Fj.resizeBilinear(input, [inputSize3, inputSize3]);
      const objectT = config3.object.enabled ? model3 == null ? void 0 : model3.execute(resize, ["tower_0/detections"]) : null;
      lastTime2 = now();
      Ot(resize);
      const obj = await process3(objectT, outputSize2, config3);
      last2 = obj;
      resolve(obj);
    });
  }
  var efficientposecoords_exports = {};
  __export(efficientposecoords_exports, {
    connected: () => connected2,
    kpt: () => kpt2
  });
  var kpt2 = [
    "head",
    "neck",
    "rightShoulder",
    "rightElbow",
    "rightWrist",
    "chest",
    "leftShoulder",
    "leftElbow",
    "leftWrist",
    "bodyCenter",
    "rightHip",
    "rightKnee",
    "rightAnkle",
    "leftHip",
    "leftKnee",
    "leftAnkle"
  ];
  var connected2 = {
    leftLeg: ["leftHip", "leftKnee", "leftAnkle"],
    rightLeg: ["rightHip", "rightKnee", "rightAnkle"],
    torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"],
    leftArm: ["leftShoulder", "leftElbow", "leftWrist"],
    rightArm: ["rightShoulder", "rightElbow", "rightWrist"],
    head: []
  };
  var model4;
  var lastTime3 = 0;
  var cache2 = { id: 0, keypoints: [], box: [0, 0, 0, 0], boxRaw: [0, 0, 0, 0], score: 0, annotations: {} };
  var skipped3 = Number.MAX_SAFE_INTEGER;
  async function load2(config3) {
    if (env.initial)
      model4 = null;
    if (!model4)
      model4 = await loadModel(config3.body.modelPath);
    else if (config3.debug)
      log$1("cached model:", model4["modelUrl"]);
    return model4;
  }
  async function max2d(inputs, minScore) {
    const [width, height] = inputs.shape;
    const reshaped = W(inputs, [height * width]);
    const max = _a(reshaped, 0);
    const newScore = (await max.data())[0];
    if (newScore > minScore) {
      const coordinates = Sk(reshaped, 0);
      const mod = T2(coordinates, width);
      const x = (await mod.data())[0];
      const div = je(coordinates, width);
      const y10 = (await div.data())[0];
      Ot([reshaped, max, coordinates, mod, div]);
      return [x, y10, newScore];
    }
    Ot([reshaped, max]);
    return [0, 0, newScore];
  }
  async function predict3(image, config3) {
    if (!(model4 == null ? void 0 : model4["executor"]) || !(model4 == null ? void 0 : model4.inputs[0].shape))
      return [];
    const skipTime = (config3.body.skipTime || 0) > now() - lastTime3;
    const skipFrame = skipped3 < (config3.body.skipFrames || 0);
    if (config3.skipAllowed && skipTime && skipFrame && Object.keys(cache2.keypoints).length > 0) {
      skipped3++;
      return [cache2];
    }
    skipped3 = 0;
    return new Promise(async (resolve) => {
      const tensor = De(() => {
        var _a22, _b2;
        const resize = Fj.resizeBilinear(image, [((_a22 = model4 == null ? void 0 : model4.inputs[0].shape) == null ? void 0 : _a22[2]) || 0, ((_b2 = model4 == null ? void 0 : model4.inputs[0].shape) == null ? void 0 : _b2[1]) || 0], false);
        const enhance2 = se(resize, constants.tf2);
        const norm = Te(enhance2, constants.tf1);
        return norm;
      });
      let resT;
      if (config3.body.enabled)
        resT = model4 == null ? void 0 : model4.execute(tensor);
      lastTime3 = now();
      Ot(tensor);
      if (resT) {
        cache2.keypoints.length = 0;
        const squeeze = mc(resT);
        Ot(resT);
        const stack = mo(squeeze, 2);
        Ot(squeeze);
        for (let id2 = 0; id2 < stack.length; id2++) {
          const [x5, y11, partScore] = await max2d(stack[id2], config3.body.minConfidence);
          if (partScore > (config3.body.minConfidence || 0)) {
            cache2.keypoints.push({
              score: Math.round(100 * partScore) / 100,
              part: kpt2[id2],
              positionRaw: [
                // normalized to 0..1
                // @ts-ignore model is not undefined here
                x5 / model4.inputs[0].shape[2],
                y11 / model4.inputs[0].shape[1]
              ],
              position: [
                // normalized to input image size
                // @ts-ignore model is not undefined here
                Math.round(image.shape[2] * x5 / model4.inputs[0].shape[2]),
                Math.round(image.shape[1] * y11 / model4.inputs[0].shape[1])
              ]
            });
          }
        }
        stack.forEach((s) => Ot(s));
      }
      cache2.score = cache2.keypoints.reduce((prev, curr) => curr.score > prev ? curr.score : prev, 0);
      const x = cache2.keypoints.map((a) => a.position[0]);
      const y10 = cache2.keypoints.map((a) => a.position[1]);
      cache2.box = [
        Math.min(...x),
        Math.min(...y10),
        Math.max(...x) - Math.min(...x),
        Math.max(...y10) - Math.min(...y10)
      ];
      const xRaw = cache2.keypoints.map((a) => a.positionRaw[0]);
      const yRaw = cache2.keypoints.map((a) => a.positionRaw[1]);
      cache2.boxRaw = [
        Math.min(...xRaw),
        Math.min(...yRaw),
        Math.max(...xRaw) - Math.min(...xRaw),
        Math.max(...yRaw) - Math.min(...yRaw)
      ];
      for (const [name2, indexes] of Object.entries(connected2)) {
        const pt2 = [];
        for (let i10 = 0; i10 < indexes.length - 1; i10++) {
          const pt0 = cache2.keypoints.find((kpt4) => kpt4.part === indexes[i10]);
          const pt1 = cache2.keypoints.find((kpt4) => kpt4.part === indexes[i10 + 1]);
          if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
            pt2.push([pt0.position, pt1.position]);
        }
        cache2.annotations[name2] = pt2;
      }
      resolve([cache2]);
    });
  }
  var getBoxSize = (box) => [Math.abs(box.endPoint[0] - box.startPoint[0]), Math.abs(box.endPoint[1] - box.startPoint[1])];
  var getBoxCenter = (box) => [box.startPoint[0] + (box.endPoint[0] - box.startPoint[0]) / 2, box.startPoint[1] + (box.endPoint[1] - box.startPoint[1]) / 2, 1];
  var clampBox = (box, input) => box ? [
    Math.trunc(Math.max(0, box.startPoint[0])),
    Math.trunc(Math.max(0, box.startPoint[1])),
    Math.trunc(Math.min(input.shape[2] || 0, box.endPoint[0]) - Math.max(0, box.startPoint[0])),
    Math.trunc(Math.min(input.shape[1] || 0, box.endPoint[1]) - Math.max(0, box.startPoint[1]))
  ] : [0, 0, 0, 0];
  var getRawBox = (box, input) => box ? [
    box.startPoint[0] / (input.shape[2] || 0),
    box.startPoint[1] / (input.shape[1] || 0),
    (box.endPoint[0] - box.startPoint[0]) / (input.shape[2] || 0),
    (box.endPoint[1] - box.startPoint[1]) / (input.shape[1] || 0)
  ] : [0, 0, 0, 0];
  var scaleBoxCoordinates = (box, factor, anchor) => {
    const startPoint = [box.startPoint[0] * factor[0], box.startPoint[1] * factor[1]];
    const endPoint = [box.endPoint[0] * factor[0], box.endPoint[1] * factor[1]];
    const landmarks = box.landmarks.map((pt2) => [(pt2[0] + anchor[0]) * factor[0], (pt2[1] + anchor[1]) * factor[1]]);
    return { startPoint, endPoint, landmarks, confidence: box.confidence };
  };
  var cutAndResize = (box, image, cropSize) => {
    const h = image.shape[1];
    const w10 = image.shape[2];
    const cutBox = [box.startPoint[1] / h, box.startPoint[0] / w10, box.endPoint[1] / h, box.endPoint[0] / w10];
    const crop = Fj.cropAndResize(image, [cutBox], [0], cropSize);
    const norm = je(crop, constants.tf255);
    Ot(crop);
    return norm;
  };
  var enlargeBox = (box, factor) => {
    const center = getBoxCenter(box);
    const size2 = getBoxSize(box);
    const halfSize = [factor * size2[0] / 2, factor * size2[1] / 2];
    return {
      startPoint: [center[0] - halfSize[0], center[1] - halfSize[1]],
      endPoint: [center[0] + halfSize[0], center[1] + halfSize[1]],
      landmarks: box.landmarks,
      confidence: box.confidence,
      size: size2
    };
  };
  var squarifyBox = (box) => {
    const centers = getBoxCenter(box);
    const size2 = getBoxSize(box);
    const halfSize = Math.max(...size2) / 2;
    return {
      startPoint: [Math.round(centers[0] - halfSize), Math.round(centers[1] - halfSize)],
      endPoint: [Math.round(centers[0] + halfSize), Math.round(centers[1] + halfSize)],
      landmarks: box.landmarks,
      confidence: box.confidence,
      size: [Math.round(size2[0]), Math.round(size2[1])]
    };
  };
  var calculateLandmarksBoundingBox = (landmarks) => {
    const x = landmarks.map((d) => d[0]);
    const y10 = landmarks.map((d) => d[1]);
    return {
      startPoint: [Math.min(...x), Math.min(...y10)],
      endPoint: [Math.max(...x), Math.max(...y10)],
      landmarks
    };
  };
  var fixedRotationMatrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  var normalizeRadians = (angle) => angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));
  var computeRotation = (point1, point2) => normalizeRadians(Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]));
  var buildTranslationMatrix = (x, y10) => [[1, 0, x], [0, 1, y10], [0, 0, 1]];
  var dot = (v12, v22) => {
    let product = 0;
    for (let i10 = 0; i10 < v12.length; i10++)
      product += v12[i10] * v22[i10];
    return product;
  };
  var getColumnFrom2DArr = (arr, columnIndex) => {
    const column = [];
    for (let i10 = 0; i10 < arr.length; i10++)
      column.push(arr[i10][columnIndex]);
    return column;
  };
  var multiplyTransformMatrices = (mat1, mat2) => {
    const product = [];
    const size2 = mat1.length;
    for (let row = 0; row < size2; row++) {
      product.push([]);
      for (let col = 0; col < size2; col++)
        product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));
    }
    return product;
  };
  var buildRotationMatrix = (rotation, center) => {
    const cosA = Math.cos(rotation);
    const sinA = Math.sin(rotation);
    const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
    const translationMatrix = buildTranslationMatrix(center[0], center[1]);
    const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);
    const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);
    return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);
  };
  var invertTransformMatrix = (matrix) => {
    const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
    const translationComponent = [matrix[0][2], matrix[1][2]];
    const invertedTranslation = [-dot(rotationComponent[0], translationComponent), -dot(rotationComponent[1], translationComponent)];
    return [rotationComponent[0].concat(invertedTranslation[0]), rotationComponent[1].concat(invertedTranslation[1]), [0, 0, 1]];
  };
  var rotatePoint = (homogeneousCoordinate, rotationMatrix) => [dot(homogeneousCoordinate, rotationMatrix[0]), dot(homogeneousCoordinate, rotationMatrix[1])];
  function generateAnchors(inputSize10) {
    const spec = inputSize10 === 192 ? { strides: [4], anchors: [1] } : { strides: [inputSize10 / 16, inputSize10 / 8], anchors: [2, 6] };
    const anchors3 = [];
    for (let i10 = 0; i10 < spec.strides.length; i10++) {
      const stride = spec.strides[i10];
      const gridRows = Math.floor((inputSize10 + stride - 1) / stride);
      const gridCols = Math.floor((inputSize10 + stride - 1) / stride);
      const anchorsNum = spec.anchors[i10];
      for (let gridY = 0; gridY < gridRows; gridY++) {
        const anchorY = stride * (gridY + 0.5);
        for (let gridX = 0; gridX < gridCols; gridX++) {
          const anchorX = stride * (gridX + 0.5);
          for (let n8 = 0; n8 < anchorsNum; n8++)
            anchors3.push([anchorX, anchorY]);
        }
      }
    }
    return anchors3;
  }
  function transformRawCoords(coordsRaw, box, angle, rotationMatrix, inputSize10) {
    const boxSize = getBoxSize(box);
    const coordsScaled = coordsRaw.map((coord) => [
      // scaled around zero-point
      boxSize[0] / inputSize10 * (coord[0] - inputSize10 / 2),
      boxSize[1] / inputSize10 * (coord[1] - inputSize10 / 2),
      coord[2] || 0
    ]);
    const largeAngle = angle && angle !== 0 && Math.abs(angle) > 0.2;
    const coordsRotationMatrix = largeAngle ? buildRotationMatrix(angle, [0, 0]) : fixedRotationMatrix;
    const coordsRotated = largeAngle ? coordsScaled.map((coord) => [...rotatePoint(coord, coordsRotationMatrix), coord[2]]) : coordsScaled;
    const inverseRotationMatrix = largeAngle ? invertTransformMatrix(rotationMatrix) : fixedRotationMatrix;
    const boxCenter = getBoxCenter(box);
    const offsets = [dot(boxCenter, inverseRotationMatrix[0]), dot(boxCenter, inverseRotationMatrix[1])];
    return coordsRotated.map((coord) => [
      Math.trunc(coord[0] + offsets[0]),
      Math.trunc(coord[1] + offsets[1]),
      Math.trunc(coord[2] || 0)
    ]);
  }
  function correctFaceRotation(rotate, box, input, inputSize10) {
    const symmetryLine = box.landmarks.length >= meshLandmarks.count ? meshLandmarks.symmetryLine : blazeFaceLandmarks.symmetryLine;
    let angle = 0;
    let rotationMatrix = fixedRotationMatrix;
    let face4;
    if (rotate && env.kernels.includes("rotatewithoffset")) {
      angle = computeRotation(box.landmarks[symmetryLine[0]], box.landmarks[symmetryLine[1]]);
      const largeAngle = angle && angle !== 0 && Math.abs(angle) > 0.2;
      if (largeAngle) {
        const center = getBoxCenter(box);
        const centerRaw = [center[0] / input.shape[2], center[1] / input.shape[1]];
        const rotated = Fj.rotateWithOffset(input, angle, 0, [centerRaw[0], centerRaw[1]]);
        rotationMatrix = buildRotationMatrix(-angle, center);
        face4 = cutAndResize(box, rotated, [inputSize10, inputSize10]);
        Ot(rotated);
      } else {
        face4 = cutAndResize(box, input, [inputSize10, inputSize10]);
      }
    } else {
      face4 = cutAndResize(box, input, [inputSize10, inputSize10]);
    }
    return [angle, rotationMatrix, face4];
  }
  var findFaceCenter = (mesh) => {
    const x = mesh.map((m) => m[0]);
    const y10 = mesh.map((m) => m[1]);
    return [Math.min(...x) + (Math.max(...x) - Math.min(...x)) / 2, Math.min(...y10) + (Math.max(...y10) - Math.min(...y10)) / 2];
  };
  var calculateFaceBox = (mesh, previousBox) => {
    const center = findFaceCenter(mesh);
    const boxSize = getBoxSize(previousBox);
    const calculatedBox = {
      startPoint: [center[0] - boxSize[0] / 2, center[1] - boxSize[1] / 2],
      endPoint: [center[0] + boxSize[0] / 2, center[1] + boxSize[1] / 2]
    };
    return calculatedBox;
  };
  var keypointsCount = 6;
  var faceBoxScaleFactor = 1.4;
  var model5;
  var anchors = null;
  var inputSize4 = 0;
  var inputSizeT = null;
  var size = () => inputSize4;
  async function load3(config3) {
    var _a22;
    if (env.initial)
      model5 = null;
    if (!model5)
      model5 = await loadModel((_a22 = config3.face.detector) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", model5["modelUrl"]);
    inputSize4 = model5["executor"] && model5.inputs[0].shape ? model5.inputs[0].shape[2] : 256;
    inputSizeT = ke(inputSize4, "int32");
    anchors = mu(generateAnchors(inputSize4));
    return model5;
  }
  function decodeBoxes2(boxOutputs) {
    if (!anchors || !inputSizeT)
      return Gr([0, 0]);
    const t8 = {};
    t8.boxStarts = Xe(boxOutputs, [0, 1], [-1, 2]);
    t8.centers = Ce(t8.boxStarts, anchors);
    t8.boxSizes = Xe(boxOutputs, [0, 3], [-1, 2]);
    t8.boxSizesNormalized = je(t8.boxSizes, inputSizeT);
    t8.centersNormalized = je(t8.centers, inputSizeT);
    t8.halfBoxSize = je(t8.boxSizesNormalized, constants.tf2);
    t8.starts = Te(t8.centersNormalized, t8.halfBoxSize);
    t8.ends = Ce(t8.centersNormalized, t8.halfBoxSize);
    t8.startNormalized = se(t8.starts, inputSizeT);
    t8.endNormalized = se(t8.ends, inputSizeT);
    const boxes = Wk([t8.startNormalized, t8.endNormalized], 1);
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return boxes;
  }
  async function getBoxes(inputImage, config3) {
    var _a22, _b2, _c22, _d22, _e, _f2;
    if (!inputImage || inputImage["isDisposedInternal"] || inputImage.shape.length !== 4 || inputImage.shape[1] < 1 || inputImage.shape[2] < 1)
      return [];
    const t8 = {};
    t8.resized = Fj.resizeBilinear(inputImage, [inputSize4, inputSize4]);
    t8.div = je(t8.resized, constants.tf127);
    t8.normalized = Te(t8.div, constants.tf05);
    const res = model5 == null ? void 0 : model5.execute(t8.normalized);
    if (Array.isArray(res) && res.length > 2) {
      const sorted = res.sort((a, b) => a.size - b.size);
      t8.concat384 = bt([sorted[0], sorted[2]], 2);
      t8.concat512 = bt([sorted[1], sorted[3]], 2);
      t8.concat = bt([t8.concat512, t8.concat384], 1);
      t8.batch = mc(t8.concat, [0]);
    } else if (Array.isArray(res)) {
      t8.batch = mc(res[0]);
    } else {
      t8.batch = mc(res);
    }
    Ot(res);
    t8.boxes = decodeBoxes2(t8.batch);
    t8.logits = Xe(t8.batch, [0, 0], [-1, 1]);
    t8.sigmoid = Na(t8.logits);
    t8.scores = mc(t8.sigmoid);
    t8.nms = await Fj.nonMaxSuppressionAsync(t8.boxes, t8.scores, ((_a22 = config3.face.detector) == null ? void 0 : _a22.maxDetected) || 0, ((_b2 = config3.face.detector) == null ? void 0 : _b2.iouThreshold) || 0, ((_c22 = config3.face.detector) == null ? void 0 : _c22.minConfidence) || 0);
    const nms = await t8.nms.array();
    const boxes = [];
    const scores = await t8.scores.data();
    for (let i10 = 0; i10 < nms.length; i10++) {
      const confidence = scores[nms[i10]];
      if (confidence > (((_d22 = config3.face.detector) == null ? void 0 : _d22.minConfidence) || 0)) {
        const b = {};
        b.bbox = Xe(t8.boxes, [nms[i10], 0], [1, -1]);
        b.slice = Xe(t8.batch, [nms[i10], keypointsCount - 1], [1, -1]);
        b.squeeze = mc(b.slice);
        b.landmarks = W(b.squeeze, [keypointsCount, -1]);
        const points = await b.bbox.data();
        const rawBox = {
          startPoint: [points[0], points[1]],
          endPoint: [points[2], points[3]],
          landmarks: await b.landmarks.array(),
          confidence
        };
        b.anchor = Xe(anchors, [nms[i10], 0], [1, 2]);
        const anchor = await b.anchor.data();
        const scaledBox = scaleBoxCoordinates(rawBox, [(inputImage.shape[2] || 0) / inputSize4, (inputImage.shape[1] || 0) / inputSize4], anchor);
        const enlargedBox = enlargeBox(scaledBox, config3.face["scale"] || faceBoxScaleFactor);
        const squaredBox = squarifyBox(enlargedBox);
        if (squaredBox.size[0] > (((_e = config3.face.detector) == null ? void 0 : _e["minSize"]) || 0) && squaredBox.size[1] > (((_f2 = config3.face.detector) == null ? void 0 : _f2["minSize"]) || 0))
          boxes.push(squaredBox);
        Object.keys(b).forEach((tensor) => Ot(b[tensor]));
      }
    }
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return boxes;
  }
  var model6;
  var inputSize5 = 0;
  var irisEnlarge = 2.3;
  var leftOutline = meshAnnotations.leftEyeLower0;
  var rightOutline = meshAnnotations.rightEyeLower0;
  var eyeLandmarks = {
    leftBounds: [leftOutline[0], leftOutline[leftOutline.length - 1]],
    rightBounds: [rightOutline[0], rightOutline[rightOutline.length - 1]]
  };
  var irisLandmarks = {
    upperCenter: 3,
    lowerCenter: 4,
    index: 71,
    numCoordinates: 76
  };
  async function load4(config3) {
    var _a22, _b2;
    if (env.initial)
      model6 = null;
    if (!model6)
      model6 = await loadModel((_a22 = config3.face.iris) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", model6["modelUrl"]);
    inputSize5 = (model6 == null ? void 0 : model6["executor"]) && ((_b2 = model6.inputs) == null ? void 0 : _b2[0].shape) ? model6.inputs[0].shape[2] : 0;
    if (inputSize5 === -1)
      inputSize5 = 64;
    return model6;
  }
  function replaceIrisCoords(rawCoords, newCoords, prefix, keys) {
    for (let i10 = 0; i10 < irisIndices.length; i10++) {
      const { key: key2, indices } = irisIndices[i10];
      const originalIndices = meshAnnotations[`${prefix}${key2}`];
      if (!keys || keys.includes(key2)) {
        for (let j = 0; j < indices.length; j++) {
          const index2 = indices[j];
          rawCoords[originalIndices[j]] = [
            newCoords[index2][0],
            newCoords[index2][1],
            (newCoords[index2][2] + rawCoords[originalIndices[j]][2]) / 2
          ];
        }
      }
    }
  }
  var getLeftToRightEyeDepthDifference = (rawCoords) => {
    const leftEyeZ = rawCoords[eyeLandmarks.leftBounds[0]][2];
    const rightEyeZ = rawCoords[eyeLandmarks.rightBounds[0]][2];
    return leftEyeZ - rightEyeZ;
  };
  var getEyeBox = (rawCoords, face4, eyeInnerCornerIndex, eyeOuterCornerIndex, meshSize, flip = false) => {
    const box = squarifyBox(enlargeBox(calculateLandmarksBoundingBox([rawCoords[eyeInnerCornerIndex], rawCoords[eyeOuterCornerIndex]]), irisEnlarge));
    const boxSize = getBoxSize(box);
    let crop = Fj.cropAndResize(face4, [[
      box.startPoint[1] / meshSize,
      box.startPoint[0] / meshSize,
      box.endPoint[1] / meshSize,
      box.endPoint[0] / meshSize
    ]], [0], [inputSize5, inputSize5]);
    if (flip && env.kernels.includes("flipleftright")) {
      const flipped = Fj.flipLeftRight(crop);
      Ot(crop);
      crop = flipped;
    }
    return { box, boxSize, crop };
  };
  var getEyeCoords = (eyeData, eyeBox, eyeBoxSize, flip = false) => {
    const eyeRawCoords = [];
    for (let i10 = 0; i10 < irisLandmarks.numCoordinates; i10++) {
      const x = eyeData[i10 * 3];
      const y10 = eyeData[i10 * 3 + 1];
      const z = eyeData[i10 * 3 + 2];
      eyeRawCoords.push([
        (flip ? 1 - x / inputSize5 : x / inputSize5) * eyeBoxSize[0] + eyeBox.startPoint[0],
        y10 / inputSize5 * eyeBoxSize[1] + eyeBox.startPoint[1],
        z
      ]);
    }
    return { rawCoords: eyeRawCoords, iris: eyeRawCoords.slice(irisLandmarks.index) };
  };
  var getAdjustedIrisCoords = (rawCoords, irisCoords, direction) => {
    const upperCenterZ = rawCoords[meshAnnotations[`${direction}EyeUpper0`][irisLandmarks.upperCenter]][2];
    const lowerCenterZ = rawCoords[meshAnnotations[`${direction}EyeLower0`][irisLandmarks.lowerCenter]][2];
    const averageZ = (upperCenterZ + lowerCenterZ) / 2;
    return irisCoords.map((coord, i10) => {
      let z = averageZ;
      if (i10 === 2) {
        z = upperCenterZ;
      } else if (i10 === 4) {
        z = lowerCenterZ;
      }
      return [coord[0], coord[1], z];
    });
  };
  async function augmentIris(rawCoords, face4, meshSize) {
    if (!(model6 == null ? void 0 : model6["executor"]))
      return rawCoords;
    const { box: leftEyeBox, boxSize: leftEyeBoxSize, crop: leftEyeCrop } = getEyeBox(rawCoords, face4, eyeLandmarks.leftBounds[0], eyeLandmarks.leftBounds[1], meshSize, true);
    const { box: rightEyeBox, boxSize: rightEyeBoxSize, crop: rightEyeCrop } = getEyeBox(rawCoords, face4, eyeLandmarks.rightBounds[0], eyeLandmarks.rightBounds[1], meshSize, true);
    const combined = bt([leftEyeCrop, rightEyeCrop]);
    Ot(leftEyeCrop);
    Ot(rightEyeCrop);
    const eyePredictions = model6.execute(combined);
    Ot(combined);
    const eyePredictionsData = await eyePredictions.data();
    Ot(eyePredictions);
    const leftEyeData = eyePredictionsData.slice(0, irisLandmarks.numCoordinates * 3);
    const { rawCoords: leftEyeRawCoords, iris: leftIrisRawCoords } = getEyeCoords(leftEyeData, leftEyeBox, leftEyeBoxSize, true);
    const rightEyeData = eyePredictionsData.slice(irisLandmarks.numCoordinates * 3);
    const { rawCoords: rightEyeRawCoords, iris: rightIrisRawCoords } = getEyeCoords(rightEyeData, rightEyeBox, rightEyeBoxSize, false);
    const leftToRightEyeDepthDifference = getLeftToRightEyeDepthDifference(rawCoords);
    if (Math.abs(leftToRightEyeDepthDifference) < 30) {
      replaceIrisCoords(rawCoords, leftEyeRawCoords, "left", null);
      replaceIrisCoords(rawCoords, rightEyeRawCoords, "right", null);
    } else if (leftToRightEyeDepthDifference < 1) {
      replaceIrisCoords(rawCoords, leftEyeRawCoords, "left", ["EyeUpper0", "EyeLower0"]);
    } else {
      replaceIrisCoords(rawCoords, rightEyeRawCoords, "right", ["EyeUpper0", "EyeLower0"]);
    }
    const adjustedLeftIrisCoords = getAdjustedIrisCoords(rawCoords, leftIrisRawCoords, "left");
    const adjustedRightIrisCoords = getAdjustedIrisCoords(rawCoords, rightIrisRawCoords, "right");
    const newCoords = rawCoords.concat(adjustedLeftIrisCoords).concat(adjustedRightIrisCoords);
    return newCoords;
  }
  async function augment(rawCoords, results) {
    var _a22, _b2, _c22, _d22, _e, _f2, _g2, _h2, _i2, _j2;
    const t8 = {
      // all attention models produce 2d results so it needs to be later augmented with correct z-coords
      // mesh: results[0], // already have it in rawCoords // output_mesh_identity
      // flag: results[1], // already processed in parent // conv_faceflag
      lips: await ((_b2 = (_a22 = results.filter((r8) => r8.size === 160)) == null ? void 0 : _a22[0]) == null ? void 0 : _b2.data()),
      // 80 x 2d = 160 // output_lips
      irisL: await ((_d22 = (_c22 = results.filter((r8) => r8.size === 10)) == null ? void 0 : _c22[0]) == null ? void 0 : _d22.data()),
      // 5 x 2d = 10 // output_right_iris
      eyeL: await ((_f2 = (_e = results.filter((r8) => r8.size === 142)) == null ? void 0 : _e[0]) == null ? void 0 : _f2.data()),
      // 71 x 2d = 142 // output_right_eye
      irisR: await ((_h2 = (_g2 = results.filter((r8) => r8.size === 10)) == null ? void 0 : _g2[1]) == null ? void 0 : _h2.data()),
      // 5 x 2d = 10 // output_left_iris
      eyeR: await ((_j2 = (_i2 = results.filter((r8) => r8.size === 142)) == null ? void 0 : _i2[1]) == null ? void 0 : _j2.data())
      // 71 x 2d = 142// output_left_eye
    };
    for (const val of Object.values(t8)) {
      if (!val)
        return rawCoords;
    }
    const irisLDepth = LANDMARKS_REFINEMENT_LEFT_EYE_CONFIG.reduce((prev, curr) => prev += rawCoords[curr][2], 0) / LANDMARKS_REFINEMENT_LEFT_EYE_CONFIG.length;
    for (let i10 = 0; i10 < t8.irisL.length / 2; i10++)
      rawCoords.push([t8.irisL[2 * i10 + 0], t8.irisL[2 * i10 + 1], irisLDepth]);
    const irisRDepth = LANDMARKS_REFINEMENT_RIGHT_EYE_CONFIG.reduce((prev, curr) => prev += rawCoords[curr][2], 0) / LANDMARKS_REFINEMENT_RIGHT_EYE_CONFIG.length;
    for (let i10 = 0; i10 < t8.irisR.length / 2; i10++)
      rawCoords.push([t8.irisR[2 * i10 + 0], t8.irisR[2 * i10 + 1], irisRDepth]);
    for (let i10 = 0; i10 < t8.eyeL.length / 2; i10++)
      rawCoords[LANDMARKS_REFINEMENT_LEFT_EYE_CONFIG[i10]] = [t8.eyeL[2 * i10 + 0], t8.eyeL[2 * i10 + 1], rawCoords[LANDMARKS_REFINEMENT_LEFT_EYE_CONFIG[i10]][2]];
    for (let i10 = 0; i10 < t8.eyeR.length / 2; i10++)
      rawCoords[LANDMARKS_REFINEMENT_RIGHT_EYE_CONFIG[i10]] = [t8.eyeR[2 * i10 + 0], t8.eyeR[2 * i10 + 1], rawCoords[LANDMARKS_REFINEMENT_RIGHT_EYE_CONFIG[i10]][2]];
    for (let i10 = 0; i10 < t8.lips.length / 2; i10++)
      rawCoords[LANDMARKS_REFINEMENT_LIPS_CONFIG[i10]] = [t8.lips[2 * i10 + 0], t8.lips[2 * i10 + 1], rawCoords[LANDMARKS_REFINEMENT_LIPS_CONFIG[i10]][2]];
    return rawCoords;
  }
  var cache3 = {
    boxes: [],
    skipped: Number.MAX_SAFE_INTEGER,
    timestamp: 0
  };
  var model7 = null;
  var inputSize6 = 0;
  async function predict4(input, config3) {
    var _a22, _b2, _c22, _d22, _e, _f2, _g2, _h2, _i2, _j2;
    const skipTime = (((_a22 = config3.face.detector) == null ? void 0 : _a22.skipTime) || 0) > now() - cache3.timestamp;
    const skipFrame = cache3.skipped < (((_b2 = config3.face.detector) == null ? void 0 : _b2.skipFrames) || 0);
    if (!config3.skipAllowed || !skipTime || !skipFrame || cache3.boxes.length === 0) {
      cache3.boxes = await getBoxes(input, config3);
      cache3.timestamp = now();
      cache3.skipped = 0;
    } else {
      cache3.skipped++;
    }
    const faces = [];
    const newCache = [];
    let id2 = 0;
    const size2 = inputSize6;
    for (let i10 = 0; i10 < cache3.boxes.length; i10++) {
      const box = cache3.boxes[i10];
      let angle = 0;
      let rotationMatrix;
      const face4 = {
        // init face result
        id: id2++,
        mesh: [],
        meshRaw: [],
        box: [0, 0, 0, 0],
        boxRaw: [0, 0, 0, 0],
        score: 0,
        boxScore: 0,
        faceScore: 0,
        size: [0, 0],
        // contoursRaw: [],
        // contours: [],
        annotations: {}
      };
      [angle, rotationMatrix, face4.tensor] = correctFaceRotation((_c22 = config3.face.detector) == null ? void 0 : _c22.rotation, box, input, ((_d22 = config3.face.mesh) == null ? void 0 : _d22.enabled) ? inputSize6 : size());
      if (config3.filter.equalization) {
        const equilized = face4.tensor ? await histogramEqualization(face4.tensor) : void 0;
        Ot(face4.tensor);
        if (equilized)
          face4.tensor = equilized;
      }
      face4.boxScore = Math.round(100 * box.confidence) / 100;
      if (!((_e = config3.face.mesh) == null ? void 0 : _e.enabled) || !(model7 == null ? void 0 : model7["executor"])) {
        face4.box = clampBox(box, input);
        face4.boxRaw = getRawBox(box, input);
        face4.score = face4.boxScore;
        face4.size = box.size;
        face4.mesh = box.landmarks;
        face4.meshRaw = face4.mesh.map((pt2) => [pt2[0] / (input.shape[2] || 0), pt2[1] / (input.shape[1] || 0), (pt2[2] || 0) / size2]);
        for (const key2 of Object.keys(blazeFaceLandmarks))
          face4.annotations[key2] = [face4.mesh[blazeFaceLandmarks[key2]]];
      } else if (!model7) {
        if (config3.debug)
          log$1("face mesh detection requested, but model is not loaded");
      } else {
        if (((_f2 = config3.face.attention) == null ? void 0 : _f2.enabled) && !env.kernels.includes("atan2")) {
          config3.face.attention.enabled = false;
          Ot(face4.tensor);
          return faces;
        }
        const results = model7.execute(face4.tensor);
        const confidenceT = results.find((t8) => t8.shape[t8.shape.length - 1] === 1);
        const faceConfidence = await confidenceT.data();
        face4.faceScore = Math.round(100 * faceConfidence[0]) / 100;
        if (face4.faceScore < (((_g2 = config3.face.detector) == null ? void 0 : _g2.minConfidence) || 1)) {
          box.confidence = face4.faceScore;
          if (config3.face.mesh["keepInvalid"]) {
            face4.box = clampBox(box, input);
            face4.boxRaw = getRawBox(box, input);
            face4.size = box.size;
            face4.score = face4.boxScore;
            face4.mesh = box.landmarks;
            face4.meshRaw = face4.mesh.map((pt2) => [pt2[0] / (input.shape[2] || 1), pt2[1] / (input.shape[1] || 1), (pt2[2] || 0) / size2]);
            for (const key2 of Object.keys(blazeFaceLandmarks)) {
              face4.annotations[key2] = [face4.mesh[blazeFaceLandmarks[key2]]];
            }
          }
        } else {
          const meshT = results.find((t8) => t8.shape[t8.shape.length - 1] === 1404);
          const coordsReshaped = W(meshT, [-1, 3]);
          let rawCoords = await coordsReshaped.array();
          Ot(coordsReshaped);
          if ((_h2 = config3.face.attention) == null ? void 0 : _h2.enabled) {
            rawCoords = await augment(rawCoords, results);
          } else if ((_i2 = config3.face.iris) == null ? void 0 : _i2.enabled) {
            rawCoords = await augmentIris(rawCoords, face4.tensor, inputSize6);
          }
          face4.mesh = transformRawCoords(rawCoords, box, angle, rotationMatrix, inputSize6);
          face4.meshRaw = face4.mesh.map((pt2) => [pt2[0] / (input.shape[2] || 0), pt2[1] / (input.shape[1] || 0), (pt2[2] || 0) / size2]);
          for (const key2 of Object.keys(meshAnnotations))
            face4.annotations[key2] = meshAnnotations[key2].map((index2) => face4.mesh[index2]);
          face4.score = face4.faceScore;
          const calculatedBox = {
            ...calculateFaceBox(face4.mesh, box),
            confidence: box.confidence,
            landmarks: box.landmarks,
            size: box.size
          };
          face4.box = clampBox(calculatedBox, input);
          face4.boxRaw = getRawBox(calculatedBox, input);
          face4.size = calculatedBox.size;
          newCache.push(calculatedBox);
        }
        Ot(results);
      }
      if (face4.score > (((_j2 = config3.face.detector) == null ? void 0 : _j2.minConfidence) || 1))
        faces.push(face4);
      else
        Ot(face4.tensor);
    }
    cache3.boxes = newCache;
    return faces;
  }
  async function load5(config3) {
    var _a22, _b2, _c22, _d22, _e, _f2;
    if (env.initial)
      model7 = null;
    if (((_a22 = config3.face.attention) == null ? void 0 : _a22.enabled) && (model7 == null ? void 0 : model7["signature"])) {
      if (Object.keys(((_b2 = model7 == null ? void 0 : model7["signature"]) == null ? void 0 : _b2.outputs) || {}).length < 6)
        model7 = null;
    }
    if (!model7) {
      if ((_c22 = config3.face.attention) == null ? void 0 : _c22.enabled)
        model7 = await loadModel(config3.face.attention.modelPath);
      else
        model7 = await loadModel((_d22 = config3.face.mesh) == null ? void 0 : _d22.modelPath);
    } else if (config3.debug) {
      log$1("cached model:", model7["modelUrl"]);
    }
    inputSize6 = model7["executor"] && ((_e = model7 == null ? void 0 : model7.inputs) == null ? void 0 : _e[0].shape) ? (_f2 = model7 == null ? void 0 : model7.inputs) == null ? void 0 : _f2[0].shape[2] : 256;
    return model7;
  }
  var triangulation = TRI468;
  var uvmap = UV468;
  var annotations = [];
  var model8;
  var last3 = [];
  var lastCount = 0;
  var lastTime4 = 0;
  var skipped4 = Number.MAX_SAFE_INTEGER;
  var rgb = false;
  async function load6(config3) {
    var _a22, _b2, _c22;
    if (env.initial)
      model8 = null;
    if (!model8) {
      model8 = await loadModel((_a22 = config3.face.emotion) == null ? void 0 : _a22.modelPath);
      rgb = ((_c22 = (_b2 = model8 == null ? void 0 : model8.inputs) == null ? void 0 : _b2[0].shape) == null ? void 0 : _c22[3]) === 3;
      if (!rgb)
        annotations = ["angry", "disgust", "fear", "happy", "sad", "surprise", "neutral"];
      else
        annotations = ["angry", "disgust", "fear", "happy", "neutral", "sad", "surprise"];
    } else if (config3.debug) {
      log$1("cached model:", model8["modelUrl"]);
    }
    return model8;
  }
  async function predict5(image, config3, idx, count2) {
    var _a22, _b2;
    if (!model8)
      return [];
    const skipFrame = skipped4 < (((_a22 = config3.face.emotion) == null ? void 0 : _a22.skipFrames) || 0);
    const skipTime = (((_b2 = config3.face.emotion) == null ? void 0 : _b2.skipTime) || 0) > now() - lastTime4;
    if (config3.skipAllowed && skipTime && skipFrame && lastCount === count2 && last3[idx] && last3[idx].length > 0) {
      skipped4++;
      return last3[idx];
    }
    skipped4 = 0;
    return new Promise(async (resolve) => {
      var _a3, _b22, _c22;
      const obj = [];
      if ((_a3 = config3.face.emotion) == null ? void 0 : _a3.enabled) {
        const t8 = {};
        const inputSize10 = (model8 == null ? void 0 : model8.inputs[0].shape) ? model8.inputs[0].shape[2] : 0;
        if (((_b22 = config3.face.emotion) == null ? void 0 : _b22["crop"]) > 0) {
          const crop = (_c22 = config3.face.emotion) == null ? void 0 : _c22["crop"];
          const box = [[crop, crop, 1 - crop, 1 - crop]];
          t8.resize = Fj.cropAndResize(image, box, [0], [inputSize10, inputSize10]);
        } else {
          t8.resize = Fj.resizeBilinear(image, [inputSize10, inputSize10], false);
        }
        if (rgb) {
          t8.mul = se(t8.resize, 255);
          t8.normalize = Te(t8.mul, [103.939, 116.779, 123.68]);
          t8.emotion = model8 == null ? void 0 : model8.execute(t8.normalize);
        } else {
          t8.channels = se(t8.resize, constants.rgb);
          t8.grayscale = ot(t8.channels, 3, true);
          t8.grayscaleSub = Te(t8.grayscale, constants.tf05);
          t8.grayscaleMul = se(t8.grayscaleSub, constants.tf2);
          t8.emotion = model8 == null ? void 0 : model8.execute(t8.grayscaleMul);
        }
        lastTime4 = now();
        const data = await t8.emotion.data();
        for (let i10 = 0; i10 < data.length; i10++) {
          if (data[i10] > (config3.face.emotion.minConfidence || 0))
            obj.push({ score: Math.min(0.99, Math.trunc(100 * data[i10]) / 100), emotion: annotations[i10] });
        }
        obj.sort((a, b) => b.score - a.score);
        Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      }
      last3[idx] = obj;
      lastCount = count2;
      resolve(obj);
    });
  }
  var model9;
  var last4 = [];
  var lastTime5 = 0;
  var lastCount2 = 0;
  var skipped5 = Number.MAX_SAFE_INTEGER;
  async function load7(config3) {
    var _a22;
    if (env.initial)
      model9 = null;
    if (!model9)
      model9 = await loadModel((_a22 = config3.face.description) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", model9["modelUrl"]);
    return model9;
  }
  function enhance(input, config3) {
    var _a22, _b2;
    const tensor = input.image || input.tensor || input;
    if (!(model9 == null ? void 0 : model9.inputs[0].shape))
      return tensor;
    let crop;
    if (((_a22 = config3.face.description) == null ? void 0 : _a22["crop"]) > 0) {
      const cropval = (_b2 = config3.face.description) == null ? void 0 : _b2["crop"];
      const box = [[cropval, cropval, 1 - cropval, 1 - cropval]];
      crop = Fj.cropAndResize(tensor, box, [0], [model9.inputs[0].shape[2], model9.inputs[0].shape[1]]);
    } else {
      crop = Fj.resizeBilinear(tensor, [model9.inputs[0].shape[2], model9.inputs[0].shape[1]], false);
    }
    const norm = se(crop, constants.tf255);
    Ot(crop);
    return norm;
  }
  async function predict6(image, config3, idx, count2) {
    var _a22, _b2, _c22, _d22;
    const obj = {
      age: 0,
      gender: "unknown",
      genderScore: 0,
      descriptor: []
    };
    if (!(model9 == null ? void 0 : model9["executor"]))
      return obj;
    const skipFrame = skipped5 < (((_a22 = config3.face.description) == null ? void 0 : _a22.skipFrames) || 0);
    const skipTime = (((_b2 = config3.face.description) == null ? void 0 : _b2.skipTime) || 0) > now() - lastTime5;
    if (config3.skipAllowed && skipFrame && skipTime && lastCount2 === count2 && ((_c22 = last4 == null ? void 0 : last4[idx]) == null ? void 0 : _c22.age) > 0 && ((_d22 = last4 == null ? void 0 : last4[idx]) == null ? void 0 : _d22.genderScore) > 0) {
      skipped5++;
      return last4[idx];
    }
    skipped5 = 0;
    return new Promise(async (resolve) => {
      var _a3;
      if ((_a3 = config3.face.description) == null ? void 0 : _a3.enabled) {
        const enhanced = enhance(image, config3);
        const resT = model9 == null ? void 0 : model9.execute(enhanced);
        lastTime5 = now();
        Ot(enhanced);
        const genderT = resT.find((t8) => t8.shape[1] === 1);
        const gender2 = await genderT.data();
        const confidence = Math.trunc(200 * Math.abs(gender2[0] - 0.5)) / 100;
        if (confidence > (config3.face.description.minConfidence || 0)) {
          obj.gender = gender2[0] <= 0.5 ? "female" : "male";
          obj.genderScore = Math.min(0.99, confidence);
        }
        const argmax = Sk(resT.find((t8) => t8.shape[1] === 100), 1);
        const ageIdx = (await argmax.data())[0];
        Ot(argmax);
        const ageT = resT.find((t8) => t8.shape[1] === 100);
        const all2 = await ageT.data();
        obj.age = Math.round(all2[ageIdx - 1] > all2[ageIdx + 1] ? 10 * ageIdx - 100 * all2[ageIdx - 1] : 10 * ageIdx + 100 * all2[ageIdx + 1]) / 10;
        if (Number.isNaN(gender2[0]) || Number.isNaN(all2[0]))
          log$1("faceres error:", { model: model9, result: resT });
        const desc = resT.find((t8) => t8.shape[1] === 1024);
        const descriptor = desc ? await desc.data() : [];
        obj.descriptor = Array.from(descriptor);
        resT.forEach((t8) => Ot(t8));
      }
      last4[idx] = obj;
      lastCount2 = count2;
      resolve(obj);
    });
  }
  var expandFact = 0.1;
  var alpha = 0.5;
  function insidePoly(x, y10, polygon) {
    let inside = false;
    let j = polygon.length - 1;
    for (let i10 = 0; i10 < polygon.length; j = i10++) {
      if (polygon[i10].y > y10 !== polygon[j].y > y10 && x < (polygon[j].x - polygon[i10].x) * (y10 - polygon[i10].y) / (polygon[j].y - polygon[i10].y) + polygon[i10].x)
        inside = !inside;
    }
    return inside;
  }
  async function mask(face4) {
    if (!face4.tensor)
      return face4.tensor;
    if (!face4.mesh || face4.mesh.length < 100)
      return face4.tensor;
    const width = face4.tensor.shape[2] || 0;
    const height = face4.tensor.shape[1] || 0;
    const buffer2 = await face4.tensor.buffer();
    let silhouette = [];
    for (const pt2 of meshAnnotations.silhouette)
      silhouette.push({ x: (face4.mesh[pt2][0] - face4.box[0]) / face4.box[2], y: (face4.mesh[pt2][1] - face4.box[1]) / face4.box[3] });
    silhouette = silhouette.map((pt2) => ({ x: pt2.x > 0.5 ? pt2.x + expandFact : pt2.x - expandFact, y: pt2.y > 0.5 ? pt2.y + expandFact : pt2.y - expandFact }));
    for (let x = 0; x < width; x++) {
      for (let y10 = 0; y10 < height; y10++) {
        const inside = insidePoly(x / width, y10 / width, silhouette);
        if (!inside) {
          buffer2.set(alpha * buffer2.get(0, y10, x, 0), 0, y10, x, 0);
          buffer2.set(alpha * buffer2.get(0, y10, x, 1), 0, y10, x, 1);
          buffer2.set(alpha * buffer2.get(0, y10, x, 2), 0, y10, x, 2);
        }
      }
    }
    const output = buffer2.toTensor();
    return output;
  }
  var model10;
  var cached = [];
  var skipped6 = Number.MAX_SAFE_INTEGER;
  var lastCount3 = 0;
  var lastTime6 = 0;
  async function load8(config3) {
    var _a22;
    if (env.initial)
      model10 = null;
    if (!model10)
      model10 = await loadModel((_a22 = config3.face.antispoof) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", model10["modelUrl"]);
    return model10;
  }
  async function predict7(image, config3, idx, count2) {
    var _a22, _b2;
    if (!(model10 == null ? void 0 : model10["executor"]))
      return 0;
    const skipTime = (((_a22 = config3.face.antispoof) == null ? void 0 : _a22.skipTime) || 0) > now() - lastTime6;
    const skipFrame = skipped6 < (((_b2 = config3.face.antispoof) == null ? void 0 : _b2.skipFrames) || 0);
    if (config3.skipAllowed && skipTime && skipFrame && lastCount3 === count2 && cached[idx]) {
      skipped6++;
      return cached[idx];
    }
    skipped6 = 0;
    return new Promise(async (resolve) => {
      const resize = Fj.resizeBilinear(image, [(model10 == null ? void 0 : model10.inputs[0].shape) ? model10.inputs[0].shape[2] : 0, (model10 == null ? void 0 : model10.inputs[0].shape) ? model10.inputs[0].shape[1] : 0], false);
      const res = model10 == null ? void 0 : model10.execute(resize);
      const num = (await res.data())[0];
      cached[idx] = Math.round(100 * num) / 100;
      lastCount3 = count2;
      lastTime6 = now();
      Ot([resize, res]);
      resolve(cached[idx]);
    });
  }
  var model11;
  var cached2 = [];
  var skipped7 = Number.MAX_SAFE_INTEGER;
  var lastCount4 = 0;
  var lastTime7 = 0;
  async function load9(config3) {
    var _a22;
    if (env.initial)
      model11 = null;
    if (!model11)
      model11 = await loadModel((_a22 = config3.face.liveness) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", model11["modelUrl"]);
    return model11;
  }
  async function predict8(image, config3, idx, count2) {
    var _a22, _b2;
    if (!(model11 == null ? void 0 : model11["executor"]))
      return 0;
    const skipTime = (((_a22 = config3.face.liveness) == null ? void 0 : _a22.skipTime) || 0) > now() - lastTime7;
    const skipFrame = skipped7 < (((_b2 = config3.face.liveness) == null ? void 0 : _b2.skipFrames) || 0);
    if (config3.skipAllowed && skipTime && skipFrame && lastCount4 === count2 && cached2[idx]) {
      skipped7++;
      return cached2[idx];
    }
    skipped7 = 0;
    return new Promise(async (resolve) => {
      const resize = Fj.resizeBilinear(image, [(model11 == null ? void 0 : model11.inputs[0].shape) ? model11.inputs[0].shape[2] : 0, (model11 == null ? void 0 : model11.inputs[0].shape) ? model11.inputs[0].shape[1] : 0], false);
      const res = model11 == null ? void 0 : model11.execute(resize);
      const num = (await res.data())[0];
      cached2[idx] = Math.round(100 * num) / 100;
      lastCount4 = count2;
      lastTime7 = now();
      Ot([resize, res]);
      resolve(cached2[idx]);
    });
  }
  var model12;
  var last5 = [];
  var raceNames = ["white", "black", "asian", "indian", "other"];
  var ageWeights = [15, 23, 28, 35.5, 45.5, 55.5, 65];
  var lastCount5 = 0;
  var lastTime8 = 0;
  var skipped8 = Number.MAX_SAFE_INTEGER;
  async function load10(config3) {
    var _a22;
    if (env.initial)
      model12 = null;
    if (!model12)
      model12 = await loadModel((_a22 = config3.face.gear) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", model12["modelUrl"]);
    return model12;
  }
  async function predict9(image, config3, idx, count2) {
    var _a22, _b2;
    if (!model12)
      return { age: 0, gender: "unknown", genderScore: 0, race: [] };
    const skipFrame = skipped8 < (((_a22 = config3.face.gear) == null ? void 0 : _a22.skipFrames) || 0);
    const skipTime = (((_b2 = config3.face.gear) == null ? void 0 : _b2.skipTime) || 0) > now() - lastTime8;
    if (config3.skipAllowed && skipTime && skipFrame && lastCount5 === count2 && last5[idx]) {
      skipped8++;
      return last5[idx];
    }
    skipped8 = 0;
    return new Promise(async (resolve) => {
      var _a3, _b22, _c22, _d22;
      if (!(model12 == null ? void 0 : model12.inputs[0].shape))
        return;
      const t8 = {};
      let box = [[0, 0.1, 0.9, 0.9]];
      if (((_a3 = config3.face.gear) == null ? void 0 : _a3["crop"]) > 0) {
        const crop = (_b22 = config3.face.gear) == null ? void 0 : _b22["crop"];
        box = [[crop, crop, 1 - crop, 1 - crop]];
      }
      t8.resize = Fj.cropAndResize(image, box, [0], [model12.inputs[0].shape[2], model12.inputs[0].shape[1]]);
      const obj = { age: 0, gender: "unknown", genderScore: 0, race: [] };
      if ((_c22 = config3.face.gear) == null ? void 0 : _c22.enabled)
        [t8.age, t8.gender, t8.race] = model12.execute(t8.resize, ["age_output", "gender_output", "race_output"]);
      const gender2 = await t8.gender.data();
      obj.gender = gender2[0] > gender2[1] ? "male" : "female";
      obj.genderScore = Math.round(100 * (gender2[0] > gender2[1] ? gender2[0] : gender2[1])) / 100;
      const race = await t8.race.data();
      for (let i10 = 0; i10 < race.length; i10++) {
        if (race[i10] > (((_d22 = config3.face.gear) == null ? void 0 : _d22.minConfidence) || 0.2))
          obj.race.push({ score: Math.round(100 * race[i10]) / 100, race: raceNames[i10] });
      }
      obj.race.sort((a, b) => b.score - a.score);
      const ageDistribution = Array.from(await t8.age.data());
      const ageSorted = ageDistribution.map((a, i10) => [ageWeights[i10], a]).sort((a, b) => b[1] - a[1]);
      let age2 = ageSorted[0][0];
      for (let i10 = 1; i10 < ageSorted.length; i10++)
        age2 += ageSorted[i10][1] * (ageSorted[i10][0] - age2);
      obj.age = Math.round(10 * age2) / 10;
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      last5[idx] = obj;
      lastCount5 = count2;
      lastTime8 = now();
      resolve(obj);
    });
  }
  var model13;
  var last6 = [];
  var lastCount6 = 0;
  var lastTime9 = 0;
  var skipped9 = Number.MAX_SAFE_INTEGER;
  async function load11(config3) {
    if (env.initial)
      model13 = null;
    if (!model13)
      model13 = await loadModel(config3.face["ssrnet"].modelPathAge);
    else if (config3.debug)
      log$1("cached model:", model13["modelUrl"]);
    return model13;
  }
  async function predict10(image, config3, idx, count2) {
    var _a22, _b2, _c22, _d22;
    if (!model13)
      return { age: 0 };
    const skipFrame = skipped9 < (((_a22 = config3.face["ssrnet"]) == null ? void 0 : _a22.skipFrames) || 0);
    const skipTime = (((_b2 = config3.face["ssrnet"]) == null ? void 0 : _b2.skipTime) || 0) > now() - lastTime9;
    if (config3.skipAllowed && skipFrame && skipTime && lastCount6 === count2 && ((_c22 = last6[idx]) == null ? void 0 : _c22.age) && ((_d22 = last6[idx]) == null ? void 0 : _d22.age) > 0) {
      skipped9++;
      return last6[idx];
    }
    skipped9 = 0;
    return new Promise(async (resolve) => {
      var _a3, _b22, _c3;
      if (!(model13 == null ? void 0 : model13.inputs) || !model13.inputs[0] || !model13.inputs[0].shape)
        return;
      const t8 = {};
      if (((_a3 = config3.face["ssrnet"]) == null ? void 0 : _a3["crop"]) > 0) {
        const crop = (_b22 = config3.face["ssrnet"]) == null ? void 0 : _b22["crop"];
        const box = [[crop, crop, 1 - crop, 1 - crop]];
        t8.resize = Fj.cropAndResize(image, box, [0], [model13.inputs[0].shape[2], model13.inputs[0].shape[1]]);
      } else {
        t8.resize = Fj.resizeBilinear(image, [model13.inputs[0].shape[2], model13.inputs[0].shape[1]], false);
      }
      t8.enhance = se(t8.resize, constants.tf255);
      const obj = { age: 0 };
      if ((_c3 = config3.face["ssrnet"]) == null ? void 0 : _c3.enabled)
        t8.age = model13.execute(t8.enhance);
      if (t8.age) {
        const data = await t8.age.data();
        obj.age = Math.trunc(10 * data[0]) / 10;
      }
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      last6[idx] = obj;
      lastCount6 = count2;
      lastTime9 = now();
      resolve(obj);
    });
  }
  var model14;
  var last7 = [];
  var lastCount7 = 0;
  var lastTime10 = 0;
  var skipped10 = Number.MAX_SAFE_INTEGER;
  var rgb2 = [0.2989, 0.587, 0.114];
  async function load12(config3) {
    var _a22;
    if (env.initial)
      model14 = null;
    if (!model14)
      model14 = await loadModel((_a22 = config3.face["ssrnet"]) == null ? void 0 : _a22.modelPathGender);
    else if (config3.debug)
      log$1("cached model:", model14["modelUrl"]);
    return model14;
  }
  async function predict11(image, config3, idx, count2) {
    var _a22, _b2, _c22, _d22;
    if (!model14)
      return { gender: "unknown", genderScore: 0 };
    const skipFrame = skipped10 < (((_a22 = config3.face["ssrnet"]) == null ? void 0 : _a22.skipFrames) || 0);
    const skipTime = (((_b2 = config3.face["ssrnet"]) == null ? void 0 : _b2.skipTime) || 0) > now() - lastTime10;
    if (config3.skipAllowed && skipFrame && skipTime && lastCount7 === count2 && ((_c22 = last7[idx]) == null ? void 0 : _c22.gender) && ((_d22 = last7[idx]) == null ? void 0 : _d22.genderScore) > 0) {
      skipped10++;
      return last7[idx];
    }
    skipped10 = 0;
    return new Promise(async (resolve) => {
      var _a3, _b22, _c3;
      if (!(model14 == null ? void 0 : model14.inputs[0].shape))
        return;
      const t8 = {};
      if (((_a3 = config3.face["ssrnet"]) == null ? void 0 : _a3["crop"]) > 0) {
        const crop = (_b22 = config3.face["ssrnet"]) == null ? void 0 : _b22["crop"];
        const box = [[crop, crop, 1 - crop, 1 - crop]];
        t8.resize = Fj.cropAndResize(image, box, [0], [model14.inputs[0].shape[2], model14.inputs[0].shape[1]]);
      } else {
        t8.resize = Fj.resizeBilinear(image, [model14.inputs[0].shape[2], model14.inputs[0].shape[1]], false);
      }
      t8.enhance = De(() => {
        var _a4, _b3;
        let normalize2;
        if (((_b3 = (_a4 = model14 == null ? void 0 : model14.inputs) == null ? void 0 : _a4[0].shape) == null ? void 0 : _b3[3]) === 1) {
          const [red, green, blue] = pi(t8.resize, 3, 3);
          const redNorm = se(red, rgb2[0]);
          const greenNorm = se(green, rgb2[1]);
          const blueNorm = se(blue, rgb2[2]);
          const grayscale = bk([redNorm, greenNorm, blueNorm]);
          normalize2 = se(Te(grayscale, constants.tf05), 2);
        } else {
          normalize2 = se(Te(t8.resize, constants.tf05), 2);
        }
        return normalize2;
      });
      const obj = { gender: "unknown", genderScore: 0 };
      if ((_c3 = config3.face["ssrnet"]) == null ? void 0 : _c3.enabled)
        t8.gender = model14.execute(t8.enhance);
      const data = await t8.gender.data();
      obj.gender = data[0] > data[1] ? "female" : "male";
      obj.genderScore = data[0] > data[1] ? Math.trunc(100 * data[0]) / 100 : Math.trunc(100 * data[1]) / 100;
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      last7[idx] = obj;
      lastCount7 = count2;
      lastTime10 = now();
      resolve(obj);
    });
  }
  var model15;
  var last8 = [];
  var lastCount8 = 0;
  var lastTime11 = 0;
  var skipped11 = Number.MAX_SAFE_INTEGER;
  async function load13(config3) {
    var _a22;
    if (env.initial)
      model15 = null;
    if (!model15)
      model15 = await loadModel((_a22 = config3.face["mobilefacenet"]) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", model15["modelUrl"]);
    return model15;
  }
  async function predict12(input, config3, idx, count2) {
    var _a22, _b2;
    if (!(model15 == null ? void 0 : model15["executor"]))
      return [];
    const skipFrame = skipped11 < (((_a22 = config3.face["mobilefacenet"]) == null ? void 0 : _a22.skipFrames) || 0);
    const skipTime = (((_b2 = config3.face["mobilefacenet"]) == null ? void 0 : _b2.skipTime) || 0) > now() - lastTime11;
    if (config3.skipAllowed && skipTime && skipFrame && lastCount8 === count2 && last8[idx]) {
      skipped11++;
      return last8[idx];
    }
    return new Promise(async (resolve) => {
      var _a3;
      let data = [];
      if (((_a3 = config3.face["mobilefacenet"]) == null ? void 0 : _a3.enabled) && (model15 == null ? void 0 : model15.inputs[0].shape)) {
        const t8 = {};
        t8.crop = Fj.resizeBilinear(input, [model15.inputs[0].shape[2], model15.inputs[0].shape[1]], false);
        t8.data = model15.execute(t8.crop);
        const output = await t8.data.data();
        data = Array.from(output);
        Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      }
      last8[idx] = data;
      lastCount8 = count2;
      lastTime11 = now();
      resolve(data);
    });
  }
  var model16;
  var last9 = [];
  var lastCount9 = 0;
  var lastTime12 = 0;
  var skipped12 = Number.MAX_SAFE_INTEGER;
  async function load14(config3) {
    if (env.initial)
      model16 = null;
    if (!model16)
      model16 = await loadModel(config3.face["insightface"].modelPath);
    else if (config3.debug)
      log$1("cached model:", model16["modelUrl"]);
    return model16;
  }
  async function predict13(input, config3, idx, count2) {
    var _a22, _b2;
    if (!(model16 == null ? void 0 : model16["executor"]))
      return [];
    const skipFrame = skipped12 < (((_a22 = config3.face["insightface"]) == null ? void 0 : _a22.skipFrames) || 0);
    const skipTime = (((_b2 = config3.face["insightface"]) == null ? void 0 : _b2.skipTime) || 0) > now() - lastTime12;
    if (config3.skipAllowed && skipTime && skipFrame && lastCount9 === count2 && last9[idx]) {
      skipped12++;
      return last9[idx];
    }
    return new Promise(async (resolve) => {
      var _a3;
      let data = [];
      if (((_a3 = config3.face["insightface"]) == null ? void 0 : _a3.enabled) && (model16 == null ? void 0 : model16.inputs[0].shape)) {
        const t8 = {};
        t8.crop = Fj.resizeBilinear(input, [model16.inputs[0].shape[2], model16.inputs[0].shape[1]], false);
        t8.data = model16.execute(t8.crop);
        const output = await t8.data.data();
        data = Array.from(output);
        Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      }
      last9[idx] = data;
      lastCount9 = count2;
      lastTime12 = now();
      resolve(data);
    });
  }
  var calculateGaze = (face4) => {
    const radians = (pt1, pt2) => Math.atan2(pt1[1] - pt2[1], pt1[0] - pt2[0]);
    if (!face4.annotations.rightEyeIris || !face4.annotations.leftEyeIris)
      return { bearing: 0, strength: 0 };
    const offsetIris = [0, -0.1];
    const eyeRatio = 1;
    const left = (face4.mesh[33][2] || 0) > (face4.mesh[263][2] || 0);
    const irisCenter = left ? face4.mesh[473] : face4.mesh[468];
    const eyeCenter = left ? [(face4.mesh[133][0] + face4.mesh[33][0]) / 2, (face4.mesh[133][1] + face4.mesh[33][1]) / 2] : [(face4.mesh[263][0] + face4.mesh[362][0]) / 2, (face4.mesh[263][1] + face4.mesh[362][1]) / 2];
    const eyeSize = left ? [face4.mesh[133][0] - face4.mesh[33][0], face4.mesh[23][1] - face4.mesh[27][1]] : [face4.mesh[263][0] - face4.mesh[362][0], face4.mesh[253][1] - face4.mesh[257][1]];
    const eyeDiff = [
      // x distance between extreme point and center point normalized with eye size
      (eyeCenter[0] - irisCenter[0]) / eyeSize[0] - offsetIris[0],
      eyeRatio * (irisCenter[1] - eyeCenter[1]) / eyeSize[1] - offsetIris[1]
    ];
    let strength = Math.sqrt(eyeDiff[0] * eyeDiff[0] + eyeDiff[1] * eyeDiff[1]);
    strength = Math.min(strength, face4.boxRaw[2] / 2, face4.boxRaw[3] / 2);
    const bearing = (radians([0, 0], eyeDiff) + Math.PI / 2) % Math.PI;
    return { bearing, strength };
  };
  var calculateFaceAngle = (face4, imageSize) => {
    const normalize2 = (v10) => {
      const length = Math.sqrt(v10[0] * v10[0] + v10[1] * v10[1] + v10[2] * v10[2]);
      v10[0] /= length;
      v10[1] /= length;
      v10[2] /= length;
      return v10;
    };
    const subVectors = (a, b) => {
      const x = a[0] - b[0];
      const y10 = a[1] - b[1];
      const z = a[2] - b[2];
      return [x, y10, z];
    };
    const crossVectors = (a, b) => {
      const x = a[1] * b[2] - a[2] * b[1];
      const y10 = a[2] * b[0] - a[0] * b[2];
      const z = a[0] * b[1] - a[1] * b[0];
      return [x, y10, z];
    };
    const rotationMatrixToEulerAngle = (r8) => {
      const [r00, _r01, _r02, r10, r11, r12, r20, r21, r22] = r8;
      let thetaX;
      let thetaY;
      let thetaZ;
      if (r10 < 1) {
        if (r10 > -1) {
          thetaZ = Math.asin(r10);
          thetaY = Math.atan2(-r20, r00);
          thetaX = Math.atan2(-r12, r11);
        } else {
          thetaZ = -Math.PI / 2;
          thetaY = -Math.atan2(r21, r22);
          thetaX = 0;
        }
      } else {
        thetaZ = Math.PI / 2;
        thetaY = Math.atan2(r21, r22);
        thetaX = 0;
      }
      if (Number.isNaN(thetaX))
        thetaX = 0;
      if (Number.isNaN(thetaY))
        thetaY = 0;
      if (Number.isNaN(thetaZ))
        thetaZ = 0;
      return { pitch: 2 * -thetaX, yaw: 2 * -thetaY, roll: 2 * -thetaZ };
    };
    const mesh = face4.meshRaw;
    if (!mesh || mesh.length < 300)
      return { angle: { pitch: 0, yaw: 0, roll: 0 }, matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1], gaze: { bearing: 0, strength: 0 } };
    const size2 = Math.max(face4.boxRaw[2] * imageSize[0], face4.boxRaw[3] * imageSize[1]) / 1.5;
    const pts = [mesh[10], mesh[152], mesh[234], mesh[454]].map((pt2) => [pt2[0] * imageSize[0] / size2, pt2[1] * imageSize[1] / size2, pt2[2]]);
    const yAxis = normalize2(subVectors(pts[1], pts[0]));
    let xAxis = normalize2(subVectors(pts[3], pts[2]));
    const zAxis = normalize2(crossVectors(xAxis, yAxis));
    xAxis = crossVectors(yAxis, zAxis);
    const matrix = [
      xAxis[0],
      xAxis[1],
      xAxis[2],
      yAxis[0],
      yAxis[1],
      yAxis[2],
      zAxis[0],
      zAxis[1],
      zAxis[2]
    ];
    const angle = rotationMatrixToEulerAngle(matrix);
    const gaze = mesh.length === 478 ? calculateGaze(face4) : { bearing: 0, strength: 0 };
    return { angle, matrix, gaze };
  };
  function calculateCameraDistance(face4, width) {
    const f = face4 == null ? void 0 : face4.annotations;
    if (!(f == null ? void 0 : f.leftEyeIris) || !(f == null ? void 0 : f.rightEyeIris))
      return 0;
    const irisSize = Math.max(Math.abs(f.leftEyeIris[3][0] - f.leftEyeIris[1][0]), Math.abs(f.rightEyeIris[3][0] - f.rightEyeIris[1][0])) / width;
    const cameraDistance = Math.round(1.17 / irisSize) / 100;
    return cameraDistance;
  }
  var detectFace = async (instance, input) => {
    var _a22, _b2, _c22, _d22, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m, _n2, _o2, _p2, _q2, _r2, _s2, _t, _u, _v2, _w2;
    let timeStamp = now();
    let ageRes;
    let gearRes;
    let genderRes;
    let emotionRes;
    let mobilefacenetRes;
    let insightfaceRes;
    let antispoofRes;
    let livenessRes;
    let descRes;
    const faceRes = [];
    instance.state = "run:face";
    const faces = await predict4(input, instance.config);
    instance.performance.face = env.perfadd ? (instance.performance.face || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
    if (!input.shape || input.shape.length !== 4)
      return [];
    if (!faces)
      return [];
    for (let i10 = 0; i10 < faces.length; i10++) {
      instance.analyze("Get Face");
      if (!faces[i10].tensor || faces[i10].tensor.isDisposedInternal) {
        log$1("Face object is disposed:", faces[i10].tensor);
        continue;
      }
      if ((_a22 = instance.config.face.detector) == null ? void 0 : _a22.mask) {
        const masked = await mask(faces[i10]);
        Ot(faces[i10].tensor);
        if (masked)
          faces[i10].tensor = masked;
      }
      const rotation = faces[i10].mesh && faces[i10].mesh.length > 200 ? calculateFaceAngle(faces[i10], [input.shape[2], input.shape[1]]) : null;
      instance.analyze("Start Emotion:");
      if (instance.config.async) {
        emotionRes = ((_b2 = instance.config.face.emotion) == null ? void 0 : _b2.enabled) ? predict5(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : [];
      } else {
        instance.state = "run:emotion";
        timeStamp = now();
        emotionRes = ((_c22 = instance.config.face.emotion) == null ? void 0 : _c22.enabled) ? await predict5(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : [];
        instance.performance.emotion = env.perfadd ? (instance.performance.emotion || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
      }
      instance.analyze("End Emotion:");
      instance.analyze("Start AntiSpoof:");
      if (instance.config.async) {
        antispoofRes = ((_d22 = instance.config.face.antispoof) == null ? void 0 : _d22.enabled) ? predict7(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : 0;
      } else {
        instance.state = "run:antispoof";
        timeStamp = now();
        antispoofRes = ((_e = instance.config.face.antispoof) == null ? void 0 : _e.enabled) ? await predict7(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : 0;
        instance.performance.antispoof = env.perfadd ? (instance.performance.antispoof || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
      }
      instance.analyze("End AntiSpoof:");
      instance.analyze("Start Liveness:");
      if (instance.config.async) {
        livenessRes = ((_f2 = instance.config.face.liveness) == null ? void 0 : _f2.enabled) ? predict8(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : 0;
      } else {
        instance.state = "run:liveness";
        timeStamp = now();
        livenessRes = ((_g2 = instance.config.face.liveness) == null ? void 0 : _g2.enabled) ? await predict8(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : 0;
        instance.performance.liveness = env.perfadd ? (instance.performance.antispoof || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
      }
      instance.analyze("End Liveness:");
      instance.analyze("Start GEAR:");
      if (instance.config.async) {
        gearRes = ((_h2 = instance.config.face.gear) == null ? void 0 : _h2.enabled) ? predict9(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
      } else {
        instance.state = "run:gear";
        timeStamp = now();
        gearRes = ((_i2 = instance.config.face.gear) == null ? void 0 : _i2.enabled) ? await predict9(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
        instance.performance.gear = Math.trunc(now() - timeStamp);
      }
      instance.analyze("End GEAR:");
      instance.analyze("Start SSRNet:");
      if (instance.config.async) {
        ageRes = ((_j2 = instance.config.face["ssrnet"]) == null ? void 0 : _j2.enabled) ? predict10(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
        genderRes = ((_k2 = instance.config.face["ssrnet"]) == null ? void 0 : _k2.enabled) ? predict11(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
      } else {
        instance.state = "run:ssrnet";
        timeStamp = now();
        ageRes = ((_l2 = instance.config.face["ssrnet"]) == null ? void 0 : _l2.enabled) ? await predict10(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
        genderRes = ((_m = instance.config.face["ssrnet"]) == null ? void 0 : _m.enabled) ? await predict11(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
        instance.performance.ssrnet = Math.trunc(now() - timeStamp);
      }
      instance.analyze("End SSRNet:");
      instance.analyze("Start MobileFaceNet:");
      if (instance.config.async) {
        mobilefacenetRes = ((_n2 = instance.config.face["mobilefacenet"]) == null ? void 0 : _n2.enabled) ? predict12(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
      } else {
        instance.state = "run:mobilefacenet";
        timeStamp = now();
        mobilefacenetRes = ((_o2 = instance.config.face["mobilefacenet"]) == null ? void 0 : _o2.enabled) ? await predict12(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
        instance.performance.mobilefacenet = Math.trunc(now() - timeStamp);
      }
      instance.analyze("End MobileFaceNet:");
      instance.analyze("Start InsightFace:");
      if (instance.config.async) {
        insightfaceRes = ((_p2 = instance.config.face["insightface"]) == null ? void 0 : _p2.enabled) ? predict13(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
      } else {
        instance.state = "run:mobilefacenet";
        timeStamp = now();
        insightfaceRes = ((_q2 = instance.config.face["insightface"]) == null ? void 0 : _q2.enabled) ? await predict13(faces[i10].tensor || ir([]), instance.config, i10, faces.length) : null;
        instance.performance.mobilefacenet = Math.trunc(now() - timeStamp);
      }
      instance.analyze("End InsightFace:");
      instance.analyze("Start Description:");
      if (instance.config.async) {
        descRes = predict6(faces[i10].tensor || ir([]), instance.config, i10, faces.length);
      } else {
        instance.state = "run:description";
        timeStamp = now();
        descRes = await predict6(faces[i10].tensor || ir([]), instance.config, i10, faces.length);
        instance.performance.description = env.perfadd ? (instance.performance.description || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
      }
      instance.analyze("End Description:");
      if (instance.config.async) {
        [ageRes, genderRes, emotionRes, mobilefacenetRes, insightfaceRes, descRes, gearRes, antispoofRes, livenessRes] = await Promise.all([ageRes, genderRes, emotionRes, mobilefacenetRes, insightfaceRes, descRes, gearRes, antispoofRes, livenessRes]);
      }
      instance.analyze("Finish Face:");
      if (((_r2 = instance.config.face["ssrnet"]) == null ? void 0 : _r2.enabled) && ageRes && genderRes) {
        descRes = {
          ...descRes,
          age: ageRes.age,
          gender: genderRes.gender,
          genderScore: genderRes.genderScore
        };
      }
      if (((_s2 = instance.config.face.gear) == null ? void 0 : _s2.enabled) && gearRes) {
        descRes = {
          ...descRes,
          age: gearRes.age,
          gender: gearRes.gender,
          genderScore: gearRes.genderScore,
          race: gearRes.race
        };
      }
      if (((_t = instance.config.face["mobilefacenet"]) == null ? void 0 : _t.enabled) && mobilefacenetRes) {
        descRes.descriptor = mobilefacenetRes;
      }
      if (((_u = instance.config.face["insightface"]) == null ? void 0 : _u.enabled) && insightfaceRes) {
        descRes.descriptor = insightfaceRes;
      }
      const irisSize = ((_v2 = instance.config.face.iris) == null ? void 0 : _v2.enabled) ? calculateCameraDistance(faces[i10], input.shape[2]) : 0;
      const tensor = ((_w2 = instance.config.face.detector) == null ? void 0 : _w2.return) ? mc(faces[i10].tensor) : null;
      Ot(faces[i10].tensor);
      if (faces[i10].tensor)
        delete faces[i10].tensor;
      const res = {
        ...faces[i10],
        id: i10
      };
      if (descRes.age)
        res.age = descRes.age;
      if (descRes.gender)
        res.gender = descRes.gender;
      if (descRes.genderScore)
        res.genderScore = descRes.genderScore;
      if (descRes.descriptor)
        res.embedding = descRes.descriptor;
      if (descRes.race)
        res.race = descRes.race;
      if (emotionRes)
        res.emotion = emotionRes;
      if (antispoofRes)
        res.real = antispoofRes;
      if (livenessRes)
        res.live = livenessRes;
      if (irisSize > 0)
        res.distance = irisSize;
      if (rotation)
        res.rotation = rotation;
      if (tensor)
        res.tensor = tensor;
      faceRes.push(res);
      instance.analyze("End Face");
    }
    instance.analyze("End FaceMesh:");
    if (instance.config.async) {
      if (instance.performance.face)
        delete instance.performance.face;
      if (instance.performance.age)
        delete instance.performance.age;
      if (instance.performance.gender)
        delete instance.performance.gender;
      if (instance.performance.emotion)
        delete instance.performance.emotion;
    }
    return faceRes;
  };
  var Finger = {
    thumb: 0,
    index: 1,
    middle: 2,
    ring: 3,
    pinky: 4,
    all: [0, 1, 2, 3, 4],
    // just for convenience
    nameMapping: { 0: "thumb", 1: "index", 2: "middle", 3: "ring", 4: "pinky" },
    // Describes mapping of joints based on the 21 points returned by handpose.
    // [0]     Palm
    // [1-4]   Thumb
    // [5-8]   Index
    // [9-12]  Middle
    // [13-16] Ring
    // [17-20] Pinky
    pointsMapping: {
      0: [[0, 1], [1, 2], [2, 3], [3, 4]],
      1: [[0, 5], [5, 6], [6, 7], [7, 8]],
      2: [[0, 9], [9, 10], [10, 11], [11, 12]],
      3: [[0, 13], [13, 14], [14, 15], [15, 16]],
      4: [[0, 17], [17, 18], [18, 19], [19, 20]]
    },
    getName: (value) => Finger.nameMapping[value],
    getPoints: (value) => Finger.pointsMapping[value]
  };
  var FingerCurl = {
    none: 0,
    half: 1,
    full: 2,
    nameMapping: { 0: "none", 1: "half", 2: "full" },
    getName: (value) => FingerCurl.nameMapping[value]
  };
  var FingerDirection = {
    verticalUp: 0,
    verticalDown: 1,
    horizontalLeft: 2,
    horizontalRight: 3,
    diagonalUpRight: 4,
    diagonalUpLeft: 5,
    diagonalDownRight: 6,
    diagonalDownLeft: 7,
    nameMapping: { 0: "verticalUp", 1: "verticalDown", 2: "horizontalLeft", 3: "horizontalRight", 4: "diagonalUpRight", 5: "diagonalUpLeft", 6: "diagonalDownRight", 7: "diagonalDownLeft" },
    getName: (value) => FingerDirection.nameMapping[value]
  };
  var FingerGesture = class {
    constructor(name2) {
      __publicField2(this, "name");
      __publicField2(this, "curls");
      __publicField2(this, "directions");
      __publicField2(this, "weights");
      __publicField2(this, "weightsRelative");
      this.name = name2;
      this.curls = {};
      this.directions = {};
      this.weights = [1, 1, 1, 1, 1];
      this.weightsRelative = [1, 1, 1, 1, 1];
    }
    curl(finger, curl, confidence) {
      if (typeof this.curls[finger] === "undefined")
        this.curls[finger] = [];
      this.curls[finger].push([curl, confidence]);
    }
    direction(finger, position, confidence) {
      if (!this.directions[finger])
        this.directions[finger] = [];
      this.directions[finger].push([position, confidence]);
    }
    weight(finger, weight) {
      this.weights[finger] = weight;
      const total = this.weights.reduce((a, b) => a + b, 0);
      this.weightsRelative = this.weights.map((el2) => el2 * 5 / total);
    }
    matchAgainst(detectedCurls, detectedDirections) {
      let confidence = 0;
      for (const fingerIdx in detectedCurls) {
        const detectedCurl = detectedCurls[fingerIdx];
        const expectedCurls = this.curls[fingerIdx];
        if (typeof expectedCurls === "undefined") {
          confidence += this.weightsRelative[fingerIdx];
          continue;
        }
        for (const [expectedCurl, score] of expectedCurls) {
          if (detectedCurl === expectedCurl) {
            confidence += score * this.weightsRelative[fingerIdx];
            break;
          }
        }
      }
      for (const fingerIdx in detectedDirections) {
        const detectedDirection = detectedDirections[fingerIdx];
        const expectedDirections = this.directions[fingerIdx];
        if (typeof expectedDirections === "undefined") {
          confidence += this.weightsRelative[fingerIdx];
          continue;
        }
        for (const [expectedDirection, score] of expectedDirections) {
          if (detectedDirection === expectedDirection) {
            confidence += score * this.weightsRelative[fingerIdx];
            break;
          }
        }
      }
      return confidence / 10;
    }
  };
  var { thumb, index, middle, ring, pinky } = Finger;
  var { none, half, full } = FingerCurl;
  var { verticalUp, verticalDown, horizontalLeft, horizontalRight, diagonalUpRight, diagonalUpLeft, diagonalDownRight, diagonalDownLeft } = FingerDirection;
  var ThumbsUp = new FingerGesture("thumbs up");
  ThumbsUp.curl(thumb, none, 1);
  ThumbsUp.direction(thumb, verticalUp, 1);
  ThumbsUp.direction(thumb, diagonalUpLeft, 0.25);
  ThumbsUp.direction(thumb, diagonalUpRight, 0.25);
  for (const finger of [Finger.index, Finger.middle, Finger.ring, Finger.pinky]) {
    ThumbsUp.curl(finger, full, 1);
    ThumbsUp.direction(finger, horizontalLeft, 1);
    ThumbsUp.direction(finger, horizontalRight, 1);
  }
  var Victory = new FingerGesture("victory");
  Victory.curl(thumb, half, 0.5);
  Victory.curl(thumb, none, 0.5);
  Victory.direction(thumb, verticalUp, 1);
  Victory.direction(thumb, diagonalUpLeft, 1);
  Victory.curl(index, none, 1);
  Victory.direction(index, verticalUp, 0.75);
  Victory.direction(index, diagonalUpLeft, 1);
  Victory.curl(middle, none, 1);
  Victory.direction(middle, verticalUp, 1);
  Victory.direction(middle, diagonalUpLeft, 0.75);
  Victory.curl(ring, full, 1);
  Victory.direction(ring, verticalUp, 0.2);
  Victory.direction(ring, diagonalUpLeft, 1);
  Victory.direction(ring, horizontalLeft, 0.2);
  Victory.curl(pinky, full, 1);
  Victory.direction(pinky, verticalUp, 0.2);
  Victory.direction(pinky, diagonalUpLeft, 1);
  Victory.direction(pinky, horizontalLeft, 0.2);
  Victory.weight(index, 2);
  Victory.weight(middle, 2);
  var Point = new FingerGesture("point");
  Point.curl(thumb, full, 1);
  Point.curl(index, none, 0.5);
  Point.curl(middle, full, 0.5);
  Point.curl(ring, full, 0.5);
  Point.curl(pinky, full, 0.5);
  Point.weight(index, 2);
  Point.weight(middle, 2);
  var MiddleFinger = new FingerGesture("middle finger");
  MiddleFinger.curl(thumb, none, 1);
  MiddleFinger.curl(index, full, 0.5);
  MiddleFinger.curl(middle, full, 0.5);
  MiddleFinger.curl(ring, full, 0.5);
  MiddleFinger.curl(pinky, full, 0.5);
  MiddleFinger.weight(index, 2);
  MiddleFinger.weight(middle, 2);
  var OpenPalm = new FingerGesture("open palm");
  OpenPalm.curl(thumb, none, 0.75);
  OpenPalm.curl(index, none, 0.75);
  OpenPalm.curl(middle, none, 0.75);
  OpenPalm.curl(ring, none, 0.75);
  OpenPalm.curl(pinky, none, 0.75);
  var fingergesture_default = [ThumbsUp, Victory, Point, MiddleFinger, OpenPalm];
  var minConfidence = 0.7;
  var options3 = {
    // curl estimation
    HALF_CURL_START_LIMIT: 60,
    NO_CURL_START_LIMIT: 130,
    // direction estimation
    DISTANCE_VOTE_POWER: 1.1,
    SINGLE_ANGLE_VOTE_POWER: 0.9,
    TOTAL_ANGLE_VOTE_POWER: 1.6
  };
  function calculateSlope(point1x, point1y, point2x, point2y) {
    const value = (point1y - point2y) / (point1x - point2x);
    let slope = Math.atan(value) * 180 / Math.PI;
    if (slope <= 0)
      slope = -slope;
    else if (slope > 0)
      slope = 180 - slope;
    return slope;
  }
  function getSlopes(point1, point2) {
    if (!point1 || !point2)
      return [0, 0];
    const slopeXY = calculateSlope(point1[0], point1[1], point2[0], point2[1]);
    if (point1.length === 2)
      return slopeXY;
    const slopeYZ = calculateSlope(point1[1], point1[2], point2[1], point2[2]);
    return [slopeXY, slopeYZ];
  }
  function angleOrientationAt(angle, weightageAt = 1) {
    let isVertical = 0;
    let isDiagonal = 0;
    let isHorizontal = 0;
    if (angle >= 75 && angle <= 105)
      isVertical = 1 * weightageAt;
    else if (angle >= 25 && angle <= 155)
      isDiagonal = 1 * weightageAt;
    else
      isHorizontal = 1 * weightageAt;
    return [isVertical, isDiagonal, isHorizontal];
  }
  function estimateFingerCurl(startPoint, midPoint, endPoint) {
    const start_mid_x_dist = startPoint[0] - midPoint[0];
    const start_end_x_dist = startPoint[0] - endPoint[0];
    const mid_end_x_dist = midPoint[0] - endPoint[0];
    const start_mid_y_dist = startPoint[1] - midPoint[1];
    const start_end_y_dist = startPoint[1] - endPoint[1];
    const mid_end_y_dist = midPoint[1] - endPoint[1];
    const start_mid_z_dist = startPoint[2] - midPoint[2];
    const start_end_z_dist = startPoint[2] - endPoint[2];
    const mid_end_z_dist = midPoint[2] - endPoint[2];
    const start_mid_dist = Math.sqrt(start_mid_x_dist * start_mid_x_dist + start_mid_y_dist * start_mid_y_dist + start_mid_z_dist * start_mid_z_dist);
    const start_end_dist = Math.sqrt(start_end_x_dist * start_end_x_dist + start_end_y_dist * start_end_y_dist + start_end_z_dist * start_end_z_dist);
    const mid_end_dist = Math.sqrt(mid_end_x_dist * mid_end_x_dist + mid_end_y_dist * mid_end_y_dist + mid_end_z_dist * mid_end_z_dist);
    let cos_in = (mid_end_dist * mid_end_dist + start_mid_dist * start_mid_dist - start_end_dist * start_end_dist) / (2 * mid_end_dist * start_mid_dist);
    if (cos_in > 1)
      cos_in = 1;
    else if (cos_in < -1)
      cos_in = -1;
    let angleOfCurve = Math.acos(cos_in);
    angleOfCurve = 57.2958 * angleOfCurve % 180;
    let fingerCurl;
    if (angleOfCurve > options3.NO_CURL_START_LIMIT)
      fingerCurl = FingerCurl.none;
    else if (angleOfCurve > options3.HALF_CURL_START_LIMIT)
      fingerCurl = FingerCurl.half;
    else
      fingerCurl = FingerCurl.full;
    return fingerCurl;
  }
  function estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x) {
    let estimatedDirection;
    if (max_dist_x === Math.abs(start_end_x_dist)) {
      if (start_end_x_dist > 0)
        estimatedDirection = FingerDirection.horizontalLeft;
      else
        estimatedDirection = FingerDirection.horizontalRight;
    } else if (max_dist_x === Math.abs(start_mid_x_dist)) {
      if (start_mid_x_dist > 0)
        estimatedDirection = FingerDirection.horizontalLeft;
      else
        estimatedDirection = FingerDirection.horizontalRight;
    } else {
      if (mid_end_x_dist > 0)
        estimatedDirection = FingerDirection.horizontalLeft;
      else
        estimatedDirection = FingerDirection.horizontalRight;
    }
    return estimatedDirection;
  }
  function estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y) {
    let estimatedDirection;
    if (max_dist_y === Math.abs(start_end_y_dist)) {
      if (start_end_y_dist < 0)
        estimatedDirection = FingerDirection.verticalDown;
      else
        estimatedDirection = FingerDirection.verticalUp;
    } else if (max_dist_y === Math.abs(start_mid_y_dist)) {
      if (start_mid_y_dist < 0)
        estimatedDirection = FingerDirection.verticalDown;
      else
        estimatedDirection = FingerDirection.verticalUp;
    } else {
      if (mid_end_y_dist < 0)
        estimatedDirection = FingerDirection.verticalDown;
      else
        estimatedDirection = FingerDirection.verticalUp;
    }
    return estimatedDirection;
  }
  function estimateDiagonalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y, start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x) {
    let estimatedDirection;
    const reqd_vertical_direction = estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y);
    const reqd_horizontal_direction = estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
    if (reqd_vertical_direction === FingerDirection.verticalUp) {
      if (reqd_horizontal_direction === FingerDirection.horizontalLeft)
        estimatedDirection = FingerDirection.diagonalUpLeft;
      else
        estimatedDirection = FingerDirection.diagonalUpRight;
    } else {
      if (reqd_horizontal_direction === FingerDirection.horizontalLeft)
        estimatedDirection = FingerDirection.diagonalDownLeft;
      else
        estimatedDirection = FingerDirection.diagonalDownRight;
    }
    return estimatedDirection;
  }
  function calculateFingerDirection(startPoint, midPoint, endPoint, fingerSlopes) {
    const start_mid_x_dist = startPoint[0] - midPoint[0];
    const start_end_x_dist = startPoint[0] - endPoint[0];
    const mid_end_x_dist = midPoint[0] - endPoint[0];
    const start_mid_y_dist = startPoint[1] - midPoint[1];
    const start_end_y_dist = startPoint[1] - endPoint[1];
    const mid_end_y_dist = midPoint[1] - endPoint[1];
    const max_dist_x = Math.max(Math.abs(start_mid_x_dist), Math.abs(start_end_x_dist), Math.abs(mid_end_x_dist));
    const max_dist_y = Math.max(Math.abs(start_mid_y_dist), Math.abs(start_end_y_dist), Math.abs(mid_end_y_dist));
    let voteVertical = 0;
    let voteDiagonal = 0;
    let voteHorizontal = 0;
    const start_end_x_y_dist_ratio = max_dist_y / (max_dist_x + 1e-5);
    if (start_end_x_y_dist_ratio > 1.5)
      voteVertical += options3.DISTANCE_VOTE_POWER;
    else if (start_end_x_y_dist_ratio > 0.66)
      voteDiagonal += options3.DISTANCE_VOTE_POWER;
    else
      voteHorizontal += options3.DISTANCE_VOTE_POWER;
    const start_mid_dist = Math.sqrt(start_mid_x_dist * start_mid_x_dist + start_mid_y_dist * start_mid_y_dist);
    const start_end_dist = Math.sqrt(start_end_x_dist * start_end_x_dist + start_end_y_dist * start_end_y_dist);
    const mid_end_dist = Math.sqrt(mid_end_x_dist * mid_end_x_dist + mid_end_y_dist * mid_end_y_dist);
    const max_dist = Math.max(start_mid_dist, start_end_dist, mid_end_dist);
    let calc_start_point_x = startPoint[0];
    let calc_start_point_y = startPoint[1];
    let calc_end_point_x = endPoint[0];
    let calc_end_point_y = endPoint[1];
    if (max_dist === start_mid_dist) {
      calc_end_point_x = endPoint[0];
      calc_end_point_y = endPoint[1];
    } else if (max_dist === mid_end_dist) {
      calc_start_point_x = midPoint[0];
      calc_start_point_y = midPoint[1];
    }
    const calcStartPoint = [calc_start_point_x, calc_start_point_y];
    const calcEndPoint = [calc_end_point_x, calc_end_point_y];
    const totalAngle = getSlopes(calcStartPoint, calcEndPoint);
    const votes = angleOrientationAt(totalAngle, options3.TOTAL_ANGLE_VOTE_POWER);
    voteVertical += votes[0];
    voteDiagonal += votes[1];
    voteHorizontal += votes[2];
    for (const fingerSlope of fingerSlopes) {
      const fingerVotes = angleOrientationAt(fingerSlope, options3.SINGLE_ANGLE_VOTE_POWER);
      voteVertical += fingerVotes[0];
      voteDiagonal += fingerVotes[1];
      voteHorizontal += fingerVotes[2];
    }
    let estimatedDirection;
    if (voteVertical === Math.max(voteVertical, voteDiagonal, voteHorizontal)) {
      estimatedDirection = estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y);
    } else if (voteHorizontal === Math.max(voteDiagonal, voteHorizontal)) {
      estimatedDirection = estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
    } else {
      estimatedDirection = estimateDiagonalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y, start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x);
    }
    return estimatedDirection;
  }
  function estimate(landmarks) {
    const slopesXY = [];
    const fingerCurls = [];
    const fingerDirections = [];
    if (!landmarks)
      return { curls: fingerCurls, directions: fingerDirections };
    for (const finger of Finger.all) {
      const points = Finger.getPoints(finger);
      const slopeAtXY = [];
      for (const point2 of points) {
        const point1 = landmarks[point2[0]];
        const point22 = landmarks[point2[1]];
        const slopes = getSlopes(point1, point22);
        const slopeXY = slopes[0];
        slopes[1];
        slopeAtXY.push(slopeXY);
      }
      slopesXY.push(slopeAtXY);
    }
    for (const finger of Finger.all) {
      const pointIndexAt = finger === Finger.thumb ? 1 : 0;
      const fingerPointsAt = Finger.getPoints(finger);
      const startPoint = landmarks[fingerPointsAt[pointIndexAt][0]];
      const midPoint = landmarks[fingerPointsAt[pointIndexAt + 1][1]];
      const endPoint = landmarks[fingerPointsAt[3][1]];
      const fingerCurled = estimateFingerCurl(startPoint, midPoint, endPoint);
      const fingerPosition = calculateFingerDirection(startPoint, midPoint, endPoint, slopesXY[finger].slice(pointIndexAt));
      fingerCurls[finger] = fingerCurled;
      fingerDirections[finger] = fingerPosition;
    }
    return { curls: fingerCurls, directions: fingerDirections };
  }
  function analyze(keypoints) {
    if (!keypoints || keypoints.length === 0)
      return null;
    const estimatorRes = estimate(keypoints);
    const landmarks = {};
    for (const fingerIdx of Finger.all) {
      landmarks[Finger.getName(fingerIdx)] = {
        curl: FingerCurl.getName(estimatorRes.curls[fingerIdx]),
        direction: FingerDirection.getName(estimatorRes.directions[fingerIdx])
      };
    }
    return landmarks;
  }
  function match(keypoints) {
    const poses = [];
    if (!keypoints || keypoints.length === 0)
      return poses;
    const estimatorRes = estimate(keypoints);
    for (const gesture2 of fingergesture_default) {
      const confidence = gesture2.matchAgainst(estimatorRes.curls, estimatorRes.directions);
      if (confidence >= minConfidence)
        poses.push({ name: gesture2.name, confidence });
    }
    return poses;
  }
  var body2 = (res) => {
    if (!res)
      return [];
    const gestures = [];
    for (let i10 = 0; i10 < res.length; i10++) {
      const leftWrist = res[i10].keypoints.find((a) => a.part === "leftWrist");
      const rightWrist = res[i10].keypoints.find((a) => a.part === "rightWrist");
      const nose = res[i10].keypoints.find((a) => a.part === "nose");
      if (nose && leftWrist && rightWrist && leftWrist.position[1] < nose.position[1] && rightWrist.position[1] < nose.position[1])
        gestures.push({ body: i10, gesture: "i give up" });
      else if (nose && leftWrist && leftWrist.position[1] < nose.position[1])
        gestures.push({ body: i10, gesture: "raise left hand" });
      else if (nose && rightWrist && rightWrist.position[1] < nose.position[1])
        gestures.push({ body: i10, gesture: "raise right hand" });
      const leftShoulder = res[i10].keypoints.find((a) => a.part === "leftShoulder");
      const rightShoulder = res[i10].keypoints.find((a) => a.part === "rightShoulder");
      if (leftShoulder && rightShoulder && Math.abs(leftShoulder.positionRaw[1] - rightShoulder.positionRaw[1]) > 0.1) {
        gestures.push({ body: i10, gesture: `leaning ${leftShoulder.position[1] > rightShoulder.position[1] ? "left" : "right"}` });
      }
    }
    return gestures;
  };
  var face2 = (res) => {
    if (!res)
      return [];
    const gestures = [];
    for (let i10 = 0; i10 < res.length; i10++) {
      if (res[i10].mesh && res[i10].mesh.length > 450) {
        const zDiff = (res[i10].mesh[33][2] || 0) - (res[i10].mesh[263][2] || 0);
        const xDiff = res[i10].mesh[33][0] - res[i10].mesh[263][0];
        if (Math.abs(zDiff / xDiff) <= 0.15)
          gestures.push({ face: i10, gesture: "facing center" });
        else
          gestures.push({ face: i10, gesture: `facing ${zDiff < 0 ? "left" : "right"}` });
        const openLeft = Math.abs(res[i10].mesh[374][1] - res[i10].mesh[386][1]) / Math.abs(res[i10].mesh[443][1] - res[i10].mesh[450][1]);
        if (openLeft < 0.2)
          gestures.push({ face: i10, gesture: "blink left eye" });
        const openRight = Math.abs(res[i10].mesh[145][1] - res[i10].mesh[159][1]) / Math.abs(res[i10].mesh[223][1] - res[i10].mesh[230][1]);
        if (openRight < 0.2)
          gestures.push({ face: i10, gesture: "blink right eye" });
        const mouthOpen = Math.min(100, 500 * Math.abs(res[i10].mesh[13][1] - res[i10].mesh[14][1]) / Math.abs(res[i10].mesh[10][1] - res[i10].mesh[152][1]));
        if (mouthOpen > 10)
          gestures.push({ face: i10, gesture: `mouth ${Math.trunc(mouthOpen)}% open` });
        const chinDepth = res[i10].mesh[152][2] || 0;
        if (Math.abs(chinDepth) > 10)
          gestures.push({ face: i10, gesture: `head ${chinDepth < 0 ? "up" : "down"}` });
      }
    }
    return gestures;
  };
  var iris2 = (res) => {
    var _a22, _b2, _c22, _d22;
    if (!res)
      return [];
    const gestures = [];
    for (let i10 = 0; i10 < res.length; i10++) {
      if (!((_b2 = (_a22 = res[i10].annotations) == null ? void 0 : _a22.leftEyeIris) == null ? void 0 : _b2[0]) || !((_d22 = (_c22 = res[i10].annotations) == null ? void 0 : _c22.rightEyeIris) == null ? void 0 : _d22[0]))
        continue;
      const sizeXLeft = res[i10].annotations.leftEyeIris[3][0] - res[i10].annotations.leftEyeIris[1][0];
      const sizeYLeft = res[i10].annotations.leftEyeIris[4][1] - res[i10].annotations.leftEyeIris[2][1];
      const areaLeft = Math.abs(sizeXLeft * sizeYLeft);
      const sizeXRight = res[i10].annotations.rightEyeIris[3][0] - res[i10].annotations.rightEyeIris[1][0];
      const sizeYRight = res[i10].annotations.rightEyeIris[4][1] - res[i10].annotations.rightEyeIris[2][1];
      const areaRight = Math.abs(sizeXRight * sizeYRight);
      let center = false;
      const difference = Math.abs(areaLeft - areaRight) / Math.max(areaLeft, areaRight);
      if (difference < 0.25) {
        center = true;
        gestures.push({ iris: i10, gesture: "facing center" });
      }
      const leftIrisCenterX = Math.abs(res[i10].mesh[263][0] - res[i10].annotations.leftEyeIris[0][0]) / res[i10].box[2];
      const rightIrisCenterX = Math.abs(res[i10].mesh[33][0] - res[i10].annotations.rightEyeIris[0][0]) / res[i10].box[2];
      if (leftIrisCenterX > 0.06 || rightIrisCenterX > 0.06)
        center = false;
      if (leftIrisCenterX > rightIrisCenterX) {
        if (rightIrisCenterX > 0.04)
          gestures.push({ iris: i10, gesture: "looking right" });
      } else {
        if (leftIrisCenterX > 0.04)
          gestures.push({ iris: i10, gesture: "looking left" });
      }
      const rightIrisCenterY = Math.abs(res[i10].mesh[145][1] - res[i10].annotations.rightEyeIris[0][1]) / res[i10].box[3];
      const leftIrisCenterY = Math.abs(res[i10].mesh[374][1] - res[i10].annotations.leftEyeIris[0][1]) / res[i10].box[3];
      if (leftIrisCenterY < 0.01 || rightIrisCenterY < 0.01 || leftIrisCenterY > 0.022 || rightIrisCenterY > 0.022)
        center = false;
      if (leftIrisCenterY < 0.01 || rightIrisCenterY < 0.01)
        gestures.push({ iris: i10, gesture: "looking down" });
      if (leftIrisCenterY > 0.022 || rightIrisCenterY > 0.022)
        gestures.push({ iris: i10, gesture: "looking up" });
      if (center)
        gestures.push({ iris: i10, gesture: "looking center" });
    }
    return gestures;
  };
  var hand2 = (res) => {
    if (!res)
      return [];
    const gestures = [];
    for (let i10 = 0; i10 < res.length; i10++) {
      const fingers = [];
      if (res[i10].annotations) {
        for (const [finger, pos] of Object.entries(res[i10].annotations)) {
          if (finger !== "palmBase" && Array.isArray(pos) && pos[0])
            fingers.push({ name: finger.toLowerCase(), position: pos[0] });
        }
      }
      if (fingers && fingers.length > 0) {
        const closest = fingers.reduce((best, a) => (best.position[2] || 0) < (a.position[2] || 0) ? best : a);
        gestures.push({ hand: i10, gesture: `${closest.name} forward` });
        const highest = fingers.reduce((best, a) => best.position[1] < a.position[1] ? best : a);
        gestures.push({ hand: i10, gesture: `${highest.name} up` });
      }
      if (res[i10].keypoints) {
        const poses = match(res[i10].keypoints);
        for (const pose of poses)
          gestures.push({ hand: i10, gesture: pose.name });
      }
    }
    return gestures;
  };
  function getBoxSize2(box) {
    return [
      Math.abs(box.endPoint[0] - box.startPoint[0]),
      Math.abs(box.endPoint[1] - box.startPoint[1])
    ];
  }
  function getBoxCenter2(box) {
    return [
      box.startPoint[0] + (box.endPoint[0] - box.startPoint[0]) / 2,
      box.startPoint[1] + (box.endPoint[1] - box.startPoint[1]) / 2
    ];
  }
  function cutBoxFromImageAndResize(box, image, cropSize) {
    const h = image.shape[1];
    const w10 = image.shape[2];
    const boxes = [[
      box.startPoint[1] / h,
      box.startPoint[0] / w10,
      box.endPoint[1] / h,
      box.endPoint[0] / w10
    ]];
    return Fj.cropAndResize(image, boxes, [0], cropSize);
  }
  function scaleBoxCoordinates2(box, factor) {
    const startPoint = [box.startPoint[0] * factor[0], box.startPoint[1] * factor[1]];
    const endPoint = [box.endPoint[0] * factor[0], box.endPoint[1] * factor[1]];
    const palmLandmarks = box.palmLandmarks.map((coord) => {
      const scaledCoord = [coord[0] * factor[0], coord[1] * factor[1]];
      return scaledCoord;
    });
    return { startPoint, endPoint, palmLandmarks, confidence: box.confidence };
  }
  function enlargeBox2(box, factor = 1.5) {
    const center = getBoxCenter2(box);
    const size2 = getBoxSize2(box);
    const newHalfSize = [factor * size2[0] / 2, factor * size2[1] / 2];
    const startPoint = [center[0] - newHalfSize[0], center[1] - newHalfSize[1]];
    const endPoint = [center[0] + newHalfSize[0], center[1] + newHalfSize[1]];
    return { startPoint, endPoint, palmLandmarks: box.palmLandmarks };
  }
  function squarifyBox2(box) {
    const centers = getBoxCenter2(box);
    const size2 = getBoxSize2(box);
    const maxEdge = Math.max(...size2);
    const halfSize = maxEdge / 2;
    const startPoint = [centers[0] - halfSize, centers[1] - halfSize];
    const endPoint = [centers[0] + halfSize, centers[1] + halfSize];
    return { startPoint, endPoint, palmLandmarks: box.palmLandmarks };
  }
  function normalizeRadians2(angle) {
    return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));
  }
  function computeRotation2(point1, point2) {
    const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);
    return normalizeRadians2(radians);
  }
  var buildTranslationMatrix2 = (x, y10) => [[1, 0, x], [0, 1, y10], [0, 0, 1]];
  function dot2(v12, v22) {
    let product = 0;
    for (let i10 = 0; i10 < v12.length; i10++) {
      product += v12[i10] * v22[i10];
    }
    return product;
  }
  function getColumnFrom2DArr2(arr, columnIndex) {
    const column = [];
    for (let i10 = 0; i10 < arr.length; i10++) {
      column.push(arr[i10][columnIndex]);
    }
    return column;
  }
  function multiplyTransformMatrices2(mat1, mat2) {
    const product = [];
    const size2 = mat1.length;
    for (let row = 0; row < size2; row++) {
      product.push([]);
      for (let col = 0; col < size2; col++) {
        product[row].push(dot2(mat1[row], getColumnFrom2DArr2(mat2, col)));
      }
    }
    return product;
  }
  function buildRotationMatrix2(rotation, center) {
    const cosA = Math.cos(rotation);
    const sinA = Math.sin(rotation);
    const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
    const translationMatrix = buildTranslationMatrix2(center[0], center[1]);
    const translationTimesRotation = multiplyTransformMatrices2(translationMatrix, rotationMatrix);
    const negativeTranslationMatrix = buildTranslationMatrix2(-center[0], -center[1]);
    return multiplyTransformMatrices2(translationTimesRotation, negativeTranslationMatrix);
  }
  function invertTransformMatrix2(matrix) {
    const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
    const translationComponent = [matrix[0][2], matrix[1][2]];
    const invertedTranslation = [
      -dot2(rotationComponent[0], translationComponent),
      -dot2(rotationComponent[1], translationComponent)
    ];
    return [
      rotationComponent[0].concat(invertedTranslation[0]),
      rotationComponent[1].concat(invertedTranslation[1]),
      [0, 0, 1]
    ];
  }
  function rotatePoint2(homogeneousCoordinate, rotationMatrix) {
    return [
      dot2(homogeneousCoordinate, rotationMatrix[0]),
      dot2(homogeneousCoordinate, rotationMatrix[1])
    ];
  }
  var anchors2 = [
    { x: 0.015625, y: 0.015625 },
    { x: 0.015625, y: 0.015625 },
    { x: 0.046875, y: 0.015625 },
    { x: 0.046875, y: 0.015625 },
    { x: 0.078125, y: 0.015625 },
    { x: 0.078125, y: 0.015625 },
    { x: 0.109375, y: 0.015625 },
    { x: 0.109375, y: 0.015625 },
    { x: 0.140625, y: 0.015625 },
    { x: 0.140625, y: 0.015625 },
    { x: 0.171875, y: 0.015625 },
    { x: 0.171875, y: 0.015625 },
    { x: 0.203125, y: 0.015625 },
    { x: 0.203125, y: 0.015625 },
    { x: 0.234375, y: 0.015625 },
    { x: 0.234375, y: 0.015625 },
    { x: 0.265625, y: 0.015625 },
    { x: 0.265625, y: 0.015625 },
    { x: 0.296875, y: 0.015625 },
    { x: 0.296875, y: 0.015625 },
    { x: 0.328125, y: 0.015625 },
    { x: 0.328125, y: 0.015625 },
    { x: 0.359375, y: 0.015625 },
    { x: 0.359375, y: 0.015625 },
    { x: 0.390625, y: 0.015625 },
    { x: 0.390625, y: 0.015625 },
    { x: 0.421875, y: 0.015625 },
    { x: 0.421875, y: 0.015625 },
    { x: 0.453125, y: 0.015625 },
    { x: 0.453125, y: 0.015625 },
    { x: 0.484375, y: 0.015625 },
    { x: 0.484375, y: 0.015625 },
    { x: 0.515625, y: 0.015625 },
    { x: 0.515625, y: 0.015625 },
    { x: 0.546875, y: 0.015625 },
    { x: 0.546875, y: 0.015625 },
    { x: 0.578125, y: 0.015625 },
    { x: 0.578125, y: 0.015625 },
    { x: 0.609375, y: 0.015625 },
    { x: 0.609375, y: 0.015625 },
    { x: 0.640625, y: 0.015625 },
    { x: 0.640625, y: 0.015625 },
    { x: 0.671875, y: 0.015625 },
    { x: 0.671875, y: 0.015625 },
    { x: 0.703125, y: 0.015625 },
    { x: 0.703125, y: 0.015625 },
    { x: 0.734375, y: 0.015625 },
    { x: 0.734375, y: 0.015625 },
    { x: 0.765625, y: 0.015625 },
    { x: 0.765625, y: 0.015625 },
    { x: 0.796875, y: 0.015625 },
    { x: 0.796875, y: 0.015625 },
    { x: 0.828125, y: 0.015625 },
    { x: 0.828125, y: 0.015625 },
    { x: 0.859375, y: 0.015625 },
    { x: 0.859375, y: 0.015625 },
    { x: 0.890625, y: 0.015625 },
    { x: 0.890625, y: 0.015625 },
    { x: 0.921875, y: 0.015625 },
    { x: 0.921875, y: 0.015625 },
    { x: 0.953125, y: 0.015625 },
    { x: 0.953125, y: 0.015625 },
    { x: 0.984375, y: 0.015625 },
    { x: 0.984375, y: 0.015625 },
    { x: 0.015625, y: 0.046875 },
    { x: 0.015625, y: 0.046875 },
    { x: 0.046875, y: 0.046875 },
    { x: 0.046875, y: 0.046875 },
    { x: 0.078125, y: 0.046875 },
    { x: 0.078125, y: 0.046875 },
    { x: 0.109375, y: 0.046875 },
    { x: 0.109375, y: 0.046875 },
    { x: 0.140625, y: 0.046875 },
    { x: 0.140625, y: 0.046875 },
    { x: 0.171875, y: 0.046875 },
    { x: 0.171875, y: 0.046875 },
    { x: 0.203125, y: 0.046875 },
    { x: 0.203125, y: 0.046875 },
    { x: 0.234375, y: 0.046875 },
    { x: 0.234375, y: 0.046875 },
    { x: 0.265625, y: 0.046875 },
    { x: 0.265625, y: 0.046875 },
    { x: 0.296875, y: 0.046875 },
    { x: 0.296875, y: 0.046875 },
    { x: 0.328125, y: 0.046875 },
    { x: 0.328125, y: 0.046875 },
    { x: 0.359375, y: 0.046875 },
    { x: 0.359375, y: 0.046875 },
    { x: 0.390625, y: 0.046875 },
    { x: 0.390625, y: 0.046875 },
    { x: 0.421875, y: 0.046875 },
    { x: 0.421875, y: 0.046875 },
    { x: 0.453125, y: 0.046875 },
    { x: 0.453125, y: 0.046875 },
    { x: 0.484375, y: 0.046875 },
    { x: 0.484375, y: 0.046875 },
    { x: 0.515625, y: 0.046875 },
    { x: 0.515625, y: 0.046875 },
    { x: 0.546875, y: 0.046875 },
    { x: 0.546875, y: 0.046875 },
    { x: 0.578125, y: 0.046875 },
    { x: 0.578125, y: 0.046875 },
    { x: 0.609375, y: 0.046875 },
    { x: 0.609375, y: 0.046875 },
    { x: 0.640625, y: 0.046875 },
    { x: 0.640625, y: 0.046875 },
    { x: 0.671875, y: 0.046875 },
    { x: 0.671875, y: 0.046875 },
    { x: 0.703125, y: 0.046875 },
    { x: 0.703125, y: 0.046875 },
    { x: 0.734375, y: 0.046875 },
    { x: 0.734375, y: 0.046875 },
    { x: 0.765625, y: 0.046875 },
    { x: 0.765625, y: 0.046875 },
    { x: 0.796875, y: 0.046875 },
    { x: 0.796875, y: 0.046875 },
    { x: 0.828125, y: 0.046875 },
    { x: 0.828125, y: 0.046875 },
    { x: 0.859375, y: 0.046875 },
    { x: 0.859375, y: 0.046875 },
    { x: 0.890625, y: 0.046875 },
    { x: 0.890625, y: 0.046875 },
    { x: 0.921875, y: 0.046875 },
    { x: 0.921875, y: 0.046875 },
    { x: 0.953125, y: 0.046875 },
    { x: 0.953125, y: 0.046875 },
    { x: 0.984375, y: 0.046875 },
    { x: 0.984375, y: 0.046875 },
    { x: 0.015625, y: 0.078125 },
    { x: 0.015625, y: 0.078125 },
    { x: 0.046875, y: 0.078125 },
    { x: 0.046875, y: 0.078125 },
    { x: 0.078125, y: 0.078125 },
    { x: 0.078125, y: 0.078125 },
    { x: 0.109375, y: 0.078125 },
    { x: 0.109375, y: 0.078125 },
    { x: 0.140625, y: 0.078125 },
    { x: 0.140625, y: 0.078125 },
    { x: 0.171875, y: 0.078125 },
    { x: 0.171875, y: 0.078125 },
    { x: 0.203125, y: 0.078125 },
    { x: 0.203125, y: 0.078125 },
    { x: 0.234375, y: 0.078125 },
    { x: 0.234375, y: 0.078125 },
    { x: 0.265625, y: 0.078125 },
    { x: 0.265625, y: 0.078125 },
    { x: 0.296875, y: 0.078125 },
    { x: 0.296875, y: 0.078125 },
    { x: 0.328125, y: 0.078125 },
    { x: 0.328125, y: 0.078125 },
    { x: 0.359375, y: 0.078125 },
    { x: 0.359375, y: 0.078125 },
    { x: 0.390625, y: 0.078125 },
    { x: 0.390625, y: 0.078125 },
    { x: 0.421875, y: 0.078125 },
    { x: 0.421875, y: 0.078125 },
    { x: 0.453125, y: 0.078125 },
    { x: 0.453125, y: 0.078125 },
    { x: 0.484375, y: 0.078125 },
    { x: 0.484375, y: 0.078125 },
    { x: 0.515625, y: 0.078125 },
    { x: 0.515625, y: 0.078125 },
    { x: 0.546875, y: 0.078125 },
    { x: 0.546875, y: 0.078125 },
    { x: 0.578125, y: 0.078125 },
    { x: 0.578125, y: 0.078125 },
    { x: 0.609375, y: 0.078125 },
    { x: 0.609375, y: 0.078125 },
    { x: 0.640625, y: 0.078125 },
    { x: 0.640625, y: 0.078125 },
    { x: 0.671875, y: 0.078125 },
    { x: 0.671875, y: 0.078125 },
    { x: 0.703125, y: 0.078125 },
    { x: 0.703125, y: 0.078125 },
    { x: 0.734375, y: 0.078125 },
    { x: 0.734375, y: 0.078125 },
    { x: 0.765625, y: 0.078125 },
    { x: 0.765625, y: 0.078125 },
    { x: 0.796875, y: 0.078125 },
    { x: 0.796875, y: 0.078125 },
    { x: 0.828125, y: 0.078125 },
    { x: 0.828125, y: 0.078125 },
    { x: 0.859375, y: 0.078125 },
    { x: 0.859375, y: 0.078125 },
    { x: 0.890625, y: 0.078125 },
    { x: 0.890625, y: 0.078125 },
    { x: 0.921875, y: 0.078125 },
    { x: 0.921875, y: 0.078125 },
    { x: 0.953125, y: 0.078125 },
    { x: 0.953125, y: 0.078125 },
    { x: 0.984375, y: 0.078125 },
    { x: 0.984375, y: 0.078125 },
    { x: 0.015625, y: 0.109375 },
    { x: 0.015625, y: 0.109375 },
    { x: 0.046875, y: 0.109375 },
    { x: 0.046875, y: 0.109375 },
    { x: 0.078125, y: 0.109375 },
    { x: 0.078125, y: 0.109375 },
    { x: 0.109375, y: 0.109375 },
    { x: 0.109375, y: 0.109375 },
    { x: 0.140625, y: 0.109375 },
    { x: 0.140625, y: 0.109375 },
    { x: 0.171875, y: 0.109375 },
    { x: 0.171875, y: 0.109375 },
    { x: 0.203125, y: 0.109375 },
    { x: 0.203125, y: 0.109375 },
    { x: 0.234375, y: 0.109375 },
    { x: 0.234375, y: 0.109375 },
    { x: 0.265625, y: 0.109375 },
    { x: 0.265625, y: 0.109375 },
    { x: 0.296875, y: 0.109375 },
    { x: 0.296875, y: 0.109375 },
    { x: 0.328125, y: 0.109375 },
    { x: 0.328125, y: 0.109375 },
    { x: 0.359375, y: 0.109375 },
    { x: 0.359375, y: 0.109375 },
    { x: 0.390625, y: 0.109375 },
    { x: 0.390625, y: 0.109375 },
    { x: 0.421875, y: 0.109375 },
    { x: 0.421875, y: 0.109375 },
    { x: 0.453125, y: 0.109375 },
    { x: 0.453125, y: 0.109375 },
    { x: 0.484375, y: 0.109375 },
    { x: 0.484375, y: 0.109375 },
    { x: 0.515625, y: 0.109375 },
    { x: 0.515625, y: 0.109375 },
    { x: 0.546875, y: 0.109375 },
    { x: 0.546875, y: 0.109375 },
    { x: 0.578125, y: 0.109375 },
    { x: 0.578125, y: 0.109375 },
    { x: 0.609375, y: 0.109375 },
    { x: 0.609375, y: 0.109375 },
    { x: 0.640625, y: 0.109375 },
    { x: 0.640625, y: 0.109375 },
    { x: 0.671875, y: 0.109375 },
    { x: 0.671875, y: 0.109375 },
    { x: 0.703125, y: 0.109375 },
    { x: 0.703125, y: 0.109375 },
    { x: 0.734375, y: 0.109375 },
    { x: 0.734375, y: 0.109375 },
    { x: 0.765625, y: 0.109375 },
    { x: 0.765625, y: 0.109375 },
    { x: 0.796875, y: 0.109375 },
    { x: 0.796875, y: 0.109375 },
    { x: 0.828125, y: 0.109375 },
    { x: 0.828125, y: 0.109375 },
    { x: 0.859375, y: 0.109375 },
    { x: 0.859375, y: 0.109375 },
    { x: 0.890625, y: 0.109375 },
    { x: 0.890625, y: 0.109375 },
    { x: 0.921875, y: 0.109375 },
    { x: 0.921875, y: 0.109375 },
    { x: 0.953125, y: 0.109375 },
    { x: 0.953125, y: 0.109375 },
    { x: 0.984375, y: 0.109375 },
    { x: 0.984375, y: 0.109375 },
    { x: 0.015625, y: 0.140625 },
    { x: 0.015625, y: 0.140625 },
    { x: 0.046875, y: 0.140625 },
    { x: 0.046875, y: 0.140625 },
    { x: 0.078125, y: 0.140625 },
    { x: 0.078125, y: 0.140625 },
    { x: 0.109375, y: 0.140625 },
    { x: 0.109375, y: 0.140625 },
    { x: 0.140625, y: 0.140625 },
    { x: 0.140625, y: 0.140625 },
    { x: 0.171875, y: 0.140625 },
    { x: 0.171875, y: 0.140625 },
    { x: 0.203125, y: 0.140625 },
    { x: 0.203125, y: 0.140625 },
    { x: 0.234375, y: 0.140625 },
    { x: 0.234375, y: 0.140625 },
    { x: 0.265625, y: 0.140625 },
    { x: 0.265625, y: 0.140625 },
    { x: 0.296875, y: 0.140625 },
    { x: 0.296875, y: 0.140625 },
    { x: 0.328125, y: 0.140625 },
    { x: 0.328125, y: 0.140625 },
    { x: 0.359375, y: 0.140625 },
    { x: 0.359375, y: 0.140625 },
    { x: 0.390625, y: 0.140625 },
    { x: 0.390625, y: 0.140625 },
    { x: 0.421875, y: 0.140625 },
    { x: 0.421875, y: 0.140625 },
    { x: 0.453125, y: 0.140625 },
    { x: 0.453125, y: 0.140625 },
    { x: 0.484375, y: 0.140625 },
    { x: 0.484375, y: 0.140625 },
    { x: 0.515625, y: 0.140625 },
    { x: 0.515625, y: 0.140625 },
    { x: 0.546875, y: 0.140625 },
    { x: 0.546875, y: 0.140625 },
    { x: 0.578125, y: 0.140625 },
    { x: 0.578125, y: 0.140625 },
    { x: 0.609375, y: 0.140625 },
    { x: 0.609375, y: 0.140625 },
    { x: 0.640625, y: 0.140625 },
    { x: 0.640625, y: 0.140625 },
    { x: 0.671875, y: 0.140625 },
    { x: 0.671875, y: 0.140625 },
    { x: 0.703125, y: 0.140625 },
    { x: 0.703125, y: 0.140625 },
    { x: 0.734375, y: 0.140625 },
    { x: 0.734375, y: 0.140625 },
    { x: 0.765625, y: 0.140625 },
    { x: 0.765625, y: 0.140625 },
    { x: 0.796875, y: 0.140625 },
    { x: 0.796875, y: 0.140625 },
    { x: 0.828125, y: 0.140625 },
    { x: 0.828125, y: 0.140625 },
    { x: 0.859375, y: 0.140625 },
    { x: 0.859375, y: 0.140625 },
    { x: 0.890625, y: 0.140625 },
    { x: 0.890625, y: 0.140625 },
    { x: 0.921875, y: 0.140625 },
    { x: 0.921875, y: 0.140625 },
    { x: 0.953125, y: 0.140625 },
    { x: 0.953125, y: 0.140625 },
    { x: 0.984375, y: 0.140625 },
    { x: 0.984375, y: 0.140625 },
    { x: 0.015625, y: 0.171875 },
    { x: 0.015625, y: 0.171875 },
    { x: 0.046875, y: 0.171875 },
    { x: 0.046875, y: 0.171875 },
    { x: 0.078125, y: 0.171875 },
    { x: 0.078125, y: 0.171875 },
    { x: 0.109375, y: 0.171875 },
    { x: 0.109375, y: 0.171875 },
    { x: 0.140625, y: 0.171875 },
    { x: 0.140625, y: 0.171875 },
    { x: 0.171875, y: 0.171875 },
    { x: 0.171875, y: 0.171875 },
    { x: 0.203125, y: 0.171875 },
    { x: 0.203125, y: 0.171875 },
    { x: 0.234375, y: 0.171875 },
    { x: 0.234375, y: 0.171875 },
    { x: 0.265625, y: 0.171875 },
    { x: 0.265625, y: 0.171875 },
    { x: 0.296875, y: 0.171875 },
    { x: 0.296875, y: 0.171875 },
    { x: 0.328125, y: 0.171875 },
    { x: 0.328125, y: 0.171875 },
    { x: 0.359375, y: 0.171875 },
    { x: 0.359375, y: 0.171875 },
    { x: 0.390625, y: 0.171875 },
    { x: 0.390625, y: 0.171875 },
    { x: 0.421875, y: 0.171875 },
    { x: 0.421875, y: 0.171875 },
    { x: 0.453125, y: 0.171875 },
    { x: 0.453125, y: 0.171875 },
    { x: 0.484375, y: 0.171875 },
    { x: 0.484375, y: 0.171875 },
    { x: 0.515625, y: 0.171875 },
    { x: 0.515625, y: 0.171875 },
    { x: 0.546875, y: 0.171875 },
    { x: 0.546875, y: 0.171875 },
    { x: 0.578125, y: 0.171875 },
    { x: 0.578125, y: 0.171875 },
    { x: 0.609375, y: 0.171875 },
    { x: 0.609375, y: 0.171875 },
    { x: 0.640625, y: 0.171875 },
    { x: 0.640625, y: 0.171875 },
    { x: 0.671875, y: 0.171875 },
    { x: 0.671875, y: 0.171875 },
    { x: 0.703125, y: 0.171875 },
    { x: 0.703125, y: 0.171875 },
    { x: 0.734375, y: 0.171875 },
    { x: 0.734375, y: 0.171875 },
    { x: 0.765625, y: 0.171875 },
    { x: 0.765625, y: 0.171875 },
    { x: 0.796875, y: 0.171875 },
    { x: 0.796875, y: 0.171875 },
    { x: 0.828125, y: 0.171875 },
    { x: 0.828125, y: 0.171875 },
    { x: 0.859375, y: 0.171875 },
    { x: 0.859375, y: 0.171875 },
    { x: 0.890625, y: 0.171875 },
    { x: 0.890625, y: 0.171875 },
    { x: 0.921875, y: 0.171875 },
    { x: 0.921875, y: 0.171875 },
    { x: 0.953125, y: 0.171875 },
    { x: 0.953125, y: 0.171875 },
    { x: 0.984375, y: 0.171875 },
    { x: 0.984375, y: 0.171875 },
    { x: 0.015625, y: 0.203125 },
    { x: 0.015625, y: 0.203125 },
    { x: 0.046875, y: 0.203125 },
    { x: 0.046875, y: 0.203125 },
    { x: 0.078125, y: 0.203125 },
    { x: 0.078125, y: 0.203125 },
    { x: 0.109375, y: 0.203125 },
    { x: 0.109375, y: 0.203125 },
    { x: 0.140625, y: 0.203125 },
    { x: 0.140625, y: 0.203125 },
    { x: 0.171875, y: 0.203125 },
    { x: 0.171875, y: 0.203125 },
    { x: 0.203125, y: 0.203125 },
    { x: 0.203125, y: 0.203125 },
    { x: 0.234375, y: 0.203125 },
    { x: 0.234375, y: 0.203125 },
    { x: 0.265625, y: 0.203125 },
    { x: 0.265625, y: 0.203125 },
    { x: 0.296875, y: 0.203125 },
    { x: 0.296875, y: 0.203125 },
    { x: 0.328125, y: 0.203125 },
    { x: 0.328125, y: 0.203125 },
    { x: 0.359375, y: 0.203125 },
    { x: 0.359375, y: 0.203125 },
    { x: 0.390625, y: 0.203125 },
    { x: 0.390625, y: 0.203125 },
    { x: 0.421875, y: 0.203125 },
    { x: 0.421875, y: 0.203125 },
    { x: 0.453125, y: 0.203125 },
    { x: 0.453125, y: 0.203125 },
    { x: 0.484375, y: 0.203125 },
    { x: 0.484375, y: 0.203125 },
    { x: 0.515625, y: 0.203125 },
    { x: 0.515625, y: 0.203125 },
    { x: 0.546875, y: 0.203125 },
    { x: 0.546875, y: 0.203125 },
    { x: 0.578125, y: 0.203125 },
    { x: 0.578125, y: 0.203125 },
    { x: 0.609375, y: 0.203125 },
    { x: 0.609375, y: 0.203125 },
    { x: 0.640625, y: 0.203125 },
    { x: 0.640625, y: 0.203125 },
    { x: 0.671875, y: 0.203125 },
    { x: 0.671875, y: 0.203125 },
    { x: 0.703125, y: 0.203125 },
    { x: 0.703125, y: 0.203125 },
    { x: 0.734375, y: 0.203125 },
    { x: 0.734375, y: 0.203125 },
    { x: 0.765625, y: 0.203125 },
    { x: 0.765625, y: 0.203125 },
    { x: 0.796875, y: 0.203125 },
    { x: 0.796875, y: 0.203125 },
    { x: 0.828125, y: 0.203125 },
    { x: 0.828125, y: 0.203125 },
    { x: 0.859375, y: 0.203125 },
    { x: 0.859375, y: 0.203125 },
    { x: 0.890625, y: 0.203125 },
    { x: 0.890625, y: 0.203125 },
    { x: 0.921875, y: 0.203125 },
    { x: 0.921875, y: 0.203125 },
    { x: 0.953125, y: 0.203125 },
    { x: 0.953125, y: 0.203125 },
    { x: 0.984375, y: 0.203125 },
    { x: 0.984375, y: 0.203125 },
    { x: 0.015625, y: 0.234375 },
    { x: 0.015625, y: 0.234375 },
    { x: 0.046875, y: 0.234375 },
    { x: 0.046875, y: 0.234375 },
    { x: 0.078125, y: 0.234375 },
    { x: 0.078125, y: 0.234375 },
    { x: 0.109375, y: 0.234375 },
    { x: 0.109375, y: 0.234375 },
    { x: 0.140625, y: 0.234375 },
    { x: 0.140625, y: 0.234375 },
    { x: 0.171875, y: 0.234375 },
    { x: 0.171875, y: 0.234375 },
    { x: 0.203125, y: 0.234375 },
    { x: 0.203125, y: 0.234375 },
    { x: 0.234375, y: 0.234375 },
    { x: 0.234375, y: 0.234375 },
    { x: 0.265625, y: 0.234375 },
    { x: 0.265625, y: 0.234375 },
    { x: 0.296875, y: 0.234375 },
    { x: 0.296875, y: 0.234375 },
    { x: 0.328125, y: 0.234375 },
    { x: 0.328125, y: 0.234375 },
    { x: 0.359375, y: 0.234375 },
    { x: 0.359375, y: 0.234375 },
    { x: 0.390625, y: 0.234375 },
    { x: 0.390625, y: 0.234375 },
    { x: 0.421875, y: 0.234375 },
    { x: 0.421875, y: 0.234375 },
    { x: 0.453125, y: 0.234375 },
    { x: 0.453125, y: 0.234375 },
    { x: 0.484375, y: 0.234375 },
    { x: 0.484375, y: 0.234375 },
    { x: 0.515625, y: 0.234375 },
    { x: 0.515625, y: 0.234375 },
    { x: 0.546875, y: 0.234375 },
    { x: 0.546875, y: 0.234375 },
    { x: 0.578125, y: 0.234375 },
    { x: 0.578125, y: 0.234375 },
    { x: 0.609375, y: 0.234375 },
    { x: 0.609375, y: 0.234375 },
    { x: 0.640625, y: 0.234375 },
    { x: 0.640625, y: 0.234375 },
    { x: 0.671875, y: 0.234375 },
    { x: 0.671875, y: 0.234375 },
    { x: 0.703125, y: 0.234375 },
    { x: 0.703125, y: 0.234375 },
    { x: 0.734375, y: 0.234375 },
    { x: 0.734375, y: 0.234375 },
    { x: 0.765625, y: 0.234375 },
    { x: 0.765625, y: 0.234375 },
    { x: 0.796875, y: 0.234375 },
    { x: 0.796875, y: 0.234375 },
    { x: 0.828125, y: 0.234375 },
    { x: 0.828125, y: 0.234375 },
    { x: 0.859375, y: 0.234375 },
    { x: 0.859375, y: 0.234375 },
    { x: 0.890625, y: 0.234375 },
    { x: 0.890625, y: 0.234375 },
    { x: 0.921875, y: 0.234375 },
    { x: 0.921875, y: 0.234375 },
    { x: 0.953125, y: 0.234375 },
    { x: 0.953125, y: 0.234375 },
    { x: 0.984375, y: 0.234375 },
    { x: 0.984375, y: 0.234375 },
    { x: 0.015625, y: 0.265625 },
    { x: 0.015625, y: 0.265625 },
    { x: 0.046875, y: 0.265625 },
    { x: 0.046875, y: 0.265625 },
    { x: 0.078125, y: 0.265625 },
    { x: 0.078125, y: 0.265625 },
    { x: 0.109375, y: 0.265625 },
    { x: 0.109375, y: 0.265625 },
    { x: 0.140625, y: 0.265625 },
    { x: 0.140625, y: 0.265625 },
    { x: 0.171875, y: 0.265625 },
    { x: 0.171875, y: 0.265625 },
    { x: 0.203125, y: 0.265625 },
    { x: 0.203125, y: 0.265625 },
    { x: 0.234375, y: 0.265625 },
    { x: 0.234375, y: 0.265625 },
    { x: 0.265625, y: 0.265625 },
    { x: 0.265625, y: 0.265625 },
    { x: 0.296875, y: 0.265625 },
    { x: 0.296875, y: 0.265625 },
    { x: 0.328125, y: 0.265625 },
    { x: 0.328125, y: 0.265625 },
    { x: 0.359375, y: 0.265625 },
    { x: 0.359375, y: 0.265625 },
    { x: 0.390625, y: 0.265625 },
    { x: 0.390625, y: 0.265625 },
    { x: 0.421875, y: 0.265625 },
    { x: 0.421875, y: 0.265625 },
    { x: 0.453125, y: 0.265625 },
    { x: 0.453125, y: 0.265625 },
    { x: 0.484375, y: 0.265625 },
    { x: 0.484375, y: 0.265625 },
    { x: 0.515625, y: 0.265625 },
    { x: 0.515625, y: 0.265625 },
    { x: 0.546875, y: 0.265625 },
    { x: 0.546875, y: 0.265625 },
    { x: 0.578125, y: 0.265625 },
    { x: 0.578125, y: 0.265625 },
    { x: 0.609375, y: 0.265625 },
    { x: 0.609375, y: 0.265625 },
    { x: 0.640625, y: 0.265625 },
    { x: 0.640625, y: 0.265625 },
    { x: 0.671875, y: 0.265625 },
    { x: 0.671875, y: 0.265625 },
    { x: 0.703125, y: 0.265625 },
    { x: 0.703125, y: 0.265625 },
    { x: 0.734375, y: 0.265625 },
    { x: 0.734375, y: 0.265625 },
    { x: 0.765625, y: 0.265625 },
    { x: 0.765625, y: 0.265625 },
    { x: 0.796875, y: 0.265625 },
    { x: 0.796875, y: 0.265625 },
    { x: 0.828125, y: 0.265625 },
    { x: 0.828125, y: 0.265625 },
    { x: 0.859375, y: 0.265625 },
    { x: 0.859375, y: 0.265625 },
    { x: 0.890625, y: 0.265625 },
    { x: 0.890625, y: 0.265625 },
    { x: 0.921875, y: 0.265625 },
    { x: 0.921875, y: 0.265625 },
    { x: 0.953125, y: 0.265625 },
    { x: 0.953125, y: 0.265625 },
    { x: 0.984375, y: 0.265625 },
    { x: 0.984375, y: 0.265625 },
    { x: 0.015625, y: 0.296875 },
    { x: 0.015625, y: 0.296875 },
    { x: 0.046875, y: 0.296875 },
    { x: 0.046875, y: 0.296875 },
    { x: 0.078125, y: 0.296875 },
    { x: 0.078125, y: 0.296875 },
    { x: 0.109375, y: 0.296875 },
    { x: 0.109375, y: 0.296875 },
    { x: 0.140625, y: 0.296875 },
    { x: 0.140625, y: 0.296875 },
    { x: 0.171875, y: 0.296875 },
    { x: 0.171875, y: 0.296875 },
    { x: 0.203125, y: 0.296875 },
    { x: 0.203125, y: 0.296875 },
    { x: 0.234375, y: 0.296875 },
    { x: 0.234375, y: 0.296875 },
    { x: 0.265625, y: 0.296875 },
    { x: 0.265625, y: 0.296875 },
    { x: 0.296875, y: 0.296875 },
    { x: 0.296875, y: 0.296875 },
    { x: 0.328125, y: 0.296875 },
    { x: 0.328125, y: 0.296875 },
    { x: 0.359375, y: 0.296875 },
    { x: 0.359375, y: 0.296875 },
    { x: 0.390625, y: 0.296875 },
    { x: 0.390625, y: 0.296875 },
    { x: 0.421875, y: 0.296875 },
    { x: 0.421875, y: 0.296875 },
    { x: 0.453125, y: 0.296875 },
    { x: 0.453125, y: 0.296875 },
    { x: 0.484375, y: 0.296875 },
    { x: 0.484375, y: 0.296875 },
    { x: 0.515625, y: 0.296875 },
    { x: 0.515625, y: 0.296875 },
    { x: 0.546875, y: 0.296875 },
    { x: 0.546875, y: 0.296875 },
    { x: 0.578125, y: 0.296875 },
    { x: 0.578125, y: 0.296875 },
    { x: 0.609375, y: 0.296875 },
    { x: 0.609375, y: 0.296875 },
    { x: 0.640625, y: 0.296875 },
    { x: 0.640625, y: 0.296875 },
    { x: 0.671875, y: 0.296875 },
    { x: 0.671875, y: 0.296875 },
    { x: 0.703125, y: 0.296875 },
    { x: 0.703125, y: 0.296875 },
    { x: 0.734375, y: 0.296875 },
    { x: 0.734375, y: 0.296875 },
    { x: 0.765625, y: 0.296875 },
    { x: 0.765625, y: 0.296875 },
    { x: 0.796875, y: 0.296875 },
    { x: 0.796875, y: 0.296875 },
    { x: 0.828125, y: 0.296875 },
    { x: 0.828125, y: 0.296875 },
    { x: 0.859375, y: 0.296875 },
    { x: 0.859375, y: 0.296875 },
    { x: 0.890625, y: 0.296875 },
    { x: 0.890625, y: 0.296875 },
    { x: 0.921875, y: 0.296875 },
    { x: 0.921875, y: 0.296875 },
    { x: 0.953125, y: 0.296875 },
    { x: 0.953125, y: 0.296875 },
    { x: 0.984375, y: 0.296875 },
    { x: 0.984375, y: 0.296875 },
    { x: 0.015625, y: 0.328125 },
    { x: 0.015625, y: 0.328125 },
    { x: 0.046875, y: 0.328125 },
    { x: 0.046875, y: 0.328125 },
    { x: 0.078125, y: 0.328125 },
    { x: 0.078125, y: 0.328125 },
    { x: 0.109375, y: 0.328125 },
    { x: 0.109375, y: 0.328125 },
    { x: 0.140625, y: 0.328125 },
    { x: 0.140625, y: 0.328125 },
    { x: 0.171875, y: 0.328125 },
    { x: 0.171875, y: 0.328125 },
    { x: 0.203125, y: 0.328125 },
    { x: 0.203125, y: 0.328125 },
    { x: 0.234375, y: 0.328125 },
    { x: 0.234375, y: 0.328125 },
    { x: 0.265625, y: 0.328125 },
    { x: 0.265625, y: 0.328125 },
    { x: 0.296875, y: 0.328125 },
    { x: 0.296875, y: 0.328125 },
    { x: 0.328125, y: 0.328125 },
    { x: 0.328125, y: 0.328125 },
    { x: 0.359375, y: 0.328125 },
    { x: 0.359375, y: 0.328125 },
    { x: 0.390625, y: 0.328125 },
    { x: 0.390625, y: 0.328125 },
    { x: 0.421875, y: 0.328125 },
    { x: 0.421875, y: 0.328125 },
    { x: 0.453125, y: 0.328125 },
    { x: 0.453125, y: 0.328125 },
    { x: 0.484375, y: 0.328125 },
    { x: 0.484375, y: 0.328125 },
    { x: 0.515625, y: 0.328125 },
    { x: 0.515625, y: 0.328125 },
    { x: 0.546875, y: 0.328125 },
    { x: 0.546875, y: 0.328125 },
    { x: 0.578125, y: 0.328125 },
    { x: 0.578125, y: 0.328125 },
    { x: 0.609375, y: 0.328125 },
    { x: 0.609375, y: 0.328125 },
    { x: 0.640625, y: 0.328125 },
    { x: 0.640625, y: 0.328125 },
    { x: 0.671875, y: 0.328125 },
    { x: 0.671875, y: 0.328125 },
    { x: 0.703125, y: 0.328125 },
    { x: 0.703125, y: 0.328125 },
    { x: 0.734375, y: 0.328125 },
    { x: 0.734375, y: 0.328125 },
    { x: 0.765625, y: 0.328125 },
    { x: 0.765625, y: 0.328125 },
    { x: 0.796875, y: 0.328125 },
    { x: 0.796875, y: 0.328125 },
    { x: 0.828125, y: 0.328125 },
    { x: 0.828125, y: 0.328125 },
    { x: 0.859375, y: 0.328125 },
    { x: 0.859375, y: 0.328125 },
    { x: 0.890625, y: 0.328125 },
    { x: 0.890625, y: 0.328125 },
    { x: 0.921875, y: 0.328125 },
    { x: 0.921875, y: 0.328125 },
    { x: 0.953125, y: 0.328125 },
    { x: 0.953125, y: 0.328125 },
    { x: 0.984375, y: 0.328125 },
    { x: 0.984375, y: 0.328125 },
    { x: 0.015625, y: 0.359375 },
    { x: 0.015625, y: 0.359375 },
    { x: 0.046875, y: 0.359375 },
    { x: 0.046875, y: 0.359375 },
    { x: 0.078125, y: 0.359375 },
    { x: 0.078125, y: 0.359375 },
    { x: 0.109375, y: 0.359375 },
    { x: 0.109375, y: 0.359375 },
    { x: 0.140625, y: 0.359375 },
    { x: 0.140625, y: 0.359375 },
    { x: 0.171875, y: 0.359375 },
    { x: 0.171875, y: 0.359375 },
    { x: 0.203125, y: 0.359375 },
    { x: 0.203125, y: 0.359375 },
    { x: 0.234375, y: 0.359375 },
    { x: 0.234375, y: 0.359375 },
    { x: 0.265625, y: 0.359375 },
    { x: 0.265625, y: 0.359375 },
    { x: 0.296875, y: 0.359375 },
    { x: 0.296875, y: 0.359375 },
    { x: 0.328125, y: 0.359375 },
    { x: 0.328125, y: 0.359375 },
    { x: 0.359375, y: 0.359375 },
    { x: 0.359375, y: 0.359375 },
    { x: 0.390625, y: 0.359375 },
    { x: 0.390625, y: 0.359375 },
    { x: 0.421875, y: 0.359375 },
    { x: 0.421875, y: 0.359375 },
    { x: 0.453125, y: 0.359375 },
    { x: 0.453125, y: 0.359375 },
    { x: 0.484375, y: 0.359375 },
    { x: 0.484375, y: 0.359375 },
    { x: 0.515625, y: 0.359375 },
    { x: 0.515625, y: 0.359375 },
    { x: 0.546875, y: 0.359375 },
    { x: 0.546875, y: 0.359375 },
    { x: 0.578125, y: 0.359375 },
    { x: 0.578125, y: 0.359375 },
    { x: 0.609375, y: 0.359375 },
    { x: 0.609375, y: 0.359375 },
    { x: 0.640625, y: 0.359375 },
    { x: 0.640625, y: 0.359375 },
    { x: 0.671875, y: 0.359375 },
    { x: 0.671875, y: 0.359375 },
    { x: 0.703125, y: 0.359375 },
    { x: 0.703125, y: 0.359375 },
    { x: 0.734375, y: 0.359375 },
    { x: 0.734375, y: 0.359375 },
    { x: 0.765625, y: 0.359375 },
    { x: 0.765625, y: 0.359375 },
    { x: 0.796875, y: 0.359375 },
    { x: 0.796875, y: 0.359375 },
    { x: 0.828125, y: 0.359375 },
    { x: 0.828125, y: 0.359375 },
    { x: 0.859375, y: 0.359375 },
    { x: 0.859375, y: 0.359375 },
    { x: 0.890625, y: 0.359375 },
    { x: 0.890625, y: 0.359375 },
    { x: 0.921875, y: 0.359375 },
    { x: 0.921875, y: 0.359375 },
    { x: 0.953125, y: 0.359375 },
    { x: 0.953125, y: 0.359375 },
    { x: 0.984375, y: 0.359375 },
    { x: 0.984375, y: 0.359375 },
    { x: 0.015625, y: 0.390625 },
    { x: 0.015625, y: 0.390625 },
    { x: 0.046875, y: 0.390625 },
    { x: 0.046875, y: 0.390625 },
    { x: 0.078125, y: 0.390625 },
    { x: 0.078125, y: 0.390625 },
    { x: 0.109375, y: 0.390625 },
    { x: 0.109375, y: 0.390625 },
    { x: 0.140625, y: 0.390625 },
    { x: 0.140625, y: 0.390625 },
    { x: 0.171875, y: 0.390625 },
    { x: 0.171875, y: 0.390625 },
    { x: 0.203125, y: 0.390625 },
    { x: 0.203125, y: 0.390625 },
    { x: 0.234375, y: 0.390625 },
    { x: 0.234375, y: 0.390625 },
    { x: 0.265625, y: 0.390625 },
    { x: 0.265625, y: 0.390625 },
    { x: 0.296875, y: 0.390625 },
    { x: 0.296875, y: 0.390625 },
    { x: 0.328125, y: 0.390625 },
    { x: 0.328125, y: 0.390625 },
    { x: 0.359375, y: 0.390625 },
    { x: 0.359375, y: 0.390625 },
    { x: 0.390625, y: 0.390625 },
    { x: 0.390625, y: 0.390625 },
    { x: 0.421875, y: 0.390625 },
    { x: 0.421875, y: 0.390625 },
    { x: 0.453125, y: 0.390625 },
    { x: 0.453125, y: 0.390625 },
    { x: 0.484375, y: 0.390625 },
    { x: 0.484375, y: 0.390625 },
    { x: 0.515625, y: 0.390625 },
    { x: 0.515625, y: 0.390625 },
    { x: 0.546875, y: 0.390625 },
    { x: 0.546875, y: 0.390625 },
    { x: 0.578125, y: 0.390625 },
    { x: 0.578125, y: 0.390625 },
    { x: 0.609375, y: 0.390625 },
    { x: 0.609375, y: 0.390625 },
    { x: 0.640625, y: 0.390625 },
    { x: 0.640625, y: 0.390625 },
    { x: 0.671875, y: 0.390625 },
    { x: 0.671875, y: 0.390625 },
    { x: 0.703125, y: 0.390625 },
    { x: 0.703125, y: 0.390625 },
    { x: 0.734375, y: 0.390625 },
    { x: 0.734375, y: 0.390625 },
    { x: 0.765625, y: 0.390625 },
    { x: 0.765625, y: 0.390625 },
    { x: 0.796875, y: 0.390625 },
    { x: 0.796875, y: 0.390625 },
    { x: 0.828125, y: 0.390625 },
    { x: 0.828125, y: 0.390625 },
    { x: 0.859375, y: 0.390625 },
    { x: 0.859375, y: 0.390625 },
    { x: 0.890625, y: 0.390625 },
    { x: 0.890625, y: 0.390625 },
    { x: 0.921875, y: 0.390625 },
    { x: 0.921875, y: 0.390625 },
    { x: 0.953125, y: 0.390625 },
    { x: 0.953125, y: 0.390625 },
    { x: 0.984375, y: 0.390625 },
    { x: 0.984375, y: 0.390625 },
    { x: 0.015625, y: 0.421875 },
    { x: 0.015625, y: 0.421875 },
    { x: 0.046875, y: 0.421875 },
    { x: 0.046875, y: 0.421875 },
    { x: 0.078125, y: 0.421875 },
    { x: 0.078125, y: 0.421875 },
    { x: 0.109375, y: 0.421875 },
    { x: 0.109375, y: 0.421875 },
    { x: 0.140625, y: 0.421875 },
    { x: 0.140625, y: 0.421875 },
    { x: 0.171875, y: 0.421875 },
    { x: 0.171875, y: 0.421875 },
    { x: 0.203125, y: 0.421875 },
    { x: 0.203125, y: 0.421875 },
    { x: 0.234375, y: 0.421875 },
    { x: 0.234375, y: 0.421875 },
    { x: 0.265625, y: 0.421875 },
    { x: 0.265625, y: 0.421875 },
    { x: 0.296875, y: 0.421875 },
    { x: 0.296875, y: 0.421875 },
    { x: 0.328125, y: 0.421875 },
    { x: 0.328125, y: 0.421875 },
    { x: 0.359375, y: 0.421875 },
    { x: 0.359375, y: 0.421875 },
    { x: 0.390625, y: 0.421875 },
    { x: 0.390625, y: 0.421875 },
    { x: 0.421875, y: 0.421875 },
    { x: 0.421875, y: 0.421875 },
    { x: 0.453125, y: 0.421875 },
    { x: 0.453125, y: 0.421875 },
    { x: 0.484375, y: 0.421875 },
    { x: 0.484375, y: 0.421875 },
    { x: 0.515625, y: 0.421875 },
    { x: 0.515625, y: 0.421875 },
    { x: 0.546875, y: 0.421875 },
    { x: 0.546875, y: 0.421875 },
    { x: 0.578125, y: 0.421875 },
    { x: 0.578125, y: 0.421875 },
    { x: 0.609375, y: 0.421875 },
    { x: 0.609375, y: 0.421875 },
    { x: 0.640625, y: 0.421875 },
    { x: 0.640625, y: 0.421875 },
    { x: 0.671875, y: 0.421875 },
    { x: 0.671875, y: 0.421875 },
    { x: 0.703125, y: 0.421875 },
    { x: 0.703125, y: 0.421875 },
    { x: 0.734375, y: 0.421875 },
    { x: 0.734375, y: 0.421875 },
    { x: 0.765625, y: 0.421875 },
    { x: 0.765625, y: 0.421875 },
    { x: 0.796875, y: 0.421875 },
    { x: 0.796875, y: 0.421875 },
    { x: 0.828125, y: 0.421875 },
    { x: 0.828125, y: 0.421875 },
    { x: 0.859375, y: 0.421875 },
    { x: 0.859375, y: 0.421875 },
    { x: 0.890625, y: 0.421875 },
    { x: 0.890625, y: 0.421875 },
    { x: 0.921875, y: 0.421875 },
    { x: 0.921875, y: 0.421875 },
    { x: 0.953125, y: 0.421875 },
    { x: 0.953125, y: 0.421875 },
    { x: 0.984375, y: 0.421875 },
    { x: 0.984375, y: 0.421875 },
    { x: 0.015625, y: 0.453125 },
    { x: 0.015625, y: 0.453125 },
    { x: 0.046875, y: 0.453125 },
    { x: 0.046875, y: 0.453125 },
    { x: 0.078125, y: 0.453125 },
    { x: 0.078125, y: 0.453125 },
    { x: 0.109375, y: 0.453125 },
    { x: 0.109375, y: 0.453125 },
    { x: 0.140625, y: 0.453125 },
    { x: 0.140625, y: 0.453125 },
    { x: 0.171875, y: 0.453125 },
    { x: 0.171875, y: 0.453125 },
    { x: 0.203125, y: 0.453125 },
    { x: 0.203125, y: 0.453125 },
    { x: 0.234375, y: 0.453125 },
    { x: 0.234375, y: 0.453125 },
    { x: 0.265625, y: 0.453125 },
    { x: 0.265625, y: 0.453125 },
    { x: 0.296875, y: 0.453125 },
    { x: 0.296875, y: 0.453125 },
    { x: 0.328125, y: 0.453125 },
    { x: 0.328125, y: 0.453125 },
    { x: 0.359375, y: 0.453125 },
    { x: 0.359375, y: 0.453125 },
    { x: 0.390625, y: 0.453125 },
    { x: 0.390625, y: 0.453125 },
    { x: 0.421875, y: 0.453125 },
    { x: 0.421875, y: 0.453125 },
    { x: 0.453125, y: 0.453125 },
    { x: 0.453125, y: 0.453125 },
    { x: 0.484375, y: 0.453125 },
    { x: 0.484375, y: 0.453125 },
    { x: 0.515625, y: 0.453125 },
    { x: 0.515625, y: 0.453125 },
    { x: 0.546875, y: 0.453125 },
    { x: 0.546875, y: 0.453125 },
    { x: 0.578125, y: 0.453125 },
    { x: 0.578125, y: 0.453125 },
    { x: 0.609375, y: 0.453125 },
    { x: 0.609375, y: 0.453125 },
    { x: 0.640625, y: 0.453125 },
    { x: 0.640625, y: 0.453125 },
    { x: 0.671875, y: 0.453125 },
    { x: 0.671875, y: 0.453125 },
    { x: 0.703125, y: 0.453125 },
    { x: 0.703125, y: 0.453125 },
    { x: 0.734375, y: 0.453125 },
    { x: 0.734375, y: 0.453125 },
    { x: 0.765625, y: 0.453125 },
    { x: 0.765625, y: 0.453125 },
    { x: 0.796875, y: 0.453125 },
    { x: 0.796875, y: 0.453125 },
    { x: 0.828125, y: 0.453125 },
    { x: 0.828125, y: 0.453125 },
    { x: 0.859375, y: 0.453125 },
    { x: 0.859375, y: 0.453125 },
    { x: 0.890625, y: 0.453125 },
    { x: 0.890625, y: 0.453125 },
    { x: 0.921875, y: 0.453125 },
    { x: 0.921875, y: 0.453125 },
    { x: 0.953125, y: 0.453125 },
    { x: 0.953125, y: 0.453125 },
    { x: 0.984375, y: 0.453125 },
    { x: 0.984375, y: 0.453125 },
    { x: 0.015625, y: 0.484375 },
    { x: 0.015625, y: 0.484375 },
    { x: 0.046875, y: 0.484375 },
    { x: 0.046875, y: 0.484375 },
    { x: 0.078125, y: 0.484375 },
    { x: 0.078125, y: 0.484375 },
    { x: 0.109375, y: 0.484375 },
    { x: 0.109375, y: 0.484375 },
    { x: 0.140625, y: 0.484375 },
    { x: 0.140625, y: 0.484375 },
    { x: 0.171875, y: 0.484375 },
    { x: 0.171875, y: 0.484375 },
    { x: 0.203125, y: 0.484375 },
    { x: 0.203125, y: 0.484375 },
    { x: 0.234375, y: 0.484375 },
    { x: 0.234375, y: 0.484375 },
    { x: 0.265625, y: 0.484375 },
    { x: 0.265625, y: 0.484375 },
    { x: 0.296875, y: 0.484375 },
    { x: 0.296875, y: 0.484375 },
    { x: 0.328125, y: 0.484375 },
    { x: 0.328125, y: 0.484375 },
    { x: 0.359375, y: 0.484375 },
    { x: 0.359375, y: 0.484375 },
    { x: 0.390625, y: 0.484375 },
    { x: 0.390625, y: 0.484375 },
    { x: 0.421875, y: 0.484375 },
    { x: 0.421875, y: 0.484375 },
    { x: 0.453125, y: 0.484375 },
    { x: 0.453125, y: 0.484375 },
    { x: 0.484375, y: 0.484375 },
    { x: 0.484375, y: 0.484375 },
    { x: 0.515625, y: 0.484375 },
    { x: 0.515625, y: 0.484375 },
    { x: 0.546875, y: 0.484375 },
    { x: 0.546875, y: 0.484375 },
    { x: 0.578125, y: 0.484375 },
    { x: 0.578125, y: 0.484375 },
    { x: 0.609375, y: 0.484375 },
    { x: 0.609375, y: 0.484375 },
    { x: 0.640625, y: 0.484375 },
    { x: 0.640625, y: 0.484375 },
    { x: 0.671875, y: 0.484375 },
    { x: 0.671875, y: 0.484375 },
    { x: 0.703125, y: 0.484375 },
    { x: 0.703125, y: 0.484375 },
    { x: 0.734375, y: 0.484375 },
    { x: 0.734375, y: 0.484375 },
    { x: 0.765625, y: 0.484375 },
    { x: 0.765625, y: 0.484375 },
    { x: 0.796875, y: 0.484375 },
    { x: 0.796875, y: 0.484375 },
    { x: 0.828125, y: 0.484375 },
    { x: 0.828125, y: 0.484375 },
    { x: 0.859375, y: 0.484375 },
    { x: 0.859375, y: 0.484375 },
    { x: 0.890625, y: 0.484375 },
    { x: 0.890625, y: 0.484375 },
    { x: 0.921875, y: 0.484375 },
    { x: 0.921875, y: 0.484375 },
    { x: 0.953125, y: 0.484375 },
    { x: 0.953125, y: 0.484375 },
    { x: 0.984375, y: 0.484375 },
    { x: 0.984375, y: 0.484375 },
    { x: 0.015625, y: 0.515625 },
    { x: 0.015625, y: 0.515625 },
    { x: 0.046875, y: 0.515625 },
    { x: 0.046875, y: 0.515625 },
    { x: 0.078125, y: 0.515625 },
    { x: 0.078125, y: 0.515625 },
    { x: 0.109375, y: 0.515625 },
    { x: 0.109375, y: 0.515625 },
    { x: 0.140625, y: 0.515625 },
    { x: 0.140625, y: 0.515625 },
    { x: 0.171875, y: 0.515625 },
    { x: 0.171875, y: 0.515625 },
    { x: 0.203125, y: 0.515625 },
    { x: 0.203125, y: 0.515625 },
    { x: 0.234375, y: 0.515625 },
    { x: 0.234375, y: 0.515625 },
    { x: 0.265625, y: 0.515625 },
    { x: 0.265625, y: 0.515625 },
    { x: 0.296875, y: 0.515625 },
    { x: 0.296875, y: 0.515625 },
    { x: 0.328125, y: 0.515625 },
    { x: 0.328125, y: 0.515625 },
    { x: 0.359375, y: 0.515625 },
    { x: 0.359375, y: 0.515625 },
    { x: 0.390625, y: 0.515625 },
    { x: 0.390625, y: 0.515625 },
    { x: 0.421875, y: 0.515625 },
    { x: 0.421875, y: 0.515625 },
    { x: 0.453125, y: 0.515625 },
    { x: 0.453125, y: 0.515625 },
    { x: 0.484375, y: 0.515625 },
    { x: 0.484375, y: 0.515625 },
    { x: 0.515625, y: 0.515625 },
    { x: 0.515625, y: 0.515625 },
    { x: 0.546875, y: 0.515625 },
    { x: 0.546875, y: 0.515625 },
    { x: 0.578125, y: 0.515625 },
    { x: 0.578125, y: 0.515625 },
    { x: 0.609375, y: 0.515625 },
    { x: 0.609375, y: 0.515625 },
    { x: 0.640625, y: 0.515625 },
    { x: 0.640625, y: 0.515625 },
    { x: 0.671875, y: 0.515625 },
    { x: 0.671875, y: 0.515625 },
    { x: 0.703125, y: 0.515625 },
    { x: 0.703125, y: 0.515625 },
    { x: 0.734375, y: 0.515625 },
    { x: 0.734375, y: 0.515625 },
    { x: 0.765625, y: 0.515625 },
    { x: 0.765625, y: 0.515625 },
    { x: 0.796875, y: 0.515625 },
    { x: 0.796875, y: 0.515625 },
    { x: 0.828125, y: 0.515625 },
    { x: 0.828125, y: 0.515625 },
    { x: 0.859375, y: 0.515625 },
    { x: 0.859375, y: 0.515625 },
    { x: 0.890625, y: 0.515625 },
    { x: 0.890625, y: 0.515625 },
    { x: 0.921875, y: 0.515625 },
    { x: 0.921875, y: 0.515625 },
    { x: 0.953125, y: 0.515625 },
    { x: 0.953125, y: 0.515625 },
    { x: 0.984375, y: 0.515625 },
    { x: 0.984375, y: 0.515625 },
    { x: 0.015625, y: 0.546875 },
    { x: 0.015625, y: 0.546875 },
    { x: 0.046875, y: 0.546875 },
    { x: 0.046875, y: 0.546875 },
    { x: 0.078125, y: 0.546875 },
    { x: 0.078125, y: 0.546875 },
    { x: 0.109375, y: 0.546875 },
    { x: 0.109375, y: 0.546875 },
    { x: 0.140625, y: 0.546875 },
    { x: 0.140625, y: 0.546875 },
    { x: 0.171875, y: 0.546875 },
    { x: 0.171875, y: 0.546875 },
    { x: 0.203125, y: 0.546875 },
    { x: 0.203125, y: 0.546875 },
    { x: 0.234375, y: 0.546875 },
    { x: 0.234375, y: 0.546875 },
    { x: 0.265625, y: 0.546875 },
    { x: 0.265625, y: 0.546875 },
    { x: 0.296875, y: 0.546875 },
    { x: 0.296875, y: 0.546875 },
    { x: 0.328125, y: 0.546875 },
    { x: 0.328125, y: 0.546875 },
    { x: 0.359375, y: 0.546875 },
    { x: 0.359375, y: 0.546875 },
    { x: 0.390625, y: 0.546875 },
    { x: 0.390625, y: 0.546875 },
    { x: 0.421875, y: 0.546875 },
    { x: 0.421875, y: 0.546875 },
    { x: 0.453125, y: 0.546875 },
    { x: 0.453125, y: 0.546875 },
    { x: 0.484375, y: 0.546875 },
    { x: 0.484375, y: 0.546875 },
    { x: 0.515625, y: 0.546875 },
    { x: 0.515625, y: 0.546875 },
    { x: 0.546875, y: 0.546875 },
    { x: 0.546875, y: 0.546875 },
    { x: 0.578125, y: 0.546875 },
    { x: 0.578125, y: 0.546875 },
    { x: 0.609375, y: 0.546875 },
    { x: 0.609375, y: 0.546875 },
    { x: 0.640625, y: 0.546875 },
    { x: 0.640625, y: 0.546875 },
    { x: 0.671875, y: 0.546875 },
    { x: 0.671875, y: 0.546875 },
    { x: 0.703125, y: 0.546875 },
    { x: 0.703125, y: 0.546875 },
    { x: 0.734375, y: 0.546875 },
    { x: 0.734375, y: 0.546875 },
    { x: 0.765625, y: 0.546875 },
    { x: 0.765625, y: 0.546875 },
    { x: 0.796875, y: 0.546875 },
    { x: 0.796875, y: 0.546875 },
    { x: 0.828125, y: 0.546875 },
    { x: 0.828125, y: 0.546875 },
    { x: 0.859375, y: 0.546875 },
    { x: 0.859375, y: 0.546875 },
    { x: 0.890625, y: 0.546875 },
    { x: 0.890625, y: 0.546875 },
    { x: 0.921875, y: 0.546875 },
    { x: 0.921875, y: 0.546875 },
    { x: 0.953125, y: 0.546875 },
    { x: 0.953125, y: 0.546875 },
    { x: 0.984375, y: 0.546875 },
    { x: 0.984375, y: 0.546875 },
    { x: 0.015625, y: 0.578125 },
    { x: 0.015625, y: 0.578125 },
    { x: 0.046875, y: 0.578125 },
    { x: 0.046875, y: 0.578125 },
    { x: 0.078125, y: 0.578125 },
    { x: 0.078125, y: 0.578125 },
    { x: 0.109375, y: 0.578125 },
    { x: 0.109375, y: 0.578125 },
    { x: 0.140625, y: 0.578125 },
    { x: 0.140625, y: 0.578125 },
    { x: 0.171875, y: 0.578125 },
    { x: 0.171875, y: 0.578125 },
    { x: 0.203125, y: 0.578125 },
    { x: 0.203125, y: 0.578125 },
    { x: 0.234375, y: 0.578125 },
    { x: 0.234375, y: 0.578125 },
    { x: 0.265625, y: 0.578125 },
    { x: 0.265625, y: 0.578125 },
    { x: 0.296875, y: 0.578125 },
    { x: 0.296875, y: 0.578125 },
    { x: 0.328125, y: 0.578125 },
    { x: 0.328125, y: 0.578125 },
    { x: 0.359375, y: 0.578125 },
    { x: 0.359375, y: 0.578125 },
    { x: 0.390625, y: 0.578125 },
    { x: 0.390625, y: 0.578125 },
    { x: 0.421875, y: 0.578125 },
    { x: 0.421875, y: 0.578125 },
    { x: 0.453125, y: 0.578125 },
    { x: 0.453125, y: 0.578125 },
    { x: 0.484375, y: 0.578125 },
    { x: 0.484375, y: 0.578125 },
    { x: 0.515625, y: 0.578125 },
    { x: 0.515625, y: 0.578125 },
    { x: 0.546875, y: 0.578125 },
    { x: 0.546875, y: 0.578125 },
    { x: 0.578125, y: 0.578125 },
    { x: 0.578125, y: 0.578125 },
    { x: 0.609375, y: 0.578125 },
    { x: 0.609375, y: 0.578125 },
    { x: 0.640625, y: 0.578125 },
    { x: 0.640625, y: 0.578125 },
    { x: 0.671875, y: 0.578125 },
    { x: 0.671875, y: 0.578125 },
    { x: 0.703125, y: 0.578125 },
    { x: 0.703125, y: 0.578125 },
    { x: 0.734375, y: 0.578125 },
    { x: 0.734375, y: 0.578125 },
    { x: 0.765625, y: 0.578125 },
    { x: 0.765625, y: 0.578125 },
    { x: 0.796875, y: 0.578125 },
    { x: 0.796875, y: 0.578125 },
    { x: 0.828125, y: 0.578125 },
    { x: 0.828125, y: 0.578125 },
    { x: 0.859375, y: 0.578125 },
    { x: 0.859375, y: 0.578125 },
    { x: 0.890625, y: 0.578125 },
    { x: 0.890625, y: 0.578125 },
    { x: 0.921875, y: 0.578125 },
    { x: 0.921875, y: 0.578125 },
    { x: 0.953125, y: 0.578125 },
    { x: 0.953125, y: 0.578125 },
    { x: 0.984375, y: 0.578125 },
    { x: 0.984375, y: 0.578125 },
    { x: 0.015625, y: 0.609375 },
    { x: 0.015625, y: 0.609375 },
    { x: 0.046875, y: 0.609375 },
    { x: 0.046875, y: 0.609375 },
    { x: 0.078125, y: 0.609375 },
    { x: 0.078125, y: 0.609375 },
    { x: 0.109375, y: 0.609375 },
    { x: 0.109375, y: 0.609375 },
    { x: 0.140625, y: 0.609375 },
    { x: 0.140625, y: 0.609375 },
    { x: 0.171875, y: 0.609375 },
    { x: 0.171875, y: 0.609375 },
    { x: 0.203125, y: 0.609375 },
    { x: 0.203125, y: 0.609375 },
    { x: 0.234375, y: 0.609375 },
    { x: 0.234375, y: 0.609375 },
    { x: 0.265625, y: 0.609375 },
    { x: 0.265625, y: 0.609375 },
    { x: 0.296875, y: 0.609375 },
    { x: 0.296875, y: 0.609375 },
    { x: 0.328125, y: 0.609375 },
    { x: 0.328125, y: 0.609375 },
    { x: 0.359375, y: 0.609375 },
    { x: 0.359375, y: 0.609375 },
    { x: 0.390625, y: 0.609375 },
    { x: 0.390625, y: 0.609375 },
    { x: 0.421875, y: 0.609375 },
    { x: 0.421875, y: 0.609375 },
    { x: 0.453125, y: 0.609375 },
    { x: 0.453125, y: 0.609375 },
    { x: 0.484375, y: 0.609375 },
    { x: 0.484375, y: 0.609375 },
    { x: 0.515625, y: 0.609375 },
    { x: 0.515625, y: 0.609375 },
    { x: 0.546875, y: 0.609375 },
    { x: 0.546875, y: 0.609375 },
    { x: 0.578125, y: 0.609375 },
    { x: 0.578125, y: 0.609375 },
    { x: 0.609375, y: 0.609375 },
    { x: 0.609375, y: 0.609375 },
    { x: 0.640625, y: 0.609375 },
    { x: 0.640625, y: 0.609375 },
    { x: 0.671875, y: 0.609375 },
    { x: 0.671875, y: 0.609375 },
    { x: 0.703125, y: 0.609375 },
    { x: 0.703125, y: 0.609375 },
    { x: 0.734375, y: 0.609375 },
    { x: 0.734375, y: 0.609375 },
    { x: 0.765625, y: 0.609375 },
    { x: 0.765625, y: 0.609375 },
    { x: 0.796875, y: 0.609375 },
    { x: 0.796875, y: 0.609375 },
    { x: 0.828125, y: 0.609375 },
    { x: 0.828125, y: 0.609375 },
    { x: 0.859375, y: 0.609375 },
    { x: 0.859375, y: 0.609375 },
    { x: 0.890625, y: 0.609375 },
    { x: 0.890625, y: 0.609375 },
    { x: 0.921875, y: 0.609375 },
    { x: 0.921875, y: 0.609375 },
    { x: 0.953125, y: 0.609375 },
    { x: 0.953125, y: 0.609375 },
    { x: 0.984375, y: 0.609375 },
    { x: 0.984375, y: 0.609375 },
    { x: 0.015625, y: 0.640625 },
    { x: 0.015625, y: 0.640625 },
    { x: 0.046875, y: 0.640625 },
    { x: 0.046875, y: 0.640625 },
    { x: 0.078125, y: 0.640625 },
    { x: 0.078125, y: 0.640625 },
    { x: 0.109375, y: 0.640625 },
    { x: 0.109375, y: 0.640625 },
    { x: 0.140625, y: 0.640625 },
    { x: 0.140625, y: 0.640625 },
    { x: 0.171875, y: 0.640625 },
    { x: 0.171875, y: 0.640625 },
    { x: 0.203125, y: 0.640625 },
    { x: 0.203125, y: 0.640625 },
    { x: 0.234375, y: 0.640625 },
    { x: 0.234375, y: 0.640625 },
    { x: 0.265625, y: 0.640625 },
    { x: 0.265625, y: 0.640625 },
    { x: 0.296875, y: 0.640625 },
    { x: 0.296875, y: 0.640625 },
    { x: 0.328125, y: 0.640625 },
    { x: 0.328125, y: 0.640625 },
    { x: 0.359375, y: 0.640625 },
    { x: 0.359375, y: 0.640625 },
    { x: 0.390625, y: 0.640625 },
    { x: 0.390625, y: 0.640625 },
    { x: 0.421875, y: 0.640625 },
    { x: 0.421875, y: 0.640625 },
    { x: 0.453125, y: 0.640625 },
    { x: 0.453125, y: 0.640625 },
    { x: 0.484375, y: 0.640625 },
    { x: 0.484375, y: 0.640625 },
    { x: 0.515625, y: 0.640625 },
    { x: 0.515625, y: 0.640625 },
    { x: 0.546875, y: 0.640625 },
    { x: 0.546875, y: 0.640625 },
    { x: 0.578125, y: 0.640625 },
    { x: 0.578125, y: 0.640625 },
    { x: 0.609375, y: 0.640625 },
    { x: 0.609375, y: 0.640625 },
    { x: 0.640625, y: 0.640625 },
    { x: 0.640625, y: 0.640625 },
    { x: 0.671875, y: 0.640625 },
    { x: 0.671875, y: 0.640625 },
    { x: 0.703125, y: 0.640625 },
    { x: 0.703125, y: 0.640625 },
    { x: 0.734375, y: 0.640625 },
    { x: 0.734375, y: 0.640625 },
    { x: 0.765625, y: 0.640625 },
    { x: 0.765625, y: 0.640625 },
    { x: 0.796875, y: 0.640625 },
    { x: 0.796875, y: 0.640625 },
    { x: 0.828125, y: 0.640625 },
    { x: 0.828125, y: 0.640625 },
    { x: 0.859375, y: 0.640625 },
    { x: 0.859375, y: 0.640625 },
    { x: 0.890625, y: 0.640625 },
    { x: 0.890625, y: 0.640625 },
    { x: 0.921875, y: 0.640625 },
    { x: 0.921875, y: 0.640625 },
    { x: 0.953125, y: 0.640625 },
    { x: 0.953125, y: 0.640625 },
    { x: 0.984375, y: 0.640625 },
    { x: 0.984375, y: 0.640625 },
    { x: 0.015625, y: 0.671875 },
    { x: 0.015625, y: 0.671875 },
    { x: 0.046875, y: 0.671875 },
    { x: 0.046875, y: 0.671875 },
    { x: 0.078125, y: 0.671875 },
    { x: 0.078125, y: 0.671875 },
    { x: 0.109375, y: 0.671875 },
    { x: 0.109375, y: 0.671875 },
    { x: 0.140625, y: 0.671875 },
    { x: 0.140625, y: 0.671875 },
    { x: 0.171875, y: 0.671875 },
    { x: 0.171875, y: 0.671875 },
    { x: 0.203125, y: 0.671875 },
    { x: 0.203125, y: 0.671875 },
    { x: 0.234375, y: 0.671875 },
    { x: 0.234375, y: 0.671875 },
    { x: 0.265625, y: 0.671875 },
    { x: 0.265625, y: 0.671875 },
    { x: 0.296875, y: 0.671875 },
    { x: 0.296875, y: 0.671875 },
    { x: 0.328125, y: 0.671875 },
    { x: 0.328125, y: 0.671875 },
    { x: 0.359375, y: 0.671875 },
    { x: 0.359375, y: 0.671875 },
    { x: 0.390625, y: 0.671875 },
    { x: 0.390625, y: 0.671875 },
    { x: 0.421875, y: 0.671875 },
    { x: 0.421875, y: 0.671875 },
    { x: 0.453125, y: 0.671875 },
    { x: 0.453125, y: 0.671875 },
    { x: 0.484375, y: 0.671875 },
    { x: 0.484375, y: 0.671875 },
    { x: 0.515625, y: 0.671875 },
    { x: 0.515625, y: 0.671875 },
    { x: 0.546875, y: 0.671875 },
    { x: 0.546875, y: 0.671875 },
    { x: 0.578125, y: 0.671875 },
    { x: 0.578125, y: 0.671875 },
    { x: 0.609375, y: 0.671875 },
    { x: 0.609375, y: 0.671875 },
    { x: 0.640625, y: 0.671875 },
    { x: 0.640625, y: 0.671875 },
    { x: 0.671875, y: 0.671875 },
    { x: 0.671875, y: 0.671875 },
    { x: 0.703125, y: 0.671875 },
    { x: 0.703125, y: 0.671875 },
    { x: 0.734375, y: 0.671875 },
    { x: 0.734375, y: 0.671875 },
    { x: 0.765625, y: 0.671875 },
    { x: 0.765625, y: 0.671875 },
    { x: 0.796875, y: 0.671875 },
    { x: 0.796875, y: 0.671875 },
    { x: 0.828125, y: 0.671875 },
    { x: 0.828125, y: 0.671875 },
    { x: 0.859375, y: 0.671875 },
    { x: 0.859375, y: 0.671875 },
    { x: 0.890625, y: 0.671875 },
    { x: 0.890625, y: 0.671875 },
    { x: 0.921875, y: 0.671875 },
    { x: 0.921875, y: 0.671875 },
    { x: 0.953125, y: 0.671875 },
    { x: 0.953125, y: 0.671875 },
    { x: 0.984375, y: 0.671875 },
    { x: 0.984375, y: 0.671875 },
    { x: 0.015625, y: 0.703125 },
    { x: 0.015625, y: 0.703125 },
    { x: 0.046875, y: 0.703125 },
    { x: 0.046875, y: 0.703125 },
    { x: 0.078125, y: 0.703125 },
    { x: 0.078125, y: 0.703125 },
    { x: 0.109375, y: 0.703125 },
    { x: 0.109375, y: 0.703125 },
    { x: 0.140625, y: 0.703125 },
    { x: 0.140625, y: 0.703125 },
    { x: 0.171875, y: 0.703125 },
    { x: 0.171875, y: 0.703125 },
    { x: 0.203125, y: 0.703125 },
    { x: 0.203125, y: 0.703125 },
    { x: 0.234375, y: 0.703125 },
    { x: 0.234375, y: 0.703125 },
    { x: 0.265625, y: 0.703125 },
    { x: 0.265625, y: 0.703125 },
    { x: 0.296875, y: 0.703125 },
    { x: 0.296875, y: 0.703125 },
    { x: 0.328125, y: 0.703125 },
    { x: 0.328125, y: 0.703125 },
    { x: 0.359375, y: 0.703125 },
    { x: 0.359375, y: 0.703125 },
    { x: 0.390625, y: 0.703125 },
    { x: 0.390625, y: 0.703125 },
    { x: 0.421875, y: 0.703125 },
    { x: 0.421875, y: 0.703125 },
    { x: 0.453125, y: 0.703125 },
    { x: 0.453125, y: 0.703125 },
    { x: 0.484375, y: 0.703125 },
    { x: 0.484375, y: 0.703125 },
    { x: 0.515625, y: 0.703125 },
    { x: 0.515625, y: 0.703125 },
    { x: 0.546875, y: 0.703125 },
    { x: 0.546875, y: 0.703125 },
    { x: 0.578125, y: 0.703125 },
    { x: 0.578125, y: 0.703125 },
    { x: 0.609375, y: 0.703125 },
    { x: 0.609375, y: 0.703125 },
    { x: 0.640625, y: 0.703125 },
    { x: 0.640625, y: 0.703125 },
    { x: 0.671875, y: 0.703125 },
    { x: 0.671875, y: 0.703125 },
    { x: 0.703125, y: 0.703125 },
    { x: 0.703125, y: 0.703125 },
    { x: 0.734375, y: 0.703125 },
    { x: 0.734375, y: 0.703125 },
    { x: 0.765625, y: 0.703125 },
    { x: 0.765625, y: 0.703125 },
    { x: 0.796875, y: 0.703125 },
    { x: 0.796875, y: 0.703125 },
    { x: 0.828125, y: 0.703125 },
    { x: 0.828125, y: 0.703125 },
    { x: 0.859375, y: 0.703125 },
    { x: 0.859375, y: 0.703125 },
    { x: 0.890625, y: 0.703125 },
    { x: 0.890625, y: 0.703125 },
    { x: 0.921875, y: 0.703125 },
    { x: 0.921875, y: 0.703125 },
    { x: 0.953125, y: 0.703125 },
    { x: 0.953125, y: 0.703125 },
    { x: 0.984375, y: 0.703125 },
    { x: 0.984375, y: 0.703125 },
    { x: 0.015625, y: 0.734375 },
    { x: 0.015625, y: 0.734375 },
    { x: 0.046875, y: 0.734375 },
    { x: 0.046875, y: 0.734375 },
    { x: 0.078125, y: 0.734375 },
    { x: 0.078125, y: 0.734375 },
    { x: 0.109375, y: 0.734375 },
    { x: 0.109375, y: 0.734375 },
    { x: 0.140625, y: 0.734375 },
    { x: 0.140625, y: 0.734375 },
    { x: 0.171875, y: 0.734375 },
    { x: 0.171875, y: 0.734375 },
    { x: 0.203125, y: 0.734375 },
    { x: 0.203125, y: 0.734375 },
    { x: 0.234375, y: 0.734375 },
    { x: 0.234375, y: 0.734375 },
    { x: 0.265625, y: 0.734375 },
    { x: 0.265625, y: 0.734375 },
    { x: 0.296875, y: 0.734375 },
    { x: 0.296875, y: 0.734375 },
    { x: 0.328125, y: 0.734375 },
    { x: 0.328125, y: 0.734375 },
    { x: 0.359375, y: 0.734375 },
    { x: 0.359375, y: 0.734375 },
    { x: 0.390625, y: 0.734375 },
    { x: 0.390625, y: 0.734375 },
    { x: 0.421875, y: 0.734375 },
    { x: 0.421875, y: 0.734375 },
    { x: 0.453125, y: 0.734375 },
    { x: 0.453125, y: 0.734375 },
    { x: 0.484375, y: 0.734375 },
    { x: 0.484375, y: 0.734375 },
    { x: 0.515625, y: 0.734375 },
    { x: 0.515625, y: 0.734375 },
    { x: 0.546875, y: 0.734375 },
    { x: 0.546875, y: 0.734375 },
    { x: 0.578125, y: 0.734375 },
    { x: 0.578125, y: 0.734375 },
    { x: 0.609375, y: 0.734375 },
    { x: 0.609375, y: 0.734375 },
    { x: 0.640625, y: 0.734375 },
    { x: 0.640625, y: 0.734375 },
    { x: 0.671875, y: 0.734375 },
    { x: 0.671875, y: 0.734375 },
    { x: 0.703125, y: 0.734375 },
    { x: 0.703125, y: 0.734375 },
    { x: 0.734375, y: 0.734375 },
    { x: 0.734375, y: 0.734375 },
    { x: 0.765625, y: 0.734375 },
    { x: 0.765625, y: 0.734375 },
    { x: 0.796875, y: 0.734375 },
    { x: 0.796875, y: 0.734375 },
    { x: 0.828125, y: 0.734375 },
    { x: 0.828125, y: 0.734375 },
    { x: 0.859375, y: 0.734375 },
    { x: 0.859375, y: 0.734375 },
    { x: 0.890625, y: 0.734375 },
    { x: 0.890625, y: 0.734375 },
    { x: 0.921875, y: 0.734375 },
    { x: 0.921875, y: 0.734375 },
    { x: 0.953125, y: 0.734375 },
    { x: 0.953125, y: 0.734375 },
    { x: 0.984375, y: 0.734375 },
    { x: 0.984375, y: 0.734375 },
    { x: 0.015625, y: 0.765625 },
    { x: 0.015625, y: 0.765625 },
    { x: 0.046875, y: 0.765625 },
    { x: 0.046875, y: 0.765625 },
    { x: 0.078125, y: 0.765625 },
    { x: 0.078125, y: 0.765625 },
    { x: 0.109375, y: 0.765625 },
    { x: 0.109375, y: 0.765625 },
    { x: 0.140625, y: 0.765625 },
    { x: 0.140625, y: 0.765625 },
    { x: 0.171875, y: 0.765625 },
    { x: 0.171875, y: 0.765625 },
    { x: 0.203125, y: 0.765625 },
    { x: 0.203125, y: 0.765625 },
    { x: 0.234375, y: 0.765625 },
    { x: 0.234375, y: 0.765625 },
    { x: 0.265625, y: 0.765625 },
    { x: 0.265625, y: 0.765625 },
    { x: 0.296875, y: 0.765625 },
    { x: 0.296875, y: 0.765625 },
    { x: 0.328125, y: 0.765625 },
    { x: 0.328125, y: 0.765625 },
    { x: 0.359375, y: 0.765625 },
    { x: 0.359375, y: 0.765625 },
    { x: 0.390625, y: 0.765625 },
    { x: 0.390625, y: 0.765625 },
    { x: 0.421875, y: 0.765625 },
    { x: 0.421875, y: 0.765625 },
    { x: 0.453125, y: 0.765625 },
    { x: 0.453125, y: 0.765625 },
    { x: 0.484375, y: 0.765625 },
    { x: 0.484375, y: 0.765625 },
    { x: 0.515625, y: 0.765625 },
    { x: 0.515625, y: 0.765625 },
    { x: 0.546875, y: 0.765625 },
    { x: 0.546875, y: 0.765625 },
    { x: 0.578125, y: 0.765625 },
    { x: 0.578125, y: 0.765625 },
    { x: 0.609375, y: 0.765625 },
    { x: 0.609375, y: 0.765625 },
    { x: 0.640625, y: 0.765625 },
    { x: 0.640625, y: 0.765625 },
    { x: 0.671875, y: 0.765625 },
    { x: 0.671875, y: 0.765625 },
    { x: 0.703125, y: 0.765625 },
    { x: 0.703125, y: 0.765625 },
    { x: 0.734375, y: 0.765625 },
    { x: 0.734375, y: 0.765625 },
    { x: 0.765625, y: 0.765625 },
    { x: 0.765625, y: 0.765625 },
    { x: 0.796875, y: 0.765625 },
    { x: 0.796875, y: 0.765625 },
    { x: 0.828125, y: 0.765625 },
    { x: 0.828125, y: 0.765625 },
    { x: 0.859375, y: 0.765625 },
    { x: 0.859375, y: 0.765625 },
    { x: 0.890625, y: 0.765625 },
    { x: 0.890625, y: 0.765625 },
    { x: 0.921875, y: 0.765625 },
    { x: 0.921875, y: 0.765625 },
    { x: 0.953125, y: 0.765625 },
    { x: 0.953125, y: 0.765625 },
    { x: 0.984375, y: 0.765625 },
    { x: 0.984375, y: 0.765625 },
    { x: 0.015625, y: 0.796875 },
    { x: 0.015625, y: 0.796875 },
    { x: 0.046875, y: 0.796875 },
    { x: 0.046875, y: 0.796875 },
    { x: 0.078125, y: 0.796875 },
    { x: 0.078125, y: 0.796875 },
    { x: 0.109375, y: 0.796875 },
    { x: 0.109375, y: 0.796875 },
    { x: 0.140625, y: 0.796875 },
    { x: 0.140625, y: 0.796875 },
    { x: 0.171875, y: 0.796875 },
    { x: 0.171875, y: 0.796875 },
    { x: 0.203125, y: 0.796875 },
    { x: 0.203125, y: 0.796875 },
    { x: 0.234375, y: 0.796875 },
    { x: 0.234375, y: 0.796875 },
    { x: 0.265625, y: 0.796875 },
    { x: 0.265625, y: 0.796875 },
    { x: 0.296875, y: 0.796875 },
    { x: 0.296875, y: 0.796875 },
    { x: 0.328125, y: 0.796875 },
    { x: 0.328125, y: 0.796875 },
    { x: 0.359375, y: 0.796875 },
    { x: 0.359375, y: 0.796875 },
    { x: 0.390625, y: 0.796875 },
    { x: 0.390625, y: 0.796875 },
    { x: 0.421875, y: 0.796875 },
    { x: 0.421875, y: 0.796875 },
    { x: 0.453125, y: 0.796875 },
    { x: 0.453125, y: 0.796875 },
    { x: 0.484375, y: 0.796875 },
    { x: 0.484375, y: 0.796875 },
    { x: 0.515625, y: 0.796875 },
    { x: 0.515625, y: 0.796875 },
    { x: 0.546875, y: 0.796875 },
    { x: 0.546875, y: 0.796875 },
    { x: 0.578125, y: 0.796875 },
    { x: 0.578125, y: 0.796875 },
    { x: 0.609375, y: 0.796875 },
    { x: 0.609375, y: 0.796875 },
    { x: 0.640625, y: 0.796875 },
    { x: 0.640625, y: 0.796875 },
    { x: 0.671875, y: 0.796875 },
    { x: 0.671875, y: 0.796875 },
    { x: 0.703125, y: 0.796875 },
    { x: 0.703125, y: 0.796875 },
    { x: 0.734375, y: 0.796875 },
    { x: 0.734375, y: 0.796875 },
    { x: 0.765625, y: 0.796875 },
    { x: 0.765625, y: 0.796875 },
    { x: 0.796875, y: 0.796875 },
    { x: 0.796875, y: 0.796875 },
    { x: 0.828125, y: 0.796875 },
    { x: 0.828125, y: 0.796875 },
    { x: 0.859375, y: 0.796875 },
    { x: 0.859375, y: 0.796875 },
    { x: 0.890625, y: 0.796875 },
    { x: 0.890625, y: 0.796875 },
    { x: 0.921875, y: 0.796875 },
    { x: 0.921875, y: 0.796875 },
    { x: 0.953125, y: 0.796875 },
    { x: 0.953125, y: 0.796875 },
    { x: 0.984375, y: 0.796875 },
    { x: 0.984375, y: 0.796875 },
    { x: 0.015625, y: 0.828125 },
    { x: 0.015625, y: 0.828125 },
    { x: 0.046875, y: 0.828125 },
    { x: 0.046875, y: 0.828125 },
    { x: 0.078125, y: 0.828125 },
    { x: 0.078125, y: 0.828125 },
    { x: 0.109375, y: 0.828125 },
    { x: 0.109375, y: 0.828125 },
    { x: 0.140625, y: 0.828125 },
    { x: 0.140625, y: 0.828125 },
    { x: 0.171875, y: 0.828125 },
    { x: 0.171875, y: 0.828125 },
    { x: 0.203125, y: 0.828125 },
    { x: 0.203125, y: 0.828125 },
    { x: 0.234375, y: 0.828125 },
    { x: 0.234375, y: 0.828125 },
    { x: 0.265625, y: 0.828125 },
    { x: 0.265625, y: 0.828125 },
    { x: 0.296875, y: 0.828125 },
    { x: 0.296875, y: 0.828125 },
    { x: 0.328125, y: 0.828125 },
    { x: 0.328125, y: 0.828125 },
    { x: 0.359375, y: 0.828125 },
    { x: 0.359375, y: 0.828125 },
    { x: 0.390625, y: 0.828125 },
    { x: 0.390625, y: 0.828125 },
    { x: 0.421875, y: 0.828125 },
    { x: 0.421875, y: 0.828125 },
    { x: 0.453125, y: 0.828125 },
    { x: 0.453125, y: 0.828125 },
    { x: 0.484375, y: 0.828125 },
    { x: 0.484375, y: 0.828125 },
    { x: 0.515625, y: 0.828125 },
    { x: 0.515625, y: 0.828125 },
    { x: 0.546875, y: 0.828125 },
    { x: 0.546875, y: 0.828125 },
    { x: 0.578125, y: 0.828125 },
    { x: 0.578125, y: 0.828125 },
    { x: 0.609375, y: 0.828125 },
    { x: 0.609375, y: 0.828125 },
    { x: 0.640625, y: 0.828125 },
    { x: 0.640625, y: 0.828125 },
    { x: 0.671875, y: 0.828125 },
    { x: 0.671875, y: 0.828125 },
    { x: 0.703125, y: 0.828125 },
    { x: 0.703125, y: 0.828125 },
    { x: 0.734375, y: 0.828125 },
    { x: 0.734375, y: 0.828125 },
    { x: 0.765625, y: 0.828125 },
    { x: 0.765625, y: 0.828125 },
    { x: 0.796875, y: 0.828125 },
    { x: 0.796875, y: 0.828125 },
    { x: 0.828125, y: 0.828125 },
    { x: 0.828125, y: 0.828125 },
    { x: 0.859375, y: 0.828125 },
    { x: 0.859375, y: 0.828125 },
    { x: 0.890625, y: 0.828125 },
    { x: 0.890625, y: 0.828125 },
    { x: 0.921875, y: 0.828125 },
    { x: 0.921875, y: 0.828125 },
    { x: 0.953125, y: 0.828125 },
    { x: 0.953125, y: 0.828125 },
    { x: 0.984375, y: 0.828125 },
    { x: 0.984375, y: 0.828125 },
    { x: 0.015625, y: 0.859375 },
    { x: 0.015625, y: 0.859375 },
    { x: 0.046875, y: 0.859375 },
    { x: 0.046875, y: 0.859375 },
    { x: 0.078125, y: 0.859375 },
    { x: 0.078125, y: 0.859375 },
    { x: 0.109375, y: 0.859375 },
    { x: 0.109375, y: 0.859375 },
    { x: 0.140625, y: 0.859375 },
    { x: 0.140625, y: 0.859375 },
    { x: 0.171875, y: 0.859375 },
    { x: 0.171875, y: 0.859375 },
    { x: 0.203125, y: 0.859375 },
    { x: 0.203125, y: 0.859375 },
    { x: 0.234375, y: 0.859375 },
    { x: 0.234375, y: 0.859375 },
    { x: 0.265625, y: 0.859375 },
    { x: 0.265625, y: 0.859375 },
    { x: 0.296875, y: 0.859375 },
    { x: 0.296875, y: 0.859375 },
    { x: 0.328125, y: 0.859375 },
    { x: 0.328125, y: 0.859375 },
    { x: 0.359375, y: 0.859375 },
    { x: 0.359375, y: 0.859375 },
    { x: 0.390625, y: 0.859375 },
    { x: 0.390625, y: 0.859375 },
    { x: 0.421875, y: 0.859375 },
    { x: 0.421875, y: 0.859375 },
    { x: 0.453125, y: 0.859375 },
    { x: 0.453125, y: 0.859375 },
    { x: 0.484375, y: 0.859375 },
    { x: 0.484375, y: 0.859375 },
    { x: 0.515625, y: 0.859375 },
    { x: 0.515625, y: 0.859375 },
    { x: 0.546875, y: 0.859375 },
    { x: 0.546875, y: 0.859375 },
    { x: 0.578125, y: 0.859375 },
    { x: 0.578125, y: 0.859375 },
    { x: 0.609375, y: 0.859375 },
    { x: 0.609375, y: 0.859375 },
    { x: 0.640625, y: 0.859375 },
    { x: 0.640625, y: 0.859375 },
    { x: 0.671875, y: 0.859375 },
    { x: 0.671875, y: 0.859375 },
    { x: 0.703125, y: 0.859375 },
    { x: 0.703125, y: 0.859375 },
    { x: 0.734375, y: 0.859375 },
    { x: 0.734375, y: 0.859375 },
    { x: 0.765625, y: 0.859375 },
    { x: 0.765625, y: 0.859375 },
    { x: 0.796875, y: 0.859375 },
    { x: 0.796875, y: 0.859375 },
    { x: 0.828125, y: 0.859375 },
    { x: 0.828125, y: 0.859375 },
    { x: 0.859375, y: 0.859375 },
    { x: 0.859375, y: 0.859375 },
    { x: 0.890625, y: 0.859375 },
    { x: 0.890625, y: 0.859375 },
    { x: 0.921875, y: 0.859375 },
    { x: 0.921875, y: 0.859375 },
    { x: 0.953125, y: 0.859375 },
    { x: 0.953125, y: 0.859375 },
    { x: 0.984375, y: 0.859375 },
    { x: 0.984375, y: 0.859375 },
    { x: 0.015625, y: 0.890625 },
    { x: 0.015625, y: 0.890625 },
    { x: 0.046875, y: 0.890625 },
    { x: 0.046875, y: 0.890625 },
    { x: 0.078125, y: 0.890625 },
    { x: 0.078125, y: 0.890625 },
    { x: 0.109375, y: 0.890625 },
    { x: 0.109375, y: 0.890625 },
    { x: 0.140625, y: 0.890625 },
    { x: 0.140625, y: 0.890625 },
    { x: 0.171875, y: 0.890625 },
    { x: 0.171875, y: 0.890625 },
    { x: 0.203125, y: 0.890625 },
    { x: 0.203125, y: 0.890625 },
    { x: 0.234375, y: 0.890625 },
    { x: 0.234375, y: 0.890625 },
    { x: 0.265625, y: 0.890625 },
    { x: 0.265625, y: 0.890625 },
    { x: 0.296875, y: 0.890625 },
    { x: 0.296875, y: 0.890625 },
    { x: 0.328125, y: 0.890625 },
    { x: 0.328125, y: 0.890625 },
    { x: 0.359375, y: 0.890625 },
    { x: 0.359375, y: 0.890625 },
    { x: 0.390625, y: 0.890625 },
    { x: 0.390625, y: 0.890625 },
    { x: 0.421875, y: 0.890625 },
    { x: 0.421875, y: 0.890625 },
    { x: 0.453125, y: 0.890625 },
    { x: 0.453125, y: 0.890625 },
    { x: 0.484375, y: 0.890625 },
    { x: 0.484375, y: 0.890625 },
    { x: 0.515625, y: 0.890625 },
    { x: 0.515625, y: 0.890625 },
    { x: 0.546875, y: 0.890625 },
    { x: 0.546875, y: 0.890625 },
    { x: 0.578125, y: 0.890625 },
    { x: 0.578125, y: 0.890625 },
    { x: 0.609375, y: 0.890625 },
    { x: 0.609375, y: 0.890625 },
    { x: 0.640625, y: 0.890625 },
    { x: 0.640625, y: 0.890625 },
    { x: 0.671875, y: 0.890625 },
    { x: 0.671875, y: 0.890625 },
    { x: 0.703125, y: 0.890625 },
    { x: 0.703125, y: 0.890625 },
    { x: 0.734375, y: 0.890625 },
    { x: 0.734375, y: 0.890625 },
    { x: 0.765625, y: 0.890625 },
    { x: 0.765625, y: 0.890625 },
    { x: 0.796875, y: 0.890625 },
    { x: 0.796875, y: 0.890625 },
    { x: 0.828125, y: 0.890625 },
    { x: 0.828125, y: 0.890625 },
    { x: 0.859375, y: 0.890625 },
    { x: 0.859375, y: 0.890625 },
    { x: 0.890625, y: 0.890625 },
    { x: 0.890625, y: 0.890625 },
    { x: 0.921875, y: 0.890625 },
    { x: 0.921875, y: 0.890625 },
    { x: 0.953125, y: 0.890625 },
    { x: 0.953125, y: 0.890625 },
    { x: 0.984375, y: 0.890625 },
    { x: 0.984375, y: 0.890625 },
    { x: 0.015625, y: 0.921875 },
    { x: 0.015625, y: 0.921875 },
    { x: 0.046875, y: 0.921875 },
    { x: 0.046875, y: 0.921875 },
    { x: 0.078125, y: 0.921875 },
    { x: 0.078125, y: 0.921875 },
    { x: 0.109375, y: 0.921875 },
    { x: 0.109375, y: 0.921875 },
    { x: 0.140625, y: 0.921875 },
    { x: 0.140625, y: 0.921875 },
    { x: 0.171875, y: 0.921875 },
    { x: 0.171875, y: 0.921875 },
    { x: 0.203125, y: 0.921875 },
    { x: 0.203125, y: 0.921875 },
    { x: 0.234375, y: 0.921875 },
    { x: 0.234375, y: 0.921875 },
    { x: 0.265625, y: 0.921875 },
    { x: 0.265625, y: 0.921875 },
    { x: 0.296875, y: 0.921875 },
    { x: 0.296875, y: 0.921875 },
    { x: 0.328125, y: 0.921875 },
    { x: 0.328125, y: 0.921875 },
    { x: 0.359375, y: 0.921875 },
    { x: 0.359375, y: 0.921875 },
    { x: 0.390625, y: 0.921875 },
    { x: 0.390625, y: 0.921875 },
    { x: 0.421875, y: 0.921875 },
    { x: 0.421875, y: 0.921875 },
    { x: 0.453125, y: 0.921875 },
    { x: 0.453125, y: 0.921875 },
    { x: 0.484375, y: 0.921875 },
    { x: 0.484375, y: 0.921875 },
    { x: 0.515625, y: 0.921875 },
    { x: 0.515625, y: 0.921875 },
    { x: 0.546875, y: 0.921875 },
    { x: 0.546875, y: 0.921875 },
    { x: 0.578125, y: 0.921875 },
    { x: 0.578125, y: 0.921875 },
    { x: 0.609375, y: 0.921875 },
    { x: 0.609375, y: 0.921875 },
    { x: 0.640625, y: 0.921875 },
    { x: 0.640625, y: 0.921875 },
    { x: 0.671875, y: 0.921875 },
    { x: 0.671875, y: 0.921875 },
    { x: 0.703125, y: 0.921875 },
    { x: 0.703125, y: 0.921875 },
    { x: 0.734375, y: 0.921875 },
    { x: 0.734375, y: 0.921875 },
    { x: 0.765625, y: 0.921875 },
    { x: 0.765625, y: 0.921875 },
    { x: 0.796875, y: 0.921875 },
    { x: 0.796875, y: 0.921875 },
    { x: 0.828125, y: 0.921875 },
    { x: 0.828125, y: 0.921875 },
    { x: 0.859375, y: 0.921875 },
    { x: 0.859375, y: 0.921875 },
    { x: 0.890625, y: 0.921875 },
    { x: 0.890625, y: 0.921875 },
    { x: 0.921875, y: 0.921875 },
    { x: 0.921875, y: 0.921875 },
    { x: 0.953125, y: 0.921875 },
    { x: 0.953125, y: 0.921875 },
    { x: 0.984375, y: 0.921875 },
    { x: 0.984375, y: 0.921875 },
    { x: 0.015625, y: 0.953125 },
    { x: 0.015625, y: 0.953125 },
    { x: 0.046875, y: 0.953125 },
    { x: 0.046875, y: 0.953125 },
    { x: 0.078125, y: 0.953125 },
    { x: 0.078125, y: 0.953125 },
    { x: 0.109375, y: 0.953125 },
    { x: 0.109375, y: 0.953125 },
    { x: 0.140625, y: 0.953125 },
    { x: 0.140625, y: 0.953125 },
    { x: 0.171875, y: 0.953125 },
    { x: 0.171875, y: 0.953125 },
    { x: 0.203125, y: 0.953125 },
    { x: 0.203125, y: 0.953125 },
    { x: 0.234375, y: 0.953125 },
    { x: 0.234375, y: 0.953125 },
    { x: 0.265625, y: 0.953125 },
    { x: 0.265625, y: 0.953125 },
    { x: 0.296875, y: 0.953125 },
    { x: 0.296875, y: 0.953125 },
    { x: 0.328125, y: 0.953125 },
    { x: 0.328125, y: 0.953125 },
    { x: 0.359375, y: 0.953125 },
    { x: 0.359375, y: 0.953125 },
    { x: 0.390625, y: 0.953125 },
    { x: 0.390625, y: 0.953125 },
    { x: 0.421875, y: 0.953125 },
    { x: 0.421875, y: 0.953125 },
    { x: 0.453125, y: 0.953125 },
    { x: 0.453125, y: 0.953125 },
    { x: 0.484375, y: 0.953125 },
    { x: 0.484375, y: 0.953125 },
    { x: 0.515625, y: 0.953125 },
    { x: 0.515625, y: 0.953125 },
    { x: 0.546875, y: 0.953125 },
    { x: 0.546875, y: 0.953125 },
    { x: 0.578125, y: 0.953125 },
    { x: 0.578125, y: 0.953125 },
    { x: 0.609375, y: 0.953125 },
    { x: 0.609375, y: 0.953125 },
    { x: 0.640625, y: 0.953125 },
    { x: 0.640625, y: 0.953125 },
    { x: 0.671875, y: 0.953125 },
    { x: 0.671875, y: 0.953125 },
    { x: 0.703125, y: 0.953125 },
    { x: 0.703125, y: 0.953125 },
    { x: 0.734375, y: 0.953125 },
    { x: 0.734375, y: 0.953125 },
    { x: 0.765625, y: 0.953125 },
    { x: 0.765625, y: 0.953125 },
    { x: 0.796875, y: 0.953125 },
    { x: 0.796875, y: 0.953125 },
    { x: 0.828125, y: 0.953125 },
    { x: 0.828125, y: 0.953125 },
    { x: 0.859375, y: 0.953125 },
    { x: 0.859375, y: 0.953125 },
    { x: 0.890625, y: 0.953125 },
    { x: 0.890625, y: 0.953125 },
    { x: 0.921875, y: 0.953125 },
    { x: 0.921875, y: 0.953125 },
    { x: 0.953125, y: 0.953125 },
    { x: 0.953125, y: 0.953125 },
    { x: 0.984375, y: 0.953125 },
    { x: 0.984375, y: 0.953125 },
    { x: 0.015625, y: 0.984375 },
    { x: 0.015625, y: 0.984375 },
    { x: 0.046875, y: 0.984375 },
    { x: 0.046875, y: 0.984375 },
    { x: 0.078125, y: 0.984375 },
    { x: 0.078125, y: 0.984375 },
    { x: 0.109375, y: 0.984375 },
    { x: 0.109375, y: 0.984375 },
    { x: 0.140625, y: 0.984375 },
    { x: 0.140625, y: 0.984375 },
    { x: 0.171875, y: 0.984375 },
    { x: 0.171875, y: 0.984375 },
    { x: 0.203125, y: 0.984375 },
    { x: 0.203125, y: 0.984375 },
    { x: 0.234375, y: 0.984375 },
    { x: 0.234375, y: 0.984375 },
    { x: 0.265625, y: 0.984375 },
    { x: 0.265625, y: 0.984375 },
    { x: 0.296875, y: 0.984375 },
    { x: 0.296875, y: 0.984375 },
    { x: 0.328125, y: 0.984375 },
    { x: 0.328125, y: 0.984375 },
    { x: 0.359375, y: 0.984375 },
    { x: 0.359375, y: 0.984375 },
    { x: 0.390625, y: 0.984375 },
    { x: 0.390625, y: 0.984375 },
    { x: 0.421875, y: 0.984375 },
    { x: 0.421875, y: 0.984375 },
    { x: 0.453125, y: 0.984375 },
    { x: 0.453125, y: 0.984375 },
    { x: 0.484375, y: 0.984375 },
    { x: 0.484375, y: 0.984375 },
    { x: 0.515625, y: 0.984375 },
    { x: 0.515625, y: 0.984375 },
    { x: 0.546875, y: 0.984375 },
    { x: 0.546875, y: 0.984375 },
    { x: 0.578125, y: 0.984375 },
    { x: 0.578125, y: 0.984375 },
    { x: 0.609375, y: 0.984375 },
    { x: 0.609375, y: 0.984375 },
    { x: 0.640625, y: 0.984375 },
    { x: 0.640625, y: 0.984375 },
    { x: 0.671875, y: 0.984375 },
    { x: 0.671875, y: 0.984375 },
    { x: 0.703125, y: 0.984375 },
    { x: 0.703125, y: 0.984375 },
    { x: 0.734375, y: 0.984375 },
    { x: 0.734375, y: 0.984375 },
    { x: 0.765625, y: 0.984375 },
    { x: 0.765625, y: 0.984375 },
    { x: 0.796875, y: 0.984375 },
    { x: 0.796875, y: 0.984375 },
    { x: 0.828125, y: 0.984375 },
    { x: 0.828125, y: 0.984375 },
    { x: 0.859375, y: 0.984375 },
    { x: 0.859375, y: 0.984375 },
    { x: 0.890625, y: 0.984375 },
    { x: 0.890625, y: 0.984375 },
    { x: 0.921875, y: 0.984375 },
    { x: 0.921875, y: 0.984375 },
    { x: 0.953125, y: 0.984375 },
    { x: 0.953125, y: 0.984375 },
    { x: 0.984375, y: 0.984375 },
    { x: 0.984375, y: 0.984375 },
    { x: 0.03125, y: 0.03125 },
    { x: 0.03125, y: 0.03125 },
    { x: 0.09375, y: 0.03125 },
    { x: 0.09375, y: 0.03125 },
    { x: 0.15625, y: 0.03125 },
    { x: 0.15625, y: 0.03125 },
    { x: 0.21875, y: 0.03125 },
    { x: 0.21875, y: 0.03125 },
    { x: 0.28125, y: 0.03125 },
    { x: 0.28125, y: 0.03125 },
    { x: 0.34375, y: 0.03125 },
    { x: 0.34375, y: 0.03125 },
    { x: 0.40625, y: 0.03125 },
    { x: 0.40625, y: 0.03125 },
    { x: 0.46875, y: 0.03125 },
    { x: 0.46875, y: 0.03125 },
    { x: 0.53125, y: 0.03125 },
    { x: 0.53125, y: 0.03125 },
    { x: 0.59375, y: 0.03125 },
    { x: 0.59375, y: 0.03125 },
    { x: 0.65625, y: 0.03125 },
    { x: 0.65625, y: 0.03125 },
    { x: 0.71875, y: 0.03125 },
    { x: 0.71875, y: 0.03125 },
    { x: 0.78125, y: 0.03125 },
    { x: 0.78125, y: 0.03125 },
    { x: 0.84375, y: 0.03125 },
    { x: 0.84375, y: 0.03125 },
    { x: 0.90625, y: 0.03125 },
    { x: 0.90625, y: 0.03125 },
    { x: 0.96875, y: 0.03125 },
    { x: 0.96875, y: 0.03125 },
    { x: 0.03125, y: 0.09375 },
    { x: 0.03125, y: 0.09375 },
    { x: 0.09375, y: 0.09375 },
    { x: 0.09375, y: 0.09375 },
    { x: 0.15625, y: 0.09375 },
    { x: 0.15625, y: 0.09375 },
    { x: 0.21875, y: 0.09375 },
    { x: 0.21875, y: 0.09375 },
    { x: 0.28125, y: 0.09375 },
    { x: 0.28125, y: 0.09375 },
    { x: 0.34375, y: 0.09375 },
    { x: 0.34375, y: 0.09375 },
    { x: 0.40625, y: 0.09375 },
    { x: 0.40625, y: 0.09375 },
    { x: 0.46875, y: 0.09375 },
    { x: 0.46875, y: 0.09375 },
    { x: 0.53125, y: 0.09375 },
    { x: 0.53125, y: 0.09375 },
    { x: 0.59375, y: 0.09375 },
    { x: 0.59375, y: 0.09375 },
    { x: 0.65625, y: 0.09375 },
    { x: 0.65625, y: 0.09375 },
    { x: 0.71875, y: 0.09375 },
    { x: 0.71875, y: 0.09375 },
    { x: 0.78125, y: 0.09375 },
    { x: 0.78125, y: 0.09375 },
    { x: 0.84375, y: 0.09375 },
    { x: 0.84375, y: 0.09375 },
    { x: 0.90625, y: 0.09375 },
    { x: 0.90625, y: 0.09375 },
    { x: 0.96875, y: 0.09375 },
    { x: 0.96875, y: 0.09375 },
    { x: 0.03125, y: 0.15625 },
    { x: 0.03125, y: 0.15625 },
    { x: 0.09375, y: 0.15625 },
    { x: 0.09375, y: 0.15625 },
    { x: 0.15625, y: 0.15625 },
    { x: 0.15625, y: 0.15625 },
    { x: 0.21875, y: 0.15625 },
    { x: 0.21875, y: 0.15625 },
    { x: 0.28125, y: 0.15625 },
    { x: 0.28125, y: 0.15625 },
    { x: 0.34375, y: 0.15625 },
    { x: 0.34375, y: 0.15625 },
    { x: 0.40625, y: 0.15625 },
    { x: 0.40625, y: 0.15625 },
    { x: 0.46875, y: 0.15625 },
    { x: 0.46875, y: 0.15625 },
    { x: 0.53125, y: 0.15625 },
    { x: 0.53125, y: 0.15625 },
    { x: 0.59375, y: 0.15625 },
    { x: 0.59375, y: 0.15625 },
    { x: 0.65625, y: 0.15625 },
    { x: 0.65625, y: 0.15625 },
    { x: 0.71875, y: 0.15625 },
    { x: 0.71875, y: 0.15625 },
    { x: 0.78125, y: 0.15625 },
    { x: 0.78125, y: 0.15625 },
    { x: 0.84375, y: 0.15625 },
    { x: 0.84375, y: 0.15625 },
    { x: 0.90625, y: 0.15625 },
    { x: 0.90625, y: 0.15625 },
    { x: 0.96875, y: 0.15625 },
    { x: 0.96875, y: 0.15625 },
    { x: 0.03125, y: 0.21875 },
    { x: 0.03125, y: 0.21875 },
    { x: 0.09375, y: 0.21875 },
    { x: 0.09375, y: 0.21875 },
    { x: 0.15625, y: 0.21875 },
    { x: 0.15625, y: 0.21875 },
    { x: 0.21875, y: 0.21875 },
    { x: 0.21875, y: 0.21875 },
    { x: 0.28125, y: 0.21875 },
    { x: 0.28125, y: 0.21875 },
    { x: 0.34375, y: 0.21875 },
    { x: 0.34375, y: 0.21875 },
    { x: 0.40625, y: 0.21875 },
    { x: 0.40625, y: 0.21875 },
    { x: 0.46875, y: 0.21875 },
    { x: 0.46875, y: 0.21875 },
    { x: 0.53125, y: 0.21875 },
    { x: 0.53125, y: 0.21875 },
    { x: 0.59375, y: 0.21875 },
    { x: 0.59375, y: 0.21875 },
    { x: 0.65625, y: 0.21875 },
    { x: 0.65625, y: 0.21875 },
    { x: 0.71875, y: 0.21875 },
    { x: 0.71875, y: 0.21875 },
    { x: 0.78125, y: 0.21875 },
    { x: 0.78125, y: 0.21875 },
    { x: 0.84375, y: 0.21875 },
    { x: 0.84375, y: 0.21875 },
    { x: 0.90625, y: 0.21875 },
    { x: 0.90625, y: 0.21875 },
    { x: 0.96875, y: 0.21875 },
    { x: 0.96875, y: 0.21875 },
    { x: 0.03125, y: 0.28125 },
    { x: 0.03125, y: 0.28125 },
    { x: 0.09375, y: 0.28125 },
    { x: 0.09375, y: 0.28125 },
    { x: 0.15625, y: 0.28125 },
    { x: 0.15625, y: 0.28125 },
    { x: 0.21875, y: 0.28125 },
    { x: 0.21875, y: 0.28125 },
    { x: 0.28125, y: 0.28125 },
    { x: 0.28125, y: 0.28125 },
    { x: 0.34375, y: 0.28125 },
    { x: 0.34375, y: 0.28125 },
    { x: 0.40625, y: 0.28125 },
    { x: 0.40625, y: 0.28125 },
    { x: 0.46875, y: 0.28125 },
    { x: 0.46875, y: 0.28125 },
    { x: 0.53125, y: 0.28125 },
    { x: 0.53125, y: 0.28125 },
    { x: 0.59375, y: 0.28125 },
    { x: 0.59375, y: 0.28125 },
    { x: 0.65625, y: 0.28125 },
    { x: 0.65625, y: 0.28125 },
    { x: 0.71875, y: 0.28125 },
    { x: 0.71875, y: 0.28125 },
    { x: 0.78125, y: 0.28125 },
    { x: 0.78125, y: 0.28125 },
    { x: 0.84375, y: 0.28125 },
    { x: 0.84375, y: 0.28125 },
    { x: 0.90625, y: 0.28125 },
    { x: 0.90625, y: 0.28125 },
    { x: 0.96875, y: 0.28125 },
    { x: 0.96875, y: 0.28125 },
    { x: 0.03125, y: 0.34375 },
    { x: 0.03125, y: 0.34375 },
    { x: 0.09375, y: 0.34375 },
    { x: 0.09375, y: 0.34375 },
    { x: 0.15625, y: 0.34375 },
    { x: 0.15625, y: 0.34375 },
    { x: 0.21875, y: 0.34375 },
    { x: 0.21875, y: 0.34375 },
    { x: 0.28125, y: 0.34375 },
    { x: 0.28125, y: 0.34375 },
    { x: 0.34375, y: 0.34375 },
    { x: 0.34375, y: 0.34375 },
    { x: 0.40625, y: 0.34375 },
    { x: 0.40625, y: 0.34375 },
    { x: 0.46875, y: 0.34375 },
    { x: 0.46875, y: 0.34375 },
    { x: 0.53125, y: 0.34375 },
    { x: 0.53125, y: 0.34375 },
    { x: 0.59375, y: 0.34375 },
    { x: 0.59375, y: 0.34375 },
    { x: 0.65625, y: 0.34375 },
    { x: 0.65625, y: 0.34375 },
    { x: 0.71875, y: 0.34375 },
    { x: 0.71875, y: 0.34375 },
    { x: 0.78125, y: 0.34375 },
    { x: 0.78125, y: 0.34375 },
    { x: 0.84375, y: 0.34375 },
    { x: 0.84375, y: 0.34375 },
    { x: 0.90625, y: 0.34375 },
    { x: 0.90625, y: 0.34375 },
    { x: 0.96875, y: 0.34375 },
    { x: 0.96875, y: 0.34375 },
    { x: 0.03125, y: 0.40625 },
    { x: 0.03125, y: 0.40625 },
    { x: 0.09375, y: 0.40625 },
    { x: 0.09375, y: 0.40625 },
    { x: 0.15625, y: 0.40625 },
    { x: 0.15625, y: 0.40625 },
    { x: 0.21875, y: 0.40625 },
    { x: 0.21875, y: 0.40625 },
    { x: 0.28125, y: 0.40625 },
    { x: 0.28125, y: 0.40625 },
    { x: 0.34375, y: 0.40625 },
    { x: 0.34375, y: 0.40625 },
    { x: 0.40625, y: 0.40625 },
    { x: 0.40625, y: 0.40625 },
    { x: 0.46875, y: 0.40625 },
    { x: 0.46875, y: 0.40625 },
    { x: 0.53125, y: 0.40625 },
    { x: 0.53125, y: 0.40625 },
    { x: 0.59375, y: 0.40625 },
    { x: 0.59375, y: 0.40625 },
    { x: 0.65625, y: 0.40625 },
    { x: 0.65625, y: 0.40625 },
    { x: 0.71875, y: 0.40625 },
    { x: 0.71875, y: 0.40625 },
    { x: 0.78125, y: 0.40625 },
    { x: 0.78125, y: 0.40625 },
    { x: 0.84375, y: 0.40625 },
    { x: 0.84375, y: 0.40625 },
    { x: 0.90625, y: 0.40625 },
    { x: 0.90625, y: 0.40625 },
    { x: 0.96875, y: 0.40625 },
    { x: 0.96875, y: 0.40625 },
    { x: 0.03125, y: 0.46875 },
    { x: 0.03125, y: 0.46875 },
    { x: 0.09375, y: 0.46875 },
    { x: 0.09375, y: 0.46875 },
    { x: 0.15625, y: 0.46875 },
    { x: 0.15625, y: 0.46875 },
    { x: 0.21875, y: 0.46875 },
    { x: 0.21875, y: 0.46875 },
    { x: 0.28125, y: 0.46875 },
    { x: 0.28125, y: 0.46875 },
    { x: 0.34375, y: 0.46875 },
    { x: 0.34375, y: 0.46875 },
    { x: 0.40625, y: 0.46875 },
    { x: 0.40625, y: 0.46875 },
    { x: 0.46875, y: 0.46875 },
    { x: 0.46875, y: 0.46875 },
    { x: 0.53125, y: 0.46875 },
    { x: 0.53125, y: 0.46875 },
    { x: 0.59375, y: 0.46875 },
    { x: 0.59375, y: 0.46875 },
    { x: 0.65625, y: 0.46875 },
    { x: 0.65625, y: 0.46875 },
    { x: 0.71875, y: 0.46875 },
    { x: 0.71875, y: 0.46875 },
    { x: 0.78125, y: 0.46875 },
    { x: 0.78125, y: 0.46875 },
    { x: 0.84375, y: 0.46875 },
    { x: 0.84375, y: 0.46875 },
    { x: 0.90625, y: 0.46875 },
    { x: 0.90625, y: 0.46875 },
    { x: 0.96875, y: 0.46875 },
    { x: 0.96875, y: 0.46875 },
    { x: 0.03125, y: 0.53125 },
    { x: 0.03125, y: 0.53125 },
    { x: 0.09375, y: 0.53125 },
    { x: 0.09375, y: 0.53125 },
    { x: 0.15625, y: 0.53125 },
    { x: 0.15625, y: 0.53125 },
    { x: 0.21875, y: 0.53125 },
    { x: 0.21875, y: 0.53125 },
    { x: 0.28125, y: 0.53125 },
    { x: 0.28125, y: 0.53125 },
    { x: 0.34375, y: 0.53125 },
    { x: 0.34375, y: 0.53125 },
    { x: 0.40625, y: 0.53125 },
    { x: 0.40625, y: 0.53125 },
    { x: 0.46875, y: 0.53125 },
    { x: 0.46875, y: 0.53125 },
    { x: 0.53125, y: 0.53125 },
    { x: 0.53125, y: 0.53125 },
    { x: 0.59375, y: 0.53125 },
    { x: 0.59375, y: 0.53125 },
    { x: 0.65625, y: 0.53125 },
    { x: 0.65625, y: 0.53125 },
    { x: 0.71875, y: 0.53125 },
    { x: 0.71875, y: 0.53125 },
    { x: 0.78125, y: 0.53125 },
    { x: 0.78125, y: 0.53125 },
    { x: 0.84375, y: 0.53125 },
    { x: 0.84375, y: 0.53125 },
    { x: 0.90625, y: 0.53125 },
    { x: 0.90625, y: 0.53125 },
    { x: 0.96875, y: 0.53125 },
    { x: 0.96875, y: 0.53125 },
    { x: 0.03125, y: 0.59375 },
    { x: 0.03125, y: 0.59375 },
    { x: 0.09375, y: 0.59375 },
    { x: 0.09375, y: 0.59375 },
    { x: 0.15625, y: 0.59375 },
    { x: 0.15625, y: 0.59375 },
    { x: 0.21875, y: 0.59375 },
    { x: 0.21875, y: 0.59375 },
    { x: 0.28125, y: 0.59375 },
    { x: 0.28125, y: 0.59375 },
    { x: 0.34375, y: 0.59375 },
    { x: 0.34375, y: 0.59375 },
    { x: 0.40625, y: 0.59375 },
    { x: 0.40625, y: 0.59375 },
    { x: 0.46875, y: 0.59375 },
    { x: 0.46875, y: 0.59375 },
    { x: 0.53125, y: 0.59375 },
    { x: 0.53125, y: 0.59375 },
    { x: 0.59375, y: 0.59375 },
    { x: 0.59375, y: 0.59375 },
    { x: 0.65625, y: 0.59375 },
    { x: 0.65625, y: 0.59375 },
    { x: 0.71875, y: 0.59375 },
    { x: 0.71875, y: 0.59375 },
    { x: 0.78125, y: 0.59375 },
    { x: 0.78125, y: 0.59375 },
    { x: 0.84375, y: 0.59375 },
    { x: 0.84375, y: 0.59375 },
    { x: 0.90625, y: 0.59375 },
    { x: 0.90625, y: 0.59375 },
    { x: 0.96875, y: 0.59375 },
    { x: 0.96875, y: 0.59375 },
    { x: 0.03125, y: 0.65625 },
    { x: 0.03125, y: 0.65625 },
    { x: 0.09375, y: 0.65625 },
    { x: 0.09375, y: 0.65625 },
    { x: 0.15625, y: 0.65625 },
    { x: 0.15625, y: 0.65625 },
    { x: 0.21875, y: 0.65625 },
    { x: 0.21875, y: 0.65625 },
    { x: 0.28125, y: 0.65625 },
    { x: 0.28125, y: 0.65625 },
    { x: 0.34375, y: 0.65625 },
    { x: 0.34375, y: 0.65625 },
    { x: 0.40625, y: 0.65625 },
    { x: 0.40625, y: 0.65625 },
    { x: 0.46875, y: 0.65625 },
    { x: 0.46875, y: 0.65625 },
    { x: 0.53125, y: 0.65625 },
    { x: 0.53125, y: 0.65625 },
    { x: 0.59375, y: 0.65625 },
    { x: 0.59375, y: 0.65625 },
    { x: 0.65625, y: 0.65625 },
    { x: 0.65625, y: 0.65625 },
    { x: 0.71875, y: 0.65625 },
    { x: 0.71875, y: 0.65625 },
    { x: 0.78125, y: 0.65625 },
    { x: 0.78125, y: 0.65625 },
    { x: 0.84375, y: 0.65625 },
    { x: 0.84375, y: 0.65625 },
    { x: 0.90625, y: 0.65625 },
    { x: 0.90625, y: 0.65625 },
    { x: 0.96875, y: 0.65625 },
    { x: 0.96875, y: 0.65625 },
    { x: 0.03125, y: 0.71875 },
    { x: 0.03125, y: 0.71875 },
    { x: 0.09375, y: 0.71875 },
    { x: 0.09375, y: 0.71875 },
    { x: 0.15625, y: 0.71875 },
    { x: 0.15625, y: 0.71875 },
    { x: 0.21875, y: 0.71875 },
    { x: 0.21875, y: 0.71875 },
    { x: 0.28125, y: 0.71875 },
    { x: 0.28125, y: 0.71875 },
    { x: 0.34375, y: 0.71875 },
    { x: 0.34375, y: 0.71875 },
    { x: 0.40625, y: 0.71875 },
    { x: 0.40625, y: 0.71875 },
    { x: 0.46875, y: 0.71875 },
    { x: 0.46875, y: 0.71875 },
    { x: 0.53125, y: 0.71875 },
    { x: 0.53125, y: 0.71875 },
    { x: 0.59375, y: 0.71875 },
    { x: 0.59375, y: 0.71875 },
    { x: 0.65625, y: 0.71875 },
    { x: 0.65625, y: 0.71875 },
    { x: 0.71875, y: 0.71875 },
    { x: 0.71875, y: 0.71875 },
    { x: 0.78125, y: 0.71875 },
    { x: 0.78125, y: 0.71875 },
    { x: 0.84375, y: 0.71875 },
    { x: 0.84375, y: 0.71875 },
    { x: 0.90625, y: 0.71875 },
    { x: 0.90625, y: 0.71875 },
    { x: 0.96875, y: 0.71875 },
    { x: 0.96875, y: 0.71875 },
    { x: 0.03125, y: 0.78125 },
    { x: 0.03125, y: 0.78125 },
    { x: 0.09375, y: 0.78125 },
    { x: 0.09375, y: 0.78125 },
    { x: 0.15625, y: 0.78125 },
    { x: 0.15625, y: 0.78125 },
    { x: 0.21875, y: 0.78125 },
    { x: 0.21875, y: 0.78125 },
    { x: 0.28125, y: 0.78125 },
    { x: 0.28125, y: 0.78125 },
    { x: 0.34375, y: 0.78125 },
    { x: 0.34375, y: 0.78125 },
    { x: 0.40625, y: 0.78125 },
    { x: 0.40625, y: 0.78125 },
    { x: 0.46875, y: 0.78125 },
    { x: 0.46875, y: 0.78125 },
    { x: 0.53125, y: 0.78125 },
    { x: 0.53125, y: 0.78125 },
    { x: 0.59375, y: 0.78125 },
    { x: 0.59375, y: 0.78125 },
    { x: 0.65625, y: 0.78125 },
    { x: 0.65625, y: 0.78125 },
    { x: 0.71875, y: 0.78125 },
    { x: 0.71875, y: 0.78125 },
    { x: 0.78125, y: 0.78125 },
    { x: 0.78125, y: 0.78125 },
    { x: 0.84375, y: 0.78125 },
    { x: 0.84375, y: 0.78125 },
    { x: 0.90625, y: 0.78125 },
    { x: 0.90625, y: 0.78125 },
    { x: 0.96875, y: 0.78125 },
    { x: 0.96875, y: 0.78125 },
    { x: 0.03125, y: 0.84375 },
    { x: 0.03125, y: 0.84375 },
    { x: 0.09375, y: 0.84375 },
    { x: 0.09375, y: 0.84375 },
    { x: 0.15625, y: 0.84375 },
    { x: 0.15625, y: 0.84375 },
    { x: 0.21875, y: 0.84375 },
    { x: 0.21875, y: 0.84375 },
    { x: 0.28125, y: 0.84375 },
    { x: 0.28125, y: 0.84375 },
    { x: 0.34375, y: 0.84375 },
    { x: 0.34375, y: 0.84375 },
    { x: 0.40625, y: 0.84375 },
    { x: 0.40625, y: 0.84375 },
    { x: 0.46875, y: 0.84375 },
    { x: 0.46875, y: 0.84375 },
    { x: 0.53125, y: 0.84375 },
    { x: 0.53125, y: 0.84375 },
    { x: 0.59375, y: 0.84375 },
    { x: 0.59375, y: 0.84375 },
    { x: 0.65625, y: 0.84375 },
    { x: 0.65625, y: 0.84375 },
    { x: 0.71875, y: 0.84375 },
    { x: 0.71875, y: 0.84375 },
    { x: 0.78125, y: 0.84375 },
    { x: 0.78125, y: 0.84375 },
    { x: 0.84375, y: 0.84375 },
    { x: 0.84375, y: 0.84375 },
    { x: 0.90625, y: 0.84375 },
    { x: 0.90625, y: 0.84375 },
    { x: 0.96875, y: 0.84375 },
    { x: 0.96875, y: 0.84375 },
    { x: 0.03125, y: 0.90625 },
    { x: 0.03125, y: 0.90625 },
    { x: 0.09375, y: 0.90625 },
    { x: 0.09375, y: 0.90625 },
    { x: 0.15625, y: 0.90625 },
    { x: 0.15625, y: 0.90625 },
    { x: 0.21875, y: 0.90625 },
    { x: 0.21875, y: 0.90625 },
    { x: 0.28125, y: 0.90625 },
    { x: 0.28125, y: 0.90625 },
    { x: 0.34375, y: 0.90625 },
    { x: 0.34375, y: 0.90625 },
    { x: 0.40625, y: 0.90625 },
    { x: 0.40625, y: 0.90625 },
    { x: 0.46875, y: 0.90625 },
    { x: 0.46875, y: 0.90625 },
    { x: 0.53125, y: 0.90625 },
    { x: 0.53125, y: 0.90625 },
    { x: 0.59375, y: 0.90625 },
    { x: 0.59375, y: 0.90625 },
    { x: 0.65625, y: 0.90625 },
    { x: 0.65625, y: 0.90625 },
    { x: 0.71875, y: 0.90625 },
    { x: 0.71875, y: 0.90625 },
    { x: 0.78125, y: 0.90625 },
    { x: 0.78125, y: 0.90625 },
    { x: 0.84375, y: 0.90625 },
    { x: 0.84375, y: 0.90625 },
    { x: 0.90625, y: 0.90625 },
    { x: 0.90625, y: 0.90625 },
    { x: 0.96875, y: 0.90625 },
    { x: 0.96875, y: 0.90625 },
    { x: 0.03125, y: 0.96875 },
    { x: 0.03125, y: 0.96875 },
    { x: 0.09375, y: 0.96875 },
    { x: 0.09375, y: 0.96875 },
    { x: 0.15625, y: 0.96875 },
    { x: 0.15625, y: 0.96875 },
    { x: 0.21875, y: 0.96875 },
    { x: 0.21875, y: 0.96875 },
    { x: 0.28125, y: 0.96875 },
    { x: 0.28125, y: 0.96875 },
    { x: 0.34375, y: 0.96875 },
    { x: 0.34375, y: 0.96875 },
    { x: 0.40625, y: 0.96875 },
    { x: 0.40625, y: 0.96875 },
    { x: 0.46875, y: 0.96875 },
    { x: 0.46875, y: 0.96875 },
    { x: 0.53125, y: 0.96875 },
    { x: 0.53125, y: 0.96875 },
    { x: 0.59375, y: 0.96875 },
    { x: 0.59375, y: 0.96875 },
    { x: 0.65625, y: 0.96875 },
    { x: 0.65625, y: 0.96875 },
    { x: 0.71875, y: 0.96875 },
    { x: 0.71875, y: 0.96875 },
    { x: 0.78125, y: 0.96875 },
    { x: 0.78125, y: 0.96875 },
    { x: 0.84375, y: 0.96875 },
    { x: 0.84375, y: 0.96875 },
    { x: 0.90625, y: 0.96875 },
    { x: 0.90625, y: 0.96875 },
    { x: 0.96875, y: 0.96875 },
    { x: 0.96875, y: 0.96875 },
    { x: 0.0625, y: 0.0625 },
    { x: 0.0625, y: 0.0625 },
    { x: 0.0625, y: 0.0625 },
    { x: 0.0625, y: 0.0625 },
    { x: 0.0625, y: 0.0625 },
    { x: 0.0625, y: 0.0625 },
    { x: 0.1875, y: 0.0625 },
    { x: 0.1875, y: 0.0625 },
    { x: 0.1875, y: 0.0625 },
    { x: 0.1875, y: 0.0625 },
    { x: 0.1875, y: 0.0625 },
    { x: 0.1875, y: 0.0625 },
    { x: 0.3125, y: 0.0625 },
    { x: 0.3125, y: 0.0625 },
    { x: 0.3125, y: 0.0625 },
    { x: 0.3125, y: 0.0625 },
    { x: 0.3125, y: 0.0625 },
    { x: 0.3125, y: 0.0625 },
    { x: 0.4375, y: 0.0625 },
    { x: 0.4375, y: 0.0625 },
    { x: 0.4375, y: 0.0625 },
    { x: 0.4375, y: 0.0625 },
    { x: 0.4375, y: 0.0625 },
    { x: 0.4375, y: 0.0625 },
    { x: 0.5625, y: 0.0625 },
    { x: 0.5625, y: 0.0625 },
    { x: 0.5625, y: 0.0625 },
    { x: 0.5625, y: 0.0625 },
    { x: 0.5625, y: 0.0625 },
    { x: 0.5625, y: 0.0625 },
    { x: 0.6875, y: 0.0625 },
    { x: 0.6875, y: 0.0625 },
    { x: 0.6875, y: 0.0625 },
    { x: 0.6875, y: 0.0625 },
    { x: 0.6875, y: 0.0625 },
    { x: 0.6875, y: 0.0625 },
    { x: 0.8125, y: 0.0625 },
    { x: 0.8125, y: 0.0625 },
    { x: 0.8125, y: 0.0625 },
    { x: 0.8125, y: 0.0625 },
    { x: 0.8125, y: 0.0625 },
    { x: 0.8125, y: 0.0625 },
    { x: 0.9375, y: 0.0625 },
    { x: 0.9375, y: 0.0625 },
    { x: 0.9375, y: 0.0625 },
    { x: 0.9375, y: 0.0625 },
    { x: 0.9375, y: 0.0625 },
    { x: 0.9375, y: 0.0625 },
    { x: 0.0625, y: 0.1875 },
    { x: 0.0625, y: 0.1875 },
    { x: 0.0625, y: 0.1875 },
    { x: 0.0625, y: 0.1875 },
    { x: 0.0625, y: 0.1875 },
    { x: 0.0625, y: 0.1875 },
    { x: 0.1875, y: 0.1875 },
    { x: 0.1875, y: 0.1875 },
    { x: 0.1875, y: 0.1875 },
    { x: 0.1875, y: 0.1875 },
    { x: 0.1875, y: 0.1875 },
    { x: 0.1875, y: 0.1875 },
    { x: 0.3125, y: 0.1875 },
    { x: 0.3125, y: 0.1875 },
    { x: 0.3125, y: 0.1875 },
    { x: 0.3125, y: 0.1875 },
    { x: 0.3125, y: 0.1875 },
    { x: 0.3125, y: 0.1875 },
    { x: 0.4375, y: 0.1875 },
    { x: 0.4375, y: 0.1875 },
    { x: 0.4375, y: 0.1875 },
    { x: 0.4375, y: 0.1875 },
    { x: 0.4375, y: 0.1875 },
    { x: 0.4375, y: 0.1875 },
    { x: 0.5625, y: 0.1875 },
    { x: 0.5625, y: 0.1875 },
    { x: 0.5625, y: 0.1875 },
    { x: 0.5625, y: 0.1875 },
    { x: 0.5625, y: 0.1875 },
    { x: 0.5625, y: 0.1875 },
    { x: 0.6875, y: 0.1875 },
    { x: 0.6875, y: 0.1875 },
    { x: 0.6875, y: 0.1875 },
    { x: 0.6875, y: 0.1875 },
    { x: 0.6875, y: 0.1875 },
    { x: 0.6875, y: 0.1875 },
    { x: 0.8125, y: 0.1875 },
    { x: 0.8125, y: 0.1875 },
    { x: 0.8125, y: 0.1875 },
    { x: 0.8125, y: 0.1875 },
    { x: 0.8125, y: 0.1875 },
    { x: 0.8125, y: 0.1875 },
    { x: 0.9375, y: 0.1875 },
    { x: 0.9375, y: 0.1875 },
    { x: 0.9375, y: 0.1875 },
    { x: 0.9375, y: 0.1875 },
    { x: 0.9375, y: 0.1875 },
    { x: 0.9375, y: 0.1875 },
    { x: 0.0625, y: 0.3125 },
    { x: 0.0625, y: 0.3125 },
    { x: 0.0625, y: 0.3125 },
    { x: 0.0625, y: 0.3125 },
    { x: 0.0625, y: 0.3125 },
    { x: 0.0625, y: 0.3125 },
    { x: 0.1875, y: 0.3125 },
    { x: 0.1875, y: 0.3125 },
    { x: 0.1875, y: 0.3125 },
    { x: 0.1875, y: 0.3125 },
    { x: 0.1875, y: 0.3125 },
    { x: 0.1875, y: 0.3125 },
    { x: 0.3125, y: 0.3125 },
    { x: 0.3125, y: 0.3125 },
    { x: 0.3125, y: 0.3125 },
    { x: 0.3125, y: 0.3125 },
    { x: 0.3125, y: 0.3125 },
    { x: 0.3125, y: 0.3125 },
    { x: 0.4375, y: 0.3125 },
    { x: 0.4375, y: 0.3125 },
    { x: 0.4375, y: 0.3125 },
    { x: 0.4375, y: 0.3125 },
    { x: 0.4375, y: 0.3125 },
    { x: 0.4375, y: 0.3125 },
    { x: 0.5625, y: 0.3125 },
    { x: 0.5625, y: 0.3125 },
    { x: 0.5625, y: 0.3125 },
    { x: 0.5625, y: 0.3125 },
    { x: 0.5625, y: 0.3125 },
    { x: 0.5625, y: 0.3125 },
    { x: 0.6875, y: 0.3125 },
    { x: 0.6875, y: 0.3125 },
    { x: 0.6875, y: 0.3125 },
    { x: 0.6875, y: 0.3125 },
    { x: 0.6875, y: 0.3125 },
    { x: 0.6875, y: 0.3125 },
    { x: 0.8125, y: 0.3125 },
    { x: 0.8125, y: 0.3125 },
    { x: 0.8125, y: 0.3125 },
    { x: 0.8125, y: 0.3125 },
    { x: 0.8125, y: 0.3125 },
    { x: 0.8125, y: 0.3125 },
    { x: 0.9375, y: 0.3125 },
    { x: 0.9375, y: 0.3125 },
    { x: 0.9375, y: 0.3125 },
    { x: 0.9375, y: 0.3125 },
    { x: 0.9375, y: 0.3125 },
    { x: 0.9375, y: 0.3125 },
    { x: 0.0625, y: 0.4375 },
    { x: 0.0625, y: 0.4375 },
    { x: 0.0625, y: 0.4375 },
    { x: 0.0625, y: 0.4375 },
    { x: 0.0625, y: 0.4375 },
    { x: 0.0625, y: 0.4375 },
    { x: 0.1875, y: 0.4375 },
    { x: 0.1875, y: 0.4375 },
    { x: 0.1875, y: 0.4375 },
    { x: 0.1875, y: 0.4375 },
    { x: 0.1875, y: 0.4375 },
    { x: 0.1875, y: 0.4375 },
    { x: 0.3125, y: 0.4375 },
    { x: 0.3125, y: 0.4375 },
    { x: 0.3125, y: 0.4375 },
    { x: 0.3125, y: 0.4375 },
    { x: 0.3125, y: 0.4375 },
    { x: 0.3125, y: 0.4375 },
    { x: 0.4375, y: 0.4375 },
    { x: 0.4375, y: 0.4375 },
    { x: 0.4375, y: 0.4375 },
    { x: 0.4375, y: 0.4375 },
    { x: 0.4375, y: 0.4375 },
    { x: 0.4375, y: 0.4375 },
    { x: 0.5625, y: 0.4375 },
    { x: 0.5625, y: 0.4375 },
    { x: 0.5625, y: 0.4375 },
    { x: 0.5625, y: 0.4375 },
    { x: 0.5625, y: 0.4375 },
    { x: 0.5625, y: 0.4375 },
    { x: 0.6875, y: 0.4375 },
    { x: 0.6875, y: 0.4375 },
    { x: 0.6875, y: 0.4375 },
    { x: 0.6875, y: 0.4375 },
    { x: 0.6875, y: 0.4375 },
    { x: 0.6875, y: 0.4375 },
    { x: 0.8125, y: 0.4375 },
    { x: 0.8125, y: 0.4375 },
    { x: 0.8125, y: 0.4375 },
    { x: 0.8125, y: 0.4375 },
    { x: 0.8125, y: 0.4375 },
    { x: 0.8125, y: 0.4375 },
    { x: 0.9375, y: 0.4375 },
    { x: 0.9375, y: 0.4375 },
    { x: 0.9375, y: 0.4375 },
    { x: 0.9375, y: 0.4375 },
    { x: 0.9375, y: 0.4375 },
    { x: 0.9375, y: 0.4375 },
    { x: 0.0625, y: 0.5625 },
    { x: 0.0625, y: 0.5625 },
    { x: 0.0625, y: 0.5625 },
    { x: 0.0625, y: 0.5625 },
    { x: 0.0625, y: 0.5625 },
    { x: 0.0625, y: 0.5625 },
    { x: 0.1875, y: 0.5625 },
    { x: 0.1875, y: 0.5625 },
    { x: 0.1875, y: 0.5625 },
    { x: 0.1875, y: 0.5625 },
    { x: 0.1875, y: 0.5625 },
    { x: 0.1875, y: 0.5625 },
    { x: 0.3125, y: 0.5625 },
    { x: 0.3125, y: 0.5625 },
    { x: 0.3125, y: 0.5625 },
    { x: 0.3125, y: 0.5625 },
    { x: 0.3125, y: 0.5625 },
    { x: 0.3125, y: 0.5625 },
    { x: 0.4375, y: 0.5625 },
    { x: 0.4375, y: 0.5625 },
    { x: 0.4375, y: 0.5625 },
    { x: 0.4375, y: 0.5625 },
    { x: 0.4375, y: 0.5625 },
    { x: 0.4375, y: 0.5625 },
    { x: 0.5625, y: 0.5625 },
    { x: 0.5625, y: 0.5625 },
    { x: 0.5625, y: 0.5625 },
    { x: 0.5625, y: 0.5625 },
    { x: 0.5625, y: 0.5625 },
    { x: 0.5625, y: 0.5625 },
    { x: 0.6875, y: 0.5625 },
    { x: 0.6875, y: 0.5625 },
    { x: 0.6875, y: 0.5625 },
    { x: 0.6875, y: 0.5625 },
    { x: 0.6875, y: 0.5625 },
    { x: 0.6875, y: 0.5625 },
    { x: 0.8125, y: 0.5625 },
    { x: 0.8125, y: 0.5625 },
    { x: 0.8125, y: 0.5625 },
    { x: 0.8125, y: 0.5625 },
    { x: 0.8125, y: 0.5625 },
    { x: 0.8125, y: 0.5625 },
    { x: 0.9375, y: 0.5625 },
    { x: 0.9375, y: 0.5625 },
    { x: 0.9375, y: 0.5625 },
    { x: 0.9375, y: 0.5625 },
    { x: 0.9375, y: 0.5625 },
    { x: 0.9375, y: 0.5625 },
    { x: 0.0625, y: 0.6875 },
    { x: 0.0625, y: 0.6875 },
    { x: 0.0625, y: 0.6875 },
    { x: 0.0625, y: 0.6875 },
    { x: 0.0625, y: 0.6875 },
    { x: 0.0625, y: 0.6875 },
    { x: 0.1875, y: 0.6875 },
    { x: 0.1875, y: 0.6875 },
    { x: 0.1875, y: 0.6875 },
    { x: 0.1875, y: 0.6875 },
    { x: 0.1875, y: 0.6875 },
    { x: 0.1875, y: 0.6875 },
    { x: 0.3125, y: 0.6875 },
    { x: 0.3125, y: 0.6875 },
    { x: 0.3125, y: 0.6875 },
    { x: 0.3125, y: 0.6875 },
    { x: 0.3125, y: 0.6875 },
    { x: 0.3125, y: 0.6875 },
    { x: 0.4375, y: 0.6875 },
    { x: 0.4375, y: 0.6875 },
    { x: 0.4375, y: 0.6875 },
    { x: 0.4375, y: 0.6875 },
    { x: 0.4375, y: 0.6875 },
    { x: 0.4375, y: 0.6875 },
    { x: 0.5625, y: 0.6875 },
    { x: 0.5625, y: 0.6875 },
    { x: 0.5625, y: 0.6875 },
    { x: 0.5625, y: 0.6875 },
    { x: 0.5625, y: 0.6875 },
    { x: 0.5625, y: 0.6875 },
    { x: 0.6875, y: 0.6875 },
    { x: 0.6875, y: 0.6875 },
    { x: 0.6875, y: 0.6875 },
    { x: 0.6875, y: 0.6875 },
    { x: 0.6875, y: 0.6875 },
    { x: 0.6875, y: 0.6875 },
    { x: 0.8125, y: 0.6875 },
    { x: 0.8125, y: 0.6875 },
    { x: 0.8125, y: 0.6875 },
    { x: 0.8125, y: 0.6875 },
    { x: 0.8125, y: 0.6875 },
    { x: 0.8125, y: 0.6875 },
    { x: 0.9375, y: 0.6875 },
    { x: 0.9375, y: 0.6875 },
    { x: 0.9375, y: 0.6875 },
    { x: 0.9375, y: 0.6875 },
    { x: 0.9375, y: 0.6875 },
    { x: 0.9375, y: 0.6875 },
    { x: 0.0625, y: 0.8125 },
    { x: 0.0625, y: 0.8125 },
    { x: 0.0625, y: 0.8125 },
    { x: 0.0625, y: 0.8125 },
    { x: 0.0625, y: 0.8125 },
    { x: 0.0625, y: 0.8125 },
    { x: 0.1875, y: 0.8125 },
    { x: 0.1875, y: 0.8125 },
    { x: 0.1875, y: 0.8125 },
    { x: 0.1875, y: 0.8125 },
    { x: 0.1875, y: 0.8125 },
    { x: 0.1875, y: 0.8125 },
    { x: 0.3125, y: 0.8125 },
    { x: 0.3125, y: 0.8125 },
    { x: 0.3125, y: 0.8125 },
    { x: 0.3125, y: 0.8125 },
    { x: 0.3125, y: 0.8125 },
    { x: 0.3125, y: 0.8125 },
    { x: 0.4375, y: 0.8125 },
    { x: 0.4375, y: 0.8125 },
    { x: 0.4375, y: 0.8125 },
    { x: 0.4375, y: 0.8125 },
    { x: 0.4375, y: 0.8125 },
    { x: 0.4375, y: 0.8125 },
    { x: 0.5625, y: 0.8125 },
    { x: 0.5625, y: 0.8125 },
    { x: 0.5625, y: 0.8125 },
    { x: 0.5625, y: 0.8125 },
    { x: 0.5625, y: 0.8125 },
    { x: 0.5625, y: 0.8125 },
    { x: 0.6875, y: 0.8125 },
    { x: 0.6875, y: 0.8125 },
    { x: 0.6875, y: 0.8125 },
    { x: 0.6875, y: 0.8125 },
    { x: 0.6875, y: 0.8125 },
    { x: 0.6875, y: 0.8125 },
    { x: 0.8125, y: 0.8125 },
    { x: 0.8125, y: 0.8125 },
    { x: 0.8125, y: 0.8125 },
    { x: 0.8125, y: 0.8125 },
    { x: 0.8125, y: 0.8125 },
    { x: 0.8125, y: 0.8125 },
    { x: 0.9375, y: 0.8125 },
    { x: 0.9375, y: 0.8125 },
    { x: 0.9375, y: 0.8125 },
    { x: 0.9375, y: 0.8125 },
    { x: 0.9375, y: 0.8125 },
    { x: 0.9375, y: 0.8125 },
    { x: 0.0625, y: 0.9375 },
    { x: 0.0625, y: 0.9375 },
    { x: 0.0625, y: 0.9375 },
    { x: 0.0625, y: 0.9375 },
    { x: 0.0625, y: 0.9375 },
    { x: 0.0625, y: 0.9375 },
    { x: 0.1875, y: 0.9375 },
    { x: 0.1875, y: 0.9375 },
    { x: 0.1875, y: 0.9375 },
    { x: 0.1875, y: 0.9375 },
    { x: 0.1875, y: 0.9375 },
    { x: 0.1875, y: 0.9375 },
    { x: 0.3125, y: 0.9375 },
    { x: 0.3125, y: 0.9375 },
    { x: 0.3125, y: 0.9375 },
    { x: 0.3125, y: 0.9375 },
    { x: 0.3125, y: 0.9375 },
    { x: 0.3125, y: 0.9375 },
    { x: 0.4375, y: 0.9375 },
    { x: 0.4375, y: 0.9375 },
    { x: 0.4375, y: 0.9375 },
    { x: 0.4375, y: 0.9375 },
    { x: 0.4375, y: 0.9375 },
    { x: 0.4375, y: 0.9375 },
    { x: 0.5625, y: 0.9375 },
    { x: 0.5625, y: 0.9375 },
    { x: 0.5625, y: 0.9375 },
    { x: 0.5625, y: 0.9375 },
    { x: 0.5625, y: 0.9375 },
    { x: 0.5625, y: 0.9375 },
    { x: 0.6875, y: 0.9375 },
    { x: 0.6875, y: 0.9375 },
    { x: 0.6875, y: 0.9375 },
    { x: 0.6875, y: 0.9375 },
    { x: 0.6875, y: 0.9375 },
    { x: 0.6875, y: 0.9375 },
    { x: 0.8125, y: 0.9375 },
    { x: 0.8125, y: 0.9375 },
    { x: 0.8125, y: 0.9375 },
    { x: 0.8125, y: 0.9375 },
    { x: 0.8125, y: 0.9375 },
    { x: 0.8125, y: 0.9375 },
    { x: 0.9375, y: 0.9375 },
    { x: 0.9375, y: 0.9375 },
    { x: 0.9375, y: 0.9375 },
    { x: 0.9375, y: 0.9375 },
    { x: 0.9375, y: 0.9375 },
    { x: 0.9375, y: 0.9375 }
  ];
  var HandDetector = class {
    constructor(model23) {
      __publicField2(this, "model");
      __publicField2(this, "anchors");
      __publicField2(this, "anchorsTensor");
      __publicField2(this, "inputSize");
      __publicField2(this, "inputSizeTensor");
      __publicField2(this, "doubleInputSizeTensor");
      var _a22, _b2, _c22, _d22;
      this.model = model23;
      this.anchors = anchors2.map((anchor) => [anchor.x, anchor.y]);
      this.anchorsTensor = mu(this.anchors);
      this.inputSize = ((_d22 = (_c22 = (_b2 = (_a22 = this == null ? void 0 : this.model) == null ? void 0 : _a22.inputs) == null ? void 0 : _b2[0]) == null ? void 0 : _c22.shape) == null ? void 0 : _d22[2]) || 0;
      this.inputSizeTensor = xr([this.inputSize, this.inputSize]);
      this.doubleInputSizeTensor = xr([this.inputSize * 2, this.inputSize * 2]);
    }
    normalizeBoxes(boxes) {
      const t8 = {};
      t8.boxOffsets = Xe(boxes, [0, 0], [-1, 2]);
      t8.boxSizes = Xe(boxes, [0, 2], [-1, 2]);
      t8.div = je(t8.boxOffsets, this.inputSizeTensor);
      t8.boxCenterPoints = Ce(t8.div, this.anchorsTensor);
      t8.halfBoxSizes = je(t8.boxSizes, this.doubleInputSizeTensor);
      t8.sub = Te(t8.boxCenterPoints, t8.halfBoxSizes);
      t8.startPoints = se(t8.sub, this.inputSizeTensor);
      t8.add = Ce(t8.boxCenterPoints, t8.halfBoxSizes);
      t8.endPoints = se(t8.add, this.inputSizeTensor);
      const res = Wk([t8.startPoints, t8.endPoints], 1);
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      return res;
    }
    normalizeLandmarks(rawPalmLandmarks, index2) {
      const t8 = {};
      t8.reshape = W(rawPalmLandmarks, [-1, 7, 2]);
      t8.div = je(t8.reshape, this.inputSizeTensor);
      t8.landmarks = Ce(t8.div, this.anchors[index2] ? this.anchors[index2] : 0);
      const res = se(t8.landmarks, this.inputSizeTensor);
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      return res;
    }
    async predict(input, config3) {
      var _a22;
      const t8 = {};
      t8.resize = Fj.resizeBilinear(input, [this.inputSize, this.inputSize]);
      t8.div = je(t8.resize, constants.tf127);
      t8.image = Te(t8.div, constants.tf1);
      t8.batched = this.model.execute(t8.image);
      t8.predictions = mc(t8.batched);
      t8.slice = Xe(t8.predictions, [0, 0], [-1, 1]);
      t8.sigmoid = Na(t8.slice);
      t8.scores = mc(t8.sigmoid);
      const scores = await t8.scores.data();
      t8.boxes = Xe(t8.predictions, [0, 1], [-1, 4]);
      t8.norm = this.normalizeBoxes(t8.boxes);
      t8.nms = await Fj.nonMaxSuppressionAsync(t8.norm, t8.scores, 3 * (((_a22 = config3.hand) == null ? void 0 : _a22.maxDetected) || 1), config3.hand.iouThreshold, config3.hand.minConfidence);
      const nms = await t8.nms.array();
      const hands = [];
      for (const index2 of nms) {
        const p = {};
        p.box = Xe(t8.norm, [index2, 0], [1, -1]);
        p.slice = Xe(t8.predictions, [index2, 5], [1, 14]);
        p.norm = this.normalizeLandmarks(p.slice, index2);
        p.palmLandmarks = W(p.norm, [-1, 2]);
        const box = await p.box.data();
        const startPoint = box.slice(0, 2);
        const endPoint = box.slice(2, 4);
        const palmLandmarks = await p.palmLandmarks.array();
        const hand3 = { startPoint, endPoint, palmLandmarks, confidence: scores[index2] };
        const scaled = scaleBoxCoordinates2(hand3, [(input.shape[2] || 1) / this.inputSize, (input.shape[1] || 0) / this.inputSize]);
        hands.push(scaled);
        Object.keys(p).forEach((tensor) => Ot(p[tensor]));
      }
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      return hands;
    }
  };
  var palmBoxEnlargeFactor = 5;
  var handBoxEnlargeFactor = 1.65;
  var palmLandmarkIds = [0, 5, 9, 13, 17, 1, 2];
  var palmLandmarksPalmBase = 0;
  var palmLandmarksMiddleFingerBase = 2;
  var lastTime13 = 0;
  var HandPipeline = class {
    constructor(handDetector, handPoseModel2) {
      __publicField2(this, "handDetector");
      __publicField2(this, "handPoseModel");
      __publicField2(this, "inputSize");
      __publicField2(this, "storedBoxes");
      __publicField2(this, "skipped");
      __publicField2(this, "detectedHands");
      var _a22, _b2, _c22;
      this.handDetector = handDetector;
      this.handPoseModel = handPoseModel2;
      this.inputSize = ((_c22 = (_b2 = (_a22 = this.handPoseModel) == null ? void 0 : _a22.inputs) == null ? void 0 : _b2[0].shape) == null ? void 0 : _c22[2]) || 0;
      this.storedBoxes = [];
      this.skipped = Number.MAX_SAFE_INTEGER;
      this.detectedHands = 0;
    }
    calculateLandmarksBoundingBox(landmarks) {
      const xs2 = landmarks.map((d) => d[0]);
      const ys2 = landmarks.map((d) => d[1]);
      const startPoint = [Math.min(...xs2), Math.min(...ys2)];
      const endPoint = [Math.max(...xs2), Math.max(...ys2)];
      return { startPoint, endPoint };
    }
    getBoxForPalmLandmarks(palmLandmarks, rotationMatrix) {
      const rotatedPalmLandmarks = palmLandmarks.map((coord) => rotatePoint2([...coord, 1], rotationMatrix));
      const boxAroundPalm = this.calculateLandmarksBoundingBox(rotatedPalmLandmarks);
      return enlargeBox2(squarifyBox2(boxAroundPalm), palmBoxEnlargeFactor);
    }
    getBoxForHandLandmarks(landmarks) {
      const boundingBox = this.calculateLandmarksBoundingBox(landmarks);
      const boxAroundHand = enlargeBox2(squarifyBox2(boundingBox), handBoxEnlargeFactor);
      boxAroundHand.palmLandmarks = [];
      for (let i10 = 0; i10 < palmLandmarkIds.length; i10++) {
        boxAroundHand.palmLandmarks.push(landmarks[palmLandmarkIds[i10]].slice(0, 2));
      }
      return boxAroundHand;
    }
    transformRawCoords(rawCoords, box2, angle, rotationMatrix) {
      const boxSize = getBoxSize2(box2);
      const scaleFactor = [boxSize[0] / this.inputSize, boxSize[1] / this.inputSize, (boxSize[0] + boxSize[1]) / this.inputSize / 2];
      const coordsScaled = rawCoords.map((coord) => [
        scaleFactor[0] * (coord[0] - this.inputSize / 2),
        scaleFactor[1] * (coord[1] - this.inputSize / 2),
        scaleFactor[2] * coord[2]
      ]);
      const coordsRotationMatrix = buildRotationMatrix2(angle, [0, 0]);
      const coordsRotated = coordsScaled.map((coord) => {
        const rotated = rotatePoint2(coord, coordsRotationMatrix);
        return [...rotated, coord[2]];
      });
      const inverseRotationMatrix = invertTransformMatrix2(rotationMatrix);
      const boxCenter = [...getBoxCenter2(box2), 1];
      const originalBoxCenter = [
        dot2(boxCenter, inverseRotationMatrix[0]),
        dot2(boxCenter, inverseRotationMatrix[1])
      ];
      return coordsRotated.map((coord) => [
        Math.trunc(coord[0] + originalBoxCenter[0]),
        Math.trunc(coord[1] + originalBoxCenter[1]),
        Math.trunc(coord[2])
      ]);
    }
    async estimateHands(image, config3) {
      let useFreshBox = false;
      let boxes;
      const skipTime = (config3.hand.skipTime || 0) > now() - lastTime13;
      const skipFrame = this.skipped < (config3.hand.skipFrames || 0);
      if (config3.skipAllowed && skipTime && skipFrame) {
        this.skipped++;
      } else {
        boxes = await this.handDetector.predict(image, config3);
        this.skipped = 0;
      }
      if (boxes && boxes.length > 0 && (boxes.length !== this.detectedHands && this.detectedHands !== config3.hand.maxDetected || !config3.hand.landmarks)) {
        this.detectedHands = 0;
        this.storedBoxes = [...boxes];
        if (this.storedBoxes.length > 0)
          useFreshBox = true;
      }
      const hands = [];
      for (let i10 = 0; i10 < this.storedBoxes.length; i10++) {
        const currentBox = this.storedBoxes[i10];
        if (!currentBox)
          continue;
        if (config3.hand.landmarks) {
          const angle = config3.hand.rotation ? computeRotation2(currentBox.palmLandmarks[palmLandmarksPalmBase], currentBox.palmLandmarks[palmLandmarksMiddleFingerBase]) : 0;
          const palmCenter = getBoxCenter2(currentBox);
          const palmCenterNormalized = [palmCenter[0] / image.shape[2], palmCenter[1] / image.shape[1]];
          const rotatedImage = config3.hand.rotation && env.kernels.includes("rotatewithoffset") ? Fj.rotateWithOffset(image, angle, 0, palmCenterNormalized) : image.clone();
          const rotationMatrix = buildRotationMatrix2(-angle, palmCenter);
          const newBox = useFreshBox ? this.getBoxForPalmLandmarks(currentBox.palmLandmarks, rotationMatrix) : currentBox;
          const croppedInput = cutBoxFromImageAndResize(newBox, rotatedImage, [this.inputSize, this.inputSize]);
          const handImage = je(croppedInput, constants.tf255);
          Ot(croppedInput);
          Ot(rotatedImage);
          const [confidenceT, keypoints] = this.handPoseModel.execute(handImage);
          lastTime13 = now();
          Ot(handImage);
          const confidence = (await confidenceT.data())[0];
          Ot(confidenceT);
          if (confidence >= config3.hand.minConfidence / 4) {
            const keypointsReshaped = W(keypoints, [-1, 3]);
            const rawCoords = await keypointsReshaped.array();
            Ot(keypoints);
            Ot(keypointsReshaped);
            const coords = this.transformRawCoords(rawCoords, newBox, angle, rotationMatrix);
            const nextBoundingBox = this.getBoxForHandLandmarks(coords);
            this.storedBoxes[i10] = { ...nextBoundingBox, confidence };
            const result = {
              landmarks: coords,
              confidence,
              boxConfidence: currentBox.confidence,
              fingerConfidence: confidence,
              box: { topLeft: nextBoundingBox.startPoint, bottomRight: nextBoundingBox.endPoint }
            };
            hands.push(result);
          } else {
            this.storedBoxes[i10] = null;
          }
          Ot(keypoints);
        } else {
          const enlarged = enlargeBox2(squarifyBox2(currentBox), handBoxEnlargeFactor);
          const result = {
            confidence: currentBox.confidence,
            boxConfidence: currentBox.confidence,
            fingerConfidence: 0,
            box: { topLeft: enlarged.startPoint, bottomRight: enlarged.endPoint },
            landmarks: []
          };
          hands.push(result);
        }
      }
      this.storedBoxes = this.storedBoxes.filter((a) => a !== null);
      this.detectedHands = hands.length;
      if (hands.length > config3.hand.maxDetected)
        hands.length = config3.hand.maxDetected;
      return hands;
    }
  };
  var meshAnnotations2 = {
    thumb: [1, 2, 3, 4],
    index: [5, 6, 7, 8],
    middle: [9, 10, 11, 12],
    ring: [13, 14, 15, 16],
    pinky: [17, 18, 19, 20],
    palm: [0]
  };
  var handDetectorModel;
  var handPoseModel;
  var handPipeline;
  function initPipeline() {
    const handDetector = handDetectorModel ? new HandDetector(handDetectorModel) : void 0;
    if (handDetector && handPoseModel)
      handPipeline = new HandPipeline(handDetector, handPoseModel);
  }
  async function predict14(input, config3) {
    if (!handPipeline)
      initPipeline();
    const predictions = await handPipeline.estimateHands(input, config3);
    if (!predictions)
      return [];
    const hands = [];
    for (let i10 = 0; i10 < predictions.length; i10++) {
      const annotations2 = {};
      if (predictions[i10].landmarks) {
        for (const key2 of Object.keys(meshAnnotations2)) {
          annotations2[key2] = meshAnnotations2[key2].map((index2) => predictions[i10].landmarks[index2]);
        }
      }
      const keypoints = predictions[i10].landmarks;
      let box = [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 0, 0];
      let boxRaw = [0, 0, 0, 0];
      if (keypoints && keypoints.length > 0) {
        for (const pt2 of keypoints) {
          if (pt2[0] < box[0])
            box[0] = pt2[0];
          if (pt2[1] < box[1])
            box[1] = pt2[1];
          if (pt2[0] > box[2])
            box[2] = pt2[0];
          if (pt2[1] > box[3])
            box[3] = pt2[1];
        }
        box[2] -= box[0];
        box[3] -= box[1];
        boxRaw = [box[0] / (input.shape[2] || 0), box[1] / (input.shape[1] || 0), box[2] / (input.shape[2] || 0), box[3] / (input.shape[1] || 0)];
      } else {
        box = predictions[i10].box ? [
          Math.trunc(Math.max(0, predictions[i10].box.topLeft[0])),
          Math.trunc(Math.max(0, predictions[i10].box.topLeft[1])),
          Math.trunc(Math.min(input.shape[2] || 0, predictions[i10].box.bottomRight[0]) - Math.max(0, predictions[i10].box.topLeft[0])),
          Math.trunc(Math.min(input.shape[1] || 0, predictions[i10].box.bottomRight[1]) - Math.max(0, predictions[i10].box.topLeft[1]))
        ] : [0, 0, 0, 0];
        boxRaw = [
          predictions[i10].box.topLeft[0] / (input.shape[2] || 0),
          predictions[i10].box.topLeft[1] / (input.shape[1] || 0),
          (predictions[i10].box.bottomRight[0] - predictions[i10].box.topLeft[0]) / (input.shape[2] || 0),
          (predictions[i10].box.bottomRight[1] - predictions[i10].box.topLeft[1]) / (input.shape[1] || 0)
        ];
      }
      const landmarks = analyze(keypoints);
      hands.push({
        id: i10,
        score: Math.round(100 * predictions[i10].confidence) / 100,
        boxScore: Math.round(100 * predictions[i10].boxConfidence) / 100,
        fingerScore: Math.round(100 * predictions[i10].fingerConfidence) / 100,
        label: "hand",
        box,
        boxRaw,
        keypoints,
        annotations: annotations2,
        landmarks
      });
    }
    return hands;
  }
  async function loadDetect2(config3) {
    var _a22;
    if (env.initial)
      handDetectorModel = null;
    if (!handDetectorModel)
      handDetectorModel = await loadModel((_a22 = config3.hand.detector) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", handDetectorModel["modelUrl"]);
    return handDetectorModel;
  }
  async function loadSkeleton(config3) {
    var _a22;
    if (env.initial)
      handPoseModel = null;
    if (!handPoseModel)
      handPoseModel = await loadModel((_a22 = config3.hand.skeleton) == null ? void 0 : _a22.modelPath);
    else if (config3.debug)
      log$1("cached model:", handPoseModel["modelUrl"]);
    return handPoseModel;
  }
  var models2 = [null, null];
  var modelOutputNodes = ["StatefulPartitionedCall/Postprocessor/Slice", "StatefulPartitionedCall/Postprocessor/ExpandDims_1"];
  var inputSize7 = [[0, 0], [0, 0]];
  var classes = ["hand", "fist", "pinch", "point", "face", "tip", "pinchtip"];
  var faceIndex = 4;
  var boxExpandFact = 1.6;
  var maxDetectorResolution = 512;
  var detectorExpandFact = 1.4;
  var skipped13 = Number.MAX_SAFE_INTEGER;
  var lastTime14 = 0;
  var outputSize = [0, 0];
  var cache4 = {
    boxes: [],
    hands: []
  };
  var fingerMap = {
    /*
    thumb: [0, 1, 2, 3, 4],
    index: [0, 5, 6, 7, 8],
    middle: [0, 9, 10, 11, 12],
    ring: [0, 13, 14, 15, 16],
    pinky: [0, 17, 18, 19, 20],
    palm: [0],
    */
    thumb: [1, 2, 3, 4],
    index: [5, 6, 7, 8],
    middle: [9, 10, 11, 12],
    ring: [13, 14, 15, 16],
    pinky: [17, 18, 19, 20],
    base: [0],
    palm: [0, 17, 13, 9, 5, 1, 0]
  };
  async function loadDetect3(config3) {
    var _a22;
    if (env.initial)
      models2[0] = null;
    if (!models2[0]) {
      fakeOps(["tensorlistreserve", "enter", "tensorlistfromtensor", "merge", "loopcond", "switch", "exit", "tensorliststack", "nextiteration", "tensorlistsetitem", "tensorlistgetitem", "reciprocal", "shape", "split", "where"], config3);
      models2[0] = await loadModel((_a22 = config3.hand.detector) == null ? void 0 : _a22.modelPath);
      const inputs = models2[0]["executor"] ? Object.values(models2[0].modelSignature["inputs"]) : void 0;
      inputSize7[0][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
      inputSize7[0][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    } else if (config3.debug)
      log$1("cached model:", models2[0]["modelUrl"]);
    return models2[0];
  }
  async function loadSkeleton2(config3) {
    var _a22;
    if (env.initial)
      models2[1] = null;
    if (!models2[1]) {
      models2[1] = await loadModel((_a22 = config3.hand.skeleton) == null ? void 0 : _a22.modelPath);
      const inputs = models2[1]["executor"] ? Object.values(models2[1].modelSignature["inputs"]) : void 0;
      inputSize7[1][0] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[1].size) : 0;
      inputSize7[1][1] = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 0;
    } else if (config3.debug)
      log$1("cached model:", models2[1]["modelUrl"]);
    return models2[1];
  }
  async function detectHands(input, config3) {
    const hands = [];
    if (!input || !models2[0])
      return hands;
    const t8 = {};
    const ratio2 = (input.shape[2] || 1) / (input.shape[1] || 1);
    const height = Math.min(Math.round((input.shape[1] || 0) / 8) * 8, maxDetectorResolution);
    const width = Math.round(height * ratio2 / 8) * 8;
    t8.resize = Fj.resizeBilinear(input, [height, width]);
    t8.cast = qe(t8.resize, "int32");
    [t8.rawScores, t8.rawBoxes] = await models2[0].executeAsync(t8.cast, modelOutputNodes);
    t8.boxes = mc(t8.rawBoxes, [0, 2]);
    t8.scores = mc(t8.rawScores, [0]);
    const classScores = mo(t8.scores, 1);
    Ot(classScores[faceIndex]);
    classScores.splice(faceIndex, 1);
    t8.filtered = kr(classScores, 1);
    Ot(classScores);
    t8.max = _a(t8.filtered, 1);
    t8.argmax = Sk(t8.filtered, 1);
    let id2 = 0;
    t8.nms = await Fj.nonMaxSuppressionAsync(t8.boxes, t8.max, (config3.hand.maxDetected || 0) + 1, config3.hand.iouThreshold || 0, config3.hand.minConfidence || 1);
    const nms = await t8.nms.data();
    const scores = await t8.max.data();
    const classNum = await t8.argmax.data();
    for (const nmsIndex of Array.from(nms)) {
      const boxSlice = Xe(t8.boxes, nmsIndex, 1);
      const boxYX = await boxSlice.data();
      Ot(boxSlice);
      const boxData = [boxYX[1], boxYX[0], boxYX[3] - boxYX[1], boxYX[2] - boxYX[0]];
      const boxRaw = scale(boxData, detectorExpandFact);
      const boxFull = [Math.trunc(boxData[0] * outputSize[0]), Math.trunc(boxData[1] * outputSize[1]), Math.trunc(boxData[2] * outputSize[0]), Math.trunc(boxData[3] * outputSize[1])];
      const score = scores[nmsIndex];
      const label = classes[classNum[nmsIndex]];
      const hand3 = { id: id2++, score, box: boxFull, boxRaw, label };
      hands.push(hand3);
    }
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    hands.sort((a, b) => b.score - a.score);
    if (hands.length > (config3.hand.maxDetected || 1))
      hands.length = config3.hand.maxDetected || 1;
    return hands;
  }
  async function detectFingers(input, h, config3) {
    const hand3 = {
      // initial values inherited from hand detect
      id: h.id,
      score: Math.round(100 * h.score) / 100,
      boxScore: Math.round(100 * h.score) / 100,
      fingerScore: 0,
      box: h.box,
      boxRaw: h.boxRaw,
      label: h.label,
      keypoints: [],
      landmarks: {},
      annotations: {}
    };
    if (input && models2[1] && config3.hand.landmarks && h.score > (config3.hand.minConfidence || 0)) {
      const t8 = {};
      const boxCrop = [h.boxRaw[1], h.boxRaw[0], h.boxRaw[3] + h.boxRaw[1], h.boxRaw[2] + h.boxRaw[0]];
      t8.crop = Fj.cropAndResize(input, [boxCrop], [0], [inputSize7[1][0], inputSize7[1][1]], "bilinear");
      t8.div = je(t8.crop, constants.tf255);
      [t8.score, t8.keypoints] = models2[1].execute(t8.div, ["Identity_1", "Identity"]);
      const rawScore = (await t8.score.data())[0];
      const score = (100 - Math.trunc(100 / (1 + Math.exp(rawScore)))) / 100;
      if (score >= (config3.hand.minConfidence || 0)) {
        hand3.fingerScore = score;
        t8.reshaped = W(t8.keypoints, [-1, 3]);
        const coordsData = await t8.reshaped.array();
        const coordsRaw = coordsData.map((kpt4) => [kpt4[0] / inputSize7[1][1], kpt4[1] / inputSize7[1][0], kpt4[2] || 0]);
        const coordsNorm = coordsRaw.map((kpt4) => [kpt4[0] * h.boxRaw[2], kpt4[1] * h.boxRaw[3], kpt4[2] || 0]);
        hand3.keypoints = coordsNorm.map((kpt4) => [outputSize[0] * (kpt4[0] + h.boxRaw[0]), outputSize[1] * (kpt4[1] + h.boxRaw[1]), kpt4[2] || 0]);
        hand3.landmarks = analyze(hand3.keypoints);
        for (const key2 of Object.keys(fingerMap)) {
          hand3.annotations[key2] = fingerMap[key2].map((index2) => hand3.landmarks && hand3.keypoints[index2] ? hand3.keypoints[index2] : null);
        }
      }
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    }
    return hand3;
  }
  async function predict15(input, config3) {
    var _a22, _b2;
    if (!((_a22 = models2[0]) == null ? void 0 : _a22["executor"]) || !((_b2 = models2[1]) == null ? void 0 : _b2["executor"]) || !models2[0].inputs[0].shape || !models2[1].inputs[0].shape)
      return [];
    outputSize = [input.shape[2] || 0, input.shape[1] || 0];
    skipped13++;
    const skipTime = (config3.hand.skipTime || 0) > now() - lastTime14;
    const skipFrame = skipped13 < (config3.hand.skipFrames || 0);
    if (config3.skipAllowed && skipTime && skipFrame) {
      return cache4.hands;
    }
    return new Promise(async (resolve) => {
      const skipTimeExtended = 3 * (config3.hand.skipTime || 0) > now() - lastTime14;
      const skipFrameExtended = skipped13 < 3 * (config3.hand.skipFrames || 0);
      if (config3.skipAllowed && cache4.hands.length === config3.hand.maxDetected) {
        cache4.hands = await Promise.all(cache4.boxes.map((handBox) => detectFingers(input, handBox, config3)));
      } else if (config3.skipAllowed && skipTimeExtended && skipFrameExtended && cache4.hands.length > 0) {
        cache4.hands = await Promise.all(cache4.boxes.map((handBox) => detectFingers(input, handBox, config3)));
      } else {
        cache4.boxes = await detectHands(input, config3);
        lastTime14 = now();
        cache4.hands = await Promise.all(cache4.boxes.map((handBox) => detectFingers(input, handBox, config3)));
        skipped13 = 0;
      }
      const oldCache = [...cache4.boxes];
      cache4.boxes.length = 0;
      if (config3.cacheSensitivity > 0) {
        for (let i10 = 0; i10 < cache4.hands.length; i10++) {
          const boxKpt = square(cache4.hands[i10].keypoints, outputSize);
          if (boxKpt.box[2] / (input.shape[2] || 1) > 0.05 && boxKpt.box[3] / (input.shape[1] || 1) > 0.05 && cache4.hands[i10].fingerScore && cache4.hands[i10].fingerScore > (config3.hand.minConfidence || 0)) {
            const boxScale = scale(boxKpt.box, boxExpandFact);
            const boxScaleRaw = scale(boxKpt.boxRaw, boxExpandFact);
            cache4.boxes.push({ ...oldCache[i10], box: boxScale, boxRaw: boxScaleRaw });
          }
        }
      }
      for (let i10 = 0; i10 < cache4.hands.length; i10++) {
        const bbox = calc(cache4.hands[i10].keypoints, outputSize);
        cache4.hands[i10].box = bbox.box;
        cache4.hands[i10].boxRaw = bbox.boxRaw;
      }
      resolve(cache4.hands);
    });
  }
  var empty = (error = null) => ({ face: [], body: [], hand: [], gesture: [], object: [], persons: [], performance: {}, timestamp: 0, width: 0, height: 0, error });
  var movenetcoords_exports = {};
  __export(movenetcoords_exports, {
    connected: () => connected3,
    horizontal: () => horizontal,
    kpt: () => kpt3,
    relative: () => relative,
    vertical: () => vertical
  });
  var kpt3 = [
    // used to create part labels
    "nose",
    "leftEye",
    "rightEye",
    "leftEar",
    "rightEar",
    "leftShoulder",
    "rightShoulder",
    "leftElbow",
    "rightElbow",
    "leftWrist",
    "rightWrist",
    "leftHip",
    "rightHip",
    "leftKnee",
    "rightKnee",
    "leftAnkle",
    "rightAnkle"
  ];
  var horizontal = [
    // used to fix left vs right
    ["leftEye", "rightEye"],
    ["leftEar", "rightEar"],
    ["leftShoulder", "rightShoulder"],
    ["leftElbow", "rightElbow"],
    ["leftWrist", "rightWrist"],
    ["leftHip", "rightHip"],
    ["leftKnee", "rightKnee"],
    ["leftAnkle", "rightAnkle"]
  ];
  var vertical = [
    // used to remove unlikely keypoint positions
    ["leftKnee", "leftShoulder"],
    ["rightKnee", "rightShoulder"],
    ["leftAnkle", "leftKnee"],
    ["rightAnkle", "rightKnee"]
  ];
  var relative = [
    // used to match relative body parts
    [["leftHip", "rightHip"], ["leftShoulder", "rightShoulder"]],
    [["leftElbow", "rightElbow"], ["leftShoulder", "rightShoulder"]]
  ];
  var connected3 = {
    // used to create body outline in annotations
    leftLeg: ["leftHip", "leftKnee", "leftAnkle"],
    rightLeg: ["rightHip", "rightKnee", "rightAnkle"],
    torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"],
    leftArm: ["leftShoulder", "leftElbow", "leftWrist"],
    rightArm: ["rightShoulder", "rightElbow", "rightWrist"],
    head: []
  };
  var bufferedResult = empty();
  var interpolateTime = 0;
  function calc2(newResult, config3) {
    var _a22, _b2, _c22, _d22, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m, _n2, _o2, _p2, _q2, _r2, _s2, _t, _u, _v2, _w2, _x2, _y, _z2;
    const t02 = now();
    if (!newResult)
      return empty();
    const elapsed = Date.now() - newResult.timestamp;
    const bufferedFactor = elapsed < 1e3 ? 8 - Math.log(elapsed + 1) : 1;
    if (newResult.canvas)
      bufferedResult.canvas = newResult.canvas;
    if (newResult.error)
      bufferedResult.error = newResult.error;
    if (!bufferedResult.body || newResult.body.length !== bufferedResult.body.length) {
      bufferedResult.body = JSON.parse(JSON.stringify(newResult.body));
    } else {
      for (let i10 = 0; i10 < newResult.body.length; i10++) {
        const box = newResult.body[i10].box.map((newBoxCoord, j) => ((bufferedFactor - 1) * bufferedResult.body[i10].box[j] + newBoxCoord) / bufferedFactor);
        const boxRaw = newResult.body[i10].boxRaw.map((newBoxCoord, j) => ((bufferedFactor - 1) * bufferedResult.body[i10].boxRaw[j] + newBoxCoord) / bufferedFactor);
        const keypoints = newResult.body[i10].keypoints.map((newKpt, j) => {
          var _a3, _b22, _c3, _d3, _e2, _f3, _g3, _h3, _i3;
          return {
            score: newKpt.score,
            part: newKpt.part,
            position: [
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j].position[0] || 0) + (newKpt.position[0] || 0)) / bufferedFactor : newKpt.position[0],
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j].position[1] || 0) + (newKpt.position[1] || 0)) / bufferedFactor : newKpt.position[1],
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j].position[2] || 0) + (newKpt.position[2] || 0)) / bufferedFactor : newKpt.position[2]
            ],
            positionRaw: [
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j].positionRaw[0] || 0) + (newKpt.positionRaw[0] || 0)) / bufferedFactor : newKpt.positionRaw[0],
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j].positionRaw[1] || 0) + (newKpt.positionRaw[1] || 0)) / bufferedFactor : newKpt.positionRaw[1],
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (bufferedResult.body[i10].keypoints[j].positionRaw[2] || 0) + (newKpt.positionRaw[2] || 0)) / bufferedFactor : newKpt.positionRaw[2]
            ],
            distance: [
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (((_a3 = bufferedResult.body[i10].keypoints[j].distance) == null ? void 0 : _a3[0]) || 0) + (((_b22 = newKpt.distance) == null ? void 0 : _b22[0]) || 0)) / bufferedFactor : (_c3 = newKpt.distance) == null ? void 0 : _c3[0],
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (((_d3 = bufferedResult.body[i10].keypoints[j].distance) == null ? void 0 : _d3[1]) || 0) + (((_e2 = newKpt.distance) == null ? void 0 : _e2[1]) || 0)) / bufferedFactor : (_f3 = newKpt.distance) == null ? void 0 : _f3[1],
              bufferedResult.body[i10].keypoints[j] ? ((bufferedFactor - 1) * (((_g3 = bufferedResult.body[i10].keypoints[j].distance) == null ? void 0 : _g3[2]) || 0) + (((_h3 = newKpt.distance) == null ? void 0 : _h3[2]) || 0)) / bufferedFactor : (_i3 = newKpt.distance) == null ? void 0 : _i3[2]
            ]
          };
        });
        const annotations2 = {};
        let coords = { connected: {} };
        if ((_a22 = config3.body.modelPath) == null ? void 0 : _a22.includes("efficientpose"))
          coords = efficientposecoords_exports;
        else if ((_b2 = config3.body.modelPath) == null ? void 0 : _b2.includes("blazepose"))
          coords = blazeposecoords_exports;
        else if ((_c22 = config3.body.modelPath) == null ? void 0 : _c22.includes("movenet"))
          coords = movenetcoords_exports;
        for (const [name2, indexes] of Object.entries(coords.connected)) {
          const pt2 = [];
          for (let j = 0; j < indexes.length - 1; j++) {
            const pt0 = keypoints.find((kp2) => kp2.part === indexes[j]);
            const pt1 = keypoints.find((kp2) => kp2.part === indexes[j + 1]);
            if (pt0 && pt1)
              pt2.push([pt0.position, pt1.position]);
          }
          annotations2[name2] = pt2;
        }
        bufferedResult.body[i10] = { ...newResult.body[i10], box, boxRaw, keypoints, annotations: annotations2 };
      }
    }
    if (!bufferedResult.hand || newResult.hand.length !== bufferedResult.hand.length) {
      bufferedResult.hand = JSON.parse(JSON.stringify(newResult.hand));
    } else {
      for (let i10 = 0; i10 < newResult.hand.length; i10++) {
        const box = newResult.hand[i10].box.map((b, j) => ((bufferedFactor - 1) * bufferedResult.hand[i10].box[j] + b) / bufferedFactor);
        const boxRaw = newResult.hand[i10].boxRaw.map((b, j) => ((bufferedFactor - 1) * bufferedResult.hand[i10].boxRaw[j] + b) / bufferedFactor);
        if (bufferedResult.hand[i10].keypoints.length !== newResult.hand[i10].keypoints.length)
          bufferedResult.hand[i10].keypoints = newResult.hand[i10].keypoints;
        const keypoints = newResult.hand[i10].keypoints && newResult.hand[i10].keypoints.length > 0 ? newResult.hand[i10].keypoints.map((landmark, j) => landmark.map((coord, k) => ((bufferedFactor - 1) * (bufferedResult.hand[i10].keypoints[j][k] || 1) + (coord || 0)) / bufferedFactor)) : [];
        let annotations2 = {};
        if (Object.keys(bufferedResult.hand[i10].annotations).length !== Object.keys(newResult.hand[i10].annotations).length) {
          bufferedResult.hand[i10].annotations = newResult.hand[i10].annotations;
          annotations2 = bufferedResult.hand[i10].annotations;
        } else if (newResult.hand[i10].annotations) {
          for (const key2 of Object.keys(newResult.hand[i10].annotations)) {
            annotations2[key2] = ((_f2 = (_e = (_d22 = newResult.hand[i10]) == null ? void 0 : _d22.annotations) == null ? void 0 : _e[key2]) == null ? void 0 : _f2[0]) ? newResult.hand[i10].annotations[key2].map((val, j) => val.map((coord, k) => ((bufferedFactor - 1) * bufferedResult.hand[i10].annotations[key2][j][k] + coord) / bufferedFactor)) : null;
          }
        }
        bufferedResult.hand[i10] = { ...newResult.hand[i10], box, boxRaw, keypoints, annotations: annotations2 };
      }
    }
    if (!bufferedResult.face || newResult.face.length !== bufferedResult.face.length) {
      bufferedResult.face = JSON.parse(JSON.stringify(newResult.face));
    } else {
      for (let i10 = 0; i10 < newResult.face.length; i10++) {
        const box = newResult.face[i10].box.map((b, j) => ((bufferedFactor - 1) * bufferedResult.face[i10].box[j] + b) / bufferedFactor);
        const boxRaw = newResult.face[i10].boxRaw.map((b, j) => ((bufferedFactor - 1) * bufferedResult.face[i10].boxRaw[j] + b) / bufferedFactor);
        let annotations2 = newResult.face[i10].annotations;
        if (Object.keys(bufferedResult.face[i10].annotations).length !== Object.keys(newResult.face[i10].annotations).length) {
          bufferedResult.face[i10].annotations = newResult.face[i10].annotations;
          annotations2 = bufferedResult.face[i10].annotations;
        } else if (newResult.face[i10].annotations) {
          for (const key2 of Object.keys(newResult.face[i10].annotations)) {
            annotations2[key2] = ((_i2 = (_h2 = (_g2 = newResult.face[i10]) == null ? void 0 : _g2.annotations) == null ? void 0 : _h2[key2]) == null ? void 0 : _i2[0]) ? newResult.face[i10].annotations[key2].map((val, j) => val.map((coord, k) => ((bufferedFactor - 1) * bufferedResult.face[i10].annotations[key2][j][k] + coord) / bufferedFactor)) : null;
          }
        }
        if (newResult.face[i10].rotation) {
          const rotation = { matrix: [0, 0, 0, 0, 0, 0, 0, 0, 0], angle: { roll: 0, yaw: 0, pitch: 0 }, gaze: { bearing: 0, strength: 0 } };
          rotation.matrix = (_j2 = newResult.face[i10].rotation) == null ? void 0 : _j2.matrix;
          rotation.angle = {
            roll: ((bufferedFactor - 1) * (((_l2 = (_k2 = bufferedResult.face[i10].rotation) == null ? void 0 : _k2.angle) == null ? void 0 : _l2.roll) || 0) + (((_n2 = (_m = newResult.face[i10].rotation) == null ? void 0 : _m.angle) == null ? void 0 : _n2.roll) || 0)) / bufferedFactor,
            yaw: ((bufferedFactor - 1) * (((_p2 = (_o2 = bufferedResult.face[i10].rotation) == null ? void 0 : _o2.angle) == null ? void 0 : _p2.yaw) || 0) + (((_r2 = (_q2 = newResult.face[i10].rotation) == null ? void 0 : _q2.angle) == null ? void 0 : _r2.yaw) || 0)) / bufferedFactor,
            pitch: ((bufferedFactor - 1) * (((_t = (_s2 = bufferedResult.face[i10].rotation) == null ? void 0 : _s2.angle) == null ? void 0 : _t.pitch) || 0) + (((_v2 = (_u = newResult.face[i10].rotation) == null ? void 0 : _u.angle) == null ? void 0 : _v2.pitch) || 0)) / bufferedFactor
          };
          rotation.gaze = {
            // not fully correct due projection on circle, also causes wrap-around draw on jump from negative to positive
            bearing: ((bufferedFactor - 1) * (((_w2 = bufferedResult.face[i10].rotation) == null ? void 0 : _w2.gaze.bearing) || 0) + (((_x2 = newResult.face[i10].rotation) == null ? void 0 : _x2.gaze.bearing) || 0)) / bufferedFactor,
            strength: ((bufferedFactor - 1) * (((_y = bufferedResult.face[i10].rotation) == null ? void 0 : _y.gaze.strength) || 0) + (((_z2 = newResult.face[i10].rotation) == null ? void 0 : _z2.gaze.strength) || 0)) / bufferedFactor
          };
          bufferedResult.face[i10] = { ...newResult.face[i10], rotation, box, boxRaw, annotations: annotations2 };
        } else {
          bufferedResult.face[i10] = { ...newResult.face[i10], box, boxRaw, annotations: annotations2 };
        }
      }
    }
    if (!bufferedResult.object || newResult.object.length !== bufferedResult.object.length) {
      bufferedResult.object = JSON.parse(JSON.stringify(newResult.object));
    } else {
      for (let i10 = 0; i10 < newResult.object.length; i10++) {
        const box = newResult.object[i10].box.map((b, j) => ((bufferedFactor - 1) * bufferedResult.object[i10].box[j] + b) / bufferedFactor);
        const boxRaw = newResult.object[i10].boxRaw.map((b, j) => ((bufferedFactor - 1) * bufferedResult.object[i10].boxRaw[j] + b) / bufferedFactor);
        bufferedResult.object[i10] = { ...newResult.object[i10], box, boxRaw };
      }
    }
    if (newResult.persons) {
      const newPersons = newResult.persons;
      if (!bufferedResult.persons || newPersons.length !== bufferedResult.persons.length) {
        bufferedResult.persons = JSON.parse(JSON.stringify(newPersons));
      } else {
        for (let i10 = 0; i10 < newPersons.length; i10++) {
          bufferedResult.persons[i10].box = newPersons[i10].box.map((box, j) => ((bufferedFactor - 1) * bufferedResult.persons[i10].box[j] + box) / bufferedFactor);
        }
      }
    }
    if (newResult.gesture)
      bufferedResult.gesture = newResult.gesture;
    bufferedResult.width = newResult.width;
    bufferedResult.height = newResult.height;
    const t12 = now();
    interpolateTime = env.perfadd ? interpolateTime + Math.round(t12 - t02) : Math.round(t12 - t02);
    if (newResult.performance)
      bufferedResult.performance = { ...newResult.performance, interpolate: interpolateTime };
    return bufferedResult;
  }
  var model17;
  async function load15(config3) {
    if (!model17 || env.initial)
      model17 = await loadModel(config3.segmentation.modelPath);
    else if (config3.debug)
      log$1("cached model:", model17["modelUrl"]);
    return model17;
  }
  async function predict16(input, config3) {
    var _a22;
    if (!model17)
      model17 = await load15(config3);
    if (!(model17 == null ? void 0 : model17["executor"]) || !((_a22 = model17 == null ? void 0 : model17.inputs) == null ? void 0 : _a22[0].shape))
      return null;
    const t8 = {};
    t8.resize = Fj.resizeBilinear(input, [model17.inputs[0].shape ? model17.inputs[0].shape[1] : 0, model17.inputs[0].shape ? model17.inputs[0].shape[2] : 0], false);
    t8.norm = je(t8.resize, constants.tf255);
    t8.res = model17.execute(t8.norm);
    t8.squeeze = mc(t8.res, [0]);
    [t8.bgRaw, t8.fgRaw] = mo(t8.squeeze, 2);
    t8.fg = _1(t8.fgRaw);
    t8.mul = se(t8.fg, constants.tf255);
    t8.expand = ai(t8.mul, 2);
    t8.output = Fj.resizeBilinear(t8.expand, [input.shape[1] || 0, input.shape[2] || 0]);
    let rgba;
    switch (config3.segmentation.mode || "default") {
      case "default":
        t8.input = mc(input);
        t8.concat = bt([t8.input, t8.output], -1);
        rgba = qe(t8.concat, "int32");
        break;
      case "alpha":
        rgba = qe(t8.output, "int32");
        break;
      default:
        rgba = ir(0);
    }
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return rgba;
  }
  var match_exports = {};
  __export(match_exports, {
    distance: () => distance,
    find: () => find,
    similarity: () => similarity
  });
  function distance(descriptor1, descriptor2, options4 = { order: 2, multiplier: 25 }) {
    if (!descriptor1 || !descriptor1)
      return Number.MAX_SAFE_INTEGER;
    let sum = 0;
    for (let i10 = 0; i10 < descriptor1.length; i10++) {
      const diff = !options4.order || options4.order === 2 ? descriptor1[i10] - descriptor2[i10] : Math.abs(descriptor1[i10] - descriptor2[i10]);
      sum += !options4.order || options4.order === 2 ? diff * diff : diff ** options4.order;
    }
    return (options4.multiplier || 20) * sum;
  }
  var normalizeDistance = (dist, order, min, max) => {
    if (dist === 0)
      return 1;
    const root = order === 2 ? Math.sqrt(dist) : dist ** (1 / order);
    const norm = (1 - root / 100 - min) / (max - min);
    const clamp2 = Math.max(Math.min(norm, 1), 0);
    return clamp2;
  };
  function similarity(descriptor1, descriptor2, options4 = { order: 2, multiplier: 25, min: 0.2, max: 0.8 }) {
    const dist = distance(descriptor1, descriptor2, options4);
    return normalizeDistance(dist, options4.order || 2, options4.min || 0, options4.max || 1);
  }
  function find(descriptor, descriptors, options4 = { order: 2, multiplier: 25, threshold: 0, min: 0.2, max: 0.8 }) {
    if (!Array.isArray(descriptor) || !Array.isArray(descriptors) || descriptor.length < 64 || descriptors.length === 0) {
      return { index: -1, distance: Number.POSITIVE_INFINITY, similarity: 0 };
    }
    let lowestDistance = Number.MAX_SAFE_INTEGER;
    let index2 = -1;
    for (let i10 = 0; i10 < descriptors.length; i10++) {
      const res = descriptors[i10].length === descriptor.length ? distance(descriptor, descriptors[i10], options4) : Number.MAX_SAFE_INTEGER;
      if (res < lowestDistance) {
        lowestDistance = res;
        index2 = i10;
      }
      if (lowestDistance < (options4.threshold || 0))
        break;
    }
    const normalizedSimilarity = normalizeDistance(lowestDistance, options4.order || 2, options4.min || 0, options4.max || 1);
    return { index: index2, distance: lowestDistance, similarity: normalizedSimilarity };
  }
  var models_exports2 = {};
  __export(models_exports2, {
    Models: () => Models,
    validateModel: () => validateModel
  });
  var maxJitter = 5e-3;
  var cache5 = {
    keypoints: [],
    padding: [[0, 0], [0, 0], [0, 0], [0, 0]]
  };
  function bodyParts(body4) {
    for (const pair of horizontal) {
      const left = body4.keypoints.findIndex((kp2) => kp2.part === pair[0]);
      const right = body4.keypoints.findIndex((kp2) => kp2.part === pair[1]);
      if (body4.keypoints[left] && body4.keypoints[right]) {
        if (body4.keypoints[left].position[0] < body4.keypoints[right].position[0]) {
          const tmp = body4.keypoints[left];
          body4.keypoints[left] = body4.keypoints[right];
          body4.keypoints[right] = tmp;
        }
      }
    }
    for (const pair of vertical) {
      const lower = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[0]);
      const higher = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[1]);
      if (body4.keypoints[lower] && body4.keypoints[higher]) {
        if (body4.keypoints[lower].position[1] < body4.keypoints[higher].position[1]) {
          body4.keypoints.splice(lower, 1);
        }
      }
    }
    for (const [pair, compare2] of relative) {
      const left = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[0]);
      const right = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === pair[1]);
      const leftTo = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === compare2[0]);
      const rightTo = body4.keypoints.findIndex((kp2) => kp2 && kp2.part === compare2[1]);
      if (!body4.keypoints[leftTo] || !body4.keypoints[rightTo])
        continue;
      const distanceLeft = body4.keypoints[left] ? [
        Math.abs(body4.keypoints[leftTo].position[0] - body4.keypoints[left].position[0]),
        Math.abs(body4.keypoints[rightTo].position[0] - body4.keypoints[left].position[0])
      ] : [0, 0];
      const distanceRight = body4.keypoints[right] ? [
        Math.abs(body4.keypoints[rightTo].position[0] - body4.keypoints[right].position[0]),
        Math.abs(body4.keypoints[leftTo].position[0] - body4.keypoints[right].position[0])
      ] : [0, 0];
      if (distanceLeft[0] > distanceLeft[1] || distanceRight[0] > distanceRight[1]) {
        const tmp = body4.keypoints[left];
        body4.keypoints[left] = body4.keypoints[right];
        body4.keypoints[right] = tmp;
      }
    }
  }
  function jitter(keypoints) {
    for (let i10 = 0; i10 < keypoints.length; i10++) {
      if (keypoints[i10] && cache5.keypoints[i10]) {
        const diff = [Math.abs(keypoints[i10].positionRaw[0] - cache5.keypoints[i10].positionRaw[0]), Math.abs(keypoints[i10].positionRaw[1] - cache5.keypoints[i10].positionRaw[1])];
        if (diff[0] < maxJitter && diff[1] < maxJitter) {
          keypoints[i10] = cache5.keypoints[i10];
        } else {
          cache5.keypoints[i10] = keypoints[i10];
        }
      } else {
        cache5.keypoints[i10] = keypoints[i10];
      }
    }
    return keypoints;
  }
  function padInput(input, inputSize10) {
    var _a22, _b2;
    const t8 = {};
    if (!((_a22 = input == null ? void 0 : input.shape) == null ? void 0 : _a22[1]) || !((_b2 = input == null ? void 0 : input.shape) == null ? void 0 : _b2[2]))
      return input;
    cache5.padding = [
      [0, 0],
      // dont touch batch
      [input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0, input.shape[2] > input.shape[1] ? Math.trunc((input.shape[2] - input.shape[1]) / 2) : 0],
      // height before&after
      [input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0, input.shape[1] > input.shape[2] ? Math.trunc((input.shape[1] - input.shape[2]) / 2) : 0],
      // width before&after
      [0, 0]
      // dont touch rbg
    ];
    t8.pad = Ea(input, cache5.padding);
    t8.resize = Fj.resizeBilinear(t8.pad, [inputSize10, inputSize10]);
    const final = qe(t8.resize, "int32");
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return final;
  }
  function rescaleBody(body4, outputSize2) {
    body4.keypoints = body4.keypoints.filter((kpt4) => kpt4 == null ? void 0 : kpt4.position);
    for (const kpt4 of body4.keypoints) {
      kpt4.position = [
        kpt4.position[0] * (outputSize2[0] + cache5.padding[2][0] + cache5.padding[2][1]) / outputSize2[0] - cache5.padding[2][0],
        kpt4.position[1] * (outputSize2[1] + cache5.padding[1][0] + cache5.padding[1][1]) / outputSize2[1] - cache5.padding[1][0]
      ];
      kpt4.positionRaw = [
        kpt4.position[0] / outputSize2[0],
        kpt4.position[1] / outputSize2[1]
      ];
    }
    const rescaledBoxes = calc(body4.keypoints.map((pt2) => pt2.position), outputSize2);
    body4.box = rescaledBoxes.box;
    body4.boxRaw = rescaledBoxes.boxRaw;
    return body4;
  }
  var model18;
  var inputSize8 = 0;
  var skipped14 = Number.MAX_SAFE_INTEGER;
  var cache6 = {
    boxes: [],
    bodies: [],
    last: 0
  };
  async function load16(config3) {
    var _a22;
    if (env.initial)
      model18 = null;
    if (!model18) {
      fakeOps(["size"], config3);
      model18 = await loadModel(config3.body.modelPath);
    } else if (config3.debug)
      log$1("cached model:", model18["modelUrl"]);
    inputSize8 = (model18 == null ? void 0 : model18["executor"]) && ((_a22 = model18 == null ? void 0 : model18.inputs) == null ? void 0 : _a22[0].shape) ? model18.inputs[0].shape[2] : 0;
    if (inputSize8 < 64)
      inputSize8 = 256;
    if (A().flagRegistry.WEBGL_USE_SHAPES_UNIFORMS)
      A().set("WEBGL_USE_SHAPES_UNIFORMS", false);
    return model18;
  }
  function parseSinglePose(res, config3, image) {
    const kpt4 = res[0][0];
    const keypoints = [];
    let score = 0;
    for (let id2 = 0; id2 < kpt4.length; id2++) {
      score = kpt4[id2][2];
      if (score > config3.body.minConfidence) {
        const positionRaw = [kpt4[id2][1], kpt4[id2][0]];
        keypoints.push({
          score: Math.round(100 * score) / 100,
          part: kpt3[id2],
          positionRaw,
          position: [
            // normalized to input image size
            Math.round((image.shape[2] || 0) * positionRaw[0]),
            Math.round((image.shape[1] || 0) * positionRaw[1])
          ]
        });
      }
    }
    score = keypoints.reduce((prev, curr) => curr.score > prev ? curr.score : prev, 0);
    const bodies = [];
    const newBox = calc(keypoints.map((pt2) => pt2.position), [image.shape[2], image.shape[1]]);
    const annotations2 = {};
    for (const [name2, indexes] of Object.entries(connected3)) {
      const pt2 = [];
      for (let i10 = 0; i10 < indexes.length - 1; i10++) {
        const pt0 = keypoints.find((kp2) => kp2.part === indexes[i10]);
        const pt1 = keypoints.find((kp2) => kp2.part === indexes[i10 + 1]);
        if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
          pt2.push([pt0.position, pt1.position]);
      }
      annotations2[name2] = pt2;
    }
    const body4 = { id: 0, score, box: newBox.box, boxRaw: newBox.boxRaw, keypoints, annotations: annotations2 };
    bodyParts(body4);
    bodies.push(body4);
    return bodies;
  }
  function parseMultiPose(res, config3, image) {
    const bodies = [];
    for (let id2 = 0; id2 < res[0].length; id2++) {
      const kpt4 = res[0][id2];
      const boxScore = Math.round(100 * kpt4[51 + 4]) / 100;
      if (boxScore > config3.body.minConfidence) {
        const keypoints = [];
        for (let i10 = 0; i10 < 17; i10++) {
          const score = kpt4[3 * i10 + 2];
          if (score > config3.body.minConfidence) {
            const positionRaw = [kpt4[3 * i10 + 1], kpt4[3 * i10 + 0]];
            keypoints.push({
              part: kpt3[i10],
              score: Math.round(100 * score) / 100,
              positionRaw,
              position: [Math.round((image.shape[2] || 0) * positionRaw[0]), Math.round((image.shape[1] || 0) * positionRaw[1])]
            });
          }
        }
        const boxRaw = [kpt4[51 + 1], kpt4[51 + 0], kpt4[51 + 3] - kpt4[51 + 1], kpt4[51 + 2] - kpt4[51 + 0]];
        const boxNorm = [Math.trunc(boxRaw[0] * (image.shape[2] || 0)), Math.trunc(boxRaw[1] * (image.shape[1] || 0)), Math.trunc(boxRaw[2] * (image.shape[2] || 0)), Math.trunc(boxRaw[3] * (image.shape[1] || 0))];
        const annotations2 = {};
        for (const [name2, indexes] of Object.entries(connected3)) {
          const pt2 = [];
          for (let i10 = 0; i10 < indexes.length - 1; i10++) {
            const pt0 = keypoints.find((kp2) => kp2.part === indexes[i10]);
            const pt1 = keypoints.find((kp2) => kp2.part === indexes[i10 + 1]);
            if (pt0 && pt1 && pt0.score > (config3.body.minConfidence || 0) && pt1.score > (config3.body.minConfidence || 0))
              pt2.push([pt0.position, pt1.position]);
          }
          annotations2[name2] = pt2;
        }
        const body4 = { id: id2, score: boxScore, box: boxNorm, boxRaw, keypoints: [...keypoints], annotations: annotations2 };
        bodyParts(body4);
        bodies.push(body4);
      }
    }
    bodies.sort((a, b) => b.score - a.score);
    if (bodies.length > config3.body.maxDetected)
      bodies.length = config3.body.maxDetected;
    return bodies;
  }
  async function predict17(input, config3) {
    var _a22;
    if (!(model18 == null ? void 0 : model18["executor"]) || !((_a22 = model18 == null ? void 0 : model18.inputs) == null ? void 0 : _a22[0].shape))
      return [];
    if (!config3.skipAllowed)
      cache6.boxes.length = 0;
    skipped14++;
    const skipTime = (config3.body.skipTime || 0) > now() - cache6.last;
    const skipFrame = skipped14 < (config3.body.skipFrames || 0);
    if (config3.skipAllowed && skipTime && skipFrame) {
      return cache6.bodies;
    }
    return new Promise(async (resolve) => {
      const t8 = {};
      skipped14 = 0;
      t8.input = padInput(input, inputSize8);
      t8.res = model18 == null ? void 0 : model18.execute(t8.input);
      cache6.last = now();
      const res = await t8.res.array();
      cache6.bodies = t8.res.shape[2] === 17 ? parseSinglePose(res, config3, input) : parseMultiPose(res, config3, input);
      for (const body4 of cache6.bodies) {
        rescaleBody(body4, [input.shape[2] || 1, input.shape[1] || 1]);
        jitter(body4.keypoints);
      }
      Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
      resolve(cache6.bodies);
    });
  }
  var model19;
  var last10 = [];
  var lastTime15 = 0;
  var skipped15 = Number.MAX_SAFE_INTEGER;
  var inputSize9 = 0;
  var scaleBox = 2.5;
  async function load17(config3) {
    if (!model19 || env.initial) {
      model19 = await loadModel(config3.object.modelPath);
      const inputs = (model19 == null ? void 0 : model19["executor"]) ? Object.values(model19.modelSignature["inputs"]) : void 0;
      inputSize9 = Array.isArray(inputs) ? parseInt(inputs[0].tensorShape.dim[2].size) : 416;
    } else if (config3.debug)
      log$1("cached model:", model19["modelUrl"]);
    return model19;
  }
  async function process4(res, outputShape, config3) {
    var _a22, _b2;
    let id2 = 0;
    let results = [];
    const size2 = inputSize9;
    for (const strideSize of [1, 2, 4]) {
      const baseSize = strideSize * 13;
      const scoresT = mc(res.find((a) => a.shape[1] === baseSize ** 2 && (a.shape[2] || 0) === labels2.length));
      const scores = await scoresT.array();
      const featuresT = mc(res.find((a) => a.shape[1] === baseSize ** 2 && (a.shape[2] || 0) < labels2.length));
      const boxesMaxT = W(featuresT, [-1, 4, (((_a22 = featuresT.shape) == null ? void 0 : _a22[1]) || 0) / 4]);
      const boxIdxT = Sk(boxesMaxT, 2);
      const boxIdx = await boxIdxT.array();
      for (let i10 = 0; i10 < scoresT.shape[0]; i10++) {
        for (let j = 0; j < (((_b2 = scoresT.shape) == null ? void 0 : _b2[1]) || 0); j++) {
          const score = scores[i10][j];
          if (score > (config3.object.minConfidence || 0) && j !== 61) {
            const cx2 = (0.5 + Math.trunc(i10 % baseSize)) / baseSize;
            const cy2 = (0.5 + Math.trunc(i10 / baseSize)) / baseSize;
            const boxOffset = boxIdx[i10].map((a) => a * (baseSize / strideSize / size2));
            const [x, y10] = [
              cx2 - scaleBox / strideSize * boxOffset[0],
              cy2 - scaleBox / strideSize * boxOffset[1]
            ];
            const [w10, h] = [
              cx2 + scaleBox / strideSize * boxOffset[2] - x,
              cy2 + scaleBox / strideSize * boxOffset[3] - y10
            ];
            let boxRaw = [x, y10, w10, h];
            boxRaw = boxRaw.map((a) => Math.max(0, Math.min(a, 1)));
            const box = [
              // results normalized to input image pixels
              boxRaw[0] * outputShape[0],
              boxRaw[1] * outputShape[1],
              boxRaw[2] * outputShape[0],
              boxRaw[3] * outputShape[1]
            ];
            const result = {
              id: id2++,
              // strideSize,
              score: Math.round(100 * score) / 100,
              class: j + 1,
              label: labels2[j].label,
              // center: [Math.trunc(outputShape[0] * cx), Math.trunc(outputShape[1] * cy)],
              // centerRaw: [cx, cy],
              box: box.map((a) => Math.trunc(a)),
              boxRaw
            };
            results.push(result);
          }
        }
      }
      Ot([scoresT, featuresT, boxesMaxT, boxIdxT]);
    }
    const nmsBoxes = results.map((a) => [a.boxRaw[1], a.boxRaw[0], a.boxRaw[3], a.boxRaw[2]]);
    const nmsScores = results.map((a) => a.score);
    let nmsIdx = [];
    if (nmsBoxes && nmsBoxes.length > 0) {
      const nms = await Fj.nonMaxSuppressionAsync(nmsBoxes, nmsScores, config3.object.maxDetected || 0, config3.object.iouThreshold, config3.object.minConfidence);
      nmsIdx = Array.from(await nms.data());
      Ot(nms);
    }
    results = results.filter((_val, idx) => nmsIdx.includes(idx)).sort((a, b) => b.score - a.score);
    return results;
  }
  async function predict18(image, config3) {
    if (!(model19 == null ? void 0 : model19["executor"]))
      return [];
    const skipTime = (config3.object.skipTime || 0) > now() - lastTime15;
    const skipFrame = skipped15 < (config3.object.skipFrames || 0);
    if (config3.skipAllowed && skipTime && skipFrame && last10.length > 0) {
      skipped15++;
      return last10;
    }
    skipped15 = 0;
    if (!env.kernels.includes("mod") || !env.kernels.includes("sparsetodense"))
      return last10;
    return new Promise(async (resolve) => {
      const outputSize2 = [image.shape[2] || 0, image.shape[1] || 0];
      const resizeT = Fj.resizeBilinear(image, [inputSize9, inputSize9], false);
      const normT = je(resizeT, constants.tf255);
      const transposeT = fc(normT, [0, 3, 1, 2]);
      let objectT;
      if (config3.object.enabled)
        objectT = model19.execute(transposeT);
      lastTime15 = now();
      const obj = await process4(objectT, outputSize2, config3);
      last10 = obj;
      Ot([resizeT, normT, transposeT, ...objectT]);
      resolve(obj);
    });
  }
  var partNames = [
    "nose",
    "leftEye",
    "rightEye",
    "leftEar",
    "rightEar",
    "leftShoulder",
    "rightShoulder",
    "leftElbow",
    "rightElbow",
    "leftWrist",
    "rightWrist",
    "leftHip",
    "rightHip",
    "leftKnee",
    "rightKnee",
    "leftAnkle",
    "rightAnkle"
  ];
  var count = partNames.length;
  var partIds = partNames.reduce((result, jointName, i10) => {
    result[jointName] = i10;
    return result;
  }, {});
  var connectedPartNames = [
    ["leftHip", "leftShoulder"],
    ["leftElbow", "leftShoulder"],
    ["leftElbow", "leftWrist"],
    ["leftHip", "leftKnee"],
    ["leftKnee", "leftAnkle"],
    ["rightHip", "rightShoulder"],
    ["rightElbow", "rightShoulder"],
    ["rightElbow", "rightWrist"],
    ["rightHip", "rightKnee"],
    ["rightKnee", "rightAnkle"],
    ["leftShoulder", "rightShoulder"],
    ["leftHip", "rightHip"]
  ];
  connectedPartNames.map(([jointNameA, jointNameB]) => [partIds[jointNameA], partIds[jointNameB]]);
  var poseChain = [
    ["nose", "leftEye"],
    ["leftEye", "leftEar"],
    ["nose", "rightEye"],
    ["rightEye", "rightEar"],
    ["nose", "leftShoulder"],
    ["leftShoulder", "leftElbow"],
    ["leftElbow", "leftWrist"],
    ["leftShoulder", "leftHip"],
    ["leftHip", "leftKnee"],
    ["leftKnee", "leftAnkle"],
    ["nose", "rightShoulder"],
    ["rightShoulder", "rightElbow"],
    ["rightElbow", "rightWrist"],
    ["rightShoulder", "rightHip"],
    ["rightHip", "rightKnee"],
    ["rightKnee", "rightAnkle"]
  ];
  function getBoundingBox(keypoints) {
    const coord = keypoints.reduce(({ maxX, maxY, minX, minY }, { position: { x, y: y10 } }) => ({
      maxX: Math.max(maxX, x),
      maxY: Math.max(maxY, y10),
      minX: Math.min(minX, x),
      minY: Math.min(minY, y10)
    }), {
      maxX: Number.NEGATIVE_INFINITY,
      maxY: Number.NEGATIVE_INFINITY,
      minX: Number.POSITIVE_INFINITY,
      minY: Number.POSITIVE_INFINITY
    });
    return [coord.minX, coord.minY, coord.maxX - coord.minX, coord.maxY - coord.minY];
  }
  function scalePoses(poses, [height, width], [inputResolutionHeight, inputResolutionWidth]) {
    const scaleY = height / inputResolutionHeight;
    const scaleX = width / inputResolutionWidth;
    const scalePose = (pose, i10) => ({
      id: i10,
      score: pose.score,
      boxRaw: [pose.box[0] / inputResolutionWidth, pose.box[1] / inputResolutionHeight, pose.box[2] / inputResolutionWidth, pose.box[3] / inputResolutionHeight],
      box: [Math.trunc(pose.box[0] * scaleX), Math.trunc(pose.box[1] * scaleY), Math.trunc(pose.box[2] * scaleX), Math.trunc(pose.box[3] * scaleY)],
      keypoints: pose.keypoints.map(({ score, part, position }) => ({
        score,
        part,
        position: [Math.trunc(position.x * scaleX), Math.trunc(position.y * scaleY)],
        positionRaw: [position.x / inputResolutionHeight, position.y / inputResolutionHeight]
      })),
      annotations: {}
    });
    const scaledPoses = poses.map((pose, i10) => scalePose(pose, i10));
    return scaledPoses;
  }
  var MaxHeap = class {
    // function call
    constructor(maxSize2, getElementValue) {
      __publicField2(this, "priorityQueue");
      __publicField2(this, "numberOfElements");
      __publicField2(this, "getElementValue");
      this.priorityQueue = new Array(maxSize2);
      this.numberOfElements = -1;
      this.getElementValue = getElementValue;
    }
    enqueue(x) {
      this.priorityQueue[++this.numberOfElements] = x;
      this.swim(this.numberOfElements);
    }
    dequeue() {
      const max = this.priorityQueue[0];
      this.exchange(0, this.numberOfElements--);
      this.sink(0);
      this.priorityQueue[this.numberOfElements + 1] = null;
      return max;
    }
    empty() {
      return this.numberOfElements === -1;
    }
    size() {
      return this.numberOfElements + 1;
    }
    all() {
      return this.priorityQueue.slice(0, this.numberOfElements + 1);
    }
    max() {
      return this.priorityQueue[0];
    }
    swim(k) {
      while (k > 0 && this.less(Math.floor(k / 2), k)) {
        this.exchange(k, Math.floor(k / 2));
        k = Math.floor(k / 2);
      }
    }
    sink(k) {
      while (2 * k <= this.numberOfElements) {
        let j = 2 * k;
        if (j < this.numberOfElements && this.less(j, j + 1))
          j++;
        if (!this.less(k, j))
          break;
        this.exchange(k, j);
        k = j;
      }
    }
    getValueAt(i10) {
      return this.getElementValue(this.priorityQueue[i10]);
    }
    less(i10, j) {
      return this.getValueAt(i10) < this.getValueAt(j);
    }
    exchange(i10, j) {
      const t8 = this.priorityQueue[i10];
      this.priorityQueue[i10] = this.priorityQueue[j];
      this.priorityQueue[j] = t8;
    }
  };
  function getOffsetPoint(y10, x, keypoint, offsets) {
    return {
      y: offsets.get(y10, x, keypoint),
      x: offsets.get(y10, x, keypoint + count)
    };
  }
  function getImageCoords(part, outputStride2, offsets) {
    const { heatmapY, heatmapX, id: keypoint } = part;
    const { y: y10, x } = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets);
    return {
      x: part.heatmapX * outputStride2 + x,
      y: part.heatmapY * outputStride2 + y10
    };
  }
  function clamp(a, min, max) {
    if (a < min)
      return min;
    if (a > max)
      return max;
    return a;
  }
  function squaredDistance(y12, x12, y22, x22) {
    const dy = y22 - y12;
    const dx2 = x22 - x12;
    return dy * dy + dx2 * dx2;
  }
  function addVectors(a, b) {
    return { x: a.x + b.x, y: a.y + b.y };
  }
  var model20;
  var poseNetOutputs = [
    "MobilenetV1/offset_2/BiasAdd",
    "MobilenetV1/heatmap_2/BiasAdd",
    "MobilenetV1/displacement_fwd_2/BiasAdd",
    "MobilenetV1/displacement_bwd_2/BiasAdd"
    /* displacementBwd */
  ];
  var localMaximumRadius = 1;
  var outputStride = 16;
  var squaredNmsRadius = 50 ** 2;
  function traverse(edgeId, sourceKeypoint, targetId, scores, offsets, displacements, offsetRefineStep = 2) {
    const getDisplacement = (point2) => ({
      y: displacements.get(point2.y, point2.x, edgeId),
      x: displacements.get(point2.y, point2.x, displacements.shape[2] / 2 + edgeId)
    });
    const getStridedIndexNearPoint = (point2, height2, width2) => ({
      y: clamp(Math.round(point2.y / outputStride), 0, height2 - 1),
      x: clamp(Math.round(point2.x / outputStride), 0, width2 - 1)
    });
    const [height, width] = scores.shape;
    const sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, height, width);
    const displacement = getDisplacement(sourceKeypointIndices);
    const displacedPoint = addVectors(sourceKeypoint.position, displacement);
    let targetKeypoint = displacedPoint;
    for (let i10 = 0; i10 < offsetRefineStep; i10++) {
      const targetKeypointIndices = getStridedIndexNearPoint(targetKeypoint, height, width);
      const offsetPoint = getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetId, offsets);
      targetKeypoint = addVectors(
        { x: targetKeypointIndices.x * outputStride, y: targetKeypointIndices.y * outputStride },
        { x: offsetPoint.x, y: offsetPoint.y }
      );
    }
    const targetKeyPointIndices = getStridedIndexNearPoint(targetKeypoint, height, width);
    const score = scores.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetId);
    return { position: targetKeypoint, part: partNames[targetId], score };
  }
  function decodePose(root, scores, offsets, displacementsFwd, displacementsBwd) {
    const tuples = poseChain.map(([parentJoinName, childJoinName]) => [partIds[parentJoinName], partIds[childJoinName]]);
    const edgesFwd = tuples.map(([, childJointId]) => childJointId);
    const edgesBwd = tuples.map(([parentJointId]) => parentJointId);
    const numParts = scores.shape[2];
    const numEdges = edgesFwd.length;
    const keypoints = new Array(numParts);
    const rootPoint = getImageCoords(root.part, outputStride, offsets);
    keypoints[root.part.id] = {
      score: root.score,
      part: partNames[root.part.id],
      position: rootPoint
    };
    for (let edge = numEdges - 1; edge >= 0; --edge) {
      const sourceId = edgesFwd[edge];
      const targetId = edgesBwd[edge];
      if (keypoints[sourceId] && !keypoints[targetId]) {
        keypoints[targetId] = traverse(edge, keypoints[sourceId], targetId, scores, offsets, displacementsBwd);
      }
    }
    for (let edge = 0; edge < numEdges; ++edge) {
      const sourceId = edgesBwd[edge];
      const targetId = edgesFwd[edge];
      if (keypoints[sourceId] && !keypoints[targetId]) {
        keypoints[targetId] = traverse(edge, keypoints[sourceId], targetId, scores, offsets, displacementsFwd);
      }
    }
    return keypoints;
  }
  function scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, scores) {
    const [height, width] = scores.shape;
    let localMaximum = true;
    const yStart = Math.max(heatmapY - localMaximumRadius, 0);
    const yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);
    for (let yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {
      const xStart = Math.max(heatmapX - localMaximumRadius, 0);
      const xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);
      for (let xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {
        if (scores.get(yCurrent, xCurrent, keypointId) > score) {
          localMaximum = false;
          break;
        }
      }
      if (!localMaximum)
        break;
    }
    return localMaximum;
  }
  function buildPartWithScoreQueue(minConfidence2, scores) {
    const [height, width, numKeypoints] = scores.shape;
    const queue2 = new MaxHeap(height * width * numKeypoints, ({ score }) => score);
    for (let heatmapY = 0; heatmapY < height; ++heatmapY) {
      for (let heatmapX = 0; heatmapX < width; ++heatmapX) {
        for (let keypointId = 0; keypointId < numKeypoints; ++keypointId) {
          const score = scores.get(heatmapY, heatmapX, keypointId);
          if (score < minConfidence2)
            continue;
          if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, scores))
            queue2.enqueue({ score, part: { heatmapY, heatmapX, id: keypointId } });
        }
      }
    }
    return queue2;
  }
  function withinRadius(poses, { x, y: y10 }, keypointId) {
    return poses.some(({ keypoints }) => {
      var _a22;
      const correspondingKeypoint = (_a22 = keypoints[keypointId]) == null ? void 0 : _a22.position;
      if (!correspondingKeypoint)
        return false;
      return squaredDistance(y10, x, correspondingKeypoint.y, correspondingKeypoint.x) <= squaredNmsRadius;
    });
  }
  function getInstanceScore(existingPoses, keypoints) {
    const notOverlappedKeypointScores = keypoints.reduce((result, { position, score }, keypointId) => {
      if (!withinRadius(existingPoses, position, keypointId))
        result += score;
      return result;
    }, 0);
    return notOverlappedKeypointScores / keypoints.length;
  }
  function decode(offsets, scores, displacementsFwd, displacementsBwd, maxDetected, minConfidence2) {
    const poses = [];
    const queue2 = buildPartWithScoreQueue(minConfidence2, scores);
    while (poses.length < maxDetected && !queue2.empty()) {
      const root = queue2.dequeue();
      const rootImageCoords = getImageCoords(root.part, outputStride, offsets);
      if (withinRadius(poses, rootImageCoords, root.part.id))
        continue;
      let keypoints = decodePose(root, scores, offsets, displacementsFwd, displacementsBwd);
      keypoints = keypoints.filter((a) => a.score > minConfidence2);
      const score = getInstanceScore(poses, keypoints);
      const box = getBoundingBox(keypoints);
      if (score > minConfidence2)
        poses.push({ keypoints, box, score: Math.round(100 * score) / 100 });
    }
    return poses;
  }
  async function predict19(input, config3) {
    if (!(model20 == null ? void 0 : model20["executor"]))
      return [];
    const res = De(() => {
      if (!model20.inputs[0].shape)
        return [];
      const resized = Fj.resizeBilinear(input, [model20.inputs[0].shape[2], model20.inputs[0].shape[1]]);
      const normalized = Te(je(qe(resized, "float32"), 127.5), 1);
      const results = model20.execute(normalized, poseNetOutputs);
      const results3d = results.map((y10) => mc(y10, [0]));
      results3d[1] = Na(results3d[1]);
      return results3d;
    });
    const buffers = await Promise.all(res.map((tensor) => tensor.buffer()));
    for (const t8 of res)
      Ot(t8);
    const decoded = decode(buffers[0], buffers[1], buffers[2], buffers[3], config3.body.maxDetected, config3.body.minConfidence);
    if (!model20.inputs[0].shape)
      return [];
    const scaled = scalePoses(decoded, [input.shape[1], input.shape[2]], [model20.inputs[0].shape[2], model20.inputs[0].shape[1]]);
    return scaled;
  }
  async function load18(config3) {
    if (!model20 || env.initial)
      model20 = await loadModel(config3.body.modelPath);
    else if (config3.debug)
      log$1("cached model:", model20["modelUrl"]);
    return model20;
  }
  var model21;
  var outputNodes2 = ["fgr", "pha", "r1o", "r2o", "r3o", "r4o"];
  var t = {};
  var ratio = 0;
  function init3(config3) {
    Ot([t.r1i, t.r2i, t.r3i, t.r4i, t.downsample_ratio]);
    t.r1i = ir(0);
    t.r2i = ir(0);
    t.r3i = ir(0);
    t.r4i = ir(0);
    ratio = config3.segmentation.ratio || 0.5;
    t.downsample_ratio = ir(ratio);
  }
  async function load19(config3) {
    if (!model21 || env.initial)
      model21 = await loadModel(config3.segmentation.modelPath);
    else if (config3.debug)
      log$1("cached model:", model21["modelUrl"]);
    init3(config3);
    return model21;
  }
  var normalize = (r8) => De(() => {
    const squeeze = mc(r8, [0]);
    const mul = se(squeeze, constants.tf255);
    const cast = qe(mul, "int32");
    return cast;
  });
  function getRGBA(fgr, pha) {
    const rgb3 = fgr ? normalize(fgr) : Ta([pha.shape[1] || 0, pha.shape[2] || 0, 3], 255, "int32");
    const a = pha ? normalize(pha) : Ta([fgr.shape[1] || 0, fgr.shape[2] || 0, 1], 255, "int32");
    const rgba = bt([rgb3, a], -1);
    Ot([rgb3, a]);
    return rgba;
  }
  function getState(state2) {
    return De(() => {
      const r8 = {};
      r8.unstack = mo(state2, -1);
      r8.concat = bt(r8.unstack, 1);
      r8.split = pi(r8.concat, 4, 1);
      r8.stack = bt(r8.split, 2);
      r8.squeeze = mc(r8.stack, [0]);
      r8.expand = ai(r8.squeeze, -1);
      r8.add = Ce(r8.expand, 1);
      r8.mul = se(r8.add, 127.5);
      r8.cast = qe(r8.mul, "int32");
      r8.tile = uu(r8.cast, [1, 1, 3]);
      r8.alpha = Ta([r8.tile.shape[0] || 0, r8.tile.shape[1] || 0, 1], 255, "int32");
      return bt([r8.tile, r8.alpha], -1);
    });
  }
  async function predict20(input, config3) {
    if (!model21)
      model21 = await load19(config3);
    if (!(model21 == null ? void 0 : model21["executor"]))
      return null;
    t.src = je(input, 255);
    if (ratio !== config3.segmentation.ratio)
      init3(config3);
    const [fgr, pha, r1o, r2o, r3o, r4o] = await model21.executeAsync(t, outputNodes2);
    let rgba;
    switch (config3.segmentation.mode || "default") {
      case "default":
        rgba = getRGBA(fgr, pha);
        break;
      case "alpha":
        rgba = getRGBA(null, pha);
        break;
      case "foreground":
        rgba = getRGBA(fgr, null);
        break;
      case "state":
        rgba = getState(r1o);
        break;
      default:
        rgba = ir(0);
    }
    Ot([t.src, fgr, pha, t.r1i, t.r2i, t.r3i, t.r4i]);
    [t.r1i, t.r2i, t.r3i, t.r4i] = [r1o, r2o, r3o, r4o];
    return rgba;
  }
  var model22;
  async function load20(config3) {
    if (!model22 || env.initial)
      model22 = await loadModel(config3.segmentation.modelPath);
    else if (config3.debug)
      log$1("cached model:", model22["modelUrl"]);
    return model22;
  }
  async function predict21(input, config3) {
    var _a22;
    if (!model22)
      model22 = await load20(config3);
    if (!(model22 == null ? void 0 : model22["executor"]) || !((_a22 = model22 == null ? void 0 : model22.inputs) == null ? void 0 : _a22[0].shape))
      return null;
    const t8 = {};
    t8.resize = Fj.resizeBilinear(input, [model22.inputs[0].shape ? model22.inputs[0].shape[1] : 0, model22.inputs[0].shape ? model22.inputs[0].shape[2] : 0], false);
    t8.norm = je(t8.resize, constants.tf255);
    t8.res = model22.execute(t8.norm);
    t8.squeeze = mc(t8.res, [0]);
    t8.alpha = Fj.resizeBilinear(t8.squeeze, [input.shape[1] || 0, input.shape[2] || 0]);
    t8.mul = se(t8.alpha, constants.tf255);
    let rgba;
    switch (config3.segmentation.mode || "default") {
      case "default":
        t8.input = mc(input);
        t8.concat = bt([t8.input, t8.mul], -1);
        rgba = qe(t8.concat, "int32");
        break;
      case "alpha":
        rgba = qe(t8.mul, "int32");
        break;
      default:
        rgba = ir(0);
    }
    Object.keys(t8).forEach((tensor) => Ot(t8[tensor]));
    return rgba;
  }
  function validateModel(instance, model23, name2) {
    var _a22, _b2;
    if (!model23)
      return null;
    if (!((_a22 = instance == null ? void 0 : instance.config) == null ? void 0 : _a22.validateModels))
      return null;
    const simpleOps = ["const", "placeholder", "noop", "pad", "squeeze", "add", "sub", "mul", "div"];
    const ignoreOps = ["biasadd", "fusedbatchnormv3", "matmul", "switch", "shape", "merge", "split", "broadcastto"];
    const ops = [];
    const missing = [];
    const url2 = model23["modelUrl"];
    const executor = model23["executor"];
    if ((_b2 = executor == null ? void 0 : executor.graph) == null ? void 0 : _b2.nodes) {
      for (const kernel of Object.values(executor.graph.nodes)) {
        const op2 = kernel.op.toLowerCase();
        if (!ops.includes(op2))
          ops.push(op2);
      }
    } else {
      if (!executor && instance.config.debug) {
        log$1("model not loaded", name2);
      }
    }
    for (const op2 of ops) {
      if (!simpleOps.includes(op2) && !ignoreOps.includes(op2) && !instance.env.kernels.includes(op2) && !instance.env.kernels.includes(op2.replace("_", "")) && !instance.env.kernels.includes(op2.replace("native", "")) && !instance.env.kernels.includes(op2.replace("v2", ""))) {
        missing.push(op2);
      }
    }
    if (instance.config.debug && missing.length > 0)
      log$1("model validation failed:", name2, missing);
    return missing.length > 0 ? { name: name2, missing, ops, url: url2 } : null;
  }
  var Models = class {
    constructor(currentInstance) {
      __publicField2(this, "instance");
      __publicField2(this, "models", {});
      this.models = {};
      this.instance = currentInstance;
    }
    stats() {
      let totalSizeFromManifest = 0;
      let totalSizeWeights = 0;
      let totalSizeLoading = 0;
      for (const m of Object.values(modelStats)) {
        totalSizeFromManifest += m.sizeFromManifest;
        totalSizeWeights += m.sizeLoadedWeights;
        totalSizeLoading += m.sizeDesired;
      }
      const percentageLoaded = totalSizeLoading > 0 ? totalSizeWeights / totalSizeLoading : 0;
      return {
        numLoadedModels: Object.values(modelStats).length,
        numDefinedModels: Object.keys(this.models).length,
        percentageLoaded,
        totalSizeFromManifest,
        totalSizeWeights,
        totalSizeLoading,
        modelStats: Object.values(modelStats)
      };
    }
    reset() {
      for (const model23 of Object.keys(this.models))
        this.models[model23] = null;
    }
    async load(instance) {
      var _a22, _b2, _c22, _d22, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m, _n2, _o2, _p2, _q2, _r2, _s2, _t, _u, _v2, _w2, _x2, _y, _z2, _A2;
      if (env.initial)
        this.reset();
      if (instance)
        this.instance = instance;
      const m = {};
      m.blazeface = this.instance.config.face.enabled && !this.models.blazeface ? load3(this.instance.config) : null;
      m.antispoof = this.instance.config.face.enabled && ((_a22 = this.instance.config.face.antispoof) == null ? void 0 : _a22.enabled) && !this.models.antispoof ? load8(this.instance.config) : null;
      m.liveness = this.instance.config.face.enabled && ((_b2 = this.instance.config.face.liveness) == null ? void 0 : _b2.enabled) && !this.models.liveness ? load9(this.instance.config) : null;
      m.faceres = this.instance.config.face.enabled && ((_c22 = this.instance.config.face.description) == null ? void 0 : _c22.enabled) && !this.models.faceres ? load7(this.instance.config) : null;
      m.emotion = this.instance.config.face.enabled && ((_d22 = this.instance.config.face.emotion) == null ? void 0 : _d22.enabled) && !this.models.emotion ? load6(this.instance.config) : null;
      m.iris = this.instance.config.face.enabled && ((_e = this.instance.config.face.iris) == null ? void 0 : _e.enabled) && !((_f2 = this.instance.config.face.attention) == null ? void 0 : _f2.enabled) && !this.models.iris ? load4(this.instance.config) : null;
      m.facemesh = this.instance.config.face.enabled && ((_g2 = this.instance.config.face.mesh) == null ? void 0 : _g2.enabled) && !this.models.facemesh ? load5(this.instance.config) : null;
      m.gear = this.instance.config.face.enabled && ((_h2 = this.instance.config.face["gear"]) == null ? void 0 : _h2.enabled) && !this.models.gear ? load10(this.instance.config) : null;
      m.ssrnetage = this.instance.config.face.enabled && ((_i2 = this.instance.config.face["ssrnet"]) == null ? void 0 : _i2.enabled) && !this.models.ssrnetage ? load11(this.instance.config) : null;
      m.ssrnetgender = this.instance.config.face.enabled && ((_j2 = this.instance.config.face["ssrnet"]) == null ? void 0 : _j2.enabled) && !this.models.ssrnetgender ? load12(this.instance.config) : null;
      m.mobilefacenet = this.instance.config.face.enabled && ((_k2 = this.instance.config.face["mobilefacenet"]) == null ? void 0 : _k2.enabled) && !this.models.mobilefacenet ? load13(this.instance.config) : null;
      m.insightface = this.instance.config.face.enabled && ((_l2 = this.instance.config.face["insightface"]) == null ? void 0 : _l2.enabled) && !this.models.insightface ? load14(this.instance.config) : null;
      m.blazepose = this.instance.config.body.enabled && !this.models.blazepose && ((_m = this.instance.config.body.modelPath) == null ? void 0 : _m.includes("blazepose")) ? loadPose(this.instance.config) : null;
      m.blazeposedetect = this.instance.config.body.enabled && !this.models.blazeposedetect && this.instance.config.body["detector"] && this.instance.config.body["detector"].modelPath ? loadDetect(this.instance.config) : null;
      m.efficientpose = this.instance.config.body.enabled && !this.models.efficientpose && ((_n2 = this.instance.config.body.modelPath) == null ? void 0 : _n2.includes("efficientpose")) ? load2(this.instance.config) : null;
      m.movenet = this.instance.config.body.enabled && !this.models.movenet && ((_o2 = this.instance.config.body.modelPath) == null ? void 0 : _o2.includes("movenet")) ? load16(this.instance.config) : null;
      m.posenet = this.instance.config.body.enabled && !this.models.posenet && ((_p2 = this.instance.config.body.modelPath) == null ? void 0 : _p2.includes("posenet")) ? load18(this.instance.config) : null;
      m.handtrack = this.instance.config.hand.enabled && !this.models.handtrack && ((_r2 = (_q2 = this.instance.config.hand.detector) == null ? void 0 : _q2.modelPath) == null ? void 0 : _r2.includes("handtrack")) ? loadDetect3(this.instance.config) : null;
      m.handskeleton = this.instance.config.hand.enabled && this.instance.config.hand.landmarks && !this.models.handskeleton && ((_t = (_s2 = this.instance.config.hand.detector) == null ? void 0 : _s2.modelPath) == null ? void 0 : _t.includes("handtrack")) ? loadSkeleton2(this.instance.config) : null;
      if (this.instance.config.hand.enabled && !this.models.handdetect && ((_v2 = (_u = this.instance.config.hand.detector) == null ? void 0 : _u.modelPath) == null ? void 0 : _v2.includes("handdetect"))) {
        m.handdetect = loadDetect2(this.instance.config);
        m.handskeleton = loadSkeleton(this.instance.config);
      }
      m.centernet = this.instance.config.object.enabled && !this.models.centernet && ((_w2 = this.instance.config.object.modelPath) == null ? void 0 : _w2.includes("centernet")) ? load(this.instance.config) : null;
      m.nanodet = this.instance.config.object.enabled && !this.models.nanodet && ((_x2 = this.instance.config.object.modelPath) == null ? void 0 : _x2.includes("nanodet")) ? load17(this.instance.config) : null;
      m.selfie = this.instance.config.segmentation.enabled && !this.models.selfie && ((_y = this.instance.config.segmentation.modelPath) == null ? void 0 : _y.includes("selfie")) ? load20(this.instance.config) : null;
      m.meet = this.instance.config.segmentation.enabled && !this.models.meet && ((_z2 = this.instance.config.segmentation.modelPath) == null ? void 0 : _z2.includes("meet")) ? load15(this.instance.config) : null;
      m.rvm = this.instance.config.segmentation.enabled && !this.models.rvm && ((_A2 = this.instance.config.segmentation.modelPath) == null ? void 0 : _A2.includes("rvm")) ? load19(this.instance.config) : null;
      for (const [model23, promise] of Object.entries(m)) {
        if (promise == null ? void 0 : promise["then"])
          promise["then"]((val) => this.models[model23] = val);
      }
      await Promise.all(Object.values(m));
    }
    list() {
      const models3 = Object.keys(this.models).map((model23) => {
        var _a22;
        return { name: model23, loaded: this.models[model23] !== null, size: 0, url: this.models[model23] ? (_a22 = this.models[model23]) == null ? void 0 : _a22["modelUrl"] : null };
      });
      for (const m of models3) {
        const stats = Object.keys(modelStats).find((s) => s.startsWith(m.name));
        if (!stats)
          continue;
        m.size = modelStats[stats].sizeLoadedWeights;
        m.url = modelStats[stats].url;
      }
      return models3;
    }
    loaded() {
      const list = this.list();
      const loaded = list.filter((model23) => model23.loaded).map((model23) => model23.name);
      return loaded;
    }
    validate() {
      const missing = [];
      for (const defined of Object.keys(this.models)) {
        const model23 = this.models[defined];
        if (!model23)
          continue;
        const res = validateModel(this.instance, model23, defined);
        if (res)
          missing.push(res);
      }
      return missing;
    }
  };
  function join2(faces, bodies, hands, gestures, shape) {
    var _a22, _b2, _c22, _d22, _e, _f2;
    let id2 = 0;
    const persons = [];
    for (const face4 of faces) {
      const person2 = { id: id2++, face: face4, body: null, hands: { left: null, right: null }, gestures: [], box: [0, 0, 0, 0] };
      for (const body4 of bodies) {
        if (face4.box[0] > body4.box[0] && face4.box[0] < body4.box[0] + body4.box[2] && face4.box[1] + face4.box[3] > body4.box[1] && face4.box[1] + face4.box[3] < body4.box[1] + body4.box[3]) {
          person2.body = body4;
        }
      }
      if (person2.body) {
        for (const hand3 of hands) {
          if (hand3.box[0] + hand3.box[2] > person2.body.box[0] && hand3.box[0] + hand3.box[2] < person2.body.box[0] + person2.body.box[2] && hand3.box[1] + hand3.box[3] > person2.body.box[1] && hand3.box[1] + hand3.box[3] < person2.body.box[1] + person2.body.box[3]) {
            if (person2.hands)
              person2.hands.left = hand3;
          }
          if (hand3.box[0] < person2.body.box[0] + person2.body.box[2] && hand3.box[0] > person2.body.box[0] && hand3.box[1] + hand3.box[3] > person2.body.box[1] && hand3.box[1] + hand3.box[3] < person2.body.box[1] + person2.body.box[3]) {
            if (person2.hands)
              person2.hands.right = hand3;
          }
        }
      }
      for (const gesture2 of gestures) {
        if (gesture2["face"] !== void 0 && gesture2["face"] === face4.id)
          person2.gestures.push(gesture2);
        else if (gesture2["iris"] !== void 0 && gesture2["iris"] === face4.id)
          person2.gestures.push(gesture2);
        else if (gesture2["body"] !== void 0 && gesture2["body"] === ((_a22 = person2.body) == null ? void 0 : _a22.id))
          person2.gestures.push(gesture2);
        else if (gesture2["hand"] !== void 0 && gesture2["hand"] === ((_b2 = person2.hands.left) == null ? void 0 : _b2.id))
          person2.gestures.push(gesture2);
        else if (gesture2["hand"] !== void 0 && gesture2["hand"] === ((_c22 = person2.hands.right) == null ? void 0 : _c22.id))
          person2.gestures.push(gesture2);
      }
      const x = [];
      const y10 = [];
      const extractXY = (box) => {
        if (box && box.length === 4) {
          x.push(box[0], box[0] + box[2]);
          y10.push(box[1], box[1] + box[3]);
        }
      };
      extractXY(person2.face.box);
      extractXY((_d22 = person2.body) == null ? void 0 : _d22.box);
      extractXY((_e = person2.hands.left) == null ? void 0 : _e.box);
      extractXY((_f2 = person2.hands.right) == null ? void 0 : _f2.box);
      const minX = Math.min(...x);
      const minY = Math.min(...y10);
      person2.box = [minX, minY, Math.max(...x) - minX, Math.max(...y10) - minY];
      if ((shape == null ? void 0 : shape[1]) && (shape == null ? void 0 : shape[2]))
        person2.boxRaw = [person2.box[0] / shape[2], person2.box[1] / shape[1], person2.box[2] / shape[2], person2.box[3] / shape[1]];
      persons.push(person2);
    }
    return persons;
  }
  var face3 = `
/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA
AAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu
bmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob
IxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo
KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E
AB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE
EQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH
SElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1
tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB
AQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET
IjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla
Y2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG
x8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML
Xp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF
PUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/
AJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z
5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9
zZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO
tHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6
8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W
wA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk
EtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6
GhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT
A7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep
rBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb
LCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ
ih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K
KAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l
pBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x
UqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4
HaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr
xL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS
NO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD
1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX
+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3
GBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K
q4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0
nhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm
uic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH
ArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV
wF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8
87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P
FQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD
YNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv
JmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ
QmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el
UJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681
ly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly
CK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc
UDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF
63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x
XY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2
ZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk
Xb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK
cBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef
eNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4
/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5
rl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru
/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A
zviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO
I4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1
jfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ
GRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG
cZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb
WmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis
ZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH
ckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi
lbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO
xuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK
JtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX
PaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c
W0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t
C6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk
4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn
xHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW
vHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi
qr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV
hamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F
j4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6
wqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm
oy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ
k7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg
nQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP
1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1
H1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ
1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx
zSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt
fFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp
Oxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj
VtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy
rFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe
5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D
d/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69
MlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ
Fbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ
MA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP
ByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn
0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU
yOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is
pNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz
TSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu
uCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem
gGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk
HvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy
s9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu
m6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb
0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz
9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN
DNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n
R6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk
nmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu
6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd
9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb
Sms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S
MSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz
FEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8
VSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx
Y0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ
mupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+
5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh
05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd
ua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ
5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR
Mqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8
1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4
B9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag
Bc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA
3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn
3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx
1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU
tzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6
f3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA
bvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ
zyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup
6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM
350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0
/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a
YfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ
agBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO
mAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl
mOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR
nqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo
EPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt
4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ
ScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p
iMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj
PQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l
c6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1
8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3
ylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY
euPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==`;
  var body3 = `
/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk
JyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF
RUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA
AhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA
AQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA
AAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA
AhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj
+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt
Fh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR
PLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl
mZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp
+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa
zhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D
h1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2
ex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67
d4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y
Rv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP
Ld3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC
vy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi
eSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/
Mx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+
r3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO
O0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s
tfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN
TmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc
0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj
q83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w
+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s
d8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t
cI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4
Yibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe
bzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi
KxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6
rNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ
9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf
Jvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V
bxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q
Vbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM
lorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/
/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme
E4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv
fauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6
jkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN
+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk
Rvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK
cGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop
yW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn
E8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX
12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW
iI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS
RWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf
0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx
DS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL
G8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK
xC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ
a9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4
ZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6
tvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+
fJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE
erk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR
Md5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9
lcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD
j8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV
5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt
Cu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/
+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c
vUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p
jrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0
77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP
Sel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8
5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe
Y0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R
Hwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV
rWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU
z7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8
to6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X
y8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt
stcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/
w9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT
DpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l
XV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t
ydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS
34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX
e09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn
26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf
3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q
6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P
NbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO
yZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN
3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8
2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h
dqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx
kr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t
DHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb
eFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc
1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka
c258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE
xEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu
s5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK
0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9
dM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt
PXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T
Md/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T
adq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b
SVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt
pdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm
vfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr
EejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N
vwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh
ZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I
tkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW
d43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe
N4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218
8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG
PNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY
V1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw
w18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT
Ex5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1
axqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/
tDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I
mbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe
XRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1
izjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2
crFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4
OadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2
r8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx
zc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz
+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v
Mevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu
ryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095
YZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE
9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8
mNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O
uSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O
fft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6
Olty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT
uTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3
6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1
Mb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF
feH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq
xVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v
ed7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ
mtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz
mWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP
B39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0
5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1
mkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt
mxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO
1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq
ZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q
ky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7
ROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK
GEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i
tMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T
+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+
O8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO
esd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es
vPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz
XV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1
+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY
36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL
q555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY
3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz
p7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr
1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV
xUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt
pCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS
fP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH
mMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z
1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+
n3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d
MRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df
zXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl
J2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs
zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH
DpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ
dHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR
tER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j
admFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC
b2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X
qdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh
ydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O
8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L
T7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0
Za1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr
vNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer
rWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL
oNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq
j/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh
odZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8
8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1
lNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+
oza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL
knU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK
EtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N
mtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm
9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N
IpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W
MYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2
+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql
o+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37
O99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE
TE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1
L7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4
izsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt
1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb
V5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum
L37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12
CvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE
ebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo
Gvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu
L8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh
5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3
6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9
XO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM
feKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj
SZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF
XaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr
79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h
yeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT
OC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223
2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt
adohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y
cnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX
DpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p
7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso
S24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l
bPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe
vVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG
H6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7
x3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz
5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY
q+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn
vLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2
IjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK
z0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ
YYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON
ZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW
ekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf
cjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c
biuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO
CkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw
y1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi
QXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E
bL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r
tv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t
LRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP
RqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm
s7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el
XX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1
vK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq
qrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v
VYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0
ZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q
mT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm
6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG
f63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo
dPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22
gtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M
MoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb
c2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX
6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn
1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK
fOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ
EqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u
7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT
qPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa
S2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf
Lp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU
IiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O
8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c
vU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx
5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V
KTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm
2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu
j8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB
TTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9
RUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL
CWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA
AAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8
cTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj
qKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF
0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK
ZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK
66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu
XT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9
XOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN
M2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv
VrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK
7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI
3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m
XY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m
1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A
JUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC
EgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9
8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL
OrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H
M+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA
TsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8
elpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp
BjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS
CRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r
rcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY
jbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW
UsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB
KUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb
Sz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL
+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v
T471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM
sfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj
FontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl
5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q
7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv
6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa
0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/
AOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM
d8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5
6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP
bFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu
LJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy
wt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX
0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK
3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn
KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0
vobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t
zya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps
uOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi
Fdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2
O3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z
aK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz
0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb
T/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l
qMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t
trJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn
mvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa
eq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe
PwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of
TdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O
1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG
f/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi
0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY
5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc
V2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L
/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM
t/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd
VknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD
KLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R
fwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3
Vxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ
DJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ
3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv
x7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
weqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI
6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew
PnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk
j3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm
OqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/
AKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez
N9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ
92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp
+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue
V9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv
avHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0
vQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP
8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt
n1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw
nUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3
7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P
0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U
x8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG
0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L
faQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ
QKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA
BAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A
tLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv
9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr
jn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm
b7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB
ACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk
dEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1
rMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+
x+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA
AAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr
YvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4
5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V
kK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg
BIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA
AAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g
Wbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx
OEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2
H/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF
+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V
h6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA
EgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu
ZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml
HMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl
n0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN
3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi
/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00
+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC
UACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2
M2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp
5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn
N1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS
OjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL
/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo
stLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3
GyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA
AAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4
qmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy
WEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a
fJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI
rTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2
rz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc
3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3
Tur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA
AAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx
skA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F
o7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx
NO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h
2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te
pSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7
cvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7
mZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA
AAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA
hGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J
qx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI
XRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy
RHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX
qNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX
kaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P
ya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC
ExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA
lAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA
AAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o
b9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP
y6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae
kzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu
9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ
k7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1
8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp
DXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh
nyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ
AAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA
AAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO
yvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5
PM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii
IpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r
O3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE
yTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX
6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2
JgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS
AAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA
AAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx
Wa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI
6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5
K2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7
Vv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id
PW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ
2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4
eF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7
piVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR
ACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ
JQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i
UiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61
rZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq
ZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2
f0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO
IjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts
bAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA
AAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA
BAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2
SbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T
lBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/
2Q==`;
  async function warmupBitmap(instance) {
    const b64toBlob = (base64, type = "application/octet-stream") => fetch(`data:${type};base64,${base64}`).then((res2) => res2.blob());
    let blob;
    let res;
    switch (instance.config.warmup) {
      case "face":
        blob = await b64toBlob(face3);
        break;
      case "body":
      case "full":
        blob = await b64toBlob(body3);
        break;
      default:
        blob = null;
    }
    if (blob) {
      const bitmap = await createImageBitmap(blob);
      res = await instance.detect(bitmap, instance.config);
      bitmap.close();
    }
    return res;
  }
  async function warmupCanvas(instance) {
    return new Promise((resolve) => {
      let src2;
      switch (instance.config.warmup) {
        case "face":
          src2 = "data:image/jpeg;base64," + face3;
          break;
        case "full":
        case "body":
          src2 = "data:image/jpeg;base64," + body3;
          break;
        default:
          src2 = "";
      }
      let img;
      if (typeof Image !== "undefined")
        img = new Image();
      else if (env.Image)
        img = new env.Image();
      else {
        resolve(void 0);
        return;
      }
      img.onload = async () => {
        const canvas3 = canvas(img.naturalWidth, img.naturalHeight);
        if (!canvas3) {
          log$1("Warmup: Canvas not found");
          resolve(void 0);
        } else {
          const ctx = canvas3.getContext("2d");
          if (ctx)
            ctx.drawImage(img, 0, 0);
          const tensor = await instance.image(canvas3, true);
          const res = tensor.tensor ? await instance.detect(tensor.tensor, instance.config) : void 0;
          resolve(res);
        }
      };
      if (src2)
        img.src = src2;
      else
        resolve(void 0);
    });
  }
  async function warmupNode(instance) {
    const atob2 = (str) => buffer$1.Buffer.from(str, "base64");
    let img;
    if (instance.config.warmup === "face")
      img = atob2(face3);
    else
      img = atob2(body3);
    let res;
    if ("node" in tfjs_esm_exports && pde() === "tensorflow") {
      const data = (void 0).decodeJpeg(img);
      const expanded = ai(data, 0);
      instance.tf.dispose(data);
      res = await instance.detect(expanded, instance.config);
      instance.tf.dispose(expanded);
    } else {
      if (instance.config.debug)
        log$1("Warmup tfjs-node not loaded");
    }
    return res;
  }
  async function runInference(instance) {
    let res;
    if (typeof createImageBitmap === "function")
      res = await warmupBitmap(instance);
    else if (typeof Image !== "undefined" || env.Canvas !== void 0)
      res = await warmupCanvas(instance);
    else
      res = await warmupNode(instance);
    return res;
  }
  async function runCompile(instance) {
    var _a22, _b2, _c22, _d22;
    if (!A().flagRegistry.ENGINE_COMPILE_ONLY)
      return;
    const backendType = pde();
    const webGLBackend = dde();
    if (backendType !== "webgl" && backendType !== "humangl" || !(webGLBackend == null ? void 0 : webGLBackend["checkCompileCompletion"])) {
      return;
    }
    A().set("ENGINE_COMPILE_ONLY", true);
    const numTensorsStart = ur().state.numTensors;
    const compiledModels = [];
    for (const [modelName, model23] of Object.entries(instance.models.models)) {
      if (!model23)
        continue;
      const shape = (model23 == null ? void 0 : model23.modelSignature) && ((_b2 = (_a22 = model23 == null ? void 0 : model23.inputs) == null ? void 0 : _a22[0]) == null ? void 0 : _b2.shape) ? [...model23.inputs[0].shape] : [1, 64, 64, 3];
      const dtype = (model23 == null ? void 0 : model23.modelSignature) && ((_d22 = (_c22 = model23 == null ? void 0 : model23.inputs) == null ? void 0 : _c22[0]) == null ? void 0 : _d22.dtype) ? model23.inputs[0].dtype : "float32";
      for (let dim = 0; dim < shape.length; dim++) {
        if (shape[dim] === -1)
          shape[dim] = dim === 0 ? 1 : 64;
      }
      const tensor = Gr(shape, dtype);
      try {
        const res = model23.execute(tensor);
        compiledModels.push(modelName);
        if (Array.isArray(res))
          res.forEach((t8) => Ot(t8));
        else
          Ot(res);
      } catch (e8) {
        if (instance.config.debug)
          log$1("compile fail model:", modelName);
      }
      Ot(tensor);
    }
    const kernels = await webGLBackend["checkCompileCompletionAsync"]();
    webGLBackend["getUniformLocations"]();
    if (instance.config.debug)
      log$1("compile pass:", { models: compiledModels, kernels: kernels.length });
    A().set("ENGINE_COMPILE_ONLY", false);
    const numTensorsEnd = ur().state.numTensors;
    if (numTensorsEnd - numTensorsStart > 0)
      log$1("tensor leak:", numTensorsEnd - numTensorsStart);
  }
  async function warmup(instance, userConfig) {
    await check(instance, false);
    const t02 = now();
    instance.state = "warmup";
    if (userConfig)
      instance.config = mergeDeep(instance.config, userConfig);
    if (!instance.config.warmup || instance.config.warmup.length === 0 || instance.config.warmup === "none") {
      return empty();
    }
    return new Promise(async (resolve) => {
      await instance.models.load();
      await runCompile(instance);
      const res = await runInference(instance);
      const t12 = now();
      if (instance.config.debug)
        log$1("warmup", instance.config.warmup, Math.round(t12 - t02), "ms");
      instance.emit("warmup");
      resolve(res);
    });
  }
  var _numTensors, _analyzeMemoryLeaks, _checkSanity, _sanity, _loops;
  var Human = class {
    // definition end
    /** Constructor for **Human** library that is futher used for all operations
     * @param userConfig - user configuration object {@link Config}
     */
    constructor(userConfig) {
      __publicField2(this, "version");
      __publicField2(this, "config");
      __publicField2(this, "result");
      __publicField2(this, "state");
      __publicField2(this, "process");
      __publicField2(this, "tf");
      __publicField2(this, "env", env);
      __publicField2(this, "draw", draw_exports);
      __publicField2(this, "match", match_exports);
      __publicField2(this, "models");
      __publicField2(this, "events");
      __publicField2(this, "faceTriangulation");
      __publicField2(this, "faceUVMap");
      __publicField2(this, "performance");
      __privateAdd(this, _numTensors, void 0);
      __privateAdd(this, _analyzeMemoryLeaks, void 0);
      __privateAdd(this, _checkSanity, void 0);
      __publicField2(this, "analyze", (...msg) => {
        if (!__privateGet(this, _analyzeMemoryLeaks))
          return;
        const currentTensors = this.tf.engine().state.numTensors;
        const previousTensors = __privateGet(this, _numTensors);
        __privateSet(this, _numTensors, currentTensors);
        const leaked = currentTensors - previousTensors;
        if (leaked !== 0)
          log$1(...msg, leaked);
      });
      __privateAdd(this, _sanity, (input) => {
        if (!__privateGet(this, _checkSanity))
          return null;
        if (!input)
          return "input is not defined";
        if (this.env.node && !(input instanceof ut))
          return "input must be a tensor";
        try {
          this.tf.getBackend();
        } catch (e8) {
          return "backend not loaded";
        }
        return null;
      });
      __publicField2(this, "webcam", new WebCam());
      __publicField2(this, "emit", (event) => {
        var _a22;
        if ((_a22 = this.events) == null ? void 0 : _a22.dispatchEvent)
          this.events.dispatchEvent(new Event(event));
      });
      __privateAdd(this, _loops, {});
      const tfVersion = Sce.tfjs.replace(/-(.*)/, "");
      config.wasmPath = `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${tfVersion}/dist/`;
      config.modelBasePath = env.browser ? "../models/" : "file://models/";
      this.version = version;
      Object.defineProperty(this, "version", { value: version });
      this.config = JSON.parse(JSON.stringify(config));
      Object.seal(this.config);
      this.config.cacheModels = typeof indexedDB !== "undefined";
      if (userConfig)
        this.config = mergeDeep(this.config, userConfig);
      setModelLoadOptions(this.config);
      this.tf = tfjs_esm_exports;
      this.state = "idle";
      __privateSet(this, _numTensors, 0);
      __privateSet(this, _analyzeMemoryLeaks, false);
      __privateSet(this, _checkSanity, false);
      this.performance = {};
      this.events = typeof EventTarget !== "undefined" ? new EventTarget() : void 0;
      this.models = new Models(this);
      init2();
      this.result = empty();
      this.process = { tensor: null, canvas: null };
      this.faceTriangulation = triangulation;
      this.faceUVMap = uvmap;
      validateModel(this, null, "");
      this.emit("create");
      if (this.config.debug || this.env.browser)
        log$1(`version: ${this.version}`);
      if (this.config.debug)
        log$1(`tfjs version: ${this.tf.version["tfjs-core"]}`);
      const envTemp = JSON.parse(JSON.stringify(this.env));
      delete envTemp.kernels;
      delete envTemp.initial;
      delete envTemp.perfadd;
      if (this.config.debug)
        log$1("environment:", envTemp);
    }
    /** Reset configuration to default values */
    reset() {
      const currentBackend = this.config.backend;
      this.config = JSON.parse(JSON.stringify(config));
      this.config.backend = currentBackend;
      reset();
      env.initial = true;
    }
    /** Validate current configuration schema */
    validate(userConfig) {
      const msgs = validate(config, userConfig || this.config);
      if (msgs.length === 0)
        this.config = mergeDeep(this.config, userConfig);
      return msgs;
    }
    /** Utility wrapper for performance.now() */
    now() {
      return now();
    }
    /** Process input as return canvas and tensor
     *
     * @param input - any input {@link Input}
     * @param getTensor - should image processing also return tensor or just canvas
     * Returns object with `tensor` and `canvas`
     */
    image(input, getTensor = false) {
      return process2(input, this.config, getTensor);
    }
    /** Segmentation method takes any input and returns RGBA tensor
     * Note: Segmentation is not triggered as part of detect process
     *
     * @param input - {@link Input}
     * Returns tensor which contains image data in RGBA format
     */
    async segmentation(input, userConfig) {
      var _a22, _b2, _c22;
      if (userConfig)
        this.config = mergeDeep(this.config, userConfig);
      if (!this.config.segmentation.enabled)
        return null;
      const processed = await process2(input, this.config);
      if (!processed.tensor)
        return null;
      let tensor = null;
      if ((_a22 = this.config.segmentation.modelPath) == null ? void 0 : _a22.includes("rvm"))
        tensor = await predict20(processed.tensor, this.config);
      if ((_b2 = this.config.segmentation.modelPath) == null ? void 0 : _b2.includes("meet"))
        tensor = await predict16(processed.tensor, this.config);
      if ((_c22 = this.config.segmentation.modelPath) == null ? void 0 : _c22.includes("selfie"))
        tensor = await predict21(processed.tensor, this.config);
      Ot(processed.tensor);
      return tensor;
    }
    /** Compare two input tensors for pixel similarity
     * - use `human.image` to process any valid input and get a tensor that can be used for compare
     * - when passing manually generated tensors:
     *  - both input tensors must be in format [1, height, width, 3]
     *  - if resolution of tensors does not match, second tensor will be resized to match resolution of the first tensor
     * - return value is pixel similarity score normalized by input resolution and rgb channels
    */
    compare(firstImageTensor, secondImageTensor) {
      return compare(this.config, firstImageTensor, secondImageTensor);
    }
    /** Explicit backend initialization
     *  - Normally done implicitly during initial load phase
     *  - Call to explictly register and initialize TFJS backend without any other operations
     *  - Use when changing backend during runtime
     */
    async init() {
      await check(this, true);
      await this.tf.ready();
      reset();
    }
    /** Load method preloads all configured models on-demand
     * - Not explicitly required as any required model is load implicitly on it's first run
     *
     * @param userConfig - {@link Config}
    */
    async load(userConfig) {
      this.state = "load";
      const timeStamp = now();
      const count2 = Object.values(this.models.models).filter((model23) => model23).length;
      if (userConfig)
        this.config = mergeDeep(this.config, userConfig);
      if (this.env.initial) {
        if (!await check(this, false))
          log$1("error: backend check failed");
        await ude();
        if (this.env.browser) {
          if (this.config.debug)
            log$1("configuration:", this.config);
          if (this.config.debug)
            log$1("tf flags:", this.tf.ENV.flags);
        }
      }
      await this.models.load(this);
      if (this.env.initial && this.config.debug)
        log$1("tf engine state:", this.tf.engine().state.numBytes, "bytes", this.tf.engine().state.numTensors, "tensors");
      this.env.initial = false;
      const loaded = Object.values(this.models.models).filter((model23) => model23).length;
      if (loaded !== count2) {
        this.models.validate();
        this.emit("load");
      }
      const current = Math.trunc(now() - timeStamp);
      if (current > (this.performance.loadModels || 0))
        this.performance.loadModels = this.env.perfadd ? (this.performance.loadModels || 0) + current : current;
    }
    /** Runs interpolation using last known result and returns smoothened result
     * Interpolation is based on time since last known result so can be called independently
     *
     * @param result - {@link Result} optional use specific result set to run interpolation on
     * @returns result - {@link Result}
     */
    next(result = this.result) {
      return calc2(result, this.config);
    }
    /** Warmup method pre-initializes all configured models for faster inference
     * - can take significant time on startup
     * - only used for `webgl` and `humangl` backends
     * @param userConfig - {@link Config}
     * @returns result - {@link Result}
    */
    async warmup(userConfig) {
      const t02 = now();
      const res = await warmup(this, userConfig);
      const t12 = now();
      this.performance.warmup = Math.trunc(t12 - t02);
      return res;
    }
    /** Run detect with tensorflow profiling
     * - result object will contain total exeuction time information for top-20 kernels
     * - actual detection object can be accessed via `human.result`
    */
    async profile(input, userConfig) {
      const profile = await this.tf.profile(() => this.detect(input, userConfig));
      const kernels = {};
      let total = 0;
      for (const kernel of profile.kernels) {
        const ms2 = Number(kernel.kernelTimeMs) || 0;
        if (kernels[kernel.name])
          kernels[kernel.name] += ms2;
        else
          kernels[kernel.name] = ms2;
        total += ms2;
      }
      const kernelArr = [];
      Object.entries(kernels).forEach((key2) => kernelArr.push({ kernel: key2[0], time: key2[1], perc: 0 }));
      for (const kernel of kernelArr) {
        kernel.perc = Math.round(1e3 * kernel.time / total) / 1e3;
        kernel.time = Math.round(1e3 * kernel.time) / 1e3;
      }
      kernelArr.sort((a, b) => b.time - a.time);
      kernelArr.length = 20;
      return kernelArr;
    }
    /** Main detection method
     * - Analyze configuration: {@link Config}
     * - Pre-process input: {@link Input}
     * - Run inference for all configured models
     * - Process and return result: {@link Result}
     *
     * @param input - {@link Input}
     * @param userConfig - {@link Config}
     * @returns result - {@link Result}
    */
    async detect(input, userConfig) {
      this.state = "detect";
      return new Promise(async (resolve) => {
        var _a22, _b2, _c22, _d22, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m, _n2, _o2, _p2, _q2, _r2, _s2, _t, _u;
        this.state = "config";
        let timeStamp;
        this.config = mergeDeep(this.config, userConfig);
        this.state = "check";
        const error = __privateGet(this, _sanity).call(this, input);
        if (error) {
          log$1(error, input);
          this.emit("error");
          resolve(empty(error));
        }
        const timeStart = now();
        await this.load();
        timeStamp = now();
        this.state = "image";
        const img = await process2(input, this.config);
        this.process = img;
        this.performance.inputProcess = this.env.perfadd ? (this.performance.inputProcess || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
        this.analyze("Get Image:");
        if (!img.tensor) {
          if (this.config.debug)
            log$1("could not convert input to tensor");
          this.emit("error");
          resolve(empty("could not convert input to tensor"));
          return;
        }
        this.emit("image");
        timeStamp = now();
        this.config.skipAllowed = await skip(this.config, img.tensor);
        this.config.filter.autoBrightness = (this.config.filter.autoBrightness || false) && this.config.skipAllowed;
        if (!this.performance.totalFrames)
          this.performance.totalFrames = 0;
        if (!this.performance.cachedFrames)
          this.performance.cachedFrames = 0;
        this.performance.totalFrames++;
        if (this.config.skipAllowed)
          this.performance.cachedFrames++;
        this.performance.cacheCheck = this.env.perfadd ? (this.performance.cacheCheck || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
        this.analyze("Check Changed:");
        let faceRes = [];
        let bodyRes = [];
        let handRes = [];
        let objectRes = [];
        this.state = "detect:face";
        if (this.config.async) {
          faceRes = this.config.face.enabled ? detectFace(this, img.tensor) : [];
          if (this.performance.face)
            delete this.performance.face;
        } else {
          timeStamp = now();
          faceRes = this.config.face.enabled ? await detectFace(this, img.tensor) : [];
          this.performance.face = this.env.perfadd ? (this.performance.face || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
        }
        if (this.config.async && (this.config.body.maxDetected === -1 || this.config.hand.maxDetected === -1))
          faceRes = await faceRes;
        this.analyze("Start Body:");
        this.state = "detect:body";
        const bodyConfig = this.config.body.maxDetected === -1 ? mergeDeep(this.config, { body: { maxDetected: this.config.face.enabled ? 1 * faceRes.length : 1 } }) : this.config;
        if (this.config.async) {
          if ((_a22 = this.config.body.modelPath) == null ? void 0 : _a22.includes("posenet"))
            bodyRes = this.config.body.enabled ? predict19(img.tensor, bodyConfig) : [];
          else if ((_b2 = this.config.body.modelPath) == null ? void 0 : _b2.includes("blazepose"))
            bodyRes = this.config.body.enabled ? predict(img.tensor, bodyConfig) : [];
          else if ((_c22 = this.config.body.modelPath) == null ? void 0 : _c22.includes("efficientpose"))
            bodyRes = this.config.body.enabled ? predict3(img.tensor, bodyConfig) : [];
          else if ((_d22 = this.config.body.modelPath) == null ? void 0 : _d22.includes("movenet"))
            bodyRes = this.config.body.enabled ? predict17(img.tensor, bodyConfig) : [];
          if (this.performance.body)
            delete this.performance.body;
        } else {
          timeStamp = now();
          if ((_e = this.config.body.modelPath) == null ? void 0 : _e.includes("posenet"))
            bodyRes = this.config.body.enabled ? await predict19(img.tensor, bodyConfig) : [];
          else if ((_f2 = this.config.body.modelPath) == null ? void 0 : _f2.includes("blazepose"))
            bodyRes = this.config.body.enabled ? await predict(img.tensor, bodyConfig) : [];
          else if ((_g2 = this.config.body.modelPath) == null ? void 0 : _g2.includes("efficientpose"))
            bodyRes = this.config.body.enabled ? await predict3(img.tensor, bodyConfig) : [];
          else if ((_h2 = this.config.body.modelPath) == null ? void 0 : _h2.includes("movenet"))
            bodyRes = this.config.body.enabled ? await predict17(img.tensor, bodyConfig) : [];
          this.performance.body = this.env.perfadd ? (this.performance.body || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
        }
        this.analyze("End Body:");
        this.analyze("Start Hand:");
        this.state = "detect:hand";
        const handConfig = this.config.hand.maxDetected === -1 ? mergeDeep(this.config, { hand: { maxDetected: this.config.face.enabled ? 2 * faceRes.length : 1 } }) : this.config;
        if (this.config.async) {
          if ((_j2 = (_i2 = this.config.hand.detector) == null ? void 0 : _i2.modelPath) == null ? void 0 : _j2.includes("handdetect"))
            handRes = this.config.hand.enabled ? predict14(img.tensor, handConfig) : [];
          else if ((_l2 = (_k2 = this.config.hand.detector) == null ? void 0 : _k2.modelPath) == null ? void 0 : _l2.includes("handtrack"))
            handRes = this.config.hand.enabled ? predict15(img.tensor, handConfig) : [];
          if (this.performance.hand)
            delete this.performance.hand;
        } else {
          timeStamp = now();
          if ((_n2 = (_m = this.config.hand.detector) == null ? void 0 : _m.modelPath) == null ? void 0 : _n2.includes("handdetect"))
            handRes = this.config.hand.enabled ? await predict14(img.tensor, handConfig) : [];
          else if ((_p2 = (_o2 = this.config.hand.detector) == null ? void 0 : _o2.modelPath) == null ? void 0 : _p2.includes("handtrack"))
            handRes = this.config.hand.enabled ? await predict15(img.tensor, handConfig) : [];
          this.performance.hand = this.env.perfadd ? (this.performance.hand || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
        }
        this.analyze("End Hand:");
        this.analyze("Start Object:");
        this.state = "detect:object";
        if (this.config.async) {
          if ((_q2 = this.config.object.modelPath) == null ? void 0 : _q2.includes("nanodet"))
            objectRes = this.config.object.enabled ? predict18(img.tensor, this.config) : [];
          else if ((_r2 = this.config.object.modelPath) == null ? void 0 : _r2.includes("centernet"))
            objectRes = this.config.object.enabled ? predict2(img.tensor, this.config) : [];
          if (this.performance.object)
            delete this.performance.object;
        } else {
          timeStamp = now();
          if ((_s2 = this.config.object.modelPath) == null ? void 0 : _s2.includes("nanodet"))
            objectRes = this.config.object.enabled ? await predict18(img.tensor, this.config) : [];
          else if ((_t = this.config.object.modelPath) == null ? void 0 : _t.includes("centernet"))
            objectRes = this.config.object.enabled ? await predict2(img.tensor, this.config) : [];
          this.performance.object = this.env.perfadd ? (this.performance.object || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
        }
        this.analyze("End Object:");
        this.state = "detect:await";
        if (this.config.async)
          [faceRes, bodyRes, handRes, objectRes] = await Promise.all([faceRes, bodyRes, handRes, objectRes]);
        this.state = "detect:gesture";
        let gestureRes = [];
        if (this.config.gesture.enabled) {
          timeStamp = now();
          gestureRes = [...face2(faceRes), ...body2(bodyRes), ...hand2(handRes), ...iris2(faceRes)];
          if (!this.config.async)
            this.performance.gesture = this.env.perfadd ? (this.performance.gesture || 0) + Math.trunc(now() - timeStamp) : Math.trunc(now() - timeStamp);
          else if (this.performance.gesture)
            delete this.performance.gesture;
        }
        this.performance.total = this.env.perfadd ? (this.performance.total || 0) + Math.trunc(now() - timeStart) : Math.trunc(now() - timeStart);
        const shape = ((_u = this.process.tensor) == null ? void 0 : _u.shape) || [0, 0, 0, 0];
        this.result = {
          face: faceRes,
          body: bodyRes,
          hand: handRes,
          gesture: gestureRes,
          object: objectRes,
          performance: this.performance,
          canvas: this.process.canvas,
          timestamp: Date.now(),
          error: null,
          width: shape[2],
          height: shape[1],
          get persons() {
            return join2(faceRes, bodyRes, handRes, gestureRes, shape);
          }
        };
        Ot(img.tensor);
        this.emit("detect");
        this.state = "idle";
        resolve(this.result);
      });
    }
    /** Helper function
     * @param ms - sleep time in miliseconds
     */
    async sleep(ms2) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms2);
      });
    }
    /** Continously detect video frames
     * @param element - HTMLVideoElement input
     * @param run - boolean run continously or stop if already running, default true
     * @param delay - number delay detection between frames for number of miliseconds, default 0
     */
    async video(element, run = true, delay = 0) {
      if (run) {
        if (!__privateGet(this, _loops)[element.id]) {
          if (this.config.debug)
            log$1("video start", element.id);
          __privateGet(this, _loops)[element.id] = true;
        }
        if (!element.paused && __privateGet(this, _loops)[element.id] && element.readyState >= 2)
          await this.detect(element);
        if (delay > 0)
          await this.sleep(delay);
        if (__privateGet(this, _loops)[element.id])
          requestAnimationFrame(() => this.video(element, run, delay));
      } else {
        if (this.config.debug)
          log$1("video stop", element.id);
        __privateGet(this, _loops)[element.id] = false;
      }
    }
  };
  _numTensors = /* @__PURE__ */ new WeakMap();
  _analyzeMemoryLeaks = /* @__PURE__ */ new WeakMap();
  _checkSanity = /* @__PURE__ */ new WeakMap();
  _sanity = /* @__PURE__ */ new WeakMap();
  _loops = /* @__PURE__ */ new WeakMap();
  const optimisedConfig = {
    // user configuration for human, used to fine-tune behavior
    cacheSensitivity: 0,
    modelBasePath: "models",
    // models can be loaded directly from cdn as well
    debug: false,
    backend: "webgl",
    filter: { enabled: true, equalization: true, flip: false },
    // lets run with histogram equilizer
    face: {
      enabled: true,
      detector: { rotation: false, return: true, mask: false },
      // return tensor is used to get detected face image
      mesh: { enabled: true },
      attention: { enabled: false },
      // TODO: need to see how this works ??
      description: { enabled: true },
      // default model for face descriptor extraction is faceres
      // mobilefacenet: { enabled: true, modelPath: 'https://vladmandic.github.io/human-models/models/mobilefacenet.json' }, // alternative model
      // insightface: { enabled: true, modelPath: 'https://vladmandic.github.io/insightface/models/insightface-mobilenet-swish.json' }, // alternative model
      iris: { enabled: true },
      // needed to determine gaze direction
      emotion: { enabled: false },
      // not needed
      antispoof: { enabled: true },
      // enable optional antispoof module
      liveness: { enabled: true }
      // enable optional liveness module
      // scale: 1.5
    },
    body: { enabled: false },
    hand: { enabled: false },
    gesture: { enabled: true },
    // parses face and iris gestures
    object: { enabled: false },
    segmentation: { enabled: false }
  };
  optimisedConfig.face["scale"] = 1.5;
  optimisedConfig.face["insightface"] = { enabled: true, modelPath: "insightface-mobilenet-swish.json" };
  const log = (messageOutputElement, ...msg) => {
    messageOutputElement.innerHTML += msg.join(" ") + "\n";
    console.log(...msg);
  };
  const drawOptions = {
    faceLabels: `face
      confidence: [score]%
      [gender] [genderScore]%
      age: [age] years
      distance: [distance]cm
      real: [real]%
      live: [live]%
      [emotions]
      roll: [roll]° yaw:[yaw]° pitch:[pitch]°
      gaze: [gaze]°`,
    bodyLabels: "body [score]%",
    bodyPartLabels: "[label] [score]%",
    objectLabels: "[label] [score]%",
    handLabels: "[label] [score]%",
    fingerLabels: "[label]",
    gestureLabels: "[where] [who]: [what]"
  };
  class SecureCitizenCamera {
    constructor(config3, type = ContainerType.Minimal) {
      __publicField(this, "dom");
      __publicField(this, "log");
      __publicField(this, "human");
      // const matchOptions = { order: 2, multiplier: 1000, min: 0.0, max: 1.0 }; // for embedding model
      __publicField(this, "matchOptions", { order: 2, multiplier: 25, min: 0.2, max: 0.8 });
      // for faceres model
      __publicField(this, "debug", false);
      __publicField(this, "options", {
        minConfidence: 0.6,
        // overal face confidence for box, face, gender, real, live
        minSize: 264,
        // min input to face descriptor model before degradation
        maxTime: 3e4,
        // max time before giving up
        blinkMin: 10,
        // minimum duration of a valid blink
        blinkMax: 800,
        // maximum duration of a valid blink
        threshold: 0.5,
        // minimum similarity
        distanceMin: 0.4,
        // closest that face is allowed to be to the cammera in cm
        distanceMax: 1,
        // farthest that face is allowed to be to the cammera in cm
        mask: (_b = (_a2 = optimisedConfig.face) == null ? void 0 : _a2.detector) == null ? void 0 : _b.mask,
        rotation: (_d2 = (_c2 = optimisedConfig.face) == null ? void 0 : _c2.detector) == null ? void 0 : _d2.rotation,
        ...this.matchOptions
      });
      __publicField(this, "current", { face: null });
      // current face record and matched database record
      __publicField(this, "blink", {
        // internal timers for blink start/end/duration
        start: 0,
        end: 0,
        time: 0
      });
      __publicField(this, "timestamp", { detect: 0, draw: 0 });
      // holds information used to calculate performance and possible memory leaks
      __publicField(this, "startTime", 0);
      this.debug = config3.debug ?? false;
      console.log("Debug Mode: " + this.debug);
      switch (type) {
        case ContainerType.Full:
          this.dom = new IFullDomContainer();
          break;
        case ContainerType.Minimal:
          this.dom = new IDomContainer();
          break;
      }
      this.sourceDomElements();
      this.human = new Human(optimisedConfig);
      this.human.env.perfadd = false;
      this.human.draw.options.lineHeight = 20;
      if (this.debug) {
        this.human.draw.options.drawPoints = true;
      }
    }
    sourceDomElements() {
      this.dom.canvas = document.getElementById("canvas");
      this.dom.fps = document.getElementById("fps");
      this.dom.ok = document.getElementById("ok");
      this.log = document.getElementById(DEFAULT_MESSAGE_OUTSINK);
      if (this.dom instanceof IFullDomContainer) {
        this.dom.match = document.getElementById("match");
        this.dom.name = document.getElementById("name");
        this.dom.save = document.getElementById("save");
        this.dom.delete = document.getElementById("delete");
        this.dom.retry = document.getElementById("retry");
        this.dom.source = document.getElementById("source");
      }
      if (this.debug) {
        this.dom.ok.style.visibility = "hidden";
      }
    }
    async validationLoop() {
      var _a3, _b2;
      const interpolated = this.human.next(this.human.result);
      this.human.draw.canvas(this.human.webcam.element, this.dom.canvas);
      if (this.debug) {
        await this.human.draw.all(this.dom.canvas, interpolated, drawOptions);
      }
      const now2 = this.human.now();
      ok$1.detectFPS.val = Math.round(1e4 / (now2 - this.timestamp.detect)) / 10;
      ok$1.drawFPS.val = Math.round(1e4 / (now2 - this.timestamp.draw)) / 10;
      this.timestamp.draw = now2;
      ok$1.faceCount.val = this.human.result.face.length;
      ok$1.faceCount.status = ok$1.faceCount.val === 1;
      if (ok$1.faceCount.status) {
        const gestures = Object.values(this.human.result.gesture).map(
          (gesture2) => gesture2.gesture
        );
        if (gestures.includes("blink left eye") || gestures.includes("blink right eye"))
          this.blink.start = this.human.now();
        if (this.blink.start > 0 && !gestures.includes("blink left eye") && !gestures.includes("blink right eye"))
          this.blink.end = this.human.now();
        ok$1.blinkDetected.status = ok$1.blinkDetected.status || Math.abs(this.blink.end - this.blink.start) > this.options.blinkMin && Math.abs(this.blink.end - this.blink.start) < this.options.blinkMax;
        if (ok$1.blinkDetected.status && this.blink.time === 0)
          this.blink.time = Math.trunc(this.blink.end - this.blink.start);
        ok$1.facingCenter.status = gestures.includes("facing center");
        ok$1.lookingCenter.status = gestures.includes("looking center");
        ok$1.faceConfidence.val = this.human.result.face[0].faceScore || this.human.result.face[0].boxScore || 0;
        ok$1.faceConfidence.status = ok$1.faceConfidence.val >= this.options.minConfidence;
        ok$1.antispoofCheck.val = this.human.result.face[0].real || 0;
        ok$1.antispoofCheck.status = ok$1.antispoofCheck.val >= this.options.minConfidence;
        ok$1.livenessCheck.val = this.human.result.face[0].live || 0;
        ok$1.livenessCheck.status = ok$1.livenessCheck.val >= this.options.minConfidence;
        ok$1.faceSize.val = Math.min(
          this.human.result.face[0].box[2],
          this.human.result.face[0].box[3]
        );
        ok$1.faceSize.status = ok$1.faceSize.val >= this.options.minSize;
        ok$1.distance.val = this.human.result.face[0].distance || 0;
        ok$1.distance.status = ok$1.distance.val >= this.options.distanceMin && ok$1.distance.val <= this.options.distanceMax;
        ok$1.descriptor.val = ((_a3 = this.human.result.face[0].embedding) == null ? void 0 : _a3.length) || 0;
        ok$1.descriptor.status = ok$1.descriptor.val > 0;
        ok$1.age.val = this.human.result.face[0].age || 0;
        ok$1.age.status = ok$1.age.val > 0;
        ok$1.gender.val = this.human.result.face[0].genderScore || 0;
        ok$1.gender.status = ok$1.gender.val >= this.options.minConfidence;
      }
      ok$1.timeout.status = ok$1.elapsedMs.val <= this.options.maxTime;
      drawValidationTests(this.dom);
      if (allOk() || !ok$1.timeout.status) {
        (_b2 = this.human.webcam.element) == null ? void 0 : _b2.pause();
        return this.human.result.face[0];
      }
      ok$1.elapsedMs.val = Math.trunc(this.human.now() - this.startTime);
      return new Promise((resolve) => {
        setTimeout(async () => {
          await this.validationLoop();
          resolve(this.human.result.face[0]);
        }, 30);
      });
    }
    async detectFace() {
      var _a3, _b2, _c3, _d3, _e;
      this.dom.canvas.style.height = "";
      (_a3 = this.dom.canvas.getContext("2d")) == null ? void 0 : _a3.clearRect(0, 0, this.options.minSize, this.options.minSize);
      if (!((_c3 = (_b2 = this.current) == null ? void 0 : _b2.face) == null ? void 0 : _c3.tensor) || !((_e = (_d3 = this.current) == null ? void 0 : _d3.face) == null ? void 0 : _e.embedding))
        return false;
      console.log("face record:", this.current.face);
      await this.human.tf.browser.toPixels(this.current.face.tensor, this.dom.canvas);
      this.human.tf.dispose(this.current.face.tensor);
    }
    // async function drawLoop() {
    //     // main screen refresh loop
    //     const interpolated = this.human.next() // get smoothened result using last-known results which are continously updated based on input webcam video
    //     this.human.draw.canvas(this.human.webcam.element!, this.dom.canvas) // draw webcam video to screen canvas // better than using procesed image as this loop happens faster than processing loop
    //     await this.human.draw.all(this.dom.canvas, interpolated) // draw labels, boxes, lines, etc.
    //     setTimeout(drawLoop, 30) // use to slow down refresh from max refresh rate to target of 1000/30 ~ 30 fps
    // }
    async main() {
      var _a3, _b2, _c3, _d3;
      ok$1.faceCount.status = false;
      ok$1.faceConfidence.status = false;
      ok$1.facingCenter.status = false;
      ok$1.blinkDetected.status = false;
      ok$1.faceSize.status = false;
      ok$1.antispoofCheck.status = false;
      ok$1.livenessCheck.status = false;
      ok$1.age.status = false;
      ok$1.gender.status = false;
      ok$1.elapsedMs.val = 0;
      await this.human.webcam.start({ crop: true });
      this.human.video(this.human.webcam.element);
      this.dom.canvas.width = this.human.webcam.width;
      this.dom.canvas.height = this.human.webcam.height;
      this.dom.canvas.onclick = async () => {
        if (this.human.webcam.paused) {
          await this.human.webcam.play();
        } else
          this.human.webcam.pause();
      };
      this.startTime = this.human.now();
      this.current.face = await this.validationLoop();
      this.dom.canvas.width = ((_b2 = (_a3 = this.current.face) == null ? void 0 : _a3.tensor) == null ? void 0 : _b2.shape[1]) || this.options.minSize;
      this.dom.canvas.height = ((_d3 = (_c3 = this.current.face) == null ? void 0 : _c3.tensor) == null ? void 0 : _d3.shape[0]) || this.options.minSize;
      this.dom.canvas.style.width = "";
      if (!allOk()) {
        return false;
      }
      return this.detectFace();
    }
    async init() {
      var _a3, _b2, _c3, _d3;
      log(this.log, "human version:", this.human.version, "| tfjs version:", this.human.tf.version["tfjs-core"]);
      log(this.log, "options:", JSON.stringify(this.options).replace(/{|}|"|\[|\]/g, "").replace(/,/g, " "));
      log(this.log, "initializing webcam...");
      log(this.log, "loading human models...");
      await this.human.load();
      log(this.log, "initializing this.human...");
      log(this.log, "face embedding model:", ((_b2 = (_a3 = optimisedConfig.face) == null ? void 0 : _a3.description) == null ? void 0 : _b2.enabled) ? "faceres" : "", ((_c3 = optimisedConfig.face["mobilefacenet"]) == null ? void 0 : _c3.enabled) ? "mobilefacenet" : "", ((_d3 = optimisedConfig.face["insightface"]) == null ? void 0 : _d3.enabled) ? "insightface" : "");
      log(this.log, "loading face database...");
      await this.human.warmup();
      await this.main();
    }
  }
  function init(config3) {
    config3.debug = true;
    const camera = new SecureCitizenCamera(config3);
    camera.init();
  }
  function authinit(config3) {
    return new SecureCitizenUserManager(config3.clientId);
  }
  const scCameraModule = {
    init,
    authinit
  };
  return scCameraModule;
});
